  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - 7  Типы  таблиц MySQL</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Reference.html">previous</A>, <A HREF="manual.ru_Clients.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Table_types" HREF="manual.ru_toc.html#Table_types">7  Типы  таблиц MySQL</A></H1>

<P>
<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
<A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>
<A NAME="IDX1470"></A>
<A NAME="IDX1471"></A>
<A NAME="IDX1472"></A>
<A NAME="IDX1473"></A>
<A NAME="IDX1474"></A>
<A NAME="IDX1475"></A>
<A NAME="IDX1476"></A>

</P>

<P>
В MySQL версии 3.23.6 можно было выбирать из трех основных форматов таблиц
(<code>ISAM</code>, <code>HEAP</code> и <code>MyISAM</code>). Более новые версии MySQL могут поддерживать
дополнительные типы таблиц (<code>InnoDB</code> или <code>BDB</code>) - в зависимости от варианта
установки.

</P>
<P>
При создании новой таблицы можно указать MySQL, какой тип таблицы для нее
использовать. 

</P>
<P>
Для таблицы и определений столбцов MySQL всегда создает файл
<tt>`.frm'</tt>. Индекс и данные хранятся в других файлах, в зависимости от типа
таблиц. 

</P>
<P>
Обратите внимание: если необходимо использовать таблицы <code>InnoDB</code>, при
запуске следует указать параметр <code>innodb_data_file_path</code>. See section <A HREF="manual.ru_Table_types.html#InnoDB_start">7.5.2  Параметры запуска InnoDB</A>.

</P>
<P>
Если попытаться воспользоваться таблицей, которая не была активизирована или
добавлена при компиляции, MySQL вместо нее создаст таблицу типа <code>MyISAM</code>.
Это очень полезная функция, когда необходимо произвести копирование таблиц с
одного SQL-сервера на другой, а серверы поддерживают различные типы таблиц
(например, при копировании таблиц на подчиненный компьютер, который
оптимизирован для быстрой работы без использования транзакционных таблиц).  

</P>
<P>
Тем
не менее, такое автоматическое изменение таблиц может сбить с толку новых
пользователей MySQL. Мы планируем устранить эту проблему путем введения
предупреждений в новом клиент-серверном протоколе в MySQL 4.1, которые будут
выводиться при автоматическом изменении типов таблиц.

</P>
<P>
Преобразовывать таблицы из одного типа в другой можно при помощи оператора
<code>ALTER TABLE</code>. See section <A HREF="manual.ru_Reference.html#ALTER_TABLE">6.5.4  Синтаксис оператора <code>ALTER TABLE</code></A>.

</P>
<P>
Обратите внимание на то, что MySQL поддерживает два различных типа таблиц:
транзакционные (<code>InnoDB</code> и <code>BDB</code>) и без поддержки транзакций (<code>HEAP</code>, <code>ISAM</code>,
<code>MERGE</code> и <code>MyISAM</code>).

</P>
<P>
Преимущества транзакционных таблиц (Transaction-safe tables, TST):

</P>

<ul>
<LI>

Надежность. Даже если произойдет сбой в работе MySQL или возникнут
проблемы с оборудованием, свои данные вы сможете восстановить - либо
методом автоматического восстановления, либо при помощи резервной
копии и журнала транзакций.
<LI>

Можно сочетать несколько операторов и принимать все эти операторы
одной командой <code>COMMIT</code>.
<LI>

Можно запустить команду <code>ROLLBACK</code>, чтобы отменить внесенные изменения
(если работа не производится в режиме автоматической фиксации).
<LI>

Если произойдет сбой во время обновления, все изменения будут
восстановлены (в нетранзакционных таблицах все внесенные изменения не
могут быть отменены).
<LI>

Лучше обеспечивает параллелизм при одновременных обновлениях таблицы и чтении.
</ul>

<P>
Обратите внимание, что для использования таблиц InnoDB вам как минимум 
следует указать опцию <code>innodb_data_file_path</code>. See section <A HREF="manual.ru_Table_types.html#InnoDB_start">7.5.2  Параметры запуска InnoDB</A>.

</P>
<P>
Преимущества нетранзакционных таблиц (non-transaction-safe
tables, NTST):

</P>

<ul>
<LI>

Работать с ними намного быстрее, так как не выполняются дополнительные
транзакции.
<LI>

Для них требуется меньше дискового пространства, так как не
применяются дополнительные транзакции.
<LI>

Для обновлений используется меньше памяти.
</ul>

<P>
В операторах можно сочетать таблицы TST и NTST, чтобы взять лучшее от
каждого типа.

</P>



<H2><A NAME="MyISAM" HREF="manual.ru_toc.html#MyISAM">7.1  Таблицы <code>MyISAM</code></A></H2>

<P>
Тип таблиц <code>MyISAM</code> принят по умолчанию в MySQL версии 3.23. Он основывается
на коде <code>ISAM</code> и обладает в сравнении с ним большим количеством полезных
дополнений.

</P>
<P>
Индекс хранится в файле с расширением <tt>`.MYI'</tt> (MYIndex), а данные - в файле
с расширением <tt>`.MYD'</tt> (MYData). Таблицы <code>MyISAM</code> можно
проверять/восстанавливать при помощи утилиты <code>myisamchk</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Crash_recovery">4.4.6.7  Использование myisamchk для послеаварийного восстановления</A>. Таблицы <code>MyISAM</code> можно сжимать при помощи
команды <code>myisampack</code>, после чего они будут занимать намного меньше места.
See section <A HREF="manual.ru_MySQL_Database_Administration.html#myisampack">4.7.4  <code>myisampack</code>, MySQL-генератор сжатых таблиц (только для чтения)</A>.

</P>
<P>
Новшества, которыми обладает тип <code>MyISAM</code>:

</P>

<ul>
<LI>

Флаг в файле <code>MyISAM</code>, указывающий, правильно была закрыта таблица или
нет. В случае запуска <code>mysqld</code> с параметром <code>--myisam-recover</code> таблицы
<code>MyISAM</code> будут автоматически проверяться и/или восстанавливаться при
открытии, если таблица была закрыта неправильно.
<LI>

При помощи команды <code>INSERT</code> можно вставлять новые строки в таблицу, в
середине файла данных которой нет свободных блоков, в то время как
другие потоки считывают из таблицы информацию (совмещенная вставка).
Свободный блок может быть получен при обновлении строки с динамической
длиной, когда большее количество данных заменяется меньшим количеством
или при удалении строк. Когда свободных блоков не остается, все
последующие блоки снова будут вставляться как совмещенные.
<LI>

Поддержка больших файлов (63 бита) в файловых/операционных системах,
которые поддерживают большие файлы.
<LI>

Хранение всех данных осуществляется с первым младшим байтом. Это
делает данные независимыми от операционной системы. Единственное
требование - в компьютере должны применяться дополненные до двух
байтов целые числа со знаком (как и во всех компьютерах в последние 20
лет) и формат с плавающей единичной запятой IEEE (также использующийся
в подавляющем большинстве серийных компьютеров). Единственными
компьютерами, которые могут не поддерживать бинарную совместимость,
являются встроенные системы (поскольку в них иногда применяются
специальные процессоры). При хранении данных с первым младшим байтом 
не происходит снижения скорости. Обычно байты в строке таблицы не
выровнены и нет большой разницы в том, как прочитать невыровненный
байт - в прямой последовательности или в обратной. Фактическое время
извлечения значения столбца также не критично по сравнению со временем
выполнения остального  кода.
<LI>

Все ключи номеров хранятся с первым старшим байтом, чтобы сжатие
индексов было более эффективным.
<LI>

Внутренняя обработка столбца <code>AUTO_INCREMENT</code>. <code>MyISAM</code> автоматически
обновляет его при выполнении команд <code>INSERT</code>/<code>UPDATE</code>. Значение
<code>AUTO_INCREMENT</code> может быть обнулено оператором <code>myisamchk</code>. После этого
столбец <code>AUTO_INCREMENT</code> будет быстрее (по крайней мере на 10%) и старые
номера не будут повторно использоваться, как со старым <code>ISAM</code>. Обратите
внимание: когда <code>AUTO_INCREMENT</code> задан в конце составного ключа, старое
поведение все еще сохраняется.
<LI>

При вставке в отсортированном порядке (как при использовании столбца
<code>AUTO_INCREMENT</code>) дерево ключей будет разделено таким образом, чтобы
верхний узел содержал только один ключ. При этом сокращается расход
пространства памяти в дереве ключей.
<LI>

Столбцы <code>BLOB</code> и <code>TEXT</code> могут быть проиндексированы.
<LI>

В индексных столбцах разрешены значения <code>NULL</code>. Они занимают 0-1 байта
на ключ.
<LI>

По умолчанию максимальная длина ключа составляет 500 байтов (это
значение может быть изменено при повторной компиляции). В случаях,
когда ключи больше 250 байтов, для них используются большие размеры
блока ключа, чем предусмотренные по умолчанию 1024 байта.
<LI>

По умолчанию в таблице может быть не более 32 ключей. Это значение
можно увеличить до 64 без повторной компиляции <code>myisamchk</code>.
<LI>

<code>myisamchk</code> будет отмечать таблицы как проверенные, если они запускаются
с параметром <code>--update-state</code>. <code>myisamchk --fast</code> будет проверять только
те таблицы, в которых отсутствует данная пометка.
<LI>

<code>myisamchk -a</code> сохраняет статистические данные по частям ключа (не
только для ключей целиком, как в <code>ISAM</code>).
<LI>

Строки с динамическим размером будут менее фрагментированными, чем при
смешивании удалений с обновлениями и вставками. Это осуществляется
путем автоматического сочетания удаленных смежных блоков и расширением
блоков, если следующий блок удален.
<LI>

<code>myisampack</code> может упаковывать столбцы <code>BLOB</code> и <code>VARCHAR</code>.
<LI>

Можно поместить файл данных и файл индексов в разные каталоги, чтобы
увеличить скорость (с параметром <code>DATA/INDEX DIRECTORY="path"</code> для
<code>CREATE TABLE</code>). See section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>.
</ul>

<P>
<code>MyISAM</code> также поддерживает следующие функции, которые можно будет
использовать в MySQL в ближайшем будущем:

</P>

<ul>
<LI>

Поддержка типа <code>VARCHAR</code>; столбец <code>VARCHAR</code> начинается с длины, которая
хранится в 2 байтах.
<LI>

Таблицы с <code>VARCHAR</code> могут иметь фиксированную или динамическую длину
записей.
<LI>

<code>VARCHAR</code> и <code>CHAR</code> могут быть до 64 Кб длиной. У всех ключевых сегментов
есть свои собственные определения языка. Это позволяет задавать в
MySQL различные определения языка для каждого столбца.
<LI>

Для <code>UNIQUE</code> может использоваться вычисленный хэш-индекс. Это позволяет
использовать <code>UNIQUE</code> с любым сочетанием столбцов в таблице (тем не
менее, нельзя производить поиск по вычисленному <code>UNIQUE</code> индексу).
</ul>

<P>
Обратите внимание, что индексные файлы при использовании <code>MyISAM</code> обычно
намного меньше в сравнении с <code>ISAM</code>. Это означает, что для <code>MyISAM</code> обычно
задействуется меньше системных ресурсов, чем для <code>ISAM</code>, но больше
загружается процессор при вставке данных в сжатый индекс.

</P>
<P>
Приведенные ниже параметры <code>mysqld</code> могут использоваться для изменения
поведения таблиц <code>MyISAM</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>. 

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Параметр</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>--myisam-recover=#</code> </TD><TD> Автоматическое восстановление таблиц после сбоя.
</TD></TR>
<TR><TD><code>-O myisam_sort_buffer_size=#</code> </TD><TD> При восстановлении таблиц используется буфер.
</TD></TR>
<TR><TD><code>--delay-key-write=ALL</code> </TD><TD> Не сбрасывать на диск ключевые буферы между записями для любых таблиц <code>MyISAM</code>
</TD></TR>
<TR><TD><code>-O myisam_max_extra_sort_file_size=#</code> </TD><TD> Используется, чтобы помочь MySQL выбрать, когда использовать медленный, но надежный метод создания индекса кэша ключей. <strong>Обратите внимание</strong> на то, что этот параметр задается в мегабайтах!
</TD></TR>
<TR><TD><code>-O myisam_max_sort_file_size=#</code> </TD><TD> Не использовать метод быстрой сортировки индекса для созданных индексов, если временный файл превысит этот размер. <strong>Обратите внимание</strong> на то, что этот параметр задается в мегабайтах!
</TD></TR>
<TR><TD><code>-O bulk_insert_buffer_size=#</code> Размер кэша дерева, используемого при оптимизации групповых вставок. <strong>Обратите внимание</strong>: это ограничение на поток!
</TD></TR>
</TABLE>

<P>
Автоматическое восстановление активизируется при запуске <code>mysqld</code> с
параметром <code>--myisam-recover=#</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>).
Когда таблица открывается, производится проверка, не помечена ли она как
сбойная, не равна ли переменная счетчика открытий таблицы нулю (0) и не
производится ли запуск с параметром <code>--skip-external-locking</code>. Если хотя бы одно из
этих условий выполняется, произойдет следующее:

</P>

<ul>
<LI>

Будет произведена проверка таблицы на наличие ошибок;
<LI>

Если обнаружится ошибка, будет произведена попытка быстрого
восстановления (с сортировкой и без повторного создания файла данных)
таблицы;
<LI>

Если восстановление не удалось из-за ошибки в файле данных (например,
ошибка дублирующегося ключа), будет произведена вторая попытка, но на
этот раз с повторным созданием файла данных.
<LI>

Если восстановление не удастся, будет произведена еще одна попытка с
применением старого метода восстановления (запись по строкам без
сортировки), который обеспечивает устранение ошибок любого типа с
использованием незначительных ресурсов диска.
</ul>

<P>
Если не удается восстановить все строки из предыдущего выполненного
оператора, и не был указан параметр <code>FORCE</code> для <code>myisam-recover</code>,
автоматическое восстановление будет отменено со следующей ошибкой в файле
ошибок:

</P>

<pre>
Error: Couldn't repair table: test.g00pages
</pre>

<P>
Если в этом случае был указан параметр <code>FORCE</code>, вместо вышеуказанного
сообщения в файле ошибок будет присутствовать следующее предупреждение:

</P>

<pre>
Warning: Found 344 of 354 rows when repairing ./test/g00pages
</pre>

<P>
Обратите внимание: если запустить автоматическое восстановление с
параметром <code>BACKUP</code>, необходимо установить скрипт <code>cron</code>, который
автоматически перемещает файлы с именами <tt>`tablename-datetime.BAK'</tt> из
каталогов базы данных на носитель резервного копирования.

</P>
<P>
See section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>.

</P>



<H3><A NAME="Key_space" HREF="manual.ru_toc.html#Key_space">7.1.1  Пространство, необходимое  для  ключей</A></H3>

<P>
<A NAME="IDX1477"></A>

</P>
<P>
В MySQL могут поддерживаться различные типы индексов, однако обычно это
тип <code>ISAM</code> или <code>MyISAM</code>. Для обоих типов используется индекс B-дерева, так что
приблизительно вычислить размер индексного файла можно по формуле (<code>длина
ключа+4)/0.67</code>, просуммированной по всем ключам (приведено значение для
самого худшего случая, когда все ключи вставлены в порядке сортировки и
сжатые ключи отсутствуют).

</P>
<P>
В индексах строк сжаты пробелы. Если первая часть индекса является
строкой, префикс также будет сжат. Сжатие пробелов позволяет уменьшить
индексный файл в сравнении со значениями, вычисляемыми по приведенной выше
формуле, если столбец строки содержит много пробелов в конце строки или
является столбцом  <code>VARCHAR</code>, который не всегда используется на полную
длину. Сжатие префикса используется с ключами, которые начинаются со
строки. Сжатие префикса полезно в случае, если имеется много строк с
одинаковыми префиксами.

</P>
<P>
В таблицах <code>MyISAM</code> можно также сжимать числа в префиксах, указывая при
создании таблицы <code>PACK_KEYS=1</code>. Это полезно в случае, когда имеется много
целочисленных ключей с одинаковыми префиксами, а числа хранятся с первым
старшим байтом.

</P>


<H3><A NAME="MyISAM_table_formats" HREF="manual.ru_toc.html#MyISAM_table_formats">7.1.2  Форматы таблиц <code>MyISAM</code></A></H3>

<P>
В <code>MyISAM</code> поддерживается три различных типа таблиц. Два из них выбираются
автоматически, в зависимости от типа используемых столбцов. Третий -
сжатые таблицы - может быть создан только при помощи инструмента
<code>myisampack</code>.

</P>
<P>
При использовании с таблицами команд <code>CREATE</code> или <code>ALTER</code> для таблиц, у
которых нет форсированной настройки <code>BLOB</code>, можно задать формат <code>DYNAMIC</code> или
<code>FIXED</code> с параметром таблицы <code>ROW_FORMAT=#</code>. В будущем можно будет
сжимать/разжимать таблицы, указывая <code>ROW_FORMAT=compressed | default</code> для
<code>ALTER TABLE</code>. See section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>.

</P>



<H4><A NAME="Static_format" HREF="manual.ru_toc.html#Static_format">7.1.2.1  Характеристики статических таблиц (с фиксированной длиной)</A></H4>

<P>
Это формат, принятый по умолчанию. Он используется, когда таблица не
содержит столбцов <code>VARCHAR</code>, <code>BLOB</code> или <code>TEXT</code>.

</P>
<P>
Данный формат - самый простой и безопасный, а также наиболее быстрый при
работе с дисками. Скорость достигается за счет простоты поиска информации
на диске: в таблицах статического формата с индексом для этого достаточно
всего лишь умножить номер строки на ее длину.

</P>
<P>
Кроме того, при сканировании таблицы очень просто считывать постоянное
количество записей при каждом чтении с диска.

</P>
<P>
Если произойдет сбой во время записи в файл <code>MyISAM</code> фиксированного размера,
<code>myisamchk</code> в любом случае сможет легко определить, где начинается и
заканчивается любая строка. Поэтому обычно удается восстановить все
записи, кроме тех, которые были частично перезаписаны. Отметим, что в
MySQL все индексы могут быть восстановлены. Свойства статических таблиц
следующие:

</P>

<ul>
<LI>

Все столбцы <code>CHAR</code>, <code>NUMERIC</code> и <code>DECIMAL</code> расширены пробелами до ширины
столбца;
<LI>

Очень быстрые;
<LI>

Легко кэшируются;
<LI>

Легко восстанавливаются после сбоя, так как записи расположены в
фиксированных позициях;
<LI>

Не нуждаются в реорганизации (при помощи <code>myisamchk</code>), кроме случаев,
когда удаляется большое количество записей и необходимо вернуть
дисковое пространство операционной системе.
<LI>

Для них обычно используется больше дискового пространства, чем для
динамических таблиц.
</ul>



<H4><A NAME="Dynamic_format" HREF="manual.ru_toc.html#Dynamic_format">7.1.2.2  Характеристики динамических таблиц</A></H4>

<P>
<A NAME="IDX1478"></A>
<A NAME="IDX1479"></A>

</P>
<P>
Данный формат используется для таблиц, которые содержат столбцы <code>VARCHAR</code>,
<code>BLOB</code> или <code>TEXT</code>, а также если таблица была создана с параметром
<code>ROW_FORMAT=dynamic</code>.

</P>
<P>
Это несколько более сложный формат, так как у каждой строки есть
заголовок, в котором указана ее длина. Одна запись может заканчиваться
более чем в одном месте, если она была увеличена во время обновления.

</P>
<P>
<A NAME="IDX1480"></A>
Чтобы произвести дефрагментацию таблицы, можно воспользоваться командами
<code>OPTIMIZE table</code> или <code>myisamchk</code>. Если у вас есть статические данные, которые
часто считываются/изменяются в некоторых столбцах <code>VARCHAR</code> или <code>BLOB</code> одной и
той же таблицы, во избежание фрагментации эти динамические столбцы лучше
переместить в другие таблицы. Свойства динамических таблиц следующие:

</P>

<ul>
<LI>

Все столбцы со строками являются динамическими (кроме тех, у которых
длина меньше 4).
<LI>

Перед каждой записью помещается битовый массив, показывающий, какие
столбцы пусты (<code>''</code>) для строковых столбцов, или ноль для числовых
столбцов (это не то же самое, что столбцы, содержащие значение <code>NULL</code>).
Если длина строкового столбца равна нулю после удаления пробелов в
конце строки, или у числового столбца значение ноль, он отмечается в
битовом массиве и не сохраняется на диск. Строки, содержащие значения,
сохраняются в виде байта длины и строки содержимого.
<LI>

Обычно такие таблицы занимают намного меньше дискового пространства,
чем таблицы с фиксированной длиной.
<LI>

Для всех записей используется ровно столько места, сколько необходимо.
Если размер записи увеличивается, она разделяется на несколько частей
- по мере необходимости. Это приводит к фрагментации записей.
<LI>

Если в строку добавляется информация, превышающая длину строки, строка
будет фрагментирована. В этом случае для увеличения производительности
можно время от времени запускать команду <code>myisamchk -r</code>. Чтобы получить
статистические данные, воспользуйтесь командой <code>myisamchk -ei tbl_name</code>.
<LI>

Восстановление после сбоя для таких таблиц является более сложным
процессом, так как запись может быть фрагментированной и состоять из
нескольких частей, а ссылка (или фрагмент) могут отсутствовать.
<LI>

Предполагаемая длина строки для динамических записей вычисляется
следующим образом:


<pre>
3
+ (число столбцов+ 7) / 8
+ (число столбцов char)
+ размер числовых столбцов в упакованном виде
+ длина строк
+ (число столбцов NULL + 7) / 8
</pre>

На каждую ссылку добавляется по 6 байтов. Динамические записи связываются
при каждом увеличении записи во время обновления. Каждая новая ссылка
занимает по крайней мере 20 байтов, поэтому следующее увеличение может
произойти либо по этой же ссылке; либо по другой, если не хватит места.
Количество ссылок можно проверить при помощи команды <code>myisamchk -ed</code>. Все
ссылки можно удалить при помощи команды <code>myisamchk -r</code>.
</ul>



<H4><A NAME="Compressed_format" HREF="manual.ru_toc.html#Compressed_format">7.1.2.3  Характеристики сжатых таблиц</A></H4>

<P>
<A NAME="IDX1481"></A>
<A NAME="IDX1482"></A>
<A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>

</P>
<P>
Таблицы этого тип предназначены только для чтения. Они генерируются при
помощи дополнительного инструмента <code>myisampack</code> (<code>pack_isam</code> для таблиц <code>ISAM</code>):

</P>

<ul>
<LI>

Все дистрибутивы MySQL, даже выпущенные до предоставления
общедоступной лицензии MySQL, могут читать таблицы, которые были сжаты
при помощи <code>myisampack</code>.
<LI>

Сжатые таблицы занимают очень мало дискового пространства; таким
образом при применении данного типа значительно снижается
использование дискового пространства. Это полезно при работе с
медленными дисками (такими как компакт-диски).
<LI>

Каждая запись сжимается отдельно (незначительные издержки при
доступе). Заголовки у записей фиксированные (1-3 байта), в зависимости
от самой большой записи в таблице. Все столбцы сжимаются по-разному.
Ниже приведено описание некоторых типов сжатия:

<ul>
<LI>

Обычно для каждого столбца используются разные таблицы Хаффмана.
<LI>

Сжимаются пробелы суффикса.
<LI>

Сжимаются пробелы префикса.
<LI>

Для хранения чисел со значением 0 отводится 1 бит.
<LI>

Если у значений в целочисленном столбце небольшой диапазон,
столбец сохраняется с использованием минимального по размерам
возможного типа. Например, столбец <code>BIGINT</code> (8 байт) может быть
сохранен как столбец <code>TINYINT</code> (1 байт) если все значения находятся
в диапазоне от <code>0</code> до <code>255</code>.
<LI>

Если в столбце содержится небольшое множество возможных значений,
тип столбца преобразовывается в <code>ENUM</code>.
<LI>

Столбец может содержать сочетание указанных выше сжатий.
</ul>

<LI>

Для таблиц этого типа возможна обработка записей с фиксированной или
динамической длиной.
<LI>

Таблицы данного типа могут быть распакованы при помощи команды myisamchk.
</ul>



<H3><A NAME="MyISAM_table_problems" HREF="manual.ru_toc.html#MyISAM_table_problems">7.1.3  Проблемы с таблицами <code>MyISAM</code>.</A></H3>

<P>
Формат  файлов, который  используется  для  хранения  данных  в MySQL,
тщательно  тестировался, но  всегда  существуют  обстоятельства, которые 
могут  привести  к  повреждениям  таблиц  баз  данных.

</P>



<H4><A NAME="Corrupted_MyISAM_tables" HREF="manual.ru_toc.html#Corrupted_MyISAM_tables">7.1.3.1  Повреждения таблиц <code>MyISAM</code></A></H4>

<P>
Несмотря на то, что формат таблиц <code>MyISAM</code> очень надежен (все изменения в
таблице записываются до возвращения значения оператора SQL), таблица, тем
не менее, может быть повреждена. Такое происходит в следующих случаях:

</P>

<ul>
<LI>

Процесс <code>mysqld</code> уничтожен во время осуществления записи;
<LI>

Неожиданное отключение компьютера (например, если выключилось
электропитание);
<LI>

Ошибка аппаратного обеспечения;
<LI>

Использование внешней программы (например <code>myisamchk</code>) на открытой
таблице.
<LI>

Ошибка программного обеспечения в коде MySQL или <code>MyISAM</code>.
</ul>

<P>
Типичные признаки поврежденной таблицы следующие:

</P>

<ul>
<LI>

Во время выбора данных из таблицы выдается ошибка <code>Incorrect key file
for table: '...'. Try to repair it</code>.
<LI>

Запросы не находят в таблице строки или выдают неполные данные.
</ul>

<P>
Проверить состояние таблицы можно при помощи команды <code>CHECK TABLE</code>. См.
раздел See section <A HREF="manual.ru_MySQL_Database_Administration.html#CHECK_TABLE">4.4.4  Синтаксис <code>CHECK TABLE</code></A>.

</P>
<P>
Для восстановления поврежденного файла можно применить команду <code>REPAIR
TABLE</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#REPAIR_TABLE">4.4.5  Синтаксис <code>REPAIR TABLE</code></A>. Таблицу можно восстановить и в
случае, когда не запущен <code>mysqld</code>, при помощи  команды <code>myisamchk</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#myisamchk_syntax">4.4.6.1  Синтаксис запуска <code>myisamchk</code></A>.

</P>
<P>
Если таблицы повреждены значительно, необходимо выяснить причину
произошедшего! See section <A HREF="manual.ru_Problems.html#Crashing">A.4.1  Что делать, если работа MySQL сопровождается постоянными сбоями</A>. 

</P>
<P>
Сначала  следует  определить, послужил  ли 
причиной повреждения таблицы сбой <code>mysqld</code> (это  можно  легко 
проверить, просмотрев последние строки <code>restarted mysqld</code> в файле 
ошибок <code>mysqld</code>). Если дело не в этом, то необходимо составить 
подробное  описание  произошедшего. See section <A HREF="manual.ru_Porting.html#Reproduceable_test_case">E.1.6  Создание контрольного примера при повреждении таблиц</A>.

</P>


<H4><A NAME="MyISAM_table_close" HREF="manual.ru_toc.html#MyISAM_table_close">7.1.3.2  Clients is using or hasn't closed the table properly</A></H4>

<P>
Клиенты неправильно используют таблицу или не закрыли ее надлежащим
образом

</P>
<P>
В заголовке каждого файла MyISAM  <tt>`.MYI'</tt> имеется счетчик, который может
использоваться для проверки правильности закрытия таблицы.

</P>
<P>
Если при выполнении команд <code>CHECK TABLE</code> или <code>myisamchk</code> выдается следующая
ошибка:

</P>

<pre>
# clients is using or hasn't closed the table properly
</pre>

<P>
значит, нарушена синхронность счетчика. Это не означает, что таблица
повреждена, но необходимо произвести проверку и убедиться, что все в
порядке.

</P>
<P>
Счетчик работает следующим образом:

</P>

<ul>
<LI>

Во время первого обновления таблицы в MySQL значение счетчика в
заголовках индексных файлов увеличивается.
<LI>

Во время следующих обновлений значение счетчика не изменяется.
<LI>

После закрытия последней записи таблицы (после применения команды
<code>FLUSH</code> или из-за отсутствия места в кэше таблицы) значение счетчика
уменьшается, если в таблицу были внесены изменения.
<LI>

Если производится проверка таблицы, или проверка показывает, что все в
порядке, счетчик устанавливается в значение 0.
<LI>

Чтобы избежать пересечения с другими процессами, которые могут
проверять таблицу, при закрытии значение счетчика не уменьшается, если
счетчик установлен в значение 0.
</ul>

<P>
Иначе говоря, синхронность может быть нарушена следующим образом:

</P>

<ul>
<LI>

Таблицы <code>MyISAM</code> копируются без команд <code>LOCK</code> и <code>FLUSH TABLES</code>.
<LI>

Между обновлением и последним закрытием произошел сбой MySQL (обратите
внимание: с таблицей все может быть в порядке, так как MySQL
документирует все изменения между выполнением каждого из операторов).
<LI>

Кто-то применил команду <code>myisamchk --recover</code> или <code>myisamchk
--update-state</code> к таблице, которая в данный момент использовалась
<code>mysqld</code>.
</ul>

<P>
Таблицу используют несколько серверов <code>mysqld</code>, и один из них выполнил
команду <code>REPAIR</code> или <code>CHECK</code> по отношению к таблице, с которой работал другой
сервер. В этом случае можно выполнить команду <code>CHECK</code> (даже если другие
серверы выдают предупреждения), но команды <code>REPAIR</code> следует избегать, так
как она заменяет файл данных новым, информация о котором не передается
другим серверам.

</P>


<H2><A NAME="MERGE" HREF="manual.ru_toc.html#MERGE">7.2  Таблицы <code>MERGE</code></A></H2>

<P>
<A NAME="IDX1485"></A>
<A NAME="IDX1486"></A>

</P>
<P>
Таблицы <code>MERGE</code> (объединение) являются новшеством версии MySQL 3.23.25. В
настоящее время код находится еще на стадии разработки, но, тем не менее,
должен быть достаточно стабилен.

</P>
<P>
Таблица <code>MERGE</code> (или таблица <code>MRG_MyISAM</code>) представляет собой совокупность
идентичных таблиц <code>MyISAM</code>, которые могут использоваться как одна таблица. К
совокупности таблиц можно применять только команды <code>SELECT</code>, <code>DELETE</code> и
<code>UPDATE</code>. Если же попытаться применить к таблице <code>MERGE</code> команду <code>DROP</code>, она
подействует только на определение <code>MERGE</code>.

</P>
<P>
Обратите внимание на то, что команда <code>DELETE FROM merge_table</code> без параметра
<code>WHERE</code> очищает только распределение для таблицы, но ничего не удаляет из
распределенных таблиц (мы планируем исправить это в версии 4.1).

</P>
<P>
Под идентичными таблицами подразумеваются таблицы, созданные с одинаковой
структурой и ключами. Нельзя объединять таблицы, в которых столбцы сжаты
разными методами или не совпадают, либо ключи расположены в другом
порядке. Тем не менее, некоторые таблицы можно сжимать при помощи команды
<code>myisampack</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#myisampack">4.7.4  <code>myisampack</code>, MySQL-генератор сжатых таблиц (только для чтения)</A>.

</P>
<P>
При создании таблицы <code>MERGE</code> будут образованы файлы определений таблиц <tt>`.frm'</tt> 
и списка таблиц <tt>`.MRG'</tt>. Файл <tt>`.MRG'</tt> содержит список индексных файлов (файлы
<tt>`.MYI'</tt>), работа с которыми должна осуществляться как с единым файлом. Все
используемые таблицы должны размещаться в той же базе данных, что и
таблица <code>MERGE</code>.

</P>
<P>
На данный момент по отношению к таблицам, которые необходимо преобразовать
в таблицу <code>MERGE</code>,необходимо обладать привилегиями <code>SELECT</code>, <code>UPDATE</code> и <code>DELETE</code>.

</P>
<P>
Ниже перечислены возможности, которые обеспечивают таблицы <code>MERGE</code>:

</P>

<ul>
<LI>

Простое управление набором файлов журналов. Например, можно поместить
данные за различные месяцы в отдельные файлы, сжать некоторые из них
при помощи <code>myisampack</code>, а затем создать таблицу <code>MERGE</code>, чтобы
использовать их как одну таблицу.
<LI>

Увеличение скорости работы. Большую таблицу можно разделить по
некоторому критерию, а затем поместить различные части таблицы на
разные диски. В этом случае таблица <code>MERGE</code> может обрабатываться намного
быстрее, чем обычная большая таблица (можно, конечно, воспользоваться
дисковым массивом <code>RAID</code>, чтобы получить те же преимущества).
<LI>

Более эффективный поиск. Если точно известно, что вы ищете, можно
производить поиск по определенным запросам только в одной из
составляющих таблицу <code>MERGE</code> таблиц, одновременно используя таблицу
<code>MERGE</code> для других запросов. Можно даже иметь несколько активных таблиц
<code>MERGE</code> (возможно, с перекрывающимися файлами).
<LI>

Более простое восстановление. Гораздо легче восстановить отдельные
файлы, которые преобразованы в файл <code>MERGE</code>, чем пытаться восстановить
действительно большой файл.
<LI>

Быстрая обработка большого количества файлов как одного. Для таблицы
<code>MERGE</code> используются индексы отдельных таблиц; поддерживать для нее один
большой индекс нет необходимости. Благодаря этому создание или
изменение таблиц <code>MERGE</code> осуществляется ОЧЕНЬ быстро. Обратите внимание
на то, что при создании таблицы <code>MERGE</code> необходимо указывать определения
ключей!
<LI>

Если требуется объединить несколько таблиц в одну большую таблицу по
требованию или при формировании, лучше создать для них по требованию
таблицу <code>MERGE</code>. Это намного быстрее и позволит сэкономить дисковое
пространство.
<LI>

Таблицы <code>MERGE</code> позволяют обходить ограничения  на размер файлов в
операционных системах.
<LI>

Можно создать псевдоним/синоним для таблицы - для этого нужно просто
применить <code>MERGE</code> к одной таблице. Заметного падения производительности
при этом наблюдаться не будет (только пара непрямых вызовов и вызовы
<code>memcpy()</code> при каждом чтении).
</ul>

<P>
Недостатки таблиц <code>MERGE</code>:

</P>

<ul>
<LI>

Для создания таблицы <code>MERGE</code> можно использовать только идентичные
таблицы <code>MyISAM</code>.
<LI>

Не работает команда <code>REPLACE</code>.
<LI>

Для таблиц <code>MERGE</code> используется больше дескрипторов файлов. Если
применяется таблица <code>MERGE</code>, преобразованная из более чем 10 таблиц, к
которым получают доступ 10 пользователей, то используется 10*10 + 10
дескрипторов файлов (10 файлов данных для 10 пользователей и 10 общих
индексных файлов).
<LI>

Ключи считываются медленнее. При чтении ключа обработчику <code>MERGE</code>
необходимо прочитать все базовые таблицы, чтобы выяснить, какая из них
больше всего соответствует указанному ключу. Если после этого
выполнить команду ``читать следующий'', то обработчик объединенной
таблицы должен будет просмотреть буферы чтения, чтобы найти следующий
ключ. Только по завершении использования одного буфера ключей
обработчику понадобится прочитать следующий блок ключей. В связи с
этим ключи <code>MERGE</code> дают большое замедление при поиске <code>eq_ref</code>, однако не
такое значительное при поиске <code>ref</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A>.
<LI>

Нельзя выполнять команды
<code>DROP TABLE</code>,
<code>ALTER TABLE</code>,
<code>DELETE FROM table_name</code> без оператора <code>WHERE</code>
<code>REPAIR TABLE</code>,
<code>TRUNCATE TABLE</code>,
<code>OPTIMIZE TABLE</code>, или
<code>ANALYZE TABLE</code>
по отношению к таблицам, которые
размещены в таблице <code>MERGE</code> и открыты. Если это сделать, в таблице <code>MERGE</code>
останутся ссылки на исходную таблицу, и полученные результаты будут
совершенно непредсказуемыми. Самый легкий путь обойти эти трудности - выполнить
комманду <code>FLUSH TABLES</code>. Это удостоверит, что ни одна таблица
<code>MERGE</code> не будет открытой.  
</ul>

<P>
При создании таблицы <code>MERGE</code> необходимо указать при помощи
<code>UNION(list-of-tables)</code>, какие таблицы требуется использовать как одну. В
случае необходимости, если требуется производить вставку в таблицу <code>MERGE</code> в
первую или в последнюю таблицу в списке <code>UNION</code>, можно задать 
<code>INSERT_METHOD</code>. Если не указать <code>INSERT_METHOD</code> или выбрать <code>NO</code>, то все
команды <code>INSERT</code> для таблицы <code>MERGE</code> будут выдавать ошибку.

</P>
<P>
В приведенном ниже примере показано, как использовать таблицы <code>MERGE</code>:

</P>

<pre>
CREATE TABLE t1 (a INT AUTO_INCREMENT PRIMARY KEY, message CHAR(20));
CREATE TABLE t2 (a INT AUTO_INCREMENT PRIMARY KEY, message CHAR(20));
INSERT INTO t1 (message) VALUES ("Testing"),("table"),("t1");
INSERT INTO t2 (message) VALUES ("Testing"),("table"),("t2");
CREATE TABLE total (a INT AUTO_INCREMENT PRIMARY KEY, message CHAR(20))
TYPE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST;
</pre>

<P>
Кроме того, можно управлять файлом <tt>`.MRG'</tt>, находясь за пределами сервера
MySQL:

</P>

<pre>
shell&#62; cd /mysql-data-directory/current-database
shell&#62; ls -1 t1.MYI t2.MYI &#62; total.MRG
shell&#62; mysqladmin flush-tables
</pre>

<P>
Теперь можно выполнять следующие действия:

</P>

<pre>
mysql&#62; SELECT * FROM total;
+---+---------+
| a | message |
+---+---------+
| 1 | Testing |
| 2 | table   |
| 3 | t1      |
| 1 | Testing |
| 2 | table   |
| 3 | t2      |
+---+---------+
</pre>

<P>
Обратите внимание на то, что столбец <code>a</code>, хотя и объявлен как
<code>PRIMARY KEY</code>, не является уникальным, так как таблица <code>MERGE</code> не может
обеспечивать уникальность для всех таблиц <code>MyISAM</code>.

</P>
<P>
Чтобы повторно преобразовать таблицу <code>MERGE</code>, можно выбрать один из
следующих вариантов:

</P>

<ul>
<LI>

Применить к таблице команду <code>DROP</code> и создать ее повторно
<LI>

Воспользоваться командой <code>ALTER TABLE table_name UNION(...)</code> 
<LI>

Изменить файл <tt>`.MRG'</tt> и выполнить команду <code>FLUSH TABLE</code> над таблицей <code>MERGE</code>
и всеми базовыми таблицами, чтобы обработчик прочитал новый файл
определения.
</ul>



<H3><A NAME="MERGE_table_problems" HREF="manual.ru_toc.html#MERGE_table_problems">7.2.1  Проблемы при работе с таблицами <code>MERGE</code></A></H3>

<P>
При работе с таблицами <code>MERGE</code> могут возникать следующие проблемы:

</P>

<ul>
<LI>

Для таблицы <code>MERGE</code> не могут поддерживаться ограничения <code>UNIQUE</code> по всей
таблице. При выполнении команды <code>INSERT</code> данные помещаются в первую или
последнюю таблицу (в соответствии с <code>INSERT_METHOD=xxx</code>) и для этой
таблицы <code>MyISAM</code> обеспечивается однозначность данных, но ей ничего не
известно об остальных таблицах <code>MyISAM</code>.
<LI>

Команда <code>DELETE FROM merge_table</code> без оператора <code>WHERE</code> очищает только
распределение для таблицы, ничего не удаляя из преобразованных таблиц.
<LI>

Использование команды <code>RENAME TABLE</code> над активной таблицей <code>MERGE</code> может
привести к повреждению таблицы. Эта ошибка будет исправлена в MySQL
4.0.x.
<LI>

При создании таблицы типа <code>MERGE</code> не проверяется совместимость типов
базовых таблиц. Создав таблицу <code>MERGE</code> на основе несовместимых типов, вы
можете столкнуться с непредсказуемыми проблемами.
<LI>

Если для первого добавления индекса <code>UNIQUE</code> в таблицу, преобразованную
в <code>MERGE</code>, используется команда <code>ALTER TABLE</code>, а затем командой <code>ALTER
TABLE</code> в таблицу <code>MERGE</code> добавляется нормальный индекс, порядок ключей
для таблиц будет разным, если в таблице был старый не однозначный
ключ. Это происходит потому, что команда <code>ALTER TABLE</code> помещает ключи
<code>UNIQUE</code> перед нормальными ключами, чтобы как можно раньше обнаружить
дублирующиеся ключи.
<LI>

Оптимизатор диапазона пока не может эффективно использовать таблицу
<code>MERGE</code>, в связи с чем иногда возникают неоптимальные соединения. Это
будет исправлено в MySQL 4.0.x.
</ul>

<P>
Команда <code>DROP TABLE</code> над таблицей, преобразованной в таблицу <code>MERGE</code>, не будет
работать под Windows, так как обработчик <code>MERGE</code> скрывает распределение
таблиц от верхнего уровня MySQL. Поскольку в Windows не разрешается
удалять открытые файлы, сначала необходимо сбросить на диск все таблицы
<code>MERGE</code> (при помощи команды <code>FLUSH TABLES</code>) или удалить таблицу <code>MERGE</code> перед
тем, как удалить таблицу. Эту ошибку мы планируем исправить одновременно с
введением <code>VIEW</code>.

</P>


<H2><A NAME="ISAM" HREF="manual.ru_toc.html#ISAM">7.3  Таблицы <code>ISAM</code></A></H2>

<P>
<A NAME="IDX1487"></A>

</P>
<P>
В MySQL пока еще можно применять  и устаревший тип таблиц <code>ISAM</code>. В
ближайшем времени этот тип будет исключен (возможно, в MySQL 5.0), так как
MyISAM является улучшенной реализацией тех же возможностей. В таблицах <code>ISAM</code>
используется индекс B-tree. Индекс хранится в файле с расширением <tt>`.ISM'</tt>, а
данные - в файле с расширением <tt>`.ISD'</tt>. Таблицы <code>ISAM</code> можно
проверять/восстанавливать при помощи утилиты <code>isamchk</code> (see section <A HREF="manual.ru_Table_types.html#MyISAM">7.1  Таблицы <code>MyISAM</code></A>).

</P>
<P>
Ниже перечислены свойства таблиц <code>ISAM</code>:

</P>

<ul>
<LI>Ключи со сжатой и фиксированной длиной

<LI>Фиксированная и динамическая длина записи

<LI>16 ключей с 16 частями ключей/ключами

<LI>Максимальная длина ключа 256 (по умолчанию)

<LI>Данные хранятся в машинном формате; благодаря этому обеспечивается

скорость, но возникает зависимость от компьютера/ОС.
</ul>

<P>
Большинство параметров таблиц <code>MyISAM</code> также соответствуют таблицам <code>ISAM</code>.
See section <A HREF="manual.ru_Table_types.html#MyISAM">7.1  Таблицы <code>MyISAM</code></A>. Ниже перечислены основные отличия таблиц <code>ISAM</code> от <code>MyISAM</code>:

</P>

<ul>
<LI>Таблицы <code>ISAM</code> не являются переносимыми в двоичном виде с одной

ОС/платформы на другую;
<LI>Невозможна работа с таблицами &#62; 4Гб.

<LI>В строках поддерживается только сжатие префикса.

<LI>Ограничения по маленьким ключам.

<LI>Динамические таблицы больше фрагментируются.

<LI>Таблицы сжимаются при помощи <code>pack_isam</code>, а не при помощи <code>myisampack</code>.

</ul>

<P>
Если вы хотите преобразовать таблицу <code>ISAM</code> в таблицу <code>MyISAM</code>, чтобы иметь
возможность работать с такими утилитами, как <code>mysqlcheck</code>, воспользуйтесь
оператором <code>ALTER TABLE</code>:

</P>

<pre>
mysql&#62; ALTER TABLE tbl_name TYPE = MYISAM;
</pre>

<P>
Встроенные версии MySQL не поддерживают таблицы <code>ISAM</code>.

</P>


<H2><A NAME="HEAP" HREF="manual.ru_toc.html#HEAP">7.4  Таблицы <code>HEAP</code></A></H2>

<P>
<A NAME="IDX1488"></A>

</P>
<P>
Для <code>HEAP</code>-таблиц используются хэш-индексы; эти таблицы хранятся в памяти.
Благодаря этому обработка их осуществляется очень быстро, однако в случае
сбоя MySQL будут утрачены все данные, которые в них хранились. Тип <code>HEAP</code>
очень хорошо подходит для временных таблиц!

</P>
<P>
Для внутренних <code>HEAP</code>-таблиц в MySQL используется 100%-ное динамическое
хэширование без областей переполнения; дополнительное пространство для
свободных списков не требуется. Отсутствуют при использовании <code>HEAP</code>-таблиц
и проблемы с командами удаления и вставки, которые часто применяются  в
хэшированных таблицах:

</P>

<pre>
mysql&#62; CREATE TABLE test TYPE=HEAP SELECT ip,SUM(downloads) AS down
    -&#62; FROM log_table GROUP BY ip;
mysql&#62; SELECT COUNT(ip),AVG(down) FROM test;
mysql&#62; DROP TABLE test;
</pre>

<P>
При использовании <code>HEAP</code>-таблиц необходимо обращать внимание на следующие
моменты:

</P>

<ul>
<LI>

Необходимо всегда указывать параметр <code>MAX_ROWS</code> в операторе <code>CREATE</code>,
чтобы случайным образом не занять всю память.
<LI>

Индексы будут использоваться только с <code>=</code> и <code>&#60;=&#62;</code> (но ОЧЕНЬ быстрые).
<LI>

В <code>HEAP</code>-таблицах для поиска строки могут использоваться только полные
ключи, в то время как для таблиц <code>MyISAM</code>  при поиске  строк может
применяться любой префикс ключа.
<LI>

Для <code>HEAP</code>-таблиц используется формат с фиксированной длиной записи.
<LI>

Для <code>HEAP</code>-таблиц не поддерживаются столбцы формата <code>BLOB</code>/<code>TEXT</code>.
<LI>

Для <code>HEAP</code>-таблиц не поддерживаются столбцы формата <code>AUTO_INCREMENT</code>.
<LI>

До версии 4.0.2 для <code>HEAP</code>-таблиц не поддерживаются индексы в столбцах формата <code>NULL</code>.
<LI>

В <code>HEAP</code>-таблицах могут встречаться совпадающие ключи (что не является
нормой для хэшированных таблиц).
<LI>

<code>HEAP</code>-таблицы используются совместно всеми клиентами (как и все другие
таблицы).
<LI>

Нельзя производить поиск следующей записи в порядке следования (т.е.
использовать индекс в команде <code>ORDER BY</code>).
<LI>

Данные <code>HEAP</code>-таблиц расположены в маленьких блоках. Таблицы на 100%
являются динамическими (при вставке). Нет необходимости ни в областях
переполнения, ни в дополнительных ключах. Удаленные строки помещаются
в связанный список и используются при вставке в таблицу новых данных.
<LI>

Следует позаботиться о том, чтобы имелось достаточное количество
дополнительной памяти  для всех <code>HEAP</code>-таблиц, которые будут
использоваться одновременно,.
<LI>

Чтобы освободить память, необходимо запустить команду <code>DELETE FROM
heap_table</code>, <code>TRUNCATE heap_table</code> или <code>DROP TABLE heap_table</code>.
<LI>

MySQL не может подсчитать, сколько строк находится между двумя
значениями (используется оптимизатором диапазонов для выбора
используемого индекса). Это может повлиять на некоторые запросы, если
преобразовать таблицу <code>MyISAM</code> в формат <code>HEAP</code>.
<LI>

При создании размер таблицы <code>HEAP</code> не может превышать
<code>max_heap_table_size</code>; это сделано для того, чтобы обеспечить защиту от
случайных неквалифицированных действий.
</ul>

<P>
Количество памяти, необходимой для одной строки в <code>HEAP</code>-таблице,
вычисляется следующим образом:

</P>

<pre>
SUM_OVER_ALL_KEYS(max_length_of_key + sizeof(char*) * 2)
+ ALIGN(length_of_row+1, sizeof(char*))
</pre>

<P>
<code>sizeof(char*)</code> составляет 4 на 32-разрядных компьютерах и 8 - на
64-разрядных.

</P>


<H2><A NAME="InnoDB" HREF="manual.ru_toc.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A></H2>

<P>
<A NAME="IDX1489"></A>
<A NAME="IDX1490"></A>
<A NAME="IDX1491"></A>
<A NAME="IDX1492"></A>

</P>



<H3><A NAME="InnoDB_overview" HREF="manual.ru_toc.html#InnoDB_overview">7.5.1  Обзор таблиц InnoDB</A></H3>

<P>
Таблицы <code>InnoDB</code> в MySQL снабжены обработчиком таблиц, обеспечивающим
безопасные транзакции (уровня <code>ACID</code>) с возможностями фиксации транзакции,
отката и восстановления после сбоя. Для таблиц InnoDB осуществляется
блокировка на уровне строки, а также используется метод чтения без
блокировок в команде <code>SELECT</code> (наподобие применяющегося в Oracle).
Перечисленные функции позволяют улучшить взаимную совместимость и повысить
производительность в многопользовательском режиме. В InnoDB нет
необходимости в расширении блокировки, так как блоки строк в InnoDB
занимают очень мало места. Для таблиц InnoDB поддерживаются ограничивающие
условия <code>FOREIGN KEY</code>.

</P>
<P>
<code>InnoDB</code> предназначается для получения максимальной производительности при
обработке больших объемов данных. По эффективности использования
процессора этот тип намного превосходит другие модели реляционных баз
данных с памятью на дисках.

</P>
<P>
Технически InnoDB является завершенной системой управления базой данных в
рамках MySQL. В InnoDB есть свой собственный буферный пул для кэширования
данных и индексов в основной памяти. Таблицы и индексы InnoDB хранятся в
специальном пространстве памяти, которое может состоять из нескольких
файлов. В этом заключается отличие InnoDB от, например, таблиц MyISAM:
каждая таблица MyISAM хранится в отдельном файле. Таблицы InnoDB могут
быть любого размера даже в тех операционных системах, где установлено
ограничение файла в 2 Гб.

</P>
<P>
Свежую информацию по InnoDB можно найти на <a HREF="http://www.innodb.com/">http://www.innodb.com/</a>. Здесь
же находится последняя версия руководства по InnoDB. Кроме того, можно
заказать коммерческие лицензии и поддержку для InnoDB.

</P>
<P>
В настоящий момент (октябрь 2001 года) таблицы InnoDB применяются  на
нескольких больших сайтах баз данных, для которых важна высокая
производительность. Так, таблицы InnoDB используются на популярном сайте
новостей Slashdot.org. Формат InnoDB применяется для хранения более 1Тб
данных компании Mytrix, Inc; можно привести пример еще одного сайта, где
при помощи при помощи InnoDB обрабатывается средняя нагрузка объемом в 800
вставок/обновлений в секунду.

</P>
<P>
Таблицы InnoDB входят в дистрибутив исходных текстов MySQL, начиная с
версии 3.23.34a; они активизированы в исполняемом коде MySQL -Max. Для
Windows исполняемые коды -Max находятся в стандартном дистрибутиве.

</P>
<P>
Если вы загрузили исполняемую версию MySQL, которая включает поддержку
InnoDB, следует просто выполнить инструкции руководства MySQL по установке
исполняемой версии MySQL. В случае, если у вас уже установлен MySQL-3.23,
проще всего установить MySQL -Max, чтобы заменить исполняемый файл <tt>`mysqld'</tt>
соответствующим файлом из дистрибутива -Max. Различными  в MySQL и MySQL
-Max являются  только исполняемые файлы сервера. См. разделы section <A HREF="manual.ru_Installing.html#Installing_binary">2.2.10  Установка бинарного дистрибутива MySQL</A> и See section <A HREF="manual.ru_MySQL_Database_Administration.html#mysqld-max">4.7.5  <code>mysqld-max</code>, расширенный сервер <code>mysqld</code></A>.

</P>
<P>
Чтобы произвести компиляцию MySQL с поддержкой InnoDB, загрузите
MySQL-3.23.34a или более новую версию с <a HREF="http://www.mysql.com/">http://www.mysql.com/</a> и настройте
MySQL при помощи параметра <code>--with-innodb</code>. См. раздел руководства MySQL по
установке дистрибутива исходного кода MySQL, See section <A HREF="manual.ru_Installing.html#Installing_source">2.3  Установка исходного дистрибутива MySQL</A>.

</P>

<pre>
cd /path/to/source/of/mysql-3.23.37
./configure --with-innodb
</pre>

<P>
Чтобы  использовать InnoDB, необходимо  указать  параметры  запуска InnoDB
в  своем  файле  <tt>`my.cnf'</tt> или <tt>`my.ini'</tt>. Самый простой способ внести
изменения - добавить в раздел <code>[mysqld]</code> строку

</P>

<pre>
innodb_data_file_path=ibdata:30M
</pre>

<P>
Однако чтобы добиться высокой скорости работы, лучше указать рекомендуемые
параметры. See section <A HREF="manual.ru_Table_types.html#InnoDB_start">7.5.2  Параметры запуска InnoDB</A>.

</P>
<P>
InnoDB распространяется на условиях общедоступной лицензии версии 2 (от
июня 1991 года). В дистрибутиве исходного кода MySQL InnoDB находится в
подкаталоге <tt>`innobase'</tt>.

</P>


<H3><A NAME="InnoDB_start" HREF="manual.ru_toc.html#InnoDB_start">7.5.2  Параметры запуска InnoDB</A></H3>

<P>
Чтобы использовать таблицы InnoDB в MySQL-Max-3.23, НЕОБХОДИМО задать
параметры конфигурации в разделе <code>[mysqld]</code> файла конфигурации <tt>`my.cnf'</tt> или
в файле параметров Windows <tt>`my.ini'</tt>.

</P>
<P>
В версии 3.23 как минимум необходимо указать имя и размер файлов данных в
<code>innodb_data_file_path</code>.  Если вы не указали <code>innodb_data_home_dir</code> в
<tt>`my.cnf'</tt> по умолчанию эти файлы создаются в директории данных MySQL. Если
вы указали <code>innodb_data_home_dir</code> как пустую строку, то вы должны указать
полный путь к вашим файлам данным в <code>innodb_data_file_path</code>. В MySQL 4.0
не требуется задавать даже <code>innodb_data_file_path</code>: по умолчанию для него
создается автоматически увеличивающийся файл размером в 10 Мб с именем
<tt>`ibdata1'</tt> в каталоге <tt>`datadir'</tt> MySQL. (в MySQL-4.0.0 и 4.0.1 размер
файла данных составляет 64 Мб и он не является автоматически увеличивающимся).

</P>
<P>
Если вы не хотите использовать <code>InnoDB</code> таблицы, вы можете добавить опцию
<code>skip-innodb</code> в конфигурационный файл MySQL. 

</P>
<P>
Однако для того, чтобы получить высокую производительность, НЕОБХОДИМО
явно задать параметры InnoDB, перечисленные в следующих примерах.

</P>
<P>
Начиная с версий 3.23.50 и 4.0.2  для InnoDB имеется возможность задавать
последний файл данных в <code>innodb_data_file_path</code> как автоматически
увеличивающийся. В этом случае для <code>innodb_data_file_path</code> используется
следующий синтаксис:

</P>

<pre>
pathtodatafile:sizespecification;pathtodatafile:sizespecification;...
... ;pathtodatafile:sizespecification[:autoextend[:max:sizespecification]]
</pre>

<P>
Если последний файл данных указан с параметром автоматического увеличения,
то в случае нехватки места для табличной области InnoDB будет увеличивать
последний файл данных; приращение файла каждый раз составляет 8 Мб.
Например, синтаксис:

</P>

<pre>
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:100M:autoextend
</pre>

<P>
указывает InnoDB создать один файл данных с начальным размером 100 Мб,
который будет увеличиваться на 8 Мб каждый раз, когда не будет хватать
места. Если текущий диск окажется заполненным, можно, к примеру, добавить
еще один файл данных на другой диск. При задании размера автоматически
увеличивающегося файла <tt>`ibdata1'</tt> следует округлить его текущий размер до
ближайшего числа, кратного 1024 * 1024 байтам (= 1 Мб), и явно указать
округленный размер <tt>`ibdata1'</tt> в <code>innodb_data_file_path</code>. После этой записи
можно добавить еще один файл данных:

</P>

<pre>
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
</pre>

<P>
Следует соблюдать осторожность при работе в файловых системах, в которых
установлено ограничение на размер файла в 2 Гб! Максимальный для данной
операционной системы размер файла InnoDB не известен. В таком случае
желательно указать максимальный размер файла данных:

</P>

<pre>
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:100M:autoextend:max:2000M
</pre>

<P>
<strong>Простой пример файла <tt>`my.cnf'</tt></strong>. Предположим, что у вас есть
компьютер с 128 Мб ОЗУ и одним жестким диском. Ниже приведены примеры возможных
параметров конфигурации в <tt>`my.cnf'</tt> или <tt>`my.ini'</tt> для InnoDB. Мы
предполагаем что у вас запущен MySQL-Max-3.23.50 и выше или MySQL-4.0.2 и выше.
Этот пример подходит для большинства пользователей работающих под Unix и
Windows, которые не хотят располагать файлы данных и журнальные файлы на
различных дисках. В этом примере создается автоматически увеличивающийся файл
<tt>`ibdata1'</tt> и два журнальных файла <tt>`ib_logfile0'</tt> и <tt>`ib_logfile1'</tt> в
в директории данных MySQL (обычно <tt>`/mysql/data'</tt>). Небольшой архивный
журнальный файл InnoDB <tt>`ib_arch_log_0000000000'</tt> также располагается в каталоге
<code>datadir</code>:

</P>

<pre>
[mysqld]
# Сюда  можно  добавить  другие  опции MySQL
# ...
#
# Файлы  данных  должны  иметь  достаточно
# места  для  сохранения  ваших  данных  и
# индексов. Убедитесь что у вас достаточно 
# свободного места на диске.
innodb_data_file_path = ibdata1:10M:autoextend
# Размер  буферного  пула  следует  задавать
# как 50 - 80% памяти  компьютера
set-variable = innodb_buffer_pool_size=70M
set-variable = innodb_additional_mem_pool_size=10M
# Размер  файла  журналов  должен  составлять
# около 25% от  размера  буферного  пула
set-variable = innodb_log_file_size=20M
set-variable = innodb_log_buffer_size=8M
# Если  допустима  потеря  некоторых
# последних  транзакций, установите
# flush_log_в_trx_commit в 0
innodb_flush_log_at_trx_commit=1
</pre>

<P>
<strong>Убедитесь, что MySQL server имеет права создавать файлы</strong> в <code>datadir</code>.

</P>
<P>
Не забывайте, что в некоторых файловых системах существует ограничение в 2
Гб на размер файла данных! Общий размер файлов журналов должен быть меньше
4 Гб, а общий размер файлов данных - больше или равен 10Мб.

</P>
<P>
При первом создании базы данных InnoDB лучше всего запустить сервер MySQL
из командной строки. Тогда на экран будет выводиться информация о создании базы
данных и вы сможете увидеть, что происходит. Смотрите следующий раздел, в
котором описано, на что должна быть похожа выводимая информация.  Например, в
Windows можно запустить <tt>`mysqld-max.exe'</tt> с параметрами:

</P>

<pre>
your-path-to-mysqld&#62;mysqld-max --console
</pre>

<P>
Где поместить файл <tt>`my.cnf'</tt> или <tt>`my.ini'</tt> в Windows? Для Windows существуют
следующие правила:

<ul>
<LI>Должен быть создан только один файл <tt>`my.cnf'</tt> или <tt>`my.ini'</tt>.

<LI>Файл <tt>`my.cnf'</tt> должен находиться в корневом каталоге диска <tt>`C:'</tt>.

<LI>Файл <tt>`my.ini'</tt> должен находиться в каталоге <tt>`WINDIR'</tt>, например в

<tt>`C:\WINDOWS'</tt> или <tt>`C:\WINNT'</tt>. Чтобы вывести значение <tt>`WINDIR'</tt>, можно
воспользоваться командой <code>SET</code> операционной системы MS-DOS.
<LI>Если на вашем компьютере применяется загрузчик операционной системы, в

котором диск <tt>`C:'</tt> не является загрузочным, то необходимо использовать
файл <tt>`my.ini'</tt>.
</ul>

<P>
<strong>Где указываются параметры в Unix?</strong>

</P>
<P>
В Unix <code>mysqld</code> считывает параметры из
следующих файлов, если они существуют, в таком порядке:

<ul>
<LI><tt>`/etc/my.cnf'</tt> - общие параметры.

<LI><tt>`COMPILATION_DATADIR/my.cnf'</tt> -- параметры для сервера.

<LI><tt>`defaults-extra-file'</tt> -- файл, указанный при помощи

<code>--defaults-extra-file=...</code>.
<LI><tt>`~/.my.cnf'</tt> - параметры для пользователя.

</ul>

<P>
<code>COMPILATION_DATADIR</code> представляет собой каталог данных MySQL, который был
указан как параметр <code>./configure</code> при компиляции <code>mysqld</code> (обычно
<tt>`/usr/local/mysql/data'</tt> для установки исполняемых файлов или <tt>`/usr/local/var'</tt> 
для установки исходного кода).

</P>
<P>
Если точно не известно, откуда <code>mysqld</code> считывает свои файлы <tt>`my.cnf'</tt> или
<tt>`my.ini'</tt>, можно задать путь как первый параметр командной строки для
сервера: <code>mysqld --defaults-file=your_path_to_my_cnf</code>.

</P>
<P>
InnoDB формирует полный путь к файлу данных путем соединения
<code>innodb_data_home_dir</code> и имени файла данных или пути в
<code>innodb_data_file_path</code>, добавляя при необходимости косую черту. Если
ключевое слово <code>innodb_data_home_dir</code> не упоминается в <tt>`my.cnf'</tt>
совсем, по умолчанию используется директория данных MySQL.

</P>
<P>
<strong>Пример расширенного файла <tt>`my.cnf'</tt></strong>

</P>
<P>
Предположим, что у вас есть
компьютер Linux с 2 Гб ОЗУ и тремя жесткими дисками по 60 Гб (с путями
каталогов <tt>``/''</tt>, <tt>``/dr2''</tt> and <tt>``/dr3''</tt>). Ниже приведен пример
возможных параметров конфигурации в <tt>`my.cnf'</tt> для InnoDB:

</P>
<P>
<strong>Учтите, что InnoDB не создает директории: вы должны создать их
самостоятельно</strong>. Используйте комманду Unix или MS-DOS <code>mkdir</code> для создания
домашней директории для InnoDB и домашней директории для группы журнальных
файлов.

</P>

<pre>
[mysqld]
# Здесь  вы  можете  задать  другие  опции  сервера MySQL
# ...
#
innodb_data_home_dir = 
# Файлы  данных  должны  иметь  достаточно
# места  для  сохранения  ваших  данных  и
# индексов
innodb_data_file_path = /ibdata/ibdata1:2000M;/dr2/ibdata/ibdata2:2000M:autoextend
# Размер  буферного  пула  следует  задавать
# как 50 - 80% памяти  компьютера, но
# для Linux x86 следует  убедиться, что
# общий  расход  памяти  не  превышает 2 Гб
set-variable = innodb_buffer_pool_size=1G
set-variable = innodb_additional_mem_pool_size=20M
innodb_log_group_home_dir = /dr3/iblogs
# .._log_arch_dir должен  быть  такой
# же, как _log_group_home_dir
innodb_log_arch_dir = /dr3/iblogs
set-variable = innodb_log_files_in_group=3
# Размер  файла  журналов  должен  составлять
# около 15 % от  размера  буферного  пула
set-variable = innodb_log_file_size=150M
set-variable = innodb_log_buffer_size=8M
# Если  допустима  потеря  некоторых
# последних  транзакций, установите
# flush_log_в_trx_commit в 0
innodb_flush_log_at_trx_commit=1
set-variable = innodb_lock_wait_timeout=50
#innodb_flush_method=fdatasync
#set-variable = innodb_thread_concurrency=5
</pre>

<P>
Обратите внимание на то, что два файла данных размещены на разных дисках.
InnoDB будет заполнять табличное пространство, образованное файлами
данных, снизу вверх. В некоторых случаях это позволяет увеличить
производительность баз данных, если не все данные размещены на одном
физическом диске. Размещение файлов журнала на другом диске очень часто
позволяет повысить производительность. Для файлов данных можно также
использовать разделы реального диска (реальные устройства): в некоторых
версиях Unix это ускоряет операции ввода/вывода. Информацию по указанию
параметров в <tt>`my.cnf'</tt> вы найдете в разделе руководства по управлению
пространством файлов InnoDB.

</P>
<P>
<strong>Предупреждение</strong>: в Linux x86 необходимо соблюдать осторожность, чтобы не
установить слишком высокое значение использования памяти. <code>glibc</code> может дать
процессу разрастись и превысить стеки потоков, что приведет к сбою
сервера. Степень риска значительно повышается, если значение

</P>

<pre>
innodb_buffer_pool_size + key_buffer +
max_connections * (sort_buffer + read_buffer_size) + max_connections * 2 MB
</pre>

<P>
приближается к значению 2 Гб или превышает его. Каждый поток будет
использовать стек (обычно 2 Мб, но в бинарной поставке MySQL AB только 256
Кб) и в худшем случае также дополнительную память <code>sort_buffer +
read_buffer_size</code>.

</P>
<P>
<strong>Как настроить другие параметры сервера mysqld?</strong>
Для большинства
пользователей подходят следующие стандартные значения:

</P>

<pre>
skip-locking
set-variable = max_connections=200
set-variable = read_buffer_size=1M
set-variable = sort_buffer=1M
# Размер key_buffer следует  задавать  как
# 5%-50% от  вашего  ОЗУ, в  зависимости
# от  того, как  часто  у  вас  используются
# таблицы MyISAM, но key_buffer +
# размер  буферного  пула InnoDB не  должен
# превышать 80% вашего  ОЗУ
set-variable = key_buffer=...
</pre>

<P>
Обратите внимание на то, что некоторые параметры представлены при помощи
формата числового параметра <tt>`my.cnf'</tt>: <code>set-variable = innodb... = 123</code>, а
остальные (строчные и логические параметры) - при помощи другого формата:
<code>innodb_... = ...</code>.

</P>
<P>
Параметры настройки имеют следующие значения:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Параметр</strong> </TD><TD> <strong>Описание</strong>

</TD></TR>
<TR><TD><code>innodb_data_home_dir</code> </TD><TD> Общая часть пути к каталогу всех файлов
данных InnoDB. Если вы не указали этот параметр в <tt>`my.cnf'</tt>, то по
умолчанию для этого параметра принято значение <code>datadir</code> MySQL. Если
вы указали как пустою строку, то в этом случае вы можете использовать полный
путь в <code>innodb_data_file_path</code>. 
</TD></TR>
<TR><TD><code>innodb_data_file_path</code> </TD><TD> Пути к отдельным файлам данных и их размеры.
Полный путь к каталогу каждого файла данных   
получается путем объединения                  
<code>innodb_data_home_dir</code> с путем, который задается
данным параметром. Размеры файлов указаны в   
мегабайтах. InnoDB также ``понимает'' сокращение 'G', 1 G означает 1024 М. Начиная с
версии 3.23.44 в операционных системах, где   
поддерживаются большие файлы, можно задавать  
размер файла, превышающий 4 Гб. В некоторых   
операционных системах файлы должны быть &#60; 2   
Гб. Общий объем файлов должен быть как минимум
10 Мб.
</TD></TR>
<TR><TD><code>innodb_mirrored_log_groups</code> </TD><TD> Количество идентичных копий групп журналов, которые хранятся для базы данных. На данный
момент этому параметру должно быть присвоено  
значение 1.
</TD></TR>
<TR><TD><code>innodb_log_group_home_dir</code> </TD><TD> Путь к каталогу файлов журналов InnoDB.
</TD></TR>
<TR><TD><code>innodb_log_files_in_group</code> </TD><TD> Количество файлов журналов в группе журналов. InnoDB производит запись в файлы по круговому
способу. Для этого параметра рекомендуется установить значение "3".
</TD></TR>
<TR><TD><code>innodb_log_file_size</code> </TD><TD> Размер каждого файла журнала в группе журналов
(указывается в мегабайтах). Разумный диапазон 
значений составляет от 1М до 1/N от размера   
буферного пула, приведенного ниже, где N -    
количество файлов журналов в группе. Чем      
больше это значение, тем меньше требуется сбросов на диск информации из буферного пула, 
что сокращает количество дисковых операций    
ввода/вывода. Однако в случае сбоя            
восстановление при больших размерах файлов    
журналов займет больше времени. Общий размер  
файлов журналов на 32-разрядных компьютерах   
должен быть &#60; 4 Гб.
</TD></TR>
<TR><TD><code>innodb_log_buffer_size</code> </TD><TD> Размер буфера, который в InnoDB используется
для записи информации файлов журналов на диск.
Разумный диапазон значений составляет от 1М до 8М. 
Большой буфер журналов позволяет осуществлять 
объемные транзакции без записи журнала на диск
до завершения транзакции. Поэтому если ваши   
транзакции отличаются значительными объемами, 
увеличение буфера журналов сократит количество
операций ввода/вывода диска.
</TD></TR>
<TR><TD><code>innodb_flush_log_at_trx_commit</code> </TD><TD> Обычно этому параметру присваивается значение
1; при этом значении после завершения         
транзакции информация журнала записывается на 
диск и фиксируются изменения, внесенные       
транзакцией, благодаря чему данные сохраняются в случае сбоя базы данных. Если у вас         
выполняется большое количество маленьких      
транзакций и вы готовы пожертвовать такой     
возможностью, можно установить значение этого 
параметра в 0, чтобы снизить количество обращений к диску.
</TD></TR>
<TR><TD><code>innodb_log_arch_dir</code> </TD><TD> Каталог, в котором будут храниться заполненные
файлы журналов, если включено архивирование журналов. Значение этого параметра на         
настоящий момент должно задаваться таким же, как и для <code>innodb_log_group_home_dir</code>.
</TD></TR>
<TR><TD><code>innodb_log_archive</code> </TD><TD> На данный момент значение этого параметра
должно устанавливаться в 0. Поскольку восстановление из резервной копии MySQL       
осуществляет при помощи своих собственных     
файлов журналов, архивировать файлы журналов  
InnoDB нет необходимости.
</TD></TR>
<TR><TD><code>innodb_buffer_pool_size</code> </TD><TD> Размер буфера памяти, который InnoDB
использует для кэширования данных и индексов  
своих таблиц. Чем больше это значение, тем    
меньше обращений к диску осуществляется при   
получении доступа к данным таблиц. На специально выделенном сервере баз данных этот 
параметр можно установить в значение до 80%   
физической памяти компьютера. Однако для этого
параметра не следует задавать слишком большое 
значение, так как при  недостатке физической  
памяти операционная система будет вынуждена   
сбрасывать часть информации на диск.
</TD></TR>
<TR><TD><code>innodb_additional_mem_pool_size</code> </TD><TD> Размер пула памяти, который InnoDB использует
для хранения информации словаря данных и      
других внутренних структур данных. Разумным   
значением для этого параметра может быть 2М,  
но чем больше таблиц в вашем приложении, тем больше информации нужно будет разместить в    
этом пуле. Если памяти в этом пуле будет      
недостаточно для InnoDB, то будет выделятся   
память операционной системы, а в файл журнала 
MySQL будут записываться предупреждающие      
сообщения.
</TD></TR>
<TR><TD><code>innodb_file_io_threads</code> </TD><TD> Количество потоков ввода/вывода файлов в
InnoDB. Обычно этому параметру присваивается значение 4, но в Windows при помощи увеличения
данного значения можно сократить количество   
обращений к диску.
</TD></TR>
<TR><TD><code>innodb_lock_wait_timeout</code> </TD><TD> Время простоя (в секундах), на протяжении
которого транзакция InnoDB может ожидать      
блокировки прежде, чем будет произведен откат.
InnoDB автоматически обнаруживает зависшие    
транзакции в своей таблице блокировок и       
производит откат транзакций. Если в той же самой транзакции используется команда <code>LOCK 
TABLES</code>, или другие обработчики таблиц с       
безопасными транзакциями, отличными от InnoDB,
то может возникнуть зависание, которое не     
будет обнаружено InnoDB. В таких ситуациях    
параметр времени простоя помогает устранить   
проблему.
</TD></TR>
<TR><TD><code>innodb_flush_method</code> (Доступен, начиная с версий 3.23.40 и выше). По умолчанию для этого параметра принято
значение <code>fdatasync</code>. Другой возможный вариант - <code>O_DSYNC</code>.                                      
</TD></TR>
</TABLE>



<H3><A NAME="InnoDB_init" HREF="manual.ru_toc.html#InnoDB_init">7.5.3  Создание табличной области InnoDB</A></H3>

<P>
Предположим, что вы установили MySQL и внесли в файл <tt>`my.cnf'</tt> необходимые
параметры настройки InnoDB. Прежде чем запустить MySQL, необходимо
убедиться, что указанные каталоги для файлов данных и журналов InnoDB
существуют, и что у вас есть право доступа к этим каталогам. InnoDB может
создавать только файлы, но не каталоги. Проверьте также, достаточно ли у
вас свободного дискового пространства для файлов данных и журналов.

</P>
<P>
Теперь при запуске MySQL InnoDB начнет создавать ваши файлы данных и файлы
журналов. При этом будет выводиться примерно такая информация:

</P>

<pre>
~/mysqlm/sql &#62; mysqld
InnoDB: The first specified datafile /home/heikki/data/ibdata1
did not exist:
InnoDB: a new database to be created!
InnoDB: Setting file /home/heikki/data/ibdata1 size to 134217728
InnoDB: Database physically writes the file full: wait...
InnoDB: datafile /home/heikki/data/ibdata2 did not exist:
new to be created
InnoDB: Setting file /home/heikki/data/ibdata2 size to 262144000
InnoDB: Database physically writes the file full: wait...
InnoDB: Log file /home/heikki/data/logs/ib_logfile0 did not exist:
new to be created
InnoDB: Setting log file /home/heikki/data/logs/ib_logfile0 size to
5242880
InnoDB: Log file /home/heikki/data/logs/ib_logfile1 did not exist:
new to be created
InnoDB: Setting log file /home/heikki/data/logs/ib_logfile1 size to
5242880
InnoDB: Log file /home/heikki/data/logs/ib_logfile2 did not exist:
new to be created
InnoDB: Setting log file /home/heikki/data/logs/ib_logfile2 size to
5242880
InnoDB: Started
mysqld: ready for connections
</pre>

<P>
Сейчас была создана новая база данных InnoDB. К серверу MySQL вы можете
подключиться при помощи обычных клиентских программ MySQL, таких как
<code>mysql</code>. Если работа сервера MySQL завершается при помощи команды <code>mysqladmin
shutdown</code>, InnoDB выведет примерно следующее:

</P>

<pre>
010321 18:33:34 mysqld: Normal shutdown
010321 18:33:34 mysqld: Shutdown Complete
InnoDB: Starting shutdown...
InnoDB: Shutdown completed
</pre>

<P>
Теперь можно просмотреть каталоги файлов данных и журналов, чтобы увидеть,
какие файлы были созданы. В каталоге журналов будет также находиться
небольшой файл <code>ib_arch_log_0000000000</code>. Этот файл появляется в результате
создания базы данных, после чего InnoDB отключает архивирование журналов.
При новом запуске MySQL будет выведена примерно следующая информация:

</P>

<pre>
~/mysqlm/sql &#62; mysqld
InnoDB: Started
mysqld: ready for connections
</pre>



<H4><A NAME="Error_creating_InnoDB" HREF="manual.ru_toc.html#Error_creating_InnoDB">7.5.3.1  Если во время создания базы данных что-то происходит не так</A></H4>

<P>
Если InnoDB выдает ошибку операционной системы во время операции с файлом,
то причиной возникшей проблемы, как правило, является одна из следующих:

</P>

<ul>
Вы не создали каталоги для файлов данных или журналов InnoDB.
<LI>У <code>mysqld</code> нет прав на создание файлов в этих каталогах.

<LI><code>mysqld</code> не считал нужный файл <tt>`my.cnf'</tt> или <tt>`my.ini'</tt> и, соответственно,

не получил указанных вами параметров.
<LI>Диск переполнен или превышена квота использования диска.

<LI>Вы создали подкаталог, имя которого совпадает с указанным файлом

данных.
<LI>Синтаксическая  ошибка в <code>innodb_data_home_dir</code> или

<code>innodb_data_file_path</code>.
</ul>

<P>
Если что-то происходит не так во время создания базы данных InnoDB,
необходимо удалить все файлы, созданные InnoDB. В их число входят все
файлы данных, все файлы журналов, небольшой архивный файл журнала; если вы
уже создали какие-либо таблицы InnoDB, то следует также удалить
соответствующие им файлы <tt>`.frm'</tt>, которые находятся в каталогах баз данных
MySQL. После этого можно попробовать создать базу данные InnoDB еще раз.

</P>


<H3><A NAME="Using_InnoDB_tables" HREF="manual.ru_toc.html#Using_InnoDB_tables">7.5.4  Создание  таблиц InnoDB</A></H3>

<P>
Предположим, что у вас запущен клиент MySQL при помощи команды <code>mysql test</code>.
Чтобы создать таблицу в формате InnoDB, необходимо в команде создания
таблицы SQL указать <code>TYPE = InnoDB</code>:

</P>

<pre>
CREATE TABLE CUSTOMER (A INT, B CHAR (20), INDEX (A)) TYPE = InnoDB;
</pre>

<P>
Эта команда SQL создаст таблицу и индекс в столбце A табличной области
InnoDB. Кроме того, MySQL создаст файл <tt>`CUSTOMER.frm'</tt> каталоге баз данных
MySQL с именем <tt>`test'</tt>. В свой собственный словарь данных InnoDB добавит
запись для таблицы <code>test/CUSTOMER</code>. Таким образом, можно создать таблицу с
таким же именем <code>CUSTOMER</code> в другой базе данных MySQL, и это не приведет к
конфликту имен таблиц в рамках InnoDB.

</P>
<P>
Для любой таблицы, которая была создана с параметром <code>TYPE = InnoDB</code>, можно
запросить количество свободного пространства в табличной области InnoDB.
Для этого нужно выполнить команду запроса состояния таблицы. Количество
свободного пространства будет выводиться в разделе примечаний к таблице в
выходной информации команды <code>SHOW</code>.

</P>
<P>
Например:

</P>

<pre>
SHOW TABLE STATUS FROM test LIKE 'CUSTOMER'
</pre>

<P>
Обратите внимание на то, что статистические данные, которые команда <code>SHOW</code>
выдает по таблицам InnoDB, являются приблизительными: они используются для
оптимизации SQL. Точными являются зарезервированные размеры таблицы и
индекса, значения которых выдаются в байтах.

</P>


<H4><A NAME="SEC459" HREF="manual.ru_toc.html#SEC459">7.5.4.1  Преобразование таблиц MyISAM в формат InnoDB</A></H4>

<P>
В InnoDB отсутствует специальная оптимизация создания отдельных индексов.
Таким образом, этот формат не обеспечивает экспорта и импорта таблиц с
последующим созданием индексов. Самый быстрый способ преобразовать таблицу
в формат InnoDB - напрямую вставить данные в таблицу InnoDB,
воспользовавшись командой <code>ALTER TABLE ... TYPE=INNODB</code>, или создать пустую
таблицу InnoDB с такой же структурой и вставить строки при помощи команды
<code>INSERT INTO ... SELECT * FROM ...</code>.

</P>
<P>
Чтобы лучше контролировать процесс вставки, большие таблицы желательно
вставлять по частям:

</P>

<pre>
INSERT INTO newtable SELECT * FROM oldtable
   WHERE yourkey &#62; something AND yourkey &#60;= somethingelse;
</pre>

<P>
После того, как все данные будут вставлены, таблицы можно будет
переименовать.

</P>
<P>
Во время преобразования больших таблиц необходимо задать достаточно
большой размер динамического буфера InnoDB, чтобы снизить количество
дисковых операций ввода/вывода. Однако размер буфера не должен превышать
80% физической памяти компьютера. Следует установить большие размеры для
файлов журналов InnoDB, а также большой размер буфера журналов.

</P>
<P>
Убедитесь, что у вас достаточно свободного пространства для табличной
области: таблицы InnoDB занимают намного больше места, чем таблицы MyISAM.
Если во время выполнения команды <code>ALTER TABLE</code> будет исчерпано свободное
дисковое пространство, начнется выполнение отката, и это может занять
несколько часов, если диск заполнен. Во время вставок для таблицы InnoDB
используется буфер вставки, чтобы произвести объединение вторичных
индексных записей с индексными таблицами при помощи групповых операций.
Это позволяет значительно снизить интенсивность дисковых операций
ввода/вывода. При откате такой механизм не используется, поэтому откат
может занять в 30 раз больше времени, чем вставка.

</P>
<P>
В случае, если началось выполнение отката и база данных не содержит ценной
информации, лучше прервать этот процесс и удалить все данные InnoDB, файлы
журналов, а также все таблицы InnoDB (файлы с расширением <tt>`.frm'</tt>), и начать
свою работу сначала, а не ждать завершения выполнения миллионов операций
ввода/вывода диска.

</P>


<H4><A NAME="SEC460" HREF="manual.ru_toc.html#SEC460">7.5.4.2  Ограничения внешнего ключа</A></H4>

<P>
Начиная с версии 3.23.43b, в InnoDB включены ограничения внешних ключей.
InnoDB - первый формат таблиц MySQL, который обеспечивает возможность
задавать ограничения внешнего ключа, чтобы обеспечить целостность данных.

</P>
<P>
Синтаксис задания ограничения внешнего ключа в InnoDB следующий:

</P>

<pre>
[CONSTRAINT symbol] FOREIGN KEY (index_col_name, ...)
                    REFERENCES table_name (index_col_name, ...)
                    [ON DELETE {CASCADE | SET NULL | NO ACTION
                                | RESTRICT}]
                    [ON UPDATE {CASCADE | SET NULL | NO ACTION
                                | RESTRICT}]
</pre>

<P>
Обе таблицы должны быть InnoDB-типа; <strong>обязательно также наличие индекса, в
котором внешний ключ и ссылочный ключ должны находиться в ПЕРВЫХ столбцах</strong>.
Для таблиц InnoDB индексы по внешним ключам или ссылочным ключам не
создаются автоматически: их создание требуется задавать явно.

</P>
<P>
Соответствующие столбцы внешнего и ссылочного ключей в таблице InnoDB
должны содержать одинаковые типы данных, чтобы их можно было сравнивать
без преобразования типов. <strong>Размер и знак целочисленных типов должны быть
одинаковыми</strong>. Длины для строковых типов могут не совпадать.

</P>
<P>
Если вы указали действие <code>SET NULL</code>, убедитесь что <strong>вы не объявили</strong>
столбец в дочерней таблице как <code>NOT NULL</code>.

</P>
<P>
Если оператор MySQL <code>CREATE TABLE</code> выдает ошибку с номером 1005, и в строке
сообщения об ошибке присутствует ссылка на ошибку с номером 150, то
произошел сбой создания таблицы из-за того, что ограничения внешнего ключа
не были сформированы надлежащим образом. Аналогично и для оператора <code>ALTER
TABLE</code>: если происходит ошибка при выполнении оператора и в сообщении
присутствует ссылка на ошибку с номером 150, то определение внешнего ключа
для преобразовываемой таблицы сформировано неправильно.

</P>
<P>
Начиная с версии 3.23.50 с ограничением внешнего ключа можно также
связывать выражения <code>ON DELETE CASCADE</code> или <code>ON DELETE SET NULL</code>.
Начиная с версии 4.0.8 вы можете это же использовать с <code>ON UPDATE</code>.

</P>
<P>
Если указано выражение <code>ON DELETE CASCADE</code> и строка в родительской таблице
удалена, то в формате InnoDB все эти строки автоматически удаляются также
и из дочерней таблицы, значения внешнего ключа которой равны значениям
ссылочного ключа в строке родительской таблицы. Если указано выражение <code>ON
DELETE SET NULL</code>, строки дочерней таблицы автоматически обновляются,
поэтому столбцам во внешнем ключе также присваивается значение SQL <code>NULL</code>.

</P>
<P>
Начиная с версии 3.23.50 в InnoDB не осуществляется проверка ограничений
внешних ключей на наличие значений внешних или родительских ключей,
которые содержат столбец <code>NULL</code>.

</P>
<P>
Начиная с версии 3.23.50 синтаксический анализатор InnoDB обеспечивает
возможность использовать обратные кавычки (`), ограничивающие имена таблиц
и столбцов в <code>FOREIGN KEY ... REFERENCES ...</code>, однако синтаксический анализатор
InnoDB еще ``не знает'' об опции <code>lower_case_table_names</code>, которая может
быть задана в файле <tt>`my.cnf'</tt>.

</P>
<P>
Пример:

</P>

<pre>
CREATE TABLE parent(id INT NOT NULL, PRIMARY KEY (id)) TYPE=INNODB;
CREATE TABLE child(id INT, parent_id INT, INDEX par_ind (parent_id),
	     FOREIGN KEY (parent_id) REFERENCES parent(id)
	     ON DELETE SET NULL
) TYPE=INNODB;
</pre>

<P>
Начиная с версии 3.23.50, для таблиц InnoDB обеспечивается возможность
добавлять новые ограничения внешних ключей для таблиц при помощи

</P>

<pre>
ALTER TABLE yourtablename
  ADD [CONSTRAINT symbol] FOREIGN KEY (...) REFERENCES anothertablename(...)
</pre>

<P>
Однако не следует забывать предварительно создавать необходимые индексы. В
InnoDB версий &#60; 3.23.50 команды <code>ALTER TABLE</code> или <code>CREATE INDEX</code> не должны
использоваться совместно с таблицами, для которых установлены ограничения
внешнего ключа или на которые есть ссылки в ограничениях внешних ключей:
Команда <code>ALTER TABLE</code> удаляет все ограничения внешних ключей, определенные в
таблице. Не следует использовать команду <code>ALTER TABLE</code> для таблиц, на
которые есть ссылки; вместо этого необходимо применять команды <code>DROP TABLE</code> 
и <code>CREATE TABLE</code>, чтобы изменить логическую структуру. При выполнении
команды <code>ALTER TABLE</code> MySQL может использовать команду <code>RENAME TABLE</code>, что
нарушит ограничения внешнего ключа, относящиеся к таблице. Оператор <code>CREATE
INDEX</code> в MySQL обрабатывается таким же образом, как и <code>ALTER TABLE</code>, поэтому
приведенные выше ограничения распространяются и на этот оператор.

</P>
<P>
При проверке внешних ключей для таблиц InnoDB устанавливается совместно
используемая блокировка строк на подлежащих просмотру родительских или
дочерних записях. Проверка ограничений внешнего ключа для таблиц InnoDB
производится немедленно и не откладывается до принятия транзакции.

</P>
<P>
Формат InnoDB обеспечивает возможность удалить любую таблицу, даже если
это нарушит ограничения внешнего ключа, ссылающегося на таблицу. При
удалении таблицы также удаляются ограничения, определенные оператором ее
создания.

</P>
<P>
Если удаленная таблица создается повторно, ее определение должно быть
согласовано с ограничениями внешнего ключа, который на нее ссылается. В
этой таблице необходимо правильно задать имена и типы столбцов; в ней
также должны присутствовать индексы ключей, на которые производится
ссылка, как указано выше. Если эти условия не будут выполнены, MySQL
выдаст ошибку с номером 1005 и ссылку на ошибку с номером 150 в строке
сообщения об ошибке.

</P>
<P>
Начиная с версии 3.23.50 InnoDB возвращает определения внешних ключей
таблицы, если вызвать

</P>

<pre>
SHOW CREATE TABLE yourtablename
</pre>

<P>
Помимо этого, <code>mysqldump</code> выводит корректные определения таблиц в файл
дампа, ``не забывая'' о внешних ключах.

</P>
<P>
Список ограничений внешнего ключа таблицы <code>T</code> можно также вывести при помощи
команды

</P>

<pre>
SHOW TABLE STATUS FROM yourdatabasename LIKE 'T'
</pre>

<P>
Ограничения внешнего ключа выводятся в комментариях к таблице.

</P>


<H3><A NAME="Adding_and_removing" HREF="manual.ru_toc.html#Adding_and_removing">7.5.5  Добавление и удаление файлов данных и журналов InnoDB</A></H3>

<P>
Начиная с версий 3.23.50 и 4.0.2, можно указать последний файл данных
InnoDB как <code>autoextend</code>. Можно также увеличить табличную область, указав
дополнительные файлы данных. Для этого необходимо остановить сервер MySQL,
внести изменения в файл <tt>`my.cnf'</tt>, добавив новый файл данных к
<code>innodb_data_file_path</code>, а затем запустить сервер MySQL снова.

</P>
<P>
На данный момент нельзя удалить файл данных из InnoDB. Чтобы уменьшить
размер своей базы данных, необходимо воспользоваться <code>mysqldump</code>, чтобы
сделать дамп всех своих таблиц, создать новую базу данных и импортировать
таблицы в новую базу данных.

</P>
<P>
Если необходимо изменить количество или размер файлов журналов InnoDB,
необходимо остановить MySQL и убедиться, что работа была завершена без
ошибок. После этого нужно скопировать старые файлы журналов в безопасное
место - на случай, если завершение работы было произведено с ошибками и
потребуется восстановление базы данных. Затем следует удалить старые файлы
журналов из каталога файлов журналов, внести изменения в <tt>`my.cnf'</tt> и снова
запустить MySQL. InnoDB при запуске сообщит о создании новых файлов
журналов.

</P>


<H3><A NAME="Backing_up" HREF="manual.ru_toc.html#Backing_up">7.5.6  Создание резервных копий и восстановление баз данных InnoDB</A></H3>

<P>
Чтобы обеспечить безопасное управление базами данных, необходимо регулярно
создавать резервные копии.

</P>
<P>
Существует интерактивный инструмент, который можно использовать для
создания резервных копий своих баз данных InnoDB, когда они открыты, -
InnoDB Hot Backup. Для своей работы InnoDB Hot Backup не требует закрытия
базы данных, блокировки данных или нарушения обычного хода обработки базы
данных. InnoDB Hot Backup является платным дополнительным инструментом, не
входящим в стандартный дистрибутив MySQL. Чтобы получить дополнительную
информацию о нем и просмотреть копии экрана, см. домашнюю страницу InnoDB
Hot Backup <a HREF="http://www.innodb.com/hotbackup.html">http://www.innodb.com/hotbackup.html</a>.

</P>
<P>
Если у вас есть возможность остановить сервер MySQL, а затем создать
двоичную резервную копию своей базы данных, необходимо выполнить следующие
действия:

</P>

<ul>
<LI>

Закройте свою базу данных MySQL и убедитесь, что закрытие было
произведено без ошибок.
<LI>

Скопируйте все свои файлы данных в безопасное место.
<LI>

Скопируйте все свои файлы журналов InnoDB в безопасное место.
<LI>

Скопируйте свой файл конфигурации <tt>`my.cnf'</tt> в безопасное место.
<LI>

Скопируйте все файлы <tt>`.frm'</tt> своих таблиц InnoDB в безопасное место.
</ul>

<P>
В дополнение к двоичным резервным копиям, описанным выше, необходимо также
регулярно создавать дампы своих таблиц при помощи <code>mysqldump</code>. Дело в том,
что повреждение двоичного файла человеку заметить сложно. Дампы таблиц
сохраняются в текстовых файлах, которые могут прочитать люди и структура
которых намного проще двоичных файлов базы данных. Увидеть повреждение
таблицы в файле дампа легче, и благодаря простоте этого формата
вероятность серьезного повреждения данных меньше.

</P>
<P>
Дампы лучше всего создавать одновременно с созданием двоичной резервной
копии своей базы данных. Чтобы получить согласованную копию всех своих
таблиц в дампах, необходимо запретить всем клиентам доступ к базе данных.
Затем можно создать двоичную резервную копию и получить согласованные
копии своей базы данных в двух форматах.

</P>
<P>
Чтобы восстановить исходное состояние своей базы данных InnoDB из
описанной выше двоичной резервной копии, необходимо запустить свою базу
данных MySQL с включенными общим журналом и архивацией журналов MySQL
(здесь под общим журналом подразумевается механизм занесения записей в
журнал сервера MySQL, независимый от журналов InnoDB).

</P>
<P>
Единственное, что нужно сделать для восстановления процесса MySQL после
сбоя, - перезапустить его. InnoDB автоматически произведет проверку
журналов и выполнит восстановление базы данных, а также автоматически
произведет откат по незавершенным транзакциям, которые проводились на
момент сбоя. Во время восстановления InnoDB будет выводить примерно
следующую информацию:

</P>

<pre>
~/mysqlm/sql &#62; mysqld
InnoDB: Database was not shut down normally.
InnoDB: Starting recovery from log files...
InnoDB: Starting log scan based on checkpoint at
InnoDB: log sequence number 0 13674004
InnoDB: Doing recovery: scanned up to log sequence number 0 13739520
InnoDB: Doing recovery: scanned up to log sequence number 0 13805056
InnoDB: Doing recovery: scanned up to log sequence number 0 13870592
InnoDB: Doing recovery: scanned up to log sequence number 0 13936128
...
InnoDB: Doing recovery: scanned up to log sequence number 0 20555264
InnoDB: Doing recovery: scanned up to log sequence number 0 20620800
InnoDB: Doing recovery: scanned up to log sequence number 0 20664692
InnoDB: 1 uncommitted transaction(s) which must be rolled back
InnoDB: Starting rollback of uncommitted transactions
InnoDB: Rolling back trx no 16745
InnoDB: Rolling back of trx no 16745 completed
InnoDB: Rollback of uncommitted transactions completed
InnoDB: Starting an apply batch of log records to the database...
InnoDB: Apply batch completed
InnoDB: Started
mysqld: ready for connections
</pre>

<P>
Если ваша база данных повреждена или произошел сбой диска, необходимо
произвести восстановление из резервной копии. В случае повреждения сначала
необходимо найти целую резервную копию, а из резервной копии произвести
восстановление по файлам общего журнала MySQL в соответствии с
инструкциями руководства MySQL.

</P>



<H4><A NAME="InnoDB_checkpoints" HREF="manual.ru_toc.html#InnoDB_checkpoints">7.5.6.1  Контрольные точки</A></H4>

<P>
В InnoDB реализован механизм контрольных точек, который получил название
нечеткой контрольной точки. В InnoDB измененные страницы базы данных
сбрасываются из буфера на диск небольшими частями. Сбрасывать содержимое
буфера одним большим пакетом нет необходимости, так как это приведет к
временной остановке обработки операторов пользователей.

</P>
<P>
В случае восстановления после сбоя InnoDB производит поиск меток
контрольных точек, записанных в файлы журналов. Известно, что все
изменения базы данных, внесенные перед меткой, уже записаны в образ базы
данных на диске. Затем InnoDB производит сканирование файлов журналов
начиная от места контрольной точки, и вносит зафиксированные изменения в
базу данных.

</P>
<P>
Запись в файлы журналов в InnoDB осуществляется по круговому методу. Все
внесенные изменения, после которых страницы базы данных в буфере начинают
отличаться от образа на диске, должны быть записаны в файлы журналов, на
случай, если InnoDB понадобится произвести восстановление. Это означает,
что когда InnoDB начинает повторно использовать файл журнала по круговому
методу, производится проверка на наличие в образах страниц базы данных на
диске изменений, зафиксированных в файле журнала, который InnoDB
собирается повторно использовать. Иначе говоря, необходимость поставить
контрольную точку зачастую приводит к тому, что InnoDB сбрасывает
измененные страницы базы данных на диск.

</P>
<P>
Из сказанного выше становится понятно, почему при больших файлах журналов
сокращается количество дисковых операций ввода/вывода при создании
контрольных точек. Иногда имеет смысл задавать общий размер файлов
журналов равным буферному пулу или даже больше. Недостатком больших файлов
журналов является то, что восстановление после сбоя может длиться дольше,
так как к базе данных придется применить больше информации из файла
журнала.

</P>


<H3><A NAME="Moving" HREF="manual.ru_toc.html#Moving">7.5.7  Перенесение базы данных InnoDB на другой компьютер</A></H3>

<P>
Файлы данных и журналов InnoDB на двоичном уровне совместимы на всех
платформах, если на компьютерах совпадает формат чисел с плавающей
десятичной запятой. Базу данных InnoDB можно перенести, просто скопировав
все относящиеся к ней файлы (список которых был приведен в предыдущем
разделе, посвященном созданию резервных копий базы данных). Если
компьютеры имеют различные форматы чисел с плавающей десятичной запятой,
но типы данных <code>FLOAT</code> или <code>DOUBLE</code> в ваших таблицах не задействованы,
последовательность действий остается точно такой же: нужно просто
скопировать все относящиеся к базе данных файлы. Если же при наличии
различных форматов в ваших таблицах содержатся данные с плавающей
десятичной запятой, то для перемещения таких таблиц необходимо
воспользоваться командами <code>mysqldump</code> и <code>mysqlimport</code>.

</P>
<P>
Чтобы увеличить скорость обработки, можно отключить автоматическую
фиксацию транзакций при импортировании в свою базу данных, исходя из
предположения, что ваша табличная область содержит достаточно пространства
для отката большого сегмента на случай генерации большой транзакции
импортирования. Фиксация производится только после импорта всей таблицы
или сегмента таблицы.

</P>


<H3><A NAME="InnoDB_transaction_model" HREF="manual.ru_toc.html#InnoDB_transaction_model">7.5.8  Транзакционная  модель InnoDB</A></H3>

<P>
Назначение транзакционной модели InnoDB заключается в том, чтобы
совместить лучшие свойства многовариантной базы данных и традиционной
двухфазной блокировки. Для таблиц InnoDB осуществляется блокировка на
уровне строки и запросы по умолчанию запускаются как целостное считывание
без блокировок, подобно тому, как это реализовано в Oracle. Хранение
таблицы блокировок InnoDB организовано настолько экономично, что нет
необходимости в расширении блокировки: обычно несколько пользователей
могут блокировать любую строку или любой набор строк в базе данных, не
занимая всю память, доступную для InnoDB.

</P>
<P>
В таблицах InnoDB все действия пользователей осуществляются при помощи
транзакций. Если в MySQL используется режим автоматической фиксации, то
для каждого оператора SQL будет создаваться отдельная транзакция. MySQL всегда
открывает новое соединение с включенным режимом автоматической фиксации.

</P>
<P>
Если режим автоматической фиксации отключен при помощи <code>SET AUTOCOMMIT = 0</code>, то мы предполагаем, что у
пользователя постоянно имеется открытая транзакция. Если он выполняет
оператор SQL <code>COMMIT</code> или <code>ROLLBACK</code>, которые завершают текущую транзакцию,
сразу же запускается новая транзакция. Оба упомянутых оператора снимают
все блокировки InnoDB, которые были установлены во время выполнения
текущей транзакции. Оператор <code>COMMIT</code> означает, что изменения, внесенные во
время выполнения текущей транзакции, принимаются и становятся видимыми
для других пользователей. Оператор <code>ROLLBACK</code> отменяет все изменения,
внесенные текущей транзакцией.

</P>
<P>
Если в соединении установлено <code>AUTOCOMMIT = 1</code>, то пользователь, тем не менее, может
использовать транзакции, начиная их с <code>BEGIN</code> и заканчивая при помощи
<code>COMMIT</code> или <code>ROLLBACK</code>.

</P>
<P>
В терминах описания уровней изоляции транзакций (SQL-1992), InnoDB по умолчанию использует
<code>REPEATABLE READ</code>. Начиная с версии 4.0.5, InnoDB предлагает все 4 уровня
изоляции описанные в стандарте SQL-1992. Вы можете установить уровень изоляции
по умолчанию для всех соединений в секции <code>[mysqld]</code> файла <tt>`my.cnf'</tt>:

</P>

<pre>
transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED
                         | REPEATABLE-READ | SERIALIZABLE}
</pre>

<P>
Пользователь может изменить уровень изоляции для отдельно взятой сессии или
нового соединения таким образом: 

</P>

<pre>
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL
                       {READ UNCOMMITTED | READ COMMITTED
                        | REPEATABLE READ | SERIALIZABLE}
</pre>

<P>
Обратите внимания что названия уровней изоляции пишется без дефиса в SQL-выражении.  
Если вы указали ключевое слово <code>GLOBAL</code> в указанном выше выражении,
оно будет определять уровень изоляции для новых соединений,
но не будет иметь эффекта для старых соединений.  Любой пользователь может
изменить уровень изоляции для своей сессии, даже внутри самой транзакции.  В
версиях старше 3.23.50 <code>SET TRANSACTION</code> не оказывает эффекта на таблицы
InnoDB. В версиях старше 4.0.5 вы можете использовать только <code>REPEATABLE
READ</code> и <code>SERIALIZABLE</code>.

</P>
<P>
Вы можете получить информацию об уровне изоляции, глобальном или для текущего соединения: 

</P>

<pre>
SELECT @@global.tx_isolation;
SELECT @@tx_isolation;
</pre>

<P>
В блокировке уровня строки InnoDB использует так называемую блокировку
следующего ключа. Это означает, что кроме индексных записей InnoDB может также
блокирует "интервал" перед индексной записью для блокировки вставок другими
пользователями непосредственно перед индексной записью. Блокировка следующего
ключа означает блокировку, которая ставится на индексную запись и интервал перед
ней. Блокировка интервала означает только блокировку интервала перед некоторыми
индексными записями.

</P>
<P>
Подробное описание каждого уровня изоляции в InnoDB:

</P>

<ul>
<LI>

<code>READ UNCOMMITTED</code> Также называется "грязным чтением": неблокирующиеся
выборки (<code>SELECT</code>) выполняются таким образом, что мы не видим возможные ранние
версии записи; таким образом они "несогласованно" читаются в этом уровне
изоляции; в остальных случаях этот уровень работает также как и <code>READ
COMMITTED</code>.

<LI>

<code>READ COMMITTED</code> 
Нечто похожее на уровень изоляции Oracle.  Все выражения
<code>SELECT ... FOR UPDATE</code> и <code>SELECT ... LOCK IN SHARE MODE</code> блокируют
только индексные записи и не блокируют интервал перед ними. Поэтому они
позволяют свободно добавлять новые записи после заблокированных.
<code>UPDATE</code> и <code>DELETE</code>, которые используют уникальный индекс и
уникальные условия поиска, блокируют только найденную индексную запись, и не
блокируют интервал перед ней.  Но в <code>UPDATE</code> и <code>DELETE</code> диапазонного
типа в InnoDB должны установить блокировку следующего ключа или интервальную
блокировку и блокировать добавления другими пользователями в интервал, покрытый
диапазоном. Это необходимо, т.к. "фантомные строки" должны быть блокированы для
успешной работы репликации и восстановления в MySQL.  <strong>Согласованное
чтение</strong> работает как и в Oracle: каждое согласованное чтение, даже внутри одной
транзакции, устанавливает и читает свой собственный снимок.

<LI>

<code>REPEATABLE READ</code> Этот уровень изоляции используется в InnoDB по умолчанию.
<code>SELECT ... FOR UPDATE</code>, <code>SELECT ... LOCK IN SHARE MODE</code>,
<code>UPDATE</code>, и <code>DELETE</code>, которые используют уникальные индексы и
уникальное условие поиска блокируют только найденную индексную запись и не
блокируют интервал перед ней. В остальных случаях эта операция использует
блокировку следующего ключа, блокирует диапазон индексов, просканированных
блокировкой следующего ключа или интервальной, и блокирует новые добавления
другими пользователями.

В <strong>согласованном чтении</strong> есть важное отличие от предыдущего уровня изоляции: 
на этом уровне все согласованные чтения внутри той же самой транзакции читают снимок,
сделанный для первого чтения. Это соглашение означает, что если вы выполните несколько 
простых выборок (<code>SELECT</code>) внутри той же самой транзакции, эти выборки будут целостными 
по отношению к друг другу.

<LI>

<code>SERIALIZABLE</code> Этот уровень похож на предыдущий, но простые <code>SELECT</code>
преобразовываются в <code>SELECT ... LOCK IN SHARE MODE</code>.
</ul>



<H4><A NAME="InnoDB_consistent_read" HREF="manual.ru_toc.html#InnoDB_consistent_read">7.5.8.1  Согласованное чтение</A></H4>

<P>
Согласованное чтение означает, что для того, чтобы предоставить запросу
копию базы данных на текущий момент времени, используется
многовариантность таблиц InnoDB. Для запроса доступны лишь те изменения,
которые были внесены транзакциями, зафиксированными на этот момент
времени, и не доступны изменения, сделанные незафиксированными или
проведенными позже транзакциями. Исключением из данного правила могут
стать только изменения, внесенные транзакцией, направляющей текущий
запрос.

</P>
<P>
Если вы используете уровень изоляции по умолчанию <code>REPEATABLE READ</code>, то
все выборки читают снимок, сделанный первым чтением в этой транзакции. Вы
можете получить более свежую копию для своих запросов - для этого следует
зафиксировать текущую транзакцию и направить новые запросы.

</P>
<P>
Согласованное чтение является режимом по умолчанию, в котором в InnoDB
обрабатываются операторы <code>SELECT</code> при <code>READ COMMITTED</code> или
<code>REPEATABLE READ</code> уровнях изоляции. При согласованном чтении не
устанавливаются блокировки на таблицы, к которым обращается запрос, и,
таким образом, остальные пользователи могут вносить изменения в эти
таблицы одновременно с согласованным чтением таблиц.

</P>


<H4><A NAME="InnoDB_locking_reads" HREF="manual.ru_toc.html#InnoDB_locking_reads">7.5.8.2  Чтение с блокировкой</A></H4>

<P>
В некоторых случаях использовать согласованное чтение нецелесообразно.
Приведем пример. Допустим, что необходимо добавить новую строку в таблицу
<code>CHILD</code>, предварительно убедившись, что для нее имеется родительская строка
в таблице <code>PARENT</code>.

</P>
<P>
Предположим, что для чтения таблицы <code>PARENT</code> было использовано согласованное
чтение, и в таблице была обнаружена родительская строка. Можно ли теперь
безопасно добавить дочернюю строку в таблицу <code>CHILD</code>? Нет, потому что в это
время другой пользователь мог без вашего ведома удалить родительскую
строку из таблицы <code>PARENT</code>.

</P>
<P>
В данной ситуации необходимо выполнить операцию <code>SELECT</code> в режиме 
блокировки, <code>LOCK IN SHARE MODE</code>.

</P>

<pre>
SELECT * FROM PARENT WHERE NAME = 'Jones' LOCK IN SHARE MODE;
</pre>

<P>
Выполнение чтения в режиме совместного использования (<code>share mode</code>)
означает, что считываются самые новые доступные данные и производится
блокировка строк, чтение которых осуществляется. Если последние данные
принадлежат еще не зафиксированной транзакции, мы ждем, пока транзакция
не будет зафиксирована. Блокировка в режиме совместного использования не
позволяет другим пользователям обновить или удалить читаемую строку. После
того, как указанный выше запрос вернет родительскую строку <code>'Jones'</code>, мы
можем безопасно добавить дочернюю строку в таблицу <code>CHILD</code> и зафиксировать
транзакцию. В этом примере показано, как использовать целостность
ссылочных данных в своей программе.

</P>
<P>
Рассмотрим еще один пример. Пусть у нас есть поле целочисленного счетчика
в таблице <code>CHILD_CODES</code>, которое мы используем для назначения уникального
идентификатора каждой дочерней записи, добавляемой к таблице <code>CHILD</code>.
Очевидно, что использование согласованного чтения или чтения в режиме
совместного доступа для получения текущего значения счетчика не подходит,
так как два пользователя базы данных могут получить одно и то же значение
счетчика и создать дублирующиеся ключи при добавлении двух дочерних
записей в таблицу.

</P>
<P>
Для этого случая возможны два способа произвести чтение и увеличить
значение счетчика: (1) сначала обновить значение счетчика, увеличив его на
1, и только после этого прочитать его или (2) сначала прочитать счетчик в
режиме блокировки <code>FOR UPDATE</code>, а после этого увеличить его значение:

</P>

<pre>
SELECT COUNTER_FIELD FROM CHILD_CODES FOR UPDATE;
UPDATE CHILD_CODES SET COUNTER_FIELD = COUNTER_FIELD + 1;
</pre>

<P>
Оператор <code>SELECT ... FOR UPDATE</code> прочитает последние доступные данные с
установкой отдельной блокировки на каждую считываемую строку. Таким
образом, блокировка на строки устанавливается точно так же, как и в случае
поиска по <code>UPDATE</code>.

</P>


<H4><A NAME="InnoDB_Next-key_locking" HREF="manual.ru_toc.html#InnoDB_Next-key_locking">7.5.8.3  Блокировка следующего ключа: устранение проблемы с фантомом</A></H4>

<P>
При блокировке на уровне строк в InnoDB используется алгоритм, который
получил название блокировки следующего ключа. В InnoDB осуществляется
блокировка на уровне строк, поэтому на время поиска или сканирования
индекса таблицы устанавливается совместно используемая или эксклюзивная
блокировка записей обрабатываемых индексов. Таким образом, более точно
блокировку на уровне строк можно определить как блокировку индексных
записей.

</P>
<P>
Блокировка, которая в InnoDB устанавливается на индексные записи, влияет
также на интервал перед этой индексной записью. Если у пользователя
имеется совместная или эксклюзивная блокировка записи R в индексе, то
другой пользователь не может вставить новую индексную запись перед R в
порядке следования индексов. Такая блокировка интервалов производится для
предотвращения так называемой проблемы с фантомом. Предположим, что
необходимо прочитать и заблокировать все дочерние записи с
идентификатором, превышающим 100, из таблицы <code>CHILD</code>, и обновить некоторые
поля в выбранных строках.

</P>

<pre>
SELECT * FROM CHILD WHERE ID &#62; 100 FOR UPDATE;
</pre>

<P>
Допустим, что создан индекс таблицы <code>CHILD</code> по столбцу <code>ID</code>. Наш запрос
произведет сканирование, начиная с первой записи, в которой <code>ID</code> больше 100.
Теперь, если установленная на записи индекса блокировка не заблокирует
вставки в интервалы, за это время в таблицу может быть вставлена новая
дочерняя запись. Если теперь в транзакции запустить

</P>

<pre>
SELECT * FROM CHILD WHERE ID &#62; 100 FOR UPDATE;
</pre>

<P>
еще раз, то в результате запроса будет выдана новая дочерняя запись. Это
противоречит принципу изоляции транзакции: транзакция должна запускаться
таким образом, чтобы считываемые ею данные не изменялись на протяжении
выполнения транзакции. Если мы рассматриваем набор строк как элемент
данных, то новая дочерняя ``запись-фантом'' нарушит этот принцип изоляции.

</P>
<P>
Когда InnoDB сканирует индекс, то возможна также блокировка интервалов
после последних записей в индексе. Именно это иллюстрируется в предыдущем
примере: блокировка, установленная InnoDB, предотвратит вставку в таблицу,
если <code>ID</code> будет больше 100.

</P>
<P>
Блокировку следующего ключа можно использовать для того, чтобы провести
проверку уникальности значений в своей программе. Если данные считываются
в режиме совместного доступа и отсутствует дубликат строки, которую
необходимо вставить, то можно безопасно вставлять свою строку и быть
уверенным, что благодаря блокировке следующего ключа, установленной на
предшествующей строке во время чтения, будет предотвращена вставка
дублирующейся строки. Таким образом, блокировка следующего ключа позволяет
``заблокировать'' отсутствие чего-либо в таблице.

</P>


<H4><A NAME="InnoDB_Locks_set" HREF="manual.ru_toc.html#InnoDB_Locks_set">7.5.8.4  Блокировка, осуществляемая различными операторами SQL в InnoDB</A></H4>


<ul>
<LI>

<code>SELECT ... FROM ...</code>: согласованное чтение, которое производится из
образа базы данных без блокировки.
<LI>

<code>SELECT ... FROM ... LOCK IN SHARE MODE</code>: устанавливает совместно
используемую блокировку следующего ключа на все считываемые индексные
записи.
<LI>

<code>SELECT ... FROM ... FOR UPDATE</code>: устанавливает эксклюзивную блокировку
следующего ключа на все считываемые индексные записи.
<LI>

<code>INSERT INTO ... VALUES (...)</code>: устанавливает эксклюзивную блокировку
на вставленную строку. Обратите внимание, что эта блокировка не
является блокировкой следующего ключа и не предотвращает вставку
другими пользователями записей в интервал перед вставленной строкой.
Если произойдет ошибка дублирующегося ключа, оператор устанавливает
блокировку совместного доступа на запись дублирующегося индекса.
<LI>

<code>INSERT INTO T SELECT ... FROM S WHERE ...</code> устанавливает эксклюзивную
(не следующего ключа) блокировку на каждую вставляемую в <code>T</code> строку.
Осуществляет поиск по <code>S</code> как согласованное чтение, но устанавливает
блокировки совместного доступа к следующему ключу на <code>S</code>, если включено
ведение журнала MySQL. InnoDB в последнем случае должен устанавливать
блокировки, так как при восстановлении работоспособности системы с
повтором всех завершенных транзакций из резервной копии все операторы
SQL должны запускаться точно таким же образом, как и изначально.
<LI>

<code>CREATE TABLE ... SELECT ...</code> выполняет операцию <code>SELECT</code> как
согласованное чтение или совместную блокировку, как и в предыдущем
пункте.
<LI>

<code>REPLACE</code> осуществляется так же, как и вставка, если нет конфликтов
уникальных ключей. В противном случае эксклюзивная блокировка
следующего ключа будет установлена на строку, которая должна быть
обновлена.
<LI>

<code>UPDATE ... SET ... WHERE ...</code>: устанавливает эксклюзивную блокировку
следующего ключа для каждой записи, по которой производится поиск.
<LI>

<code>DELETE FROM ... WHERE ...</code>: устанавливает эксклюзивную блокировку
следующего ключа для каждой записи, по которой производится поиск.
<LI>

Если для таблицы определены ограничения <code>FOREIGN KEY</code>, для любой
вставки, обновления или удаления, для которых требуется проверка
условий ограничения, устанавливается совместная блокировка на уровне
записей, которые просматриваются для проверки ограничения. В InnoDB
эти блокировки устанавливаются также  в случае нарушения ограничения.
<LI>

<code>LOCK TABLES ...</code>: устанавливает блокировку таблицы. Эта блокировка
производится кодом уровня MySQL. Механизм автоматического обнаружения
взаимоблокировок (<code>deadlock</code>) InnoDB не может детектировать
взаимоблокировки, в которых участвуют такие блокировки таблиц (см.
следующий раздел). Кроме того, поскольку MySQL ``знает'' о блокировке
на уровне строки, возможно установление блокировки таблицы, в которой
другой пользователь заблокировал строки. Но это не опасно для
целостности транзакции. See section <A HREF="manual.ru_Table_types.html#InnoDB_restrictions">7.5.13  Ограничения для таблиц InnoDB</A>.
</ul>



<H4><A NAME="InnoDB_Deadlock_detection" HREF="manual.ru_toc.html#InnoDB_Deadlock_detection">7.5.8.5  Обнаружение и откат взаимоблокировки (deadlock)</A></H4>

<P>
InnoDB автоматически обнаруживает взаимоблокировку транзакций и производит
откат транзакции или транзакций для предотвращения взаимоблокировок. 
Начиная с версии 4.0.5 InnoDB будет пытаться выбрать меньшую транзакцию для
отката. Размер транзакции определяется количеством строк, которые должны быть
добавлены, обновлены или удалены. До версии 4.0.5 InnoDB всегда откатывал
транзакцию, запрос на блокировку которой вызвал возникновение взаимоблокировки,
то есть замкнутого цикла в графике ожиданий транзакций.

</P>
<P>
InnoDB не может обнаружить взаимоблокировку, установленную оператором
MySQL <code>LOCK TABLES</code>, или блокировку, установленную отличным от InnoDB
обработчиком таблиц. Такие ситуации необходимо исправлять при помощи
параметра <code>innodb_lock_wait_timeout</code>, который задается в <tt>`my.cnf'</tt>.

</P>
<P>
Когда InnoDB выполняет полный откат транзакции, все блокировки,
установленные транзакцией, снимаются. Тем не менее, если в результате
ошибки производится откат только одного оператора SQL, некоторые
блокировки, установленные оператором, могут остаться в силе. Это
происходит потому, что InnoDB хранит блокировку строк в формате, по
которому впоследствии нельзя определить, каким оператором SQL была
установлена блокировка.

</P>


<H4><A NAME="InnoDB_Consistent_read_example" HREF="manual.ru_toc.html#InnoDB_Consistent_read_example">7.5.8.6  Пример работы согласованного чтения в InnoDB</A></H4>

<P>
Допустим, вы используете уровень изоляции, установленый по умолчанию - <code>REPEATABLE READ</code>.
При выполнении согласованного чтения (т.е. обычного оператора <code>SELECT</code>)
InnoDB определяет для транзакции момент времени, по состоянию на который
запросу будет предоставляться информация из базы данных. Таким образом,
если транзакция удаляет строку и фиксирует это изменение после
назначенного момента времени, то вы не увидите, что строка была удалена.
Это справедливо также для вставок и обновлений.

</P>
<P>
Чтобы такой момент времени ``передвинуть вперед'', нужно зафиксировать
транзакцию, а затем выполнить новую команду <code>SELECT</code>.

</P>
<P>
Это называется многовариантным контролем совпадений.

</P>

<pre>
		 Пользователь A 	  Пользователь B

		SET AUTOCOMMIT=0;	SET AUTOCOMMIT=0;

время
| 		SELECT * FROM t;
|		пустой набор данных
|					INSERT INTO t VALUES (1, 2);
|
v 		SELECT * FROM t;
		пустой набор данных
					COMMIT;
		SELECT * FROM t;
		пустой набор данных;

		COMMIT;

		SELECT * FROM t;
		---------------------
		| 1 | 2 |
		---------------------
</pre>

<P>
Таким образом, пользователь A увидит строку, вставленную пользователем B
только после того, как B зафиксирует вставку, и A зафиксирует свою
собственную транзакцию, чтобы момент времени передвинулся на позицию,
находящуюся после фиксации, произведенной пользователем B.

</P>
<P>
Чтобы увидеть ``самое свежее'' состояние базы данных, необходимо
использовать чтение с блокировкой:

</P>

<pre>
SELECT * FROM t LOCK IN SHARE MODE;
</pre>



<H4><A NAME="Innodb_deadlocks" HREF="manual.ru_toc.html#Innodb_deadlocks">7.5.8.7  Каким образом избежать взаимоблокировок (deadlock)?</A></H4>

<P>
Взаимоблокировки - классическая проблема транзакционных баз данных. Они не
опасны до тех пор пока не становятся настолько частыми, что вы вообще не можете
запустить некоторые транзакции. Обычно вы можете написать свои
приложения таким образом, что они всегда будут подготавливать перезапуск
транзакции, если произошел откат из-за взаимоблокировок.

</P>
<P>
InnoDB использует автоматическую блокировку уровня строки. Вы можете создать
взаимоблокировку даже в случае транзакций, которые всего лишь добавляют или
удаляют единичную строку. Это происходит из-за того, что в действительности эти
операции не являются "атомарными": они автоматически устанавливают блокировку
на индексные записи добавляемых/удаляемых строк (или на несколько записей).

</P>
<P>
Вы можете избежать взаимоблокировок или уменьшить их количество, следуя следующим приемам:

</P>

<ul>
<LI>

Используйте <code>SHOW INNODB STATUS</code> в MySQL начиная с 3.23.52 и 4.0.3 для
определения причины последней взаимоблокировки. Это поможет вам настроить ваше
приложение, что бы избежать взаимоблокировок.
<LI>

Всегда подготавливайте перезапуск транзакции, если произошел откат из-за
взаимоблокировки. Взаимоблокировка не опасна: всего лишь попробуйте еще раз.
<LI>

Чаще фиксируйте свои транзакии. Маленькие транзакции меньше склонны к противоречиям.
<LI>

Если вы используете чтение с блокировкой <code>SELECT ... FOR UPDATE</code> или
<code>... LOCK IN SHARE MODE</code>, попробуйте использовать более низкий уровень
изоляции <code>READ COMMITTED</code>.
<LI>

Производите операции с вашими таблицам и строками в фиксированном порядке. Тогда
транзакции будут формировать очередь и не будет происходить взаимоблокировка.
<LI>

Добавьте хорошие индексы на ваши таблицы. Тогда ваши запросы будут сканировать
меньше индексных записей и, соответственно, будут устанавливать меньше
блокировок. Используйте <code>EXPLAIN SELECT</code> для того, чтобы узнать, выбирает
ли MySQL соответствующий индекс для ваших запросов.
<LI>

Используйте меньше блокировок: если вы можете допустить, чтобы <code>SELECT</code>
возвращал данные из старого снимка, не добавляйте к выражению <code>FOR UPDATE</code>
или <code>LOCK IN SHARE MODE</code>. Используйте уровень изоляции <code>READ
COMMITTED</code>, который больше всего подходит для данной ситуации, так как каждое
согласованное чтение внутри одной и той же транзакции читает свой собственный
свежий снимок.

<LI>

Если ничего не помогло, сериализируйте свои транзакции с блокировкой уровня
таблиц: <code>LOCK TABLES t1 WRITE, t2 READ, ... ; [здесь можете развлекаться 
с таблицами t1 и t2]; UNLOCK TABLES</code>. Блокировка на уровне таблиц выстраивает ваши
транзакции в очередь, и позволяет избежать взаимоблокировки. Заметьте, что
<code>LOCK TABLES</code> неявным образом начинает транзакцию наподобие <code>BEGIN</code>,
и <code>UNLOCK TABLES</code> неявным образом завершает ее в <code>COMMIT</code>.
<LI>

Другое решение для сериализации транзакций - это создание вспомагательного
"семафора" таблицы, где есть всего лишь одна строка. Каждая транзакция обновляет
эту строку перед доступом к другой таблице. В этом случае все транзакции
выполняются в виде очереди. Отметим что таким же образом в настоящий момент
работает и алгоритм определения взаимоблокировок в InnoDB, так как блокировка
сериализации - это блокировка уровня строки. При блокировке на уровне таблицы в
MySQL мы используем метод таймаута для разрешения взаимоблокировки.
</ul>

<P>
  

</P>


<H4><A NAME="Innodb_tuning" HREF="manual.ru_toc.html#Innodb_tuning">7.5.8.8  Рекомендации по увеличению производительности</A></H4>

<P>
<strong>1.</strong>
Если top операционной системы Unix или Task Manager Windows показывают
процент рабочей нагрузки процессора меньше 70%, это значит, что объем
рабочей нагрузки в основном сводится к обращениям к диску. Возможно,
слишком часто производится фиксация транзакций, или буферный пул слишком
мал. Здесь может помочь увеличение размера буферного пула, но не следует
устанавливать его значение большим, чем 80% физической памяти.

</P>
<P>
<strong>2.</strong>
Несколько изменений следует вносить за одну транзакцию. InnoDB должен
сбрасывать журнал на диск после каждой фиксации транзакции, если эта
транзакция вносит изменения в базу данных. Поскольку скорость вращения
диска обычно не превышает 167 оборотов в секунду, то количество фиксаций
ограничено 167 фиксациями в секунду, если, конечно, диск не обманывает
операционную систему.

</P>
<P>
<strong>3.</strong>
Если вы можете позволить себе потерять последние зафиксированные
транзакции, установите параметр <code>innodb_flush_log_at_trx_commit</code> в файле
<tt>`my.cnf'</tt> в нулевое значение. Так или иначе InnoDB пытается сохранить журнал
ежесекундно, и в этом случае сохранение не гарантируется.

</P>
<P>
<strong>4.</strong>
Увеличьте размеры файлов журналов, доведите их даже до размера
буферного пула. Когда InnoDB заполняет файлы журналов, он должен сохранить
измененное содержимое буферного пула на диск в виде моментального снимка
базы. Маленькие журналы будут вызывать множество ненужных записей на диск.
Есть и оборотная сторона медали - если файлы журналов большие, то время
восстановления транзакций (в случае сбоя) будет больше.

</P>
<P>
<strong>5.</strong>
Кроме того, буфер журнала должен быть достаточно большим, например 8
Мб.

</P>
<P>
<strong>6.</strong>
(Актуально для версии 3.23.39 и выше.) В некоторых версиях операционных
систем Linux и Unix запись файлов на диск при помощи команды Unix
<code>fdatasync</code> и других подобных методов производится на удивление медленно.
Принятый по умолчанию метод InnoDB использует функцию <code>fdatasync</code>. Если
скорость записи базы данных вас не устраивает, можно попробовать для
параметра <code>innodb_flush_method</code> в файле <tt>`my.cnf'</tt> задать значение <code>O_DSYNC</code>, хотя
на многих системах <code>O_DSYNC</code> обычно работает медленнее.

</P>
<P>
<strong>7.</strong>
При импортировании данных в InnoDB убедитесь что в MySQL не установлено
значение <code>autocommit=1</code>. Если оно установлено, то каждая вставка требует
сохранения журналов на диске. Поместите прямо в начале вашего файла с
данными:

</P>

<pre>
SET AUTOCOMMIT=0;
</pre>

<P>
и в конце

</P>

<pre>
COMMIT;
</pre>

<P>
Если используется параметр mysqldump  --opt, то вы получите файлы, которые
достаточно быстро импортируются в InnoDB, даже если их не окружить
вышеуказанными командами <code>SET AUTOCOMMIT=0; ... COMMIT;</code>.

</P>
<P>
<strong>8.</strong>
Осторожно относитесь к значительным откатам больших вставок InnoDB
использует буфер вставок для того, чтобы меньше ``дергать'' диск на
вставках, однако для соответствующего отката транзакции такой механизм не
предусмотрен.. Ограниченный производительностью диска откат может занять в
30 раз больше времени, чем вставка. Удаление процесса базы данных не
поможет, так как откат начнется снова после запуска базы данных.
Единственный способ избежать такого отката - это увеличить буферный пул
настолько, что откат станет зависеть только от производительности
процессора, перестанет ``равняться'' по диску и отработается быстро. Есть
еще один способ - это удаление базы данных InnoDB целиком.

</P>
<P>
<strong>9.</strong>
Следует также осторожно относиться к операциям со значительными
объемами данных, зависящим от производительности диска. Чтобы очистить
таблицу, используйте команды <code>DROP TABLE</code> или <code>TRUNCATE</code> (начиная с версии
MySQL-4.0 и выше), а не <code>DELETE FROM yourtable</code>.

</P>
<P>
<strong>10.</strong>
Используйте множественные вставки для уменьшения нагрузки на
коммуникации между клиентом и сервером, если вам нужно вставить множество
записей:

</P>

<pre>
INSERT INTO yourtable VALUES (1, 2), (5, 5);
</pre>

<P>
Эта рекомендация подходит для вставок в таблицы любого типа, а не только
InnoDB.

</P>


<H4><A NAME="Innodb_Monitor" HREF="manual.ru_toc.html#Innodb_Monitor">7.5.8.9  InnoDB Monitor</A></H4>

<P>
Начиная с версии 3.23.41 в состав InnoDB входит InnoDB Monitor, который
выводит информацию по внутреннему состоянию InnoDB. Когда InnoDB Monitor
включен, сервер MySQL <code>mysqld</code> выводит стандартный набор данных (обратите
внимание: клиент MySQL ничего не выводит) примерно каждые 15 секунд. Эти
данные могут пригодиться при настройке производительности. В операционной
системе Windows необходимо запустить <code>mysqld-max</code> из командной строки MS-DOS
с параметрами <code>--standalone --console</code>, чтобы направить выводимые данные в
окно MS-DOS.

</P>
<P>
Существует отдельная функция <code>innodb_lock_monitor</code>, которая выводит такую же
информацию как <code>innodb_monitor</code>, а также данные по блокировкам,
установленным каждой транзакцией.

</P>
<P>
Выводящаяся информация включает следующие данные:

<ul>
<LI>

по блокировкам, ожидающим транзакций;
<LI>

по семафорам, ожидающим потоков;
<LI>

по файлам, ожидающим ответа на запрос ввода/вывода;
<LI>

статистику  буферного пула;
<LI>

по активности буферов удаления и вставок в основном потоке InnoDB.
</ul>

<P>
InnoDB Monitor можно запустить при помощи следующей команды SQL:

</P>

<pre>
CREATE TABLE innodb_monitor(a int) type = innodb;
</pre>

<P>
а остановить его при помощи:

</P>

<pre>
DROP TABLE innodb_monitor;
</pre>

<P>
Вызов  команды <code>CREATE TABLE</code> является только способом передачи команды в
InnoDB через программу синтаксического анализа SQL. Факт создания таблицы
не играет никакой роли для InnoDB Monitor. Если вы останавливаете сервер,
когда монитор работает, и хотите запустить монитор заново, следует
уничтожить таблицу прежде, чем снова вызвать <code>CREATE TABLE</code> для запуска
монитора. Синтаксис может измениться в будущих версиях.

</P>
<P>
Пример информации, выводимой InnoDB Monitor:

</P>

<pre>
================================
010809 18:45:06 INNODB MONITOR OUTPUT
================================
--------------------------
LOCKS HELD BY TRANSACTIONS
--------------------------
LOCK INFO:
Number of locks in the record hash table 1294
LOCKS FOR TRANSACTION ID 0 579342744
TABLE LOCK table test/mytable trx id 0 582333343 lock_mode IX
RECORD LOCKS space id 0 page no 12758 n bits 104 table test/mytable index
PRIMARY trx id 0 582333343 lock_mode X
Record lock, heap no 2 PHYSICAL RECORD: n_fields 74; 1-byte offs FALSE;
info bits 0
0: len 4; hex 0001a801; asc ;; 1: len 6; hex 000022b5b39f; asc ";;
2: len 7; hex 000002001e03ec; asc ;; 3: len 4; hex 00000001;
...
-----------------------------------------------
CURRENT SEMAPHORES RESERVED AND SEMAPHORE WAITS
-----------------------------------------------
SYNC INFO:
Sorry, cannot give mutex list info in non-debug version!
Sorry, cannot give rw-lock list info in non-debug version!
-----------------------------------------------------
SYNC ARRAY INFO: reservation count 6041054, signal count 2913432
4a239430 waited for by thread 49627477 op. S-LOCK file NOT KNOWN line 0
Mut ex 0 sp 5530989 r 62038708 sys 2155035;
rws 0 8257574 8025336; rwx 0 1121090 1848344
-----------------------------------------------------
CURRENT PENDING FILE I/O'S
--------------------------
Pending normal aio reads:
Reserved slot, messages 40157658 4a4a40b8
Reserved slot, messages 40157658 4a477e28
...
Reserved slot, messages 40157658 4a4424a8
Reserved slot, messages 40157658 4a39ea38
Total of 36 reserved aio slots
Pending aio writes:
Total of 0 reserved aio slots
Pending insert buffer aio reads:
Total of 0 reserved aio slots
Pending log writes or reads:
Reserved slot, messages 40158c98 40157f98
Total of 1 reserved aio slots
Pending synchronous reads or writes:
Total of 0 reserved aio slots
-----------
BUFFER POOL
-----------
LRU list length 8034
Free list length 0
Flush list length 999
Buffer pool size in pages 8192
Pending reads 39
Pending writes: LRU 0, flush list 0, single page 0
Pages read 31383918, created 51310, written 2985115
----------------------------
END OF INNODB MONITOR OUTPUT
============================
010809 18:45:22 InnoDB starts purge
010809 18:45:22 InnoDB purged 0 pages
</pre>

<P>
Некоторые примечания по выводу:

</P>

<ul>
<LI>

Если раздел <code>LOCKS HELD BY TRANSACTIONS</code> содержит информацию по
ожидаемым блокировкам, то у вашей программы может быть конфликт
блокировок. Выводимая информация также может оказать помощь в
отслеживании причин возникновения взаимных блокировок.
<LI>

Если InnoDB скомпилировать при помощи <code>UNIV_SYNC_DEBUG</code>  в <tt>`univ.i'</tt>, то 
раздел <code>SYNC INFO</code> будет содержать информацию по зарезервированным
семафорам.
<LI>

Раздел <code>SYNC ARRAY INFO</code> содержит информацию по потокам, ожидающим
семафора, а также статистические данные по количеству повторных циклов
или ожиданий, выполненных потоками для семафоров или блокировок
чтения/записи. Большое количество потоков, ожидающих семафоров, может
возникнуть в результате частого выполнения операций ввода/вывода
диска, оно может быть также обусловлено конфликтами внутри самого
InnoDB. Конфликты могут возникать при большом количестве параллельных
запросов или в случае проблем операционной системы с планированием
потоков.
<LI>

В разделе <code>CURRENT PENDING FILE I/O'S</code> выводится список файлов,
ожидающих ответа на запрос ввода/вывода. Большое количество таких
файлов говорит о том, что рабочая нагрузка ограничена операциями
ввода/вывода диска.
<LI>

Раздел <code>BUFFER POOL</code> содержит статистическую информацию по записываемым
и считываемым страницам. По этим данным можно вычислить, сколько
запросов ввода/вывода по файлам данных выполняется на данный момент.
</ul>



<H3><A NAME="Implementation" HREF="manual.ru_toc.html#Implementation">7.5.9  Реализация многовариантности</A></H3>

<P>
Поскольку InnoDB является многовариантной базой данных, информация по
старым версиям строк в ней хранится в табличной области. Эта информация
содержится в структуре данных, которую мы по аналогии со структурой данных
в Oracle называем сегментом отката.

</P>
<P>
К каждому внутреннему представлению строки таблицы, хранящейся в базе
данных InnoDB, добавляется по два поля. В 6-байтовом поле хранится
идентификатор последней транзакции, которая производила вставку или
обновление строки. Удаление рассматривается как обновление, при котором
специальный бит удаления строки помечается соответствующим образом. Помимо
этого, каждая строка содержит также 7-байтовое поле, которое называется
указателем отката. Указатель отката указывает на запись журнала отмены,
занесенную в сегмент отката. Если строка была обновлена, запись журнала
отмены содержит необходимую информацию для восстановления содержимого
строки до обновления.

</P>
<P>
Информация из сегмента отката в базе данных InnoDB используется для того,
чтобы произвести отмену, необходимую для отката транзакции, а также для
создания предыдущих версий строки для согласованного чтения.

</P>
<P>
Журналы отмены в сегменте отката разделяются на журналы вставки и журналы
обновления. Журналы отмены вставки необходимы только для отката транзакций
и могут быть удалены сразу после фиксации транзакции. Журналы отмены
обновления используются для согласованного чтения, и их можно удалять
только после того, как не останется транзакций, для которых в InnoDB
определена копия, создающая при согласованном чтении раннюю версию строки
по информации из журнала отмены обновления.

</P>
<P>
Не забывайте регулярно фиксировать свои транзакции, включая транзакции,
использующие согласованное чтение. В противном случае InnoDB не сможет
удалить данные из журналов отмены обновления, что приведет к разрастанию
сегмента отката, который может занять всю вашу табличную область.

</P>
<P>
Физический размер записи журнала отмены в сегменте отката обычно меньше,
чем соответствующая вставка или обновленная строка. Эту информацию можно
использовать для вычисления размера пространства, необходимого для
сегмента отката.

</P>
<P>
В нашей многовариантной схеме строка физически не удаляется из базы данных
немедленно после удаления ее при помощи оператора SQL. Только после того,
как InnoDB сможет удалить запись журнала отмены обновления, занесенную для
удаления, соответствующая строка и ее индексная запись из базы данных
могут быть физически удалены. Эта операция удаления называется чисткой.
Она производится достаточно быстро - на нее уходит столько же времени, как
и на выполнение оператора удаления SQL.

</P>


<H3><A NAME="Table_and_index" HREF="manual.ru_toc.html#Table_and_index">7.5.10  Структуры таблиц и индексов</A></H3>

<P>
В MySQL информация словаря данных таблиц хранится в файлах <tt>`.frm'</tt>,
расположенных в каталогах баз данных. Но для каждой таблицы InnoDB имеются
также свои записи во внутренних словарях данных InnoDB в табличной
области. Когда MySQL удаляет таблицу или базу данных, необходимо удалить
как файлы <tt>`.frm'</tt>, так и соответствующие записи в словаре данных InnoDB.
Именно поэтому нельзя перемещать таблицы InnoDB между базами данных путем
простого перемещения файлов <tt>`.frm'</tt>. По этой же причине <code>DROP DATABASE</code> не
работал для таблиц InnoDB в MySQL версий &#60;= 3.23.43.

</P>
<P>
Для всех таблиц InnoDB есть специальный индекс, в котором хранятся данные
строк - он называется кластеризованным индексом. Если в таблице определить
<code>PRIMARY KEY</code>, то индекс первичного ключа будет кластеризированным индексом.

</P>
<P>
Если первичный ключ для таблицы не определен, то InnoDB самостоятельно
создаст кластеризированный индекс; строки в этом индексе будут упорядочены
по идентификатору строки, который InnoDB назначил строкам этой таблицы.
Идентификатор строки представляет собой 6-байтовое поле, значение которого
постоянно увеличивается при вставке новых строк. Таким образом, сортировка
по идентификатору строки фактически представляет собой сортировку по
последовательности вставки.

</P>
<P>
Доступ к строке через кластеризированный индекс осуществляется достаточно
быстро, поскольку данные строки находятся на той же странице, к которой
приводит поиск по индексу. Во многих базах данных информация и индексная
запись традиционно хранятся на разных страницах. При больших размерах
таблицы архитектура кластеризированных индексов часто позволяет сократить
количество дисковых операций ввода/вывода по сравнению с традиционными
решениями.

</P>
<P>
Записи в некластеризированных индексах (мы называем их также вторичными
индексами), в InnoDB содержат значение первичного ключа для строки. InnoDB
использует этот значение первичного ключа для поиска строки в
кластеризированном индексе. Следует учитывать, что если первичный ключ
достаточно велик, вторичные индексы будут занимать больше места.

</P>



<H4><A NAME="InnoDB_physical_structure" HREF="manual.ru_toc.html#InnoDB_physical_structure">7.5.10.1  Физическая структура индекса</A></H4>

<P>
Все индексы в InnoDB представляют собой B-деревья, в которых записи
индексов хранятся в страницах ответвления дерева. По умолчанию размер
индексной страницы составляет 16 Кб. При вставке новых записей InnoDB
старается оставить 1 / 16 страницы свободной - для будущих вставок и
обновлений индексных записей.

</P>
<P>
Если записи индекса вставлены в последовательном порядке (в порядке
возрастания или убывания), то получившиеся индексные страницы будут
заполнены примерно на 15/16. Для записей, которые вставляются в случайном
порядке, эти значения составят от 1/2 до 15/16. Если коэффициент
заполнения индексной страницы уменьшится и станет ниже 1/2, InnoDB
попытается объединить записи индексного дерева, чтобы освободить страницу.

</P>


<H4><A NAME="InnoDB_Insert_buffering" HREF="manual.ru_toc.html#InnoDB_Insert_buffering">7.5.10.2  Буферизация вставок</A></H4>

<P>
Нередко в программах для работы с базами данных первичный ключ является
уникальным идентификатором и новые строки вставляются в порядке
возрастания первичного ключа. Таким образом, вставки в кластеризированный
индекс не требуют проведения случайных считываний с диска.

</P>
<P>
Что же касается вторичных индексов, то они, напротив, обычно не являются
уникальными, так что вставки во вторичные индексы производятся в
относительно случайном порядке. Это приводит к выполнению большого
количества случайных дисковых операций ввода/вывода диска, если не
используется специальный механизм, применяемый в InnoDB.

</P>
<P>
Если требуется вставить запись индекса во вторичный индекс, который не
является уникальным, InnoDB проверяет, находится ли страница вторичного
индекса в буферном пуле. Если она там есть, InnoDB произведет вставку
непосредственно в страницу индекса. Но если страница индекса не найдена в
буферном пуле, InnoDB вставляет запись в специальную структуру буфера
вставок. Буфер вставок настолько мал, что полностью помещается в буферный
пул, и вставки в него могут производиться очень быстро.

</P>
<P>
Буфер вставок периодически объединяется с деревьями вторичных индексов в
базе данных. Часто, объединив несколько вставок на одной странице
индексного дерева, можно за счет этого сократить количество операций
ввода/вывода диска. Использование буфера вставки может ускорить вставку в
таблицу в 15 раз.

</P>


<H4><A NAME="InnoDB_Adaptive_hash" HREF="manual.ru_toc.html#InnoDB_Adaptive_hash">7.5.10.3  Адаптивный хешированный индекс</A></H4>

<P>
Если база данных почти полностью помещается в основной памяти, то самым
быстрым способом выполнения запросов по этой базе данных является
использование хешированных индексов. В InnoDB существует автоматический
механизм, который отслеживает поиск по индексу, осуществляемый по
индексам, определенным для таблицы, и если InnoDB посчитает, что запросы
выиграют от создания хешированного индекса, такой индекс будет создан
автоматически.

</P>
<P>
Но следует учитывать, что хешированный индекс всегда создается на основе
существующего индекса B-дерева таблицы. InnoDB может создать хешированный
индекс на префиксах любой длины ключа, определенного для B-дерева, в
зависимости от того, по какой схеме поиска InnoDB производит обзор индекса
the B-дерева. Хешированный индекс может быть частичным: не обязательно
кэшировать в буферном пуле весь индекс B-дерева. InnoDB будет создавать
хешированные индексы по запросу для тех страниц индекса, к которым часто
производится доступ.

</P>
<P>
Хотя механизм адаптивного хешированного индекса InnoDB приспосабливается к
большому количеству основной памяти, он больше подходит для архитектуры
баз данных основной памяти.

</P>


<H4><A NAME="InnoDB_Physical_record" HREF="manual.ru_toc.html#InnoDB_Physical_record">7.5.10.4  Физическая структура записи</A></H4>


<ul>
<LI>

У всех записей индекса в InnoDB есть заголовок, состоящий из 6 байтов.
Заголовок используется для связывания вместе последовательных записей,
а также при блокировке на уровне строк.
<LI>

Записи в кластеризированном индексе содержат поля для всех столбцов,
определенных пользователем. Кроме того, имеется 6-байтовое поле для
идентификатора транзакции и 7-байтовое поле для указателя строки.
<LI>

Если пользователь не определил для таблицы первичный ключ, то в каждой
записи кластеризированного индекса также содержится 6-байтовое поле
идентификатора строки.
<LI>

Все записи вторичного индекса содержат также все поля, определенные
для ключа кластеризированного индекса.
<LI>

Запись также содержит указатель на каждое поле записи. Если общая
длина полей в записи меньше 128 байтов, то размер указателя будет 1
байт, в противном случае - 2 байта.
</ul>



<H4><A NAME="SEC481" HREF="manual.ru_toc.html#SEC481">7.5.10.5  Как работают автоинкрементные столбцы в InnoDB</A></H4>

<P>
Когда пользователь после запуска базы данных осуществляет первую вставку в
таблицу T, где определен автоинкрементный столбец, и пользователь не
предоставляет конкретного значения для этого столбца, InnoDB выполняет
<code>SELECT MAX(auto-inc-column) FROM T</code>, затем присваивает это значение,
увеличенное на единицу, столбцу, и автоматически увеличивает счетчик
таблицы. Эту последовательность действий мы называем инициализацией
счетчика автоматического увеличения для таблицы <code>T</code>.

</P>
<P>
Ту же последовательность действий InnoDB выполняет и для инициализации
автоинкрементного счетчика вновь созданной таблицы.

</P>
<P>
Обратите внимание: если пользователь указывает при вставке значение
автоинкрементного столбца 0, то InnoDB обрабатывает строку так, как
будто значение не было указано.

</P>
<P>
Если после инициализации автоматического увеличения счетчика пользователь
вставляет строку, в которой он явно указывает значение столбца, и это
значение превышает текущее значение счетчика, то счетчик устанавливается в
указанное значение столбца. Если пользователь явно не указывает значение,
то InnoDB увеличивает счетчик на единицу и присваивает столбцу это новое
значение.

</P>
<P>
При присвоении значений из счетчика механизм автоматического увеличения
обходит блокировку и управление транзакциями. Вследствие этого могут
возникнуть пропуски в последовательности чисел в случае, если производится
откат транзакций, которые получили номера из счетчика.

</P>
<P>
Для случаев, когда пользователь присваивает столбцу отрицательное значение
или если значение превысит максимальное целое число, которое может
храниться в переменной целочисленного типа, поведение механизма
механического увеличения не определено.

</P>


<H3><A NAME="File_space_management" HREF="manual.ru_toc.html#File_space_management">7.5.11  Управление файловым пространством и дисковый ввод/вывод</A></H3>



<H4><A NAME="InnoDB_Disk_I_O" HREF="manual.ru_toc.html#InnoDB_Disk_I_O">7.5.11.1  Дисковый ввод/вывод</A></H4>

<P>
В операциях дискового ввода/вывода для таблиц InnoDB используется
асинхронный ввод/вывод. В Windows NT применяется собственный асинхронный
ввод/вывод, обеспечиваемый операционной системой, а в Unix - эмуляция
асинхронного ввода/вывода, встроенная в InnoDB (InnoDB создает
определенное количество потоков ввода/вывода, чтобы обеспечить операции
ввода/вывода, такие как опережающее считывание). В будущей версии мы
добавим поддержку эмуляции асинхронного ввода/вывода в Windows NT и
собственного асинхронного ввода/вывода в тех версиях Unix, в которых он
есть.

</P>
<P>
В Windows NT для таблиц InnoDB используется ввод/вывод без буферизации.
Это означает, что страницы на диске, которые записывает или считывает
InnoDB, не заносятся в файловый кэш операционной системы. При этом
экономится некоторое количество памяти.

</P>
<P>
Начиная с версии 3.23.41 в InnoDB используется новая техника сбрасывания
файлов на диск, которая получила название двойной записи. Она обеспечивает
большую безопасность при восстановлении после сбоев (таких как, например,
зависание операционной системы или отключение питания) и повышение
производительности на большинстве версий Unix, так как снижается
необходимость в операциях fsync.

</P>
<P>
``Двойная запись'' означает, что InnoDB перед записью страниц в файл данных
сначала записывает их в смежный участок табличной области, который
называется буфером двойной записи. Запись страниц в предназначенные для
них места файла данных осуществляется только после завершения записи и
сброса буфера двойной записи на диск. В случае сбоя системы во время
записи страницы InnoDB во время восстановления найдет в буфере двойной
записи пригодную копию страницы.

</P>
<P>
Начиная с версии 3.23.41 в качестве файла данных можно также использовать
раздел реального диска, хотя тестирование этой возможности еще не
проводилось. При создании нового файла данных в <code>innodb_data_file_path</code>
сразу после размера файла данных необходимо ввести ключевое слово newraw.
Раздел диска должен быть больше указанного размера или равен ему. Обратите
внимание: 1  Мб в InnoDB -это 1024 x 1024 байт, тогда как в
характеристиках диска 1 Мб обычно соответствует 1000 000 байт.

</P>

<pre>
innodb_data_file_path=hdd1:5Gnewraw;hdd2:2Gnewraw
</pre>

<P>
При новом запуске базы данных Вы <strong>должны</strong> изменить ключевое слово на <code>raw</code>. В
противном случае InnoDB перезапишет ваш раздел!

</P>

<pre>
innodb_data_file_path=hdd1:5Graw;hdd2:2Graw
</pre>

<P>
Используя реальный диск, в некоторых версиях Unix можно производить
небуферизованные операции ввода/вывода.

</P>
<P>
В InnoDB существует два эвристических метода опережающего считывания:
последовательное опережающее считывание и случайное опережающее
считывание. Метод последовательного опережающего считывания
предусматривает, что InnoDB, определив, что схема доступа к сегменту в
табличной области является последовательной, будет заранее направлять
системе ввода/вывода пакет считываний страниц базы данных. Метод
случайного опережающего считывания предполагает, что InnoDB, определив,
что некоторые части табличной области полностью считываются в буферный
пул, направляет оставшиеся считывания системе ввода/вывода.

</P>


<H4><A NAME="InnoDB_File_space" HREF="manual.ru_toc.html#InnoDB_File_space">7.5.11.2  Управление файловым пространством</A></H4>

<P>
Табличную область InnoDB составляют файлы данных, определенные в файле
конфигурации. Файлы  используются  последовательно, распределения  данных
(striping ) по  ним  не  производится. На данный момент вы не можете
непосредственно указать, где должны быть размещены таблицы. Можно только
воспользоваться знанием того факта, что для вновь созданной табличной
области InnoDB будет распределяться  место с начала памяти.

</P>
<P>
Табличная область состоит из страниц базы данных, принятый по умолчанию
размер которых составляет 16 Кб. Эти страницы сгруппированы в блоки по 64
последовательных страницы. 'Файлы' внутри табличной области в InnoDB
называются сегментами. Название 'сегмент отката' несколько не
соответствует действительности, так как фактически в нем содержится много
сегментов табличной области.

</P>
<P>
Для каждого индекса в InnoDB выделяется два сегмента: один - для конечных
узлов B-дерева, а другой - для остальных узлов. Идея заключается в том,
чтобы получить лучшее координирование конечных узлов, в которых содержатся
данные.

</P>
<P>
Когда сегмент внутри табличной области возрастает, InnoDB выделяет первые
32 специально для этого сегмента. После этого InnoDB начинает выделять
целые области для этого сегмента. Чтобы обеспечить хорошее координирование
данных, InnoDB может единовременно добавить к большому сегменту до 4
областей,.

</P>
<P>
Некоторые страницы табличной области содержат битовые образы других
страниц, поэтому несколько областей в табличной области InnoDB могут быть
выделены не для целого сегмента, а только для отдельных страниц.

</P>
<P>
Когда вы запускаете запрос <code>SHOW TABLE STATUS FROM ... LIKE ...</code> для
получения информации по доступному свободному пространству табличной
области, InnoDB предоставит данные по свободным областям табличной
области. InnoDB всегда резервирует области для очистки и других внутренних
операций. Зарезервированные области не включаются в объем свободного
пространства.

</P>
<P>
Если из таблицы удаляются данные, InnoDB объединяет соответствующие
индексы B-дерева. В зависимости от схемы удалений, когда освобождаются
отдельные страницы или области табличной области, это пространство
становится доступным для других пользователей. Удаление таблицы или
удаление всех ее строк гарантированно освободит пространство для других
пользователей, но не следует забывать, что физически строки удаляются
только после проведения чистки, после чего они больше не нужны при откате
транзакций или согласованном чтении.

</P>


<H4><A NAME="InnoDB_File_Defragmenting" HREF="manual.ru_toc.html#InnoDB_File_Defragmenting">7.5.11.3  Дефрагментация  таблицы</A></H4>

<P>
Если в индексной таблице производились случайные вставки или удаления,
индекс может стать фрагментированным. Под фрагментацией мы подразумеваем
то, что физическое расположение индексных страниц на диске значительно
отличается от алфавитного порядка страниц, или что в 64-страничных блоках
много пустых страниц, которые занесены в индекс.

</P>
<P>
Скорость сканирования индекса может возрасти, если периодически
использовать команду mysqldump для копирования дампа таблицы в текстовый
файл, записи диска на диск и повторного считывания таблицы из дампа. Есть
еще один способ произвести дефрагментацию - преобразовать таблицу при
помощи команды <code>ALTER</code> в тип <code>MyISAM</code>, а затем обратно в тип InnoDB. Обратите
внимание на то, что таблица типа <code>MyISAM</code> должна помещаться в один файл в
вашей операционной системе.

</P>
<P>
Если вставки в индекс всегда производятся последовательно, а удаления -
только с конца, то алгоритм управления файловым пространством InnoDB
гарантирует, что фрагментации индекса не возникнет.

</P>


<H3><A NAME="Error_handling" HREF="manual.ru_toc.html#Error_handling">7.5.12  Обработка ошибок</A></H3>

<P>
Обработка ошибок в InnoDB не всегда соответствует спецификациям, указанным
в стандарте ANSI SQL. В соответствии со стандартом ANSI любая ошибка,
произошедшая во время выполнения оператора SQL должна привести к откату
оператора. InnoDB иногда осуществляет откат только части оператора или
целой транзакции. Особенности обработки ошибок в InnoDB указаны в
приведенном ниже списке.

</P>

<ul>
<LI>

Если закончилось свободное место в табличной области, будет выдано
сообщение об ошибке MySQL <code>'Table is full'</code> и InnoDB произведет откат
оператора SQL.
<LI>

Взаимоблокировка транзакции или истечение времени ожидания при
блокировке приводят к откату целой транзакции в InnoDB.
<LI>

Ошибка дублирующегося ключа приводит к откату вставки только этой
определенной строки, даже в операторе <code>INSERT INTO ... SELECT ...</code>. Этот
алгоритм мы, возможно, изменим, с тем чтобы производился откат всего
оператора SQL, если для него не указан параметр <code>IGNORE</code>.
<LI>

Ошибка <code>'row too long'</code> приводит к откату оператора SQL.
<LI>

Большинство остальных ошибок обнаруживается на уровне кода MySQL, и
производится откат соответствующего оператора SQL.
</ul>



<H3><A NAME="InnoDB_restrictions" HREF="manual.ru_toc.html#InnoDB_restrictions">7.5.13  Ограничения для таблиц InnoDB</A></H3>


<ul>

<LI>

Предупреждение: <strong>НЕЛЬЗЯ</strong> преобразовывать системные таблицы MySQL из
формата MyISAM в формат InnoDB! Эта операция не поддерживается, и если
попытаться ее осуществить, MySQL не перезапустится, пока не будут
восстановлены старые системные таблицы из резервной копии, или пока не
будут созданы новые таблицы при помощи скрипта <code>mysql_install_db</code>.

<LI>

Команда <code>SHOW TABLE STATUS</code> не выдает точных статистических данных по
таблицам InnoDB, за исключением размера физического пространства,
зарезервированного для таблицы. Подсчет строк производится
приблизительно  так, как в оптимизации SQL.

<LI>

Если попытаться создать уникальный индекс на префиксе столбца, то
будет выдана ошибка:


<pre>
CREATE TABLE T (A CHAR(20), B INT, UNIQUE (A(5))) TYPE = InnoDB;
</pre>

Если на префиксе столбца создать неуникальный индекс, InnoDB создаст
индекс по всему столбцу.
<LI>

Для таблиц InnoDB не поддерживается команда <code>INSERT DELAYED</code>.
<LI>

Операция MySQL <code>LOCK TABLES</code> не знает про блокировки InnoDB на уровне
строк в уже выполненном операторе SQL: это означает, что можно
установить блокировку на таблицу, даже если существуют транзакции
других пользователей, которые установили блокировку этой же таблицы на
уровне строк. Таким образом, может оказаться, что ваши операции над
таблицей будут вынуждены ожидать, если такая блокировка будет
установлена другими пользователями: возможна также и взаимоблокировка.
Тем не менее, это не угрожает целостности транзакций, так как при
установке блокировки на таблицы InnoDB всегда соблюдается целостность.
Кроме того, блокировка таблицы не позволяет другим транзакциям
установить на таблицу дополнительные блокировки на уровне строки (в
режиме несовместимости блокировок).
<LI>

Нельзя установить ключ для столбцов типа <code>BLOB</code> или <code>TEXT</code>.
<LI>

Таблица не может содержать больше 1000 столбцов.
<LI>

Команда <code>DELETE FROM TABLE</code> не пересоздает таблицу, она удаляет все
строки по одной, что осуществляется не очень быстро. В будущих версиях
MySQL можно будет использовать команду <code>TRUNCATE</code>, которая намного
быстрее.
<LI>

Принятый по умолчанию размер страницы в InnoDB составляет 16  Кб.
Повторно скомпилировав код, можно установить значение от 8 Кб до 64
Кб. В версиях &#60;= 3.23.40 InnoDB максимальная длина строки несколько
меньше половины размера страницы базы данных. Начиная с релиза
исходного кода версии 3.23.41 столбцы типов <code>BLOB</code> и <code>TEXT</code> могут
достигать 4 Гб, общая длина строк также не должна превышать 4 Гб.
Поля с размером меньше или равным 128 байтам в InnoDB не хранятся на
отдельных страницах. После того как InnoDB изменит строку, сохранив
длинные поля на отдельных страницах, оставшаяся длина строки должна
быть меньше половины страницы базы данных. Максимальная длина ключа -
7000 байтов.
<LI>

В некоторых операционных системах файлы данных не должны превышать 2
Гб. Общий размер файлов журналов должен быть меньше 4 Гб.
<LI>

Максимальный размер табличной области составляет 4 миллиарда страниц
базы данных. Это также максимальный размер таблицы. Минимальный размер
табличной области составляет 10 Мб.
</ul>



<H3><A NAME="InnoDB_change_history" HREF="manual.ru_toc.html#InnoDB_change_history">7.5.14  История изменений InnoDB</A></H3>

<P>
Раздел в переводе.

</P>


<H3><A NAME="InnoDB_contact_information" HREF="manual.ru_toc.html#InnoDB_contact_information">7.5.15  Контактная информация для получения данных по InnoDB</A></H3>

<P>
Контактная информация компании Innobase Oy, которая создала модель InnoDB:
веб-сайт: <a HREF="http://www.innodb.com/">http://www.innodb.com/</a>, e-mail: <a HREF="mailto:Heikki.Tuuri@innodb.com">Heikki.Tuuri@innodb.com</a> 

</P>

<pre>
Телефон: 358-9-6969 3250 (офис) 358-40-5617367 (мобильный)
Innobase Oy Inc.
World Trade Center Helsinki
Aleksanterinkatu 17
P.O.Box 800
00101 Helsinki
Finland
</pre>



<H2><A NAME="BDB" HREF="manual.ru_toc.html#BDB">7.6  Таблицы <code>BDB</code> или BerkeleyDB</A></H2>

<P>
<A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>

</P>



<H3><A NAME="BDB_overview" HREF="manual.ru_toc.html#BDB_overview">7.6.1  Обзор таблиц <code>BDB</code></A></H3>

<P>
Поддержка таблиц <code>BDB</code> включена в дистрибутив исходного кода MySQL начиная с
версии 3.23.34 и в бинарную версию MySQL-Max.

</P>
<P>
BerkeleyDB, доступный на веб-сайте <a HREF="http://www.sleepycat.com/">http://www.sleepycat.com/</a>, обеспечивает
транзакционный обработчик таблиц для MySQL. 

</P>
<P>
Использование BerkeleyDB
повышает для ваших таблиц шансы уцелеть после сбоев, а также предоставляет
возможность осуществлять операции <code>COMMIT</code> и <code>ROLLBACK</code> для транзакций.
Дистрибутив исходного кода MySQL поставляется с дистрибутивом <code>BDB</code>,
содержащим несколько небольших исправлений, которые позволяют устранить
определенные проблемы при работе с MySQL. Неисправленные версии <code>BDB</code> при
работе с MySQL использовать нельзя.

</P>
<P>
В целях поддержания высокого уровня и качества интерфейса MySQL/BDB
компания MySQL AB тесно сотрудничает с компанией Sleepycat.

</P>
<P>
Что касается поддержки таблиц <code>BDB</code>, то мы взяли на себя обязательство
оказывать помощь нашим пользователям в выявлении проблем и создании
воспроизводимых контрольных примеров для любых ошибок, возникающих при
использовании таблиц <code>BDB</code>. Все такие контрольные примеры направляются в
компанию Sleepycat, которая, в свою очередь, помогает нам выявлять и
исправлять ошибки. Поскольку эта операция состоит из двух этапов, решение
проблем с таблицами <code>BDB</code> может отнять у нас больше времени, чем устранение
ошибок других обработчиков таблиц. Тем не менее, поскольку помимо MySQL
код BerkeleyDB использовался с большим количеством других приложений, мы
не думаем, что с ним возникнут серьезные проблемы (see section <A HREF="manual.ru_Introduction.html#Business_Services_Support">1.5.1.1  Поддержка</A>).

</P>


<H3><A NAME="BDB_install" HREF="manual.ru_toc.html#BDB_install">7.6.2  Установка <code>BDB</code></A></H3>

<P>
Если вы загрузили бинарную версию MySQL, которая включает поддержку
BerkeleyDB, просто выполните инструкции по установке бинарной версии MySQL
(см. разделы section <A HREF="manual.ru_Installing.html#Installing_binary">2.2.10  Установка бинарного дистрибутива MySQL</A> и see section <A HREF="manual.ru_MySQL_Database_Administration.html#mysqld-max">4.7.5  <code>mysqld-max</code>, расширенный сервер <code>mysqld</code></A>).

</P>
<P>
Чтобы произвести компиляцию MySQL с поддержкой Berkeley DB, загрузите
MySQL версии 3.23.34 или выше и выполните настройку MySQL при помощи
параметра <code>--with-berkeley-db</code> (see section <A HREF="manual.ru_Installing.html#Installing_source">2.3  Установка исходного дистрибутива MySQL</A>).

</P>

<pre>
cd /path/to/source/of/mysql-3.23.34
./configure --with-berkeley-db
</pre>

<P>
Чтобы получить самую последнюю информацию, обращайтесь к руководству,
которое поставляется с дистрибутивом BDB.

</P>
<P>
Хотя Berkeley DB детально протестирован и надежен, BDB-интерфейс MySQL
пока еще является бета-версией. Мы совершенствуем и оптимизируем его,
чтобы в скором времени добиться стабильной работы.

</P>


<H3><A NAME="BDB_start" HREF="manual.ru_toc.html#BDB_start">7.6.3  Параметры запуска <code>BDB</code></A></H3>

<P>
Если запуск производился с параметром <code>AUTOCOMMIT=0</code>, то изменения,
сделанные в в таблицах BDB, не вносятся, пока не будет выполнена команда
<code>COMMIT</code>. Кроме операции фиксации, можно запустить команду <code>ROLLBACK</code>, чтобы
отменить изменения (see section <A HREF="manual.ru_Reference.html#COMMIT">6.7.1  Синтаксис команд <code>BEGIN/COMMIT/ROLLBACK</code></A>).

</P>
<P>
Если вы работаете с параметром <code>AUTOCOMMIT=1</code> (значение по умолчанию),
внесенные изменения будут фиксироваться немедленно. Можно выполнить
расширенную транзакцию при помощи команды SQL <code>BEGIN WORK</code>, после которой
изменения не будут зафиксированы до запуска команды <code>COMMIT</code> (или будут
отменены при помощи команды <code>ROLLBACK</code>).

</P>
<P>
Чтобы изменить параметры таблиц <code>BDB</code>, можно воспользоваться следующими
опциями <code>mysqld</code>:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Параметр</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>--bdb-home=directory</code> </TD><TD> Базовый каталог для таблиц <code>BDB</code>.  Это должен быть тот же каталог, что и для <code>--datadir</code>.
</TD></TR>
<TR><TD><code>--bdb-lock-detect=#</code> </TD><TD> Обнаружение блокировки Berkeley; одно из значений: <code>DEFAULT</code>, <code>OLDEST</code>, <code>RANDOM</code> или <code>YOUNGEST</code>
</TD></TR>
<TR><TD><code>--bdb-logdir=directory</code> </TD><TD> Каталог файла журнала Berkeley DB
</TD></TR>
<TR><TD><code>--bdb-no-sync</code> </TD><TD> Отмена синхронной записи журналов на диск
</TD></TR>
<TR><TD><code>--bdb-no-recover</code> </TD><TD> Отмена запуска Berkeley DB в режиме восстановления
</TD></TR>
<TR><TD><code>--bdb-shared-data</code> </TD><TD> Запуск Berkeley DB в режиме параллельной обработки (при инициализации Berkeley DB не следует использовать <code>DB_PRIVATE</code>)
</TD></TR>
<TR><TD><code>--bdb-tmpdir=directory</code> </TD><TD> Имя временной директории Berkeley DB
</TD></TR>
<TR><TD><code>--skip-bdb</code> </TD><TD> Отмена использования таблиц <code>BDB</code>
</TD></TR>
<TR><TD><code>-O bdb_max_lock=1000</code> </TD><TD> Задает максимальное количество возможных блокировок (see section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>).
</TD></TR>
</TABLE>

<P>
Если используется параметр <code>--skip-bdb</code>, MySQL не будет инициализировать
библиотеку Berkeley DB, что позволит сэкономить большое количество памяти.
Разумеется, после включения этого параметра нельзя пользоваться таблицами
BDB. если вы попытаетесь создать таблицу <code>BDB</code>, то в этом случае MySQL
будет создавать таблицу <code>MyISAM</code>.

</P>
<P>
Обычно если предполагается использовать таблицы <code>BDB</code>, следует запускать
<code>mysqld</code> без параметра <code>--bdb-no-recover</code>. Однако если файлы журналов <code>BDB</code>
повреждены, то при попытке запуска mysqld могут возникнуть проблемы (see section <A HREF="manual.ru_Installing.html#Starting_server">2.4.2  Проблемы при запуске сервера MySQL</A>).

</P>
<P>
При помощи параметра <code>bdb_max_lock</code> задается максимальное количество
блокировок (10000 по умолчанию), которые могут быть установлены на таблицу
<code>BDB</code>. Это значение необходимо увеличить, если возникают ошибки <code>bdb: Lock
table is out of available locks или Got error 12 from ...</code> при проведении
длинных транзакций или когда <code>mysqld</code> должен просмотреть много строк, чтобы
произвести необходимые вычисления для запроса.

</P>
<P>
Можно также изменить <code>binlog_cache_size</code> и <code>max_binlog_cache_size</code>, если
используются большие многострочные транзакции (see section <A HREF="manual.ru_Reference.html#COMMIT">6.7.1  Синтаксис команд <code>BEGIN/COMMIT/ROLLBACK</code></A>).

</P>


<H3><A NAME="BDB_characteristics" HREF="manual.ru_toc.html#BDB_characteristics">7.6.4  Характеристики таблиц <code>BDB</code></A></H3>


<ul>
<LI>

Чтобы обеспечить возможность отката транзакций, для таблиц BDB
поддерживается ведение файлов журналов. Для достижения максимальной
производительности эти файлы необходимо разместить на разных с базой
данных дисках, воспользовавшись параметром <code>--bdb-logdir</code>.
<LI>

Каждый раз, когда создается новый файл журнала <code>BDB</code>, MySQL
устанавливает контрольные точки и удаляет все файлы журналов, которые
не нужны для текущих транзакций. Можно также в любое время запустить
команду <code>FLUSH LOGS</code>, чтобы установить контрольную точку для таблиц
Berkeley DB. Чтобы произвести восстановление после сбоя, необходимо
воспользоваться резервными копиями таблицы, а также бинарным журналом
MySQL (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Backup">4.4.1  Резервное копирование баз данных</A>). Предупреждение: если удалить
используемые старые файлы журналов, BDB не сможет осуществить
восстановление, и в случае сбоя вы можете потерять данные.
<LI>

В MySQL все таблицы <code>BDB</code> должны иметь  первичные ключи, чтобы
обеспечить возможность обращаться к ранее считанным строкам. Если
первичный ключ не создан, MySQL создаст его и будет поддерживать
скрытый первичный ключ. Длина скрытого ключа составляет 5 байтов, а 
его значение увеличивается при каждой попытке вставки.
<LI>

Если все столбцы, к которым производится обращение в таблице <code>BDB</code>,
являются частью одного индекса или одного первичного ключа, то MySQL
может выполнить запрос, не обращаясь к самой строке. Для таблиц <code>MyISAM</code>
это справедливо только если столбцы являются частью одного индекса.
<LI>

Первичный ключ обеспечивает более быструю обработку, чем любой другой
ключ, так как он хранится вместе с данными строки. Поскольку остальные
ключи хранятся как данные ключа + <code>PRIMARY KEY</code>, очень важно иметь как
можно более короткие первичные ключи, чтобы сэкономить дисковое
пространство и увеличить производительность.
<LI>

Команда <code>LOCK TABLES</code> работает с таблицами <code>BDB</code> точно так же, как и с
другими таблицами. Если команда <code>LOCK TABLE</code> не используется, MySQL
устанавливает на таблицу внутреннюю множественную блокировку записи,
чтобы обеспечить правильную блокировку, если другой поток установит
блокировку таблицы.
<LI>

Внутренняя блокировка в таблицах <code>BDB</code> осуществляется на уровне страниц.
<LI>

Команда <code>SELECT COUNT(*) FROM table_name</code> выполняется медленно, так как
для таблиц <code>BDB</code> не поддерживается подсчет количества строк в таблице.
<LI>

Сканирование осуществляется медленнее, чем в таблицах <code>MyISAM</code>, так как
данные в таблицах <code>BDB</code> хранятся в B-деревьях, а не в отдельных файлах
данных.
<LI>

Приложение всегда должно быть готово к обработке ситуаций, в которых
любые изменения таблицы <code>BDB</code> могут привести к автоматическому откату и
любое считывание может вызвать сбой из-за возникновения
взаимоблокировки.
<LI>

Ключи не являются пакованными как в <code>MyISAM</code>. 
Иначе говоря, информация по ключам в таблицах BDB
займет несколько больше места по сравнению с таблицами <code>MyISAM</code>.
<LI>

В таблице <code>BDB</code> всегда имеются промежутки, благодаря чему можно
вставлять новые строки в середину дерева ключа. Из-за этого таблицы
<code>BDB</code> несколько больше, чем таблицы <code>MyISAM</code>.
<LI>

Оптимизатору необходимо знать приблизительное количество строк в
таблице. В MySQL этот вопрос решается путем подсчета количества
вставок и поддержки этой информации в отдельном сегменте каждой
таблицы <code>BDB</code>. Если операторов <code>DELETE</code> или <code>ROLLBACK</code> выполнялось не
слишком много, это количество должно быть достаточно точным для
оптимизатора MySQL, но MySQL сохраняет это число только при закрытии,
и оно в случае аварийного завершения работы MySQL может оказаться
неверным. Если число не соответствует действительности на 100% -
ничего страшного в этом нет. Количество строк можно обновить, запустив
команду <code>ANALYZE TABLE</code> или <code>OPTIMIZE TABLE</code> 
(см. разделы section <A HREF="manual.ru_MySQL_Database_Administration.html#ANALYZE_TABLE">4.5.2  Синтаксис команды <code>ANALYZE TABLE</code></A> и see section <A HREF="manual.ru_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  Синтаксис  команды <code>OPTIMIZE TABLE</code></A>).
<LI>

Если таблица <code>BDB</code> займет все пространство на диске, то будет выведено
сообщение об ошибке (возможно, ошибка 28) и выполнен откат транзакции. В
отличие от <code>BDB</code>, таблицы <code>MyISAM</code> и <code>ISAM</code> в <code>mysqld</code> будут ожидать, пока не
появится свободное место, а потом продолжат работу.
</ul>



<H3><A NAME="BDB_TODO" HREF="manual.ru_toc.html#BDB_TODO">7.6.5  Что нам нужно исправить в <code>BDB</code> в ближайшем будущем:</A></H3>


<ul>
<LI>

Процесс одновременного открытия многих таблиц <code>BDB</code> производится очень
медленно. Если вы собираетесь применять таблицы <code>BDB</code>, не следует
создавать очень большой кэш таблицы (например, больше 256  Кб) и
необходимо использовать параметр <code>--no-auto-rehash</code> для клиента <code>mysql</code>.
Мы планируем частично исправить это в версии 4.0.
<LI>

Команда <code>SHOW TABLE STATUS</code> еще не предоставляет достаточного количества
информации по таблицам <code>BDB</code>.
<LI>

Оптимизация производительности.
<LI>

Переход на запрет использования блокировок при сканировании таблиц.
</ul>



<H3><A NAME="BDB_portability" HREF="manual.ru_toc.html#BDB_portability">7.6.6  Операционные системы, поддерживаемые <code>BDB</code></A></H3>

<P>
На данный момент нам известно, что таблицы <code>BDB</code> работают со следующими
операционными системами.

</P>

<ul>
<LI>

Linux 2.x Intel
<LI>

Solaris SPARC
<LI>

Caldera (SCO) OpenServer
<LI>

Caldera (SCO) UnixWare 7.0.1
</ul>

<P>
И не работают со следующими:

</P>

<ul>
<LI>

Linux 2.x Alpha
<LI>

Max OS X
</ul>

<P>
Этот список неполон. Мы будем обновлять его по мере поступления свежей информации. 

</P>
<P>
Если вы собираете MySQL с поддержкой таблиц BDB и получаете вот такую ошибку в 
файле журнала при запуске <code>mysqld</code>: 

</P>

<pre>
bdb: architecture lacks fast mutexes: applications cannot be threaded
Can't init dtabases
</pre>

<P>
То это означает, что таблицы BDB не поддерживаются на вашей платформе. В этом
случае вам следует пересобрать MySQL без поддержки таблиц BDB.

</P>


<H3><A NAME="BDB_restrictions" HREF="manual.ru_toc.html#BDB_restrictions">7.6.7  Ограничения таблиц <code>BDB</code></A></H3>

<P>
Ниже приведены ограничения при использовании таблиц <code>BDB</code>:

</P>

<ul>
<LI>

Таблицы <code>BDB</code> хранятся в файле <tt>`.db'</tt>, который находится в том же каталоге,
где был создан (это сделано для того, чтобы была возможность
обнаруживать блокировки в многопользовательской среде с поддержкой
символических ссылок).

Но вследствие этого таблицы <code>BDB</code> нельзя
перемещать между каталогами!

<LI>

При создании резервных копий таблиц <code>BDB</code> необходимо использовать <code>mysqldump</code>
или создать резервные копии всех файлов <tt>`table_name.db'</tt> и файлов журналов
<code>BDB</code>. Файлы журналов <code>BDB</code> - это файлы в базовом каталоге донных с именами
<tt>`log.XXXXXX'</tt> (6 цифр). Обработчик таблицы <code>BDB</code> хранит незавершенные
транзакции в файлах журналов; их наличие требуется при запуске <code>mysqld</code>.
</ul>



<H3><A NAME="BDB_errors" HREF="manual.ru_toc.html#BDB_errors">7.6.8  Ошибки, которые могут возникнуть при использовании таблиц <code>BDB</code></A></H3>


<ul>
<LI>

Если в <tt>`hostname.err log'</tt> при запуске <code>mysqld</code> возникла следующая ошибка:


<pre>
bdb: Ignoring log file: .../log.XXXXXXXXXX: unsupported log version #
</pre>

это означает, что новая версия <code>BDB</code> не поддерживает старый формат файлов
журналов. В этом случае необходимо удалить все файлы журналов <code>BDB</code> из
каталога своей базы данных (файлы формата <tt>`log.XXXXXXXXXX'</tt> ) и перезапустить
<code>mysqld</code>. Мы  также  рекомендуем  сохранить  содержимое <code>BDB</code>-баз  данных  в 
файл  путем  вызова <code>mysqldump --opt</code>, удалить  старые  файлы  таблиц  и 
восстановить  базы  данных  из  сохраненного  файла.
<LI>

Если запуск производится не в режиме <code>auto_commit</code> и происходит удаление
таблицы, которая используется другим потоком, в файле ошибок MySQL
могут появится следующие записи:


<pre>
001119 23:43:56 bdb: Missing log fileid entry
001119 23:43:56 bdb: txn_abort: Log undo failed for LSN:
1 3644744: Invalid
</pre>

Это не смертельно, но мы не рекомендуем удалять таблицы, если вы не
находитесь в режиме <code>auto_commit</code>, пока эта проблема не будет решена (а
решить ее вовсе не просто).
</ul>

<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Reference.html">previous</A>, <A HREF="manual.ru_Clients.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
