  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - E  Перенос на другие системы</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_News.html">previous</A>, <A HREF="manual.ru_Environment_variables.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Porting" HREF="manual.ru_toc.html#Porting">E  Перенос на другие системы</A></H1>

<P>
<A NAME="IDX1799"></A>
<A NAME="IDX1800"></A>
<A NAME="IDX1801"></A>

</P>

<P>
Цель данного раздела - обеспечить помощь в переносе MySQL на другие
операционные системы. Но сначала необходимо ознакомиться со списком
поддерживаемых в настоящее время операционных систем (see section <A HREF="manual.ru_Installing.html#Which_OS">2.2.5  Операционные системы, поддерживаемые MySQL</A>). Если вы создали новую версию переноса
MySQL, пожалуйста, сообщите нам - тогда мы включим ее в настоящий список и
в список на нашем веб-сайте (<a HREF="http://www.mysql.com/">http://www.mysql.com/</a>) и сможем рекомендовать
ее другим пользователям.

</P>
<P>
Примечание: те, кто создаст новую версию переноса MySQL, имеют право
размножать и распространять на условиях лицензии GPL, но это не делает их
обладателями авторского права на MySQL.

</P>
<P>
Для сервера необходима рабочая библиотека Posix-потоков. Под операционной
системой Solaris 2.5 мы используем потоки Sun  PThreads ("родная"
поддержка потоков в версии 2.4 и более ранних не является достаточно
хорошей), а под Linux мы используем LinuxThreads, разработку Ксавье Лероя
(Xavier  Leroy, <a HREF="mailto:Xavier.Leroy@inria.fr">Xavier.Leroy@inria.fr</a>).

</P>
<P>
При переносе на новый вариант Unix без хорошей поддержки собственных
потоков наиболее трудной частью является перенос потоков MIT-pthreads. См.
<tt>`mit-pthreads/README'</tt>  и Programming POSIX Threads (Программирование 
POSIX-потоков) (<a HREF="http://www.humanfactor.com/pthreads/">http://www.humanfactor.com/pthreads/</a>).

</P>
<P>
В состав поставки MySQL входит исправленная версия Pthreads Провензано
(Provenzano) от MIT (см. веб-страницу MIT  Pthreads на
<a HREF="http://www.mit.edu:8001/people/proven/pthreads.html">http://www.mit.edu:8001/people/proven/pthreads.html</a>). Эту версию можно
применять для операционных систем, не имеющих POSIX-потоков.

</P>
<P>
Можно использовать и другой пакет потоков пользовательского уровня - FSU
Pthreads (<a HREF="http://www.informatik.hu-berlin.de/~mueller/pthreads.html">
страница FSU Pthreads</a>). Эта реализация применяется для переноса SCO.

</P>
<P>
Для ознакомления этими проблемами и анализа их следует изучить программы
<tt>`thr_lock.c'</tt> и <tt>`thr_alarm.c'</tt> в каталоге <tt>`mysys'</tt>.

</P>
<P>
И сервер, и клиент нуждаются в работающем компиляторе C++ (мы используем
<code>gcc</code>, испытывали также SPARCworks). Еще одним работающим компилятором
является Irix  <code>cc</code>.

</P>
<P>
Для компиляции только клиентской части используйте 
<code>./configure --without-server</code>.

</P>
<P>
Компиляция отдельно серверной части в настоящее время не поддерживается, и
добавлять такую возможность не планируется до тех пор, пока для этого не
будет веских оснований.

</P>
<P>
Если необходимо изменить любой <tt>`Makefile'</tt> или скрипт конфигурации, следует
использовать <code>Automake</code> и <code>Autoconf</code>. Мы применяли версии <code>automake-1.2</code> и
<code>autoconf-2.12</code>.

</P>
<P>
Ниже перечислены действия, необходимые для того, чтобы собрать все заново
из базовых файлов:

</P>

<pre>
/bin/rm */.deps/*.P
/bin/rm -f config.cache
aclocal
autoheader
aclocal
automake
autoconf
./configure --with-debug=full --prefix='your installation directory'

# makefiles были сгенерированы для GNU make 3.75 или более новой,
# обозначенной как gmake строчкой ниже

gmake clean all install init-db
</pre>

<P>
Если вы столкнетесь с проблемами новой версии переноса, то, возможно,
потребуется произвести некоторую отладку MySQL! See section <A HREF="manual.ru_Porting.html#Debugging_server">E.1  Отладка сервера MySQL</A>.

</P>
<P>
<strong>Примечание:</strong> прежде чем запускать отладку <code>mysqld</code>, нужно добиться, чтобы
заработала тестовая программа <tt>`mysys/thr_alarm'</tt>  and  <tt>`mysys/thr_lock'</tt>, -
тогда у вас появится хотя бы призрачный шанс получить рабочие потоки.

</P>



<H2><A NAME="Debugging_server" HREF="manual.ru_toc.html#Debugging_server">E.1  Отладка сервера MySQL</A></H2>

<P>
Если вы используете в MySQL совершенно новую функциональную возможность,
то можно попробовать запустить <code>mysqld</code> с параметром <code>--skip-new</code> (при этом
все новые, потенциально ненадежные функции будут заблокированы) или с
параметром <code>--safe-mode</code> - он отключает ряд оптимизаций, которые могут
вызвать проблемы. See section <A HREF="manual.ru_Problems.html#Crashing">A.4.1  Что делать, если работа MySQL сопровождается постоянными сбоями</A>.

</P>
<P>
Если <code>mysqld</code> не хочет стартовать, то необходимо посмотреть, не влияют ли на
ваши настройки какие-либо конфигурационные файлы! Вы можете проверить
аргументы файла <tt>`my.cnf'</tt> с помощью <code>mysqld --print-defaults</code> и, чтобы
запретить их использование, стартовать <code>mysqld</code>  с параметром <code>--no-defaults ....</code>

</P>
<P>
Если для запуска <code>mysqld</code> требуется большое количество ресурсов центрального
процессора или памяти, а также в случае зависания программы можно
использовать команду <code>mysqladmin processlist status</code>. Эта команда позволит
определить, какой именно запрос требует столь длительного времени
выполнения. При изучении проблем, связанных с производительностью или
трудностями при подсоединении новых клиентов, иногда полезно запустить
команду <code>mysqladmin -i10 processlist status</code> в другом окне.

</P>
<P>
Команда <code>mysqladmin debug</code> выводит в журнальный файл информацию о
применяемых блокировках, используемой памяти и работе с запросами запросов
- возможно, это поможет вам решить некоторые проблемы. Данная команда
снабдит вас полезной информацией даже в том случае, если код MySQL не был
скомпилирован для отладки!

</P>
<P>
Если проблема заключается в том, что некоторые таблицы справляются с
работой все медленнее и медленнее, то такие таблицы необходимо попробовать
оптимизировать с помощью команды <code>OPTIMIZE TABLE</code> или <code>myisamchk</code>. 
See section <A HREF="manual.ru_MySQL_Database_Administration.html#MySQL_Database_Administration">4  Администрирование баз данных</A>. Для проверки медленных запросов можно также
использовать <code>EXPLAIN</code>.

</P>
<P>
Кроме того, чтобы решить уникальные для конкретных условий эксплуатации
проблемы, необходимо изучить раздел данного руководства, в котором
описывается специфика определенной операционной системы. 
See section <A HREF="manual.ru_Installing.html#Operating_System_Specific_Notes">2.6  Заметки по операционным системам</A>.

</P>



<H3><A NAME="Compiling_for_debugging" HREF="manual.ru_toc.html#Compiling_for_debugging">E.1.1  Компиляция MySQL для отладки</A></H3>

<P>
Иногда в случае каких-либо очень специфических проблем помогает отладка
MySQL. Для этого необходимо сконфигурировать сборку MySQL с параметрами
<code>--with-debug</code> или <code>--with-debug=full</code>. Чтобы проверить, был ли код MySQL
скомпилирован с возможностью отладки, нужно запустить команду: <code>mysqld
--help</code>. Если среди опций присутствует флаг <code>--debug</code>, то отладка доступна.
Кроме того, если задана возможность отладки, команда <code>mysqladmin ver</code>
выводит версию <code>mysqld</code> как <code>mysql ... --debug</code>.

</P>
<P>
При использовании компиляторов gcc или egcs рекомендуется следующая
конфигурационная строка:

</P>

<pre>
CC=gcc CFLAGS="-O2" CXX=gcc CXXFLAGS="-O2 -felide-constructors \
   -fno-exceptions -fno-rtti" ./configure --prefix=/usr/local/mysql \
   --with-debug --with-extra-charsets=complex
</pre>

<P>
Такая запись позволит избежать проблем с библиотекой <code>libstdc++</code> и
исключениями C++ (многие компиляторы имеют проблемы с исключениями C++ в
кодах потоков) и скомпилировать версию MySQL с поддержкой всех кодировок.

</P>
<P>
Если есть подозрение, что может возникнуть ошибка переполнения памяти, то
можно сконфигурировать MySQL с параметром <code>--with-debug=full</code>, чтобы
установить программу контроля выделения памяти (<code>SAFEMALLOC</code>). Однако
<code>SAFEMALLOC</code> замедляет работу системы, поэтому при возникновении проблем с
производительностью необходимо запустить <code>mysqld</code> с опцией
<code>--skip-safemalloc</code>. Эта опция заблокирует проверки переполнения памяти для
каждого вызова <code>malloc</code> и <code>free</code>.

</P>
<P>
Если <code>mysqld</code> перестает падать в аварийном режиме при компиляции ее с
параметром <code>--with-debug</code>, то, возможно, вы нашли ошибку в компиляторе или
произошла ошибка синхронизации внутри MySQL. В этом случае можно
попытаться добавить к переменным <code>CFLAGS</code> и <code>CXXFLAGS</code> в приведенной выше
конфигурационной строке <code>-g</code> и не использовать параметр <code>--with-debug</code>. Если
<code>mysqld</code> и после этого будет падать, то можно по меньшей мере подключить к
ней отладчик <code>gdb</code> или использовать <code>gdb</code> для core-файла, чтобы выяснить, что
происходит.

</P>
<P>
Если MySQL сконфигурирован для отладки, то автоматически становятся
доступными множество дополнительных функций контроля надежности, которые
отслеживают состояние <code>mysqld</code>. Если они обнаруживают что-либо
"неожиданное", то информация об этом будет записана в поток вывода
<code>stderr</code>, который <code>safe_mysqld</code> направит в журнал ошибок! Таким образом, если
возникают какие-либо неожиданные проблемы с MySQL и при этом доступен
исходный код дистрибутива, то первое, что необходимо сделать, -
сконфигурировать MySQL для отладки! (А второе необходимое действие - это,
конечно, послать письмо на <a HREF="mailto:mysql@lists.mysql.com">mysql@lists.mysql.com</a> и попросить помощи).
Пожалуйста, для всех сообщений о сбоях или вопросов относительно
используемой версии MySQL используйте скрипт <code>mysqlbug</code>!

</P>
<P>
В поставке MySQL для Windows файл <code>mysqld.exe</code> по умолчанию скомпилирован с
поддержкой трассировочных файлов.

</P>


<H3><A NAME="Making_trace_files" HREF="manual.ru_toc.html#Making_trace_files">E.1.2  Создание трассировочных файлов</A></H3>

<P>
Если сервер <code>mysqld</code> не запускается или если вы можете вызвать его скорую
аварийную остановку, то для выяснения причин неполадок можно попытаться
создать трассировочный файл.

</P>
<P>
Для этого необходимо иметь <code>mysqld</code>, скомпилированный для отладки.
Проверить, скомпилирован ли <code>mysqld</code> для отладки можно, выполнив <code>mysqld -V</code>.
Если номер данной версии заканчивается на <code>-debug</code>, то она скомпилирована с
поддержкой трассировочных файлов.

</P>
<P>
Запустите сервер <code>mysqld</code> с журналом трассировки в каталоге
<tt>`/tmp/mysqld.trace'</tt> (или <tt>`C:\mysqld.trace'</tt> под Windows):

</P>

<pre>
mysqld --debug
</pre>

<P>
Под Windows необходимо также использовать флаг <code>--standalone</code>, чтобы <code>mysqld</code>
не стартовал как сервис:

</P>
<P>
В окне DOS введите следующее:

</P>

<pre>
mysqld --debug --standalone
</pre>

<P>
После этого можно использовать клиента командной строки <code>mysql.exe</code> во
втором окне DOS, чтобы воспроизвести проблему. Для остановки описанного
выше сервера <code>mysqld</code> следует воспользоваться командой <code>mysqladmin shutdown</code>.

</P>
<P>
Следует учесть, что трассировочный файл получится очень большим! Чтобы
получить трассировочный файл меньшего размера, можно использовать
что-нибудь вроде:

</P>

<pre>
mysqld --debug=d,info,error,query,general,where:O,/tmp/mysqld.trace
</pre>

<P>
при этом в каталог <tt>`/tmp/mysqld.trace'</tt> будет выводиться только информация
с наиболее интересными для вас признаками.

</P>
<P>
Если вы создаете отчет о подобных ошибках, то, пожалуйста, присылайте в
соответствующий список рассылки только те строки из трассировочного файла,
которые, по вашему мнению, имеют непосредственное отношение к ошибке! Те
же, кто затрудняются определить место ошибки, могут загрузить на ftp
трассировочный файл вместе с отчетом об ошибках по адресу
<a HREF="ftp://support.mysql.com/pub/mysql/secret/">ftp://support.mysql.com/pub/mysql/secret/</a>, чтобы разработчики MySQL могли
взглянуть на него.

</P>
<P>
Трассировочный файл создается с помощью пакета <code>DBUG</code>, автором которого
является Фред Фиш (Fred  Fish). See section <A HREF="manual.ru_Porting.html#The_DBUG_package">E.3  Пакет DBUG</A>.

</P>


<H3><A NAME="Using_gdb_on_mysqld" HREF="manual.ru_toc.html#Using_gdb_on_mysqld">E.1.3  Отладка mysqld при помощи gdb</A></H3>

<P>
В большинстве операционных систем можно запускать <code>mysqld</code> под отладчиком
<code>gdb</code> - это позволяет получить больше информации при аварийных остановках
<code>mysqld</code>,

</P>
<P>
С некоторыми более старыми версиями <code>gdb</code> под Linux, чтобы обеспечить
возможность отладки потоков <code>mysqld</code>, необходимо использовать run
<code>--one-thread</code>. В этом случае в каждый момент времени доступен для отладки
только один поток. Нам остается только рекомендовать вам как можно быстрее
заменить старые версии отладчика на версию <code>gdb</code> 5.1, поскольку отладка
потоков в этой версии работает намного лучше!

</P>
<P>
При работе <code>mysqld</code> под отладчиком <code>gdb</code> необходимо заблокировать трассировку
стеков при помощи <code>--skip-stack-trace</code>, что обеспечит возможность выявить
ошибки сегмантацию внутри <code>gdb</code>.

</P>
<P>
Если постоянно подсоединяются новые пользователи, то отладка MySQL под <code>gdb</code>
может оказаться достаточно сложным делом, поскольку <code>gdb</code> не освобождает
память, занимаемую старыми потоками. Эту проблему можно устранить,
запустив <code>mysqld</code> с параметрами <code>-O thread_cache_size='max_connections+1'</code>.
В большинстве случаев даже простое использование <code>-O thread_cache_size=5</code>
может очень помочь!

</P>
<P>
Для получения дампа оперативной памяти под Linux, если <code>mysqld</code> падает по
сигналу <code>SIGSEGV</code>, можно запустить <code>mysqld</code> с опцией <code>--core-file</code>. Этот файл
оперативной памяти (core) можно использовать для обратной трассировки при
выявлении причин останова <code>mysqld</code>:

</P>

<pre>
shell&#62; gdb mysqld core
gdb&#62; backtrace full
gdb&#62; exit
</pre>

<P>
See section <A HREF="manual.ru_Problems.html#Crashing">A.4.1  Что делать, если работа MySQL сопровождается постоянными сбоями</A>.

</P>
<P>
При использовании версии <code>gdb</code> 4.17.x или выше под Linux необходимо
установить в текущем каталоге файл <tt>`.gdb'</tt> со следующей информацией:

</P>

<pre>
set print sevenbit off
handle SIGUSR1 nostop noprint
handle SIGUSR2 nostop noprint
handle SIGWAITING nostop noprint
handle SIGLWP nostop noprint
handle SIGPIPE nostop
handle SIGALRM nostop
handle SIGHUP nostop
handle SIGTERM nostop noprint
</pre>

<P>
Если при отладке потоков с помощью <code>gdb</code> возникают проблемы, необходимо
загрузить версию <code>gdb</code> 5.x и попробовать использовать ее вместо прежней.
Новая версия отладчика <code>gdb</code> обеспечивает значительно улучшенную обработку
потоков!

</P>
<P>
Ниже приводится пример отладки mysqld:

</P>

<pre>
shell&#62; gdb /usr/local/libexec/mysqld
gdb&#62; run
...
backtrace full # Делайте это при аварийной остановке mysqld
</pre>

<P>
Включите полученный вывод в письмо, сгенерированное с помощью <code>mysqlbug</code>, и
пошлите это письмо по адресу <a HREF="mailto:mysql@lists.mysql.com">mysql@lists.mysql.com</a>.

</P>
<P>
Если <code>mysqld</code> зависает, можно попробовать использовать некоторые системные
средства наподобие <code>strace</code> или <code>/usr/proc/bin/pstack</code> для выяснения, где
именно произошло зависание <code>mysqld</code>.

</P>

<pre>
strace /tmp/log libexec/mysqld
</pre>

<P>
Если используется интерфейс Perl  <code>DBI</code>, то можно получить отладочную
информацию, используя метод <code>trace</code> или установив переменную окружения
<code>DBI_TRACE</code>. See section <A HREF="manual.ru_Clients.html#Perl_DBI_Class">8.2.2  Интерфейс <code>DBI</code></A>.

</P>


<H3><A NAME="Using_stack_trace" HREF="manual.ru_toc.html#Using_stack_trace">E.1.4  Использование трассировки стека</A></H3>

<P>
В некоторых операционных системах журнал ошибок в случае смерти <code>mysqld</code> 
будет содержать трассировку стека. Эти данные можно использовать для
выяснения, где (и, может быть, почему) умер <code>mysqld</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Error_log">4.9.1  Журнал ошибок</A>). Для получения трассировки стека не следует компилировать <code>mysqld</code> с
опцией <code>-fomit-frame-pointer</code> для <code>gcc</code> (see section <A HREF="manual.ru_Porting.html#Compiling_for_debugging">E.1.1  Компиляция MySQL для отладки</A>).

</P>
<P>
Если файл ошибок содержит что-нибудь похожее на следующее:

</P>

<pre>
mysqld got signal 11;
The manual section 'Debugging a MySQL server' tells you how to use a
stack trace and/or the core file to produce a readable backtrace that may
help in finding out why mysqld died
Attemping backtrace. You can use the following information to find out
where mysqld died.  If you see no messages after this, something went
terribly wrong
stack range sanity check, ok, backtrace follows
0x40077552
0x81281a0
0x8128f47
0x8127be0
0x8127995
0x8104947
0x80ff28f
0x810131b
0x80ee4bc
0x80c3c91
0x80c6b43
0x80c1fd9
0x80c1686
</pre>

<P>
то можно определить, где произошла остановка <code>mysqld</code>. Для этого нужно
выполнить следующие действия:

</P>

<ol>
<LI>

Скопируйте приведенные выше числовые значения в файл, например
<code>mysqld.stack</code>.

<LI>

Создайте файл символов для сервера <code>mysqld</code>:


<pre>
nm -n libexec/mysqld &#62; /tmp/mysqld.sym
</pre>

Следует учесть, что во многих бинарных поставках MySQL приведенный
выше файл с именем <tt>`mysqld.sym.gz'</tt>  уже имеется. В этом случае
необходимо распаковать его следующим образом:


<pre>
gunzip &#60; bin/mysqld.sym.gz &#62; /tmp/mysqld.sym
</pre>

<LI>

Выполните  <code>resolve_stack_dump -s /tmp/mysqld.sym -n mysqld.stack</code>,
чтобы  вывести  место  остановки  <code>mysqld</code>. Если и это не поможет
определить причину останова <code>mysqld</code>, то следует сделать отчет об ошибке
и включить в него данный вывод с комментарием. Следует учитывать,
однако, что в большинстве случаев наличие лишь только трассировки
стеков не поможет нам определить причину данной проблемы. Чтобы иметь
возможность локализовать данный сбой или рекомендовать обходной путь,
нам, как правило, необходимо знать, какой именно запрос привел к
остановке mysqld и, желательно, иметь контрольный пример, чтобы мы
могли воспроизвести данную проблему! See section <A HREF="manual.ru_Introduction.html#Bug_reports">1.8.1.3  Как отправлять отчеты об ошибках или проблемах</A>.
</ol>



<H3><A NAME="Using_log_files" HREF="manual.ru_toc.html#Using_log_files">E.1.5  Использование журналов для определения причин ошибок в mysqld</A></H3>

<P>
Обратите внимание: перед запуском <code>mysqld</code> с <code>--log</code> необходимо проверить все
используемые таблицы с помощью <code>myisamchk</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#MySQL_Database_Administration">4  Администрирование баз данных</A>).

</P>
<P>
Если демон <code>mysqld</code> умрет или зависнет, следует запустить <code>mysqld</code> с опцией
<code>--log</code>. Если аварийное завершение <code>mysqld</code> снова повторится, то можно
исследовать часть журнала, относящуюся к запросу, убившему <code>mysqld</code>.

</P>
<P>
При использовании опции <code>--log</code> без имени файла данный журнал хранится в
каталоге базе данных как <tt>``hostname`.log'</tt>. В большинстве случаев именно
последний запрос в системном журнале приводит к смерти <code>mysqld</code>, но при
возможности лучше в этом убедиться: перезапустите <code>mysqld</code> и выполните
найденный запрос из командной строки <code>mysql</code>. Если запрос выполняется, то
следует протестировать все сложные запросы, которые не завершились.

</P>
<P>
Можно также попробовать выполнить команду <code>EXPLAIN</code> для всех выражений
<code>SELECT</code>, которые занимают длительное время, чтобы убедиться, что <code>mysqld</code>
правильно использует индексы. See section <A HREF="manual.ru_MySQL_Optimisation.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A>.

</P>
<P>
Запросы, требующие слишком длительного времени для выполнения, можно
выявить, запустив <code>mysqld</code> с параметром <code>--log-slow-queries</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Slow_query_log">4.9.5  Журнал медленных запросов</A>.

</P>
<P>
Если в журнале ошибок (обычно он имеет имя <tt>``hostname`.err'</tt>) присутствует
запись "<code>mysqld restarted</code>", то у вас есть шанс найти запрос, вызывающий
смерть <code>mysqld</code>. В этом случае необходимо проверить все таблицы с помощью
команды <code>myisamchk</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#MySQL_Database_Administration">4  Администрирование баз данных</A>) и проанализировать
запросы в журналах MySQL, чтобы определить, какой из них не работает. Если
такой запрос найден, прежде всего необходимо попытаться сделать апгрейд
MySQL до новейшей версии. Если же это не помогает и нет ничего похожего в
архиве списка рассылки <code>mysql</code>, пришлите отчет о данном сбое по адресу
<a HREF="mailto:mysql@lists.mysql.com">mysql@lists.mysql.com</a>. Ссылки на архивы списка рассылки доступны по адресу
<a HREF="http://lists.mysql.com/">http://lists.mysql.com/</a>.

</P>
<P>
Если демон <code>mysqld</code> был запущен с параметром <code>myisam-recover</code>, то MySQL
автоматически проверяет и пытается восстановить таблицы MyISAM (если они
отмечены как "таблица не закрыта правильно" или "таблица повреждена").
В этом случае MySQL запишет в файл <tt>`hostname.err'</tt> предупреждение:
"<code>Warning: Checking table ...</code>", за которым следует "<code>Warning: Repairing
table</code>", если данную таблицу следует исправить. Если таких ошибок в
журнале много, а <code>mysqld</code> перед этим не умирал со сбоем, то что-то работает
неправильно и необходимы дальнейшие исследования. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>.

</P>
<P>
Конечно, неожиданная смерть <code>mysqld</code> - событие малоприятное, но в этом
случае следует не изучать сообщения "<code>Checking table...</code>", а попытаться
найти причины остановки <code>mysqld</code>.

</P>


<H3><A NAME="Reproduceable_test_case" HREF="manual.ru_toc.html#Reproduceable_test_case">E.1.6  Создание контрольного примера при повреждении таблиц</A></H3>

<P>
Когда таблицы оказываются поврежденными или <code>mysqld</code> всегда дает сбой после
некоторых команд, то можно провести испытания (если данный сбой
воспроизводим). Для этого нужно выполнить следующие действия:

</P>

<ul>
<LI>

Остановите демон MySQL (с помощью команды <code>mysqladmin shutdown</code>).

<LI>

Сделайте резервную копию таблиц (в качестве меры предосторожности на
случай, если процесс исправления таблиц пройдет некорректно, хотя это
и маловероятно).

<LI>

Проверьте все таблицы с помощью команды <code>myisamchk -s database/*.MYI</code>.
Исправьте некорректные таблицы с помощью команды 
<code>myisamchk -r database/table.MYI</code>.

<LI>

Создайте еще раз резервные копии этих таблиц.

<LI>

Переместите (или удалите совсем) все старые журнальные файлы из
каталога данных MySQL, если нужно освободить больше места.

<LI>

Запустите <code>mysqld</code> с <code>--log-bin</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Binary_log">4.9.4  Бинарный журнал обновлений</A>).
Если вы хотите найти запрос, который приводит к сбою <code>mysqld</code>, то
следует использовать <code>--log --log-bin</code>.

<LI>

Когда таблица с искажениями будет получена, остановите сервер <code>mysqld</code>.

<LI>

Восстановите систему из резервной копии.

<LI>

Перезапустите сервер <code>mysqld</code>  без  <code>--log-bin</code>.

<LI>

Выполните заново команды <code>mysqlbinlog update-log-file | mysql</code>.
Обновленная запись в журнале сохраняется в каталоге баз данных MySQL с
именем <tt>`hostname-bin.#'</tt>.

<LI>

Если в результате вышеприведенной команды таблицы опять окажутся
поврежденными или вы можете получить сбой в работе <code>mysqld</code>, то, значит,
вы нашли повторяющуюся ошибку, которую можно исправить! Загрузите 
эти таблицы и запись из двоичного журнала по адресу
<a HREF="ftp://support.mysql.com/pub/mysql/secret/">ftp://support.mysql.com/pub/mysql/secret/</a> и пошлите письмо с описанием
данной проблемы на <code>bugs@lists.mysql.com</code> или (если вы являетесь
коммерческим пользователем) на <code>support@mysql.com</code> - и команда
разработчиков MySQL устранит ошибку настолько быстро, насколько это
возможно.
</ul>

<P>
Для локализации проблемы можно также использовать скрипт <code>mysql_find_rows</code>,
чтобы просто выполнить ряд обновляющих команд.

</P>


<H2><A NAME="Debugging_client" HREF="manual.ru_toc.html#Debugging_client">E.2  Отладка клиента MySQL</A></H2>

<P>
Чтобы иметь возможность отладки клиента MySQL с помощью встроенного
отладчика, необходимо сконфигурировать сборку MySQL с <code>--with-debug</code> или
<code>--with-debug=full</code>. See section <A HREF="manual.ru_Installing.html#configure_options">2.3.3  Типичные опции <code>configure</code></A>.

</P>
<P>
Перед запуском клиента следует установить переменную окружения <code>MYSQL_DEBUG</code>:

</P>


<pre>
shell&#62; MYSQL_DEBUG=d:t:O,/tmp/client.trace
shell&#62; export MYSQL_DEBUG
</pre>

<P>
Это заставит клиента генерировать трассировочный файл в
<tt>`/tmp/client.trace'</tt>.

</P>
<P>
Если существуют проблемы с кодом конкретного клиента, необходимо
попытаться соединиться с сервером и послать запрос, используя другой
заведомо работоспособный клиент. Это следует делать при работе <code>mysql</code> в
режиме отладки (предполагается, что данный экземпляр MySQL скомпилирован с
возможностью отладки):

</P>

<pre>
shell&#62; mysql --debug=d:t:O,/tmp/client.trace
</pre>

<P>
приведенный выше вызов снабдит вас полезной информацией для отчета об
ошибках. See section <A HREF="manual.ru_Introduction.html#Bug_reports">1.8.1.3  Как отправлять отчеты об ошибках или проблемах</A>.

</P>
<P>
Если ваш клиент, имея "правильный" на первый взгляд код, отказывается
устойчиво работать, необходимо проверить, соответствует ли включаемый файл
<tt>`mysql.h'</tt> файлу вашей библиотеки <code>mysql</code>. Очень распространенная ошибка
заключается в том, что используется старый файл <tt>`mysql.h'</tt> из MySQL старой
установки с новой библиотекой MySQL.

</P>



<H2><A NAME="The_DBUG_package" HREF="manual.ru_toc.html#The_DBUG_package">E.3  Пакет DBUG</A></H2>

<P>
Сервер MySQL и большинство клиентов MySQL компилируются с пакетом <code>DBUG</code>,
автором первой версии которого является Фред Фиш (Fred  Fish). При
конфигурации MySQL в отладочном режиме этот пакет дает возможность
получить трассировочный файл для отладки программы. See section <A HREF="manual.ru_Porting.html#Making_trace_files">E.1.2  Создание трассировочных файлов</A>.

</P>
<P>
Чтобы воспользоваться пакетом отладки, следует в вызове программы задать
опцию <code>--debug="..."</code> или <code>-#...</code>

</P>
<P>
Большинство программ MySQL по умолчанию имеют отладочную строку, которая будет 
использована, если не задана опция <code>--debug</code>. По умолчанию
трассировочный файл обычно находится в <tt>`/tmp/имя_программы.trace'</tt> под Unix и
в <tt>`\имя_программы.trace'</tt> под Windows.

</P>
<P>
Строка управления отладкой представляет собой последовательность
разделенных двоеточиями полей, как в следующем примере:

</P>

<pre>
&#60;field_1&#62;:&#60;field_2&#62;:...:&#60;field_N&#62;
</pre>

<P>
Каждое поле состоит из обязательного флагового символа, за которым следует
необязательный символ "," и разделенный запятыми список модификаторов:

</P>

<pre>
flag[,modifier,modifier,...,modifier]
</pre>

<P>
В настоящее время распознаются следующие символы флагов:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Флаг</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>d </TD><TD> Разрешает вывод из макроса <code>DBUG_&#60;N&#62;</code> для текущего состояния. За этим
флагом может следовать список ключевых слов. Если задан такой список, то
из вывода макроса <code>DBUG</code> будет выбираться вывод только с данными ключевыми
словами. Если задан пустой список ключевых слов, выбирается вывод всего
макроса.

</TD></TR>
<TR><TD>D </TD><TD> Задает задержку вывода после каждой строки отладчика. Аргумент
представляет собой количество десятых долей секунд задержки в
соответствии с возможностями машины. Т.е. <code>D,20</code> означает задержку в две
секунды.

</TD></TR>
<TR><TD>f </TD><TD> Ограничивает отладку и/или трассировку и профайлинг только перечисленными
в списке функциями. Обратите внимание: если задан нулевой список, то
будут заблокированы все функции. Соответствующие флаги "<code>d</code>" или "<code>t</code>" должны
также задаваться, данный флаг только ограничивает их действия, если они
разрешены.

</TD></TR>
<TR><TD>F </TD><TD> Идентифицирует имя исходного файла для каждой строки вывода отладки или
трассировки.

</TD></TR>
<TR><TD>i </TD><TD> Идентифицирует процесс указанием <code>pid</code> или идентификатором потока (<code>thread
id</code>) в каждой строке вывода отладки или трассировки.

</TD></TR>
<TR><TD>g </TD><TD> Разрешает профайлинг. Создает файл с именем <tt>`dbugmon.out'</tt>, содержащий
информацию, которую можно использовать для профайлинга программы. За этим
флагом может следовать список ключевых слов; если такой список задан, то
профайлинг будет применяться только для функций из этого списка. Если
задан нулевой список ключевых слов, то профайлинг применяется ко всем
функциям.

</TD></TR>
<TR><TD>L </TD><TD> Идентифицирует номер строки исходного файла для каждой строки вывода
отладки или трассировки.

</TD></TR>
<TR><TD>n </TD><TD> Задает вывод глубины вложенности текущей функции для каждой строки вывода
отладки или трассировки.

</TD></TR>
<TR><TD>N </TD><TD> Задает нумерацию каждой строки в выводе <code>dbug</code>.

</TD></TR>
<TR><TD>o </TD><TD> Переадресует выходной поток отладчика в указанный файл. По умолчанию
вывод осуществляется в stderr.

</TD></TR>
<TR><TD>O </TD><TD> То же, что и <code>o</code>, но указанный файл сбрасывается на диск каждый раз между
операциями записи. При необходимости этот файл закрывается и снова
открывается каждый раз между операциями записи.

</TD></TR>
<TR><TD>p </TD><TD> Ограничивает действия отладчика указанным процессом. Процесс должен быть
идентифицирован макросом <code>DBUG_PROCESS</code> и совпадать с указанным в списке
для действий отладчика.

</TD></TR>
<TR><TD>P </TD><TD> Выводит имя текущего процесса для каждой строки вывода отладки или
трассировки.

</TD></TR>
<TR><TD>r </TD><TD> Не наследовать уровень вложенности функции в предыдущем состоянии при
переходе в новое состояние. Полезно, если вывод должен начинаться с
левого поля.

</TD></TR>
<TR><TD>S </TD><TD> Выполнять функцию <code>_sanity(_file_,_line_)</code> для каждой отлаженной функции,
пока <code>_sanity()</code> не возвратит значение, отличное от <code>0</code>. (Главным
образом используется совместно с <code>safemalloc</code> для определения утечек
памяти).

</TD></TR>
<TR><TD>t </TD><TD> Разрешает трассировку вызовов функций/выход из функций. За этим
параметром может следовать список (содержащий только один модификатор).
Данный модификатор задает число - максимальный уровень вложения функций,
ниже которого не производится вывод ни для отладочного, ни для
трассировочного макросов. Параметр по умолчанию задается во время
компиляции.
</TD></TR>
</TABLE>

<P>
Ниже представлены некоторые примеры строк управления отладкой, которые
можно применять в командной строке оболочки (символ "<code>-#</code>" обычно
используется для внедрения управляющей строки в программу):

</P>

<pre>
-#d:t
-#d:f,main,subr1:F:L:t,20
-#d,input,output,files:n
-#d:t:i:O,\\mysqld.trace
</pre>

<P>
В MySQL обычно применяются следующие дескрипторы для вывода (совместно с
опцией <code>d</code>): <code>enter,exit,error,warning,info</code> и <code>loop</code>.

</P>


<H2><A NAME="Locking_methods" HREF="manual.ru_toc.html#Locking_methods">E.4  Методы блокировки</A></H2>

<P>
В настоящее время MySQL поддерживает только табличную блокировку для
таблиц типов ISAM/MyISAM и HEAP, страничную блокировку для таблиц BDB и
строковую блокировку для таблиц InnoDB (see section <A HREF="manual.ru_MySQL_Optimisation.html#Internal_locking">5.3.1  Как MySQL блокирует таблицы</A>). Для таблиц MyISAM можно произвольным образом сочетать команды
<code>INSERT</code> и <code>SELECT</code> без блокировок, поскольку поддерживается управление
версиями (Versioning).

</P>
<P>
Начиная с версии 3.23.33 имеется возможность анализировать конфликты и
конкуренцию блокировок таблиц в системе. Это делается путем проверки
переменных <code>Table_locks_waited</code> и <code>Table_locks_immediate</code>.

</P>
<P>
Если вы хотите использовать тип таблиц с блокировкой уровня записи, то
прежде, чем принимать такое решение, следует посмотреть, что делает данное
приложение и какая принята модель выборки/обновления данных.

</P>
<P>
Аргументы в пользу строковой блокировки:

</P>

<ul>
<LI>

Меньше конфликтов блокировок при обращении к различным строкам из
множества потоков.

<LI>

Меньше изменений при откатах.

<LI>

Возможна блокировка одной строки на длительное время.
</ul>

<P>
Аргументы против строковой блокировки

</P>

<ul>
<LI>

Требуется больше памяти, чем при страничной или табличной блокировке.

<LI>

При использовании большой части таблицы строковая блокировка работает
медленнее в сравнении с блокировкой на уровне страниц или таблиц,
поскольку требуется производить намного больше блокировок.

<LI>

Определенно хуже других блокировок, если часто выполняется операция
<code>GROUP BY</code> на значительной части данных или если приходится сканировать
всю таблицу.

<LI>

Для блокировок более высокого уровня также проще осуществить поддержку
различных типов блокировок для настройки приложения, поскольку для них
затраты на блокировку менее заметны, чем для строкового уровня
блокировки.
</ul>

<P>
Блокировки на уровне таблиц лучше, чем блокировки страничного/строкового
уровня в следующих случаях:

</P>

<ul>
<LI>

Когда производится главным образом чтение.

<LI>

При чтении и обновлении для строго заданных ключей; при обновлении или
удалении строки, которая может быть извлечена чтением одного ключа:


<pre>
UPDATE table_name SET column=value WHERE unique_key#
DELETE FROM table_name WHERE unique_key=#
</pre>

<LI>

<code>SELECT</code> с <code>INSERT</code> (и очень мало операций
<code>UPDATE</code> и <code>DELETE</code>).

<LI>

Выполняется много операций просмотра и группировки <code>GROUP BY</code> на всей
таблице без записи.
</ul>

<P>
Другие возможности, кроме строчного/страничного уровня блокирования:

</P>
<P>
Управление версиями (Versioning), подобно тому, как это делается в MySQL
для параллельных вставок. При этом один из пользователей может выполнять
операцию записи в то же время, когда несколько пользователей производят
чтение. Это означает, что данная база данных/таблица поддерживает
различные представления для данных в зависимости от того, когда произошло
обращение к ним. Существуют и другие названия этой возможности -
перемещение по времени (time  travel), метод копирования в момент записи
(copy  on  write) или метод копирования по запросу (copy  on  demand).

</P>
<P>
Копирование по запросу во многих случаях значительно лучше, чем страничный
или строковый уровень блокировки; однако в наиболее неблагоприятном
варианте этот метод требует намного больше памяти, чем при использовании
обычных блокировок.

</P>
<P>
Вместо использования блокировок строкового уровня можно применять
блокировки уровня приложения (подобно get_lock/release_lock в MySQL).
Конечно, такие блокировки годятся только для корректно работающих
приложений.

</P>
<P>
Если речь идет о конкретном приложении, то обычно можно с уверенностью
сказать, какой тип блокировки лучше всего в нем использовать, однако для
общего случая такой вывод сделать практически невозможно: все зависит от
конкретного приложения, причем для различных частей приложения могут
требоваться различные типы блокировок.

</P>
<P>
Ниже приводится несколько советов по блокировкам в MySQL:

</P>
<P>
Большинство веб-приложений выполняют большое количество
выборок, очень мало удалений, обновления главным образом по ключам и
вставки в некоторые специальные таблицы. Базовая установка MySQL очень
хорошо настроена для этого.

</P>
<P>
Одновременный доступ пользователей не представляет проблем, если не
происходит смешивания обновлений и выборок, требующих проверки нескольких
строк в одной и той же таблице.

</P>
<P>
В случае сочетания вставок и удалений в одной и той же таблице очень
полезно применять <code>INSERT DELAYED</code>.

</P>
<P>
Для повышения скорости можно также использовать <code>LOCK TABLES</code> (несколько
обновлений в рамках одной блокировки выполняются намного быстрее, чем
обновления без блокировок). Целесообразно также распределять данные по
различным таблицам.

</P>
<P>
Иногда проблемы со скоростью при блокировках таблиц в MySQL удается решить
преобразованием ряда таблиц в таблицы типа InnoDB или BDB. 
See section <A HREF="manual.ru_Table_types.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A>. See section <A HREF="manual.ru_Table_types.html#BDB">7.6  Таблицы <code>BDB</code> или BerkeleyDB</A>.

</P>
<P>
Большое количество различных аспектов настройки приложения рассмотрено в
разделе данного руководства, посвященном оптимизации (see section <A HREF="manual.ru_MySQL_Optimisation.html#Tips">5.2.12  Другие советы по оптимизации</A>).

</P>


<H2><A NAME="RTS-threads" HREF="manual.ru_toc.html#RTS-threads">E.5  Замечания по потокам RTS</A></H2>

<P>
При попытке применить пакеты потоков RTS с MySQL автору пришлось
столкнуться со следующими проблемами:

</P>
<P>
В этих пакетах используются старые версии большинства вызовов POSIX,
поэтому очень утомительно создавать оболочки (wrapper) для всех функций.
На мой взгляд, было бы легче изменить библиотеки этих потоков в
соответствии с современной спецификацией POSIX.

</P>
<P>
Некоторые оболочки уже написаны (чтобы получить более подробную
информацию, обращайтесь к <tt>`mysys/my_pthread.c'</tt>).

</P>
<P>
Следует изменить, по меньшей мере, следующие аспекты:

</P>
<P>
В  <code>pthread_get_specific</code> должен использоваться один аргумент, а в <code>sigwait</code> -
два аргумента. Многие функции (по крайней мере, <code>pthread_cond_wait</code>,
<code>pthread_cond_timedwait</code>) должны возвращать код ошибки или ошибку. Сейчас
они возвращают <code>-1</code> и устанавливают <code>errno</code>.

</P>
<P>
Еще одна проблема заключается в том, что потоки пользовательского уровня
используют сигнал <code>ALRM</code>, преждевременно прекращающий работу многих функций
(<code>read, write, open...</code>). MySQL должен повторять попытку выполнить такие
вызовы в случае прерывания, но это не так легко проверить.

</P>
<P>
Наиболее значительная из нерешенных проблем заключается в следующем:

</P>
<P>
Чтобы получать alarm на уровне потока, я изменил <code>mysys/thr_alarm.c</code> -
чтобы ожидать alarm с помощью функции <code>pthread_cond_timedwait()</code>. Однако
оказалось, что это приводит к преждевременному прекращению работы с
ошибкой <code>EINTR</code>. Чтобы понять, почему так получается, я пытался отладить
библиотеку потока, но не смог найти никакого простого решения.

</P>
<P>
Для тех, кто хочет попробовать использовать MySQL с потоками RTS, я
предлагаю следующее:

</P>

<ul>
<LI>

Измените функции, используемые MySQL из библиотеки потоков для POSIX.
Это не должно занять много времени.

<LI>

Скомпилируйте все библиотеки с <code>-DHAVE_rts_threads</code>.

<LI>

Скомпилируйте <code>thr_alarm</code>.

<LI>

Если существуют некоторые небольшие отличия в реализации, то они могут
быть устранены изменением <tt>`my_pthread.h'</tt> и <tt>`my_pthread.c'</tt>.

<LI>

Запустите <code>thr_alarm</code>. Если программа выполняется без каких-либо
предупреждений, сообщений об ошибках или об аварийном выходе, значит,
вы на правильном пути. Ниже приводится успешный прогон программы под
Solaris:


<pre>
Main thread: 1
Thread 0 (5) started
Thread: 5  Waiting
process_alarm
Thread 1 (6) started
Thread: 6  Waiting
process_alarm
process_alarm
thread_alarm
Thread: 6  Slept for 1 (1) sec
Thread: 6  Waiting
process_alarm
process_alarm
thread_alarm
Thread: 6  Slept for 2 (2) sec
Thread: 6  Simulation of no alarm needed
Thread: 6  Slept for 0 (3) sec
Thread: 6  Waiting
process_alarm
process_alarm
thread_alarm
Thread: 6  Slept for 4 (4) sec
Thread: 6  Waiting
process_alarm
thread_alarm
Thread: 5  Slept for 10 (10) sec
Thread: 5  Waiting
process_alarm
process_alarm
thread_alarm
Thread: 6  Slept for 5 (5) sec
Thread: 6  Waiting
process_alarm
process_alarm

...
thread_alarm
Thread: 5  Slept for 0 (1) sec
end
</pre>

</ul>



<H2><A NAME="Thread_packages" HREF="manual.ru_toc.html#Thread_packages">E.6  Различия между разными потоковыми пакетами</A></H2>

<P>
Работа MySQL в значительной степени зависит от используемого потокового
пакета. Таким образом, при выборе хорошей платформы для MySQL потоковый
пакет играет очень важную роль.

</P>
<P>
Существуют по меньшей мере три типа потоковых пакетов:

</P>

<ul>
<LI>

Пользовательские потоки в одном процессе. Переключение потоков
осуществляется сигналами (alarm) и библиотека потоков управляет всеми
функциями, не поддерживающими потоки, с помощью блокировок. Операции
чтения, записи и выборки обычно управляются программой выбора потоков,
которая переключает их на другой поток, если текущий должен ожидать
данные (речь идет о вызове select). Пакеты пользовательских потоков
могут быть интегрированы в стандартные библиотеки (FreeBSD- и
BSDI-потоки). Такие интегрированные пакеты требуют меньше затрат в
сравнении с потоковыми пакетами, которые должны обрабатывать все
ненадежные вызовы (MIT-pthreads, FSU  Pthreads и потоки RTS). В
некоторых средах (например SCO) все системные вызовы поддерживают
потоки, так что обработка может быть выполнена очень просто (FSU 
Pthreads под SCO). Недостатки такого метода: поскольку все вызовы, для
которых установлены соответствия, занимают мало времени, очень сложно
контролировать обработку всех ситуаций. Обычно существуют также
системные вызовы, не обрабатываемые потоковым пакетом (такие как
MIT-pthreads и сокеты). Диспетчеризация потоков не всегда является
оптимальной.

<LI>

Пользовательские потоки в раздельных процессах. Переключение потоков
производится ядром и все данные используются совместно всеми потоками.
Потоковый пакет управляет стандартными вызовами потоков, чтобы
обеспечить совместное использование данных этими потоками. Такой метод
используется в LinuxThreads. Недостатки этого метода: масса процессов;
медленное создание потока. Если один поток умирает, то остальные
обычно зависают и необходимо их уничтожать перед перезапуском.
Переключение потоков отчасти затратно.

<LI>

Потоки ядра. Переключение потоков управляется потоковой библиотекой
или ядром и происходит очень быстро. Все делается в одном процессе, но
для некоторых систем <code>ps</code> может показывать разные потоки. Если один из
потоков неожиданно умрет, то происходит аварийное прерывание всего
процесса. Большинство системных вызовов поддерживают потоки и должны
требовать очень небольших затрат. С потоками ядра работают Solaris,
HP-UX, AIX и OSF/1.
</ul>

<P>
В некоторых системах управление потоками ядра осуществляется путем
интеграции потоков пользовательского уровня в системные библиотеки. В
подобных случаях переключение потоков может осуществляться только данной
потоковой библиотекой, и ядро фактически "не в курсе событий".
<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_News.html">previous</A>, <A HREF="manual.ru_Environment_variables.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
