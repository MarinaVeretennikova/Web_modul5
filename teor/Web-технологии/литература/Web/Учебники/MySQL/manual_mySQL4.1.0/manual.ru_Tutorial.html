  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - 3  Учебное пособие по MySQL</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Installing.html">previous</A>, <A HREF="manual.ru_MySQL_Database_Administration.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Tutorial" HREF="manual.ru_toc.html#Tutorial">3  Учебное пособие по MySQL</A></H1>

<P>
<A NAME="IDX361"></A>
<A NAME="IDX362"></A>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>

</P>

<P>
Эта глава представляет собой обучающий курс по MySQL: в ней
демонстрируется использование клиентской программы <code>mysql</code> для создания
несложной базы данных и работы с ней. Утилита <code>mysql</code> (иногда называемая
также ``терминальным монитором'' или просто ``монитором'') представляет
собой интерактивную программу, позволяющую подсоединяться к MySQL-серверу,
запускать запросы, и просматривать результаты. Программа <code>mysql</code> может
работать и в пакетном режиме: для этого необходимо записать все запросы в
файл, а затем передать его содержимое на исполнение <code>mysql</code>. Ниже описаны
оба способа использования <code>mysql</code>.

</P>
<P>
Увидеть список команд программы <code>mysql</code> можно, запустив ее с параметром
<code>--help</code>:

</P>

<pre>
shell&#62; mysql --help
</pre>

<P>
Текст главы построен с расчетом на то, что на вашем компьютере установлен
<code>mysql</code> и существует связь с сервером MySQL. Если это не так, свяжитесь со
своим администратором MySQL (если вы и есть администратор, обратитесь к
другим разделам настоящего руководства).

</P>
<P>
В этой главе дано подробное описание всего процесса установки и
использования базы данных. Если вы хотите лишь работать с ранее созданной
базой, можете пропустить разделы, посвященные созданию базы и содержащихся
в ней таблиц.

</P>
<P>
Так как эта глава задумывалась как учебное пособие, многие детали пришлось
опустить. Дополнительную информацию о раскрытых в этой главе темах можно
почерпнуть из соответствующих разделов руководства.

</P>



<H2><A NAME="Connecting-disconnecting" HREF="manual.ru_toc.html#Connecting-disconnecting">3.1  Подсоединение к серверу и отсоединение от него</A></H2>

<P>
<A NAME="IDX365"></A>
<A NAME="IDX366"></A>
<A NAME="IDX367"></A>
<A NAME="IDX368"></A>

</P>
<P>
При подключении к серверу с помощью <code>mysql</code> обычно нужно ввести имя
пользователя MySQL и, в большинстве случаев, пароль. Если сервер запущен
не на том компьютере, с которого вы вошли в систему, необходимо также
указать имя хоста. Параметры соединения (а именно - соответствующее имя
хоста, пользователя и пароль) вы сможете узнать у администратора. Получив
соответствующие параметры, подсоединиться к серверу можно следующим
образом:

</P>

<pre>
shell&#62; mysql -h host -u user -p
Enter password: ********
</pre>

<P>
Символы ******** обозначают ваш пароль; введите его, когда <code>mysql</code> выведет
на экран запрос <code>Enter password:</code>.

</P>
<P>
Если все сработает, на экране должна появиться следующая информация и
метка командной строки <code>mysql&#62;</code>:

</P>

<pre>
shell&#62; mysql -h host -u user -p
Enter password: ********

Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 459 to server version: 3.22.20a-log

Type 'help' for help.

mysql&#62;
</pre>

<P>
Метка обозначает, что программа <code>mysql</code> готова к вводу команд.

</P>
<P>
В некоторых вариантах установки MySQL возможно подсоединение к запущенному
на локальном хосте серверу без ввода имени пользователя (пользователь
anonymous). Если ваша система настроена именно так, подсоединиться к
серверу вы сможете, запустив <code>mysql</code> со следующими параметрами:

</P>

<pre>
shell&#62; mysql
</pre>

<P>
После установки соединения можно в любой момент отключиться от сервера,
набрав в командной строке <code>mysql&#62;</code> команду <code>QUIT</code>:

</P>

<pre>
mysql&#62; QUIT
Bye
</pre>

<P>
Отсоединиться от сервера можно и при помощи сочетания клавиш Control-D.

</P>
<P>
Большая часть приведенных ниже примеров построена с учетом того, что
соединение с сервером уже установлено. Это видно по наличию в них
командной строки <code>mysql&#62;</code>.

</P>



<H2><A NAME="Entering_queries" HREF="manual.ru_toc.html#Entering_queries">3.2  Ввод запросов</A></H2>

<P>
<A NAME="IDX369"></A>
<A NAME="IDX370"></A>
<A NAME="IDX371"></A>

</P>
<P>
Подсоединитесь к серверу, как было описано выше. Таким образом  никакая
база выбрана не будет, но это не страшно. На данном этапе нам гораздо
важней разобраться с созданием запросов, нежели сразу усложнять себе жизнь
созданием таблиц, загрузкой в них данных и извлечением их оттуда. В этом
разделе разъясняются основные принципы ввода команд; на примере нескольких
запросов вы можете поближе познакомиться с работой <code>mysql</code>.

</P>
<P>
Ниже приведена простая команда, запрашивающая у сервера информацию об его
версии и текущей дате. Введите ее в командной строке <code>mysql&#62;</code> и нажмите
Enter:

</P>

<pre>
mysql&#62; SELECT VERSION(), CURRENT_DATE;

+--------------+--------------+
| VERSION()    | CURRENT_DATE |
+--------------+--------------+
| 3.22.20a-log | 1999-03-19   |
+--------------+--------------+
1 row in set (0.01 sec)
mysql&#62;
</pre>

<P>
Этот запрос иллюстрирует следующие особенности <code>mysql</code>:

</P>

<ul>

<LI>

Команда обычно состоит из SQL-выражения, за которым следует точка с
запятой. (Из этого правила есть и исключения - команды без точки с
запятой. Одним из них является упомянутая выше команда <code>QUIT</code>, остальные
мы рассмотрим позднее.)

<LI>

Когда пользователь вводит команду, <code>mysql</code> отправляет ее серверу для
выполнения и выводит на экран сначала результаты, а затем - новую
строку <code>mysql&#62;</code>, что означает готовность к выполнению новых команд.

<LI>

mysql выводит результаты работы запроса в виде таблицы (строк и
столбцов). В первой строке этой таблицы содержатся заголовки столбцов,
а в следующих строках - собственно результаты. Обычно заголовками
столбцов становятся имена, полученные из таблиц базы. Если же
извлекается не столбец таблицы, а значение выражения (как это
происходит в приведенном выше примере), <code>mysql</code> дает столбцу имя
запрашиваемого выражения.

<LI>

mysql сообщает количество возвращаемых строк и время выполнения
запроса, что позволяет в некоторой степени составить представление о
производительности сервера. Эти значения обычно весьма впечатляют, так
как представляют обычное (а не машинное время), кроме того, на них
оказывает влияние загрузка сервера и скорость работы сети (для
сокращения размеров листингов в остальных примерах этой главы строка
"rows in set" удалена).

</ul>

<P>
Для ввода ключевых слов можно использовать любой регистр символов.
Приведенные ниже запросы абсолютно идентичны:

</P>

<pre>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
mysql&#62; select version(), current_date;
mysql&#62; SeLeCt vErSiOn(), current_DATE;
</pre>

<P>
А это - еще один запрос. В нем демонстрируется использование <code>mysql</code> в
качестве несложного калькулятора:

</P>

<pre>
mysql&#62; SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
</pre>

<P>
Все команды, представленные выше, были относительно короткими и состояли
из одной строки. В одну строку можно поместить и несколько команд. Но
каждая из них должна заканчиваться точкой с запятой:

</P>

<pre>
mysql&#62; SELECT VERSION(); SELECT NOW();
+--------------+
| VERSION()    |
+--------------+
| 3.22.20a-log |
+--------------+

+---------------------+
| NOW()               |
+---------------------+
| 1999-03-19 00:15:33 |
+---------------------+
</pre>

<P>
Втискивать все команды в одну строку совсем не обязательно, так что
создание длинных команд, занимающих несколько строк, никаких проблем не
вызывает. Для <code>mysql</code> признаком завершения выражения является точка с
запятой, а не конец строки (другими словами, <code>mysql</code> принимает команды без
форматирования: строки с командами собираются, но не исполняются до тех
пор, пока программа не обнаружит точку с запятой).

</P>
<P>
Вот пример несложного выражения, занимающего несколько строк:

</P>

<pre>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; ,
    -&#62; CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
</pre>

<P>
Обратите внимание на то, как изменилась метка командной строки (с <code>mysql&#62;</code>
на <code>-&#62;</code>) после ввода первой строки этого запроса. Таким образом программа
mysql показывает, что завершенного выражения она пока что не получила и
ожидает его полного ввода. Эта метка очень полезна, так как предоставляет
весьма ценную информацию о состоянии программы. С ее помощью всегда можно
узнать, чего ждет <code>mysql</code>.

</P>
<P>
Если вы решите отменить исполнение набираемой команды, наберите <code>\c</code>:

</P>

<pre>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; \c
mysql&#62;
</pre>

<P>
Обратите внимание на метку: после ввода команды <code>\c</code> она снова принимает вид
mysql&#62;, показывая, что программа <code>mysql</code> перешла в режим ожидания указаний.

</P>
<P>
В этой таблице приведены все возможные варианта вида метки командной
строки и соответствующие им состояния <code>mysql</code>:

</P>
<P>
<A NAME="IDX372"></A>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Метка</strong> </TD><TD> <strong>Значение</strong>
</TD></TR>
<TR><TD><code>mysql&#62;</code> </TD><TD> Ожидание новой команды.
</TD></TR>
<TR><TD><code>    -&#62;</code> </TD><TD> Ожидание следующей строки многострочной команды.
</TD></TR>
<TR><TD><code>    '&#62;</code> </TD><TD> Ожидание следующей строки, сбор строкового выражения,
начинающегося с одиночной кавычки (<samp>`''</samp>).
</TD></TR>
<TR><TD><code>    "&#62;</code> </TD><TD> Ожидание следующей строки, сбор строкового выражения,
начинающегося с двойной кавычки (<samp>`"'</samp>).
</TD></TR>
</TABLE>

</P>
<P>
Обычно многострочные команды получаются случайно, когда хочешь создать
обычную команду, но забываешь поставить завершающую точку с запятой. В
таком случае <code>mysql</code> ожидает продолжения:

</P>

<pre>
mysql&#62; SELECT USER()
    -&#62;
</pre>

<P>
Если с вами произошло подобное (вы думаете, что завершили команду, но
программа выдает только метку <code>-&#62;</code>), то <code>mysql</code>, вероятнее всего, ждет точки с
запятой. Не обратив внимание на метку командной строки, можно довольно
долго ждать выполнения команды, не понимая в чем дело. А достаточно лишь
поставить точку с запятой, завершив команду, которую <code>mysql</code> и выполнит:

</P>

<pre>
mysql&#62; SELECT USER()
    -&#62; ;
+--------------------+
| USER()             |
+--------------------+
| joesmith@localhost |
+--------------------+
</pre>

<P>
Метки <code>'&#62;</code> и <code>"&#62;</code> используются при сборе строк. В MySQL строки можно заключать
как в одинарные (<samp>`''</samp>), так и в двойные (<samp>`"'</samp>) кавычки (можно, например,
написать <code>'hello'</code> или <code>"goodbye"</code>), к тому же, <code>mysql</code> позволяет вводить
строковые выражения, состоящие из нескольких строчек текста. Метка <code>'&#62;</code> или
<code>"&#62;</code> обозначает, что вы ввели строку, открывающуюся символом кавычек <samp>`''</samp> или
<samp>`"'</samp>, но еще не ввели завершающую строковое выражение закрывающую кавычку.

</P>
<P>
Это, конечно, нормально, если вы собираетесь создать большое строковое
выражение из нескольких строчек. Но это не слишком частый случай. Гораздо
чаще оказывается, что вы просто забыли поставить закрывающую кавычку.
Например:

</P>

<pre>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62;
</pre>

<P>
Если ввести такую команду <code>SELECT</code>, нажать Enter и подождать результатов,
ничего не произойдет. Тут-то и нужно обратить внимание на метку командной
строки, выглядящую вот так: <code>"&#62;</code>. Это значит, что <code>mysql</code> ждет ввода
завершающей части строки. (Теперь заметили ошибку в команде? В строке
<code>"Smith</code> нет закрывающей кавычки.)

</P>
<P>
Что делать в этом случае? Проще всего было бы отменить команду. Однако
теперь просто набрать <code>\c</code> нельзя, так как <code>mysql</code> примет эти символы за часть
собираемой строки! Вместо этого нужно ввести закрывающие кавычки (тем
самым дав <code>mysql</code> понять, что строка закончилась) и лишь затем набрать <code>\c</code>:

</P>

<pre>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62; "\c
mysql&#62;
</pre>

<P>
Метка командной строки снова примет вид <code>mysql&#62;</code>, показывая готовность mysql
к выполнению команд.

</P>
<P>
Знать значение меток <code>'&#62;</code> и <code>"&#62;</code> необходимо, так как при вводе незавершенной
строки все последующие строки будут игнорироваться <code>mysql</code> - включая строку
с командой <code>QUIT</code>! Это может основательно сбить с толку, особенно если не
знать, что для отмены команды перед соответствующей последовательностью
символов необходимо поставить закрывающую кавычку.

</P>



<H2><A NAME="Database_use" HREF="manual.ru_toc.html#Database_use">3.3  Создание и использование базы данных</A></H2>

<P>
<A NAME="IDX373"></A>
<A NAME="IDX374"></A>
<A NAME="IDX375"></A>

</P>

<P>
Теперь, когда вы знаете, как вводить команды, пора начать работу с базой
данных.

</P>
<P>
Предположим, у вас дома (или в вольере) живет несколько домашних любимцев
и вы хотите создать систему для хранения разнообразной информации о своем
живом уголке. Для того чтобы это сделать, нужно просто создать таблицы и
записать в них информацию. После этого любые данные можно будет получить,
извлекая данные из таблиц. В этом разделе вы научитесь:

</P>


<ul>
<LI>

создавать базу данных
<LI>

создавать таблицу
<LI>

записывать в таблицу данные
<LI>

извлекать данные из таблицы различными способами
<LI>

работать с несколькими таблицами сразу
</ul>

<P>
Наша база данных будет чрезвычайно проста (это мы сделали намеренно), но
совсем несложно придумать реальные задачи, решение которых потребовало бы
применения подобной базы данных. Такая база, например, может пригодиться
скотоводу для хранения информации о поголовье или ветеринару - для учета
пациентов. Готовая база данных <code>menagerie</code>, в которой содержатся некоторые
из запросов и данные из приведенных ниже разделов, находится на web-сайте
MySQL. Ее можно загрузить в виде сжатого <code>tar</code>-файла 
(<a HREF="http://www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz">http://www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz</a>) или Zip
(<a HREF="http://www.mysql.com/Downloads/Contrib/Examples/menagerie.zip">http://www.mysql.com/Downloads/Contrib/Examples/menagerie.zip</a>).

</P>
<P>
Узнать, какие базы существуют в настоящее время на сервере, можно при
помощи команды <code>SHOW</code>:

</P>

<pre>
mysql&#62; SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</pre>

<P>
На вашем компьютере список баз, вероятно, будет другим, но в нем все
равно, скорее всего, будут присутствовать базы <code>mysql</code> и <code>test</code>. База данных
<code>mysql</code> просто необходима, так как в ней она описываются пользовательские
права доступа. База <code>test</code> часто применяется для экспериментов.

</P>
<P>
Впрочем, всех баз вы можете и не увидеть, если у вас нет привилегии <code>SHOW
DATABASES</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#GRANT">4.3.1  Синтаксис команд <code>GRANT</code> и <code>REVOKE</code></A>.

</P>
<P>
Если база данных <code>test</code> существует, попробуйте обратиться к ней:

</P>

<pre>
mysql&#62; USE test
Database changed
</pre>

<P>
В команде <code>USE</code>, как и <code>QUIT</code>, точка с запятой не нужна (конечно, данные
команды тоже можно завершать точкой с запятой - никакого вреда от этого не
будет). Команда <code>USE</code> отличается от остальных и кое-чем еще: она должна
задаваться одной строкой.

</P>
<P>
Базу данных <code>test</code> (если, конечно, у вас есть доступ к ней) можно
использовать для работы с приведенными ниже примерами, но все созданное в
ней может быть уничтожено любым другим пользователем, имеющим к ней
доступ. Поэтому вам лучше попросить у своего администратора MySQL
разрешение на создание собственной базы. Предположим, вы захотите назвать
ее menagerie (``зверинец''). В таким случае администратору нужно будет
набрать примерно такую команду:

</P>

<pre>
mysql&#62; GRANT ALL ON menagerie.* TO your_mysql_name;
</pre>

<P>
где your_mysql_name - присвоенное вам имя MySQL.

</P>



<H3><A NAME="Creating_database" HREF="manual.ru_toc.html#Creating_database">3.3.1  Создание и выбор базы данных</A></H3>

<P>
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>

</P>
<P>
Если администратор при выдаче разрешения создаст для вас базу, с ней можно
сразу начинать работу. В противном случае вам придется создать ее
самостоятельно:

</P>


<pre>
mysql&#62; CREATE DATABASE menagerie;
</pre>

<P>
В Unix имеет значение регистр символов в именах баз данных (в отличие от
ключевых слов SQL), так что в этой ОС вам всегда придется называть свою
базу <code>menagerie</code>, а не <code>Menagerie</code>, <code>MENAGERIE</code> или еще как-нибудь. Это же
правило распространяется и на имена таблиц (в Windows данное ограничение
не действует, однако при обращении к базам и таблицам в пределах одного
запроса, тем не менее, можно использовать только один регистр).

</P>
<P>
При создании базы данных она автоматически не выбирается; выбирать ее
нужно отдельно. Сделать menagerie текущей базой можно с помощью следующей
команды:

</P>

<pre>
mysql&#62; USE menagerie
Database changed
</pre>

<P>
Создавать базу нужно только однажды, но выбирать ее приходится в каждом
сеансе работы с <code>mysql</code>. Делать это можно с помощью команды USE,
представленной выше. А можно выбирать базу и из командной строки при
запуске <code>mysql</code>. Для этого достаточно лишь ввести ее имя после параметров
соединения, которые нужно вводить в любом случае. Например:

</P>

<pre>
shell&#62; mysql -h host -u user -p menagerie
Enter password: ********
</pre>

<P>
Обратите внимание: в вышеприведенной команде <code>menagerie</code> не является
паролем. Ввести пароль в командной строке после параметра -p можно без
пробела (например, <code>-pmypassword</code>, а не <code>-p mypassword</code>). Впрочем, пароль в
командной строке все равно лучше не вводить, так как таким образом его
могут и подсмотреть.

</P>



<H3><A NAME="Creating_tables" HREF="manual.ru_toc.html#Creating_tables">3.3.2  Создание таблицы</A></H3>

<P>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>

</P>
<P>
Как вы уже успели убедиться, создать базу данных было просто. Однако пока
что в ней ничего нет - в этом можно удостовериться при помощи команды <code>SHOW
TABLES</code>:

</P>

<pre>
mysql&#62; SHOW TABLES;
Empty set (0.00 sec)
</pre>

<P>
Гораздо труднее определиться со структурой своей базы, т.е. с тем, какие
могут понадобиться таблицы, и какие столбцы должны содержаться в каждой из
них.

</P>
<P>
Вам обязательно будет нужна таблица, содержащая по записи на каждое из
животных. Назвать ее можно <code>pet</code>, и храниться в ней будут, как минимум,
имена. Но так как само по себе имя неинформативно, в таблице должны будут
присутствовать и другие данные. Например, если домашние животные есть
более чем у одного члена вашей семьи, в таблицу можно добавить и имя
владельца каждого животного. Кроме того, в базу стоит внести и
описательную информацию - например, вид и пол животного.

</P>
<P>
Но вот как быть с возрастом? Эта информация тоже может оказаться полезной,
но хранить такие данные в базе неудобно. Возраст со временем меняется, а
это значит, что придется довольно часто обновлять записи. Значительно
удобнее хранить фиксированные значения - например, даты рождения. В таком
случае возраст всегда можно получить, вычислив разницу между текущей датой
и датой рождения. В MySQL есть функции для арифметических действий над
данными, так что это совсем несложно. Хранение даты рождения имеет и
другие преимущества:

</P>

<ul>
<LI>

Базу данных можно использовать для выдачи напоминаний о приближающихся
днях рождения животных (не спешите улыбаться: та же задача может
возникнуть и при работе с деловой базой данных, которая должна уметь
напоминать о днях рождения клиентов, облегчая таким образом рассылку
поздравлений).

<LI>

Возраст можно подсчитывать относительно любой даты, а не только для
текущей. Например, если записать в базу и дату смерти животного,
всегда можно будет узнать, сколько лет ему было на момент смерти.
</ul>

<P>
Можно было бы придумать и еще какие-нибудь данные, которые неплохо было бы
хранить в таблице pet, но пока что мы ограничимся уже выбранными: именем
(<code>name</code>), именем владельца (<code>owner</code>), видом (<code>species</code>), полом (<code>sex</code>), датой
рождения (<code>birth</code>) и датой смерти (<code>death</code>).

</P>
<P>
При помощи команды <code>CREATE TABLE</code> определим структуру новой таблицы:

</P>

<pre>
mysql&#62; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -&#62; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
</pre>

<P>
Тип <code>VARCHAR</code> отлично подойдет для хранения имени животного, имени владельца
и названия вида, так как длина данных этого типа может варьироваться.
Конечно, длины таких столбцов вовсе не должны совпадать и не должны быть
равны 20 - можно выбрать любое значение в пределах от 1 до 255 (если при
выборе длины столбца вы ошибетесь, и при работе с базой окажется, что
столбец маловат, можно будет исправить ошибку при помощи команды <code>ALTER
TABLE</code>).

</P>
<P>
Пол животного можно обозначать несколькими способами, например буквами "m"
и "f", или словами male (мужской) и female (женский). С буквами "m" и "f"
будет проще.

</P>
<P>
Применение типа данных <code>DATE</code> для хранения дат рождения и смерти вполне
очевидно.

</P>
<P>
Теперь, когда таблица создана, команда <code>SHOW TABLES</code> должна вывести
следующее:

</P>

<pre>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</pre>

<P>
Проверить, правильно была ли таблица создана в соответствии с планом,
можно при помощи команды <code>DESCRIBE</code>:

</P>

<pre>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre>

<P>
Использовать команду <code>DESCRIBE</code> можно в любое время, например, если вы
забудете имена столбцов или типы, к которым они относятся.

</P>



<H3><A NAME="Loading_tables" HREF="manual.ru_toc.html#Loading_tables">3.3.3  Загрузка данных в таблицу</A></H3>

<P>
<A NAME="IDX380"></A>
<A NAME="IDX381"></A>
<A NAME="IDX382"></A>

</P>
<P>
Создав таблицу, нужно позаботиться об ее заполнении. Для этого
предназначены команды <code>LOAD DATA</code> и <code>INSERT</code>.

</P>
<P>
Предположим, ваши записи соответствуют приведенным в этой таблице
(обратите внимание: MySQL принимает даты в формате <code>ГГГГ-ММ-ДД</code>; возможно, к
такой записи вы не привыкли).

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>name</strong> </TD><TD> <strong>owner</strong> </TD><TD> <strong>species</strong> </TD><TD> <strong>sex</strong> </TD><TD> <strong>birth</strong> </TD><TD> <strong>death</strong>
</TD></TR>
<TR><TD>Fluffy </TD><TD> Harold </TD><TD> cat </TD><TD> f </TD><TD> 1993-02-04 </TD><TD>
</TD></TR>
<TR><TD>Claws </TD><TD> Gwen </TD><TD> cat </TD><TD> m </TD><TD> 1994-03-17 </TD><TD>
</TD></TR>
<TR><TD>Buffy </TD><TD> Harold </TD><TD> dog </TD><TD> f </TD><TD> 1989-05-13 </TD><TD>
</TD></TR>
<TR><TD>Fang </TD><TD> Benny </TD><TD> dog </TD><TD> m </TD><TD> 1990-08-27 </TD><TD>
</TD></TR>
<TR><TD>Bowser </TD><TD> Diane </TD><TD> dog </TD><TD> m </TD><TD> 1998-08-31 </TD><TD> 1995-07-29
</TD></TR>
<TR><TD>Chirpy </TD><TD> Gwen </TD><TD> bird </TD><TD> f </TD><TD> 1998-09-11 </TD><TD>
</TD></TR>
<TR><TD>Whistler </TD><TD> Gwen </TD><TD> bird </TD><TD> </TD><TD> 1997-12-09 </TD><TD>
</TD></TR>
<TR><TD>Slim </TD><TD> Benny </TD><TD> snake </TD><TD> m </TD><TD> 1996-04-29 </TD><TD>
</TD></TR>
</TABLE>

<P>
Так как вы начинаете работу с пустой таблицей, заполнить ее будет проще
всего, если создать текстовый файл, содержащий по строке на каждое из
животных, а затем загрузить его содержимое в таблицу одной командой.

</P>
<P>
Создайте текстовый файл с именем <tt>`pet.txt'</tt>, содержащий по одной записи в
каждой строке (значения столбцов должны быть разделены символами табуляции
и даны в том порядке, который был определен командой <code>CREATE TABLE</code>).
Незаполненным полям (например, неизвестный пол или даты смерти живых на
сегодняшний день животных), можно присвоить значение <code>NULL</code>. В текстовом
файле это значение представляется символами <code>\N</code>. Например, запись для птицы
<code>Whistler</code> должна выглядеть примерно так (между значениями должны
располагаться одиночные символы табуляции):

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>name</strong> </TD><TD> <strong>owner</strong> </TD><TD> <strong>species</strong> </TD><TD> <strong>sex</strong> </TD><TD> <strong>birth</strong> </TD><TD> <strong>death</strong>
</TD></TR>
<TR><TD><code>Whistler</code> </TD><TD> <code>Gwen</code> </TD><TD> <code>bird</code> </TD><TD> <code>\N</code> </TD><TD> <code>1997-12-09</code> </TD><TD> <code>\N</code>
</TD></TR>
</TABLE>

<P>
Загрузить файл <tt>`pet.txt'</tt> в таблицу можно с помощью следующей команды:

</P>

<pre>
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</pre>

<P>
Маркер конца строки и символ, разделяющий значения столбцов, можно
специально задать в команде <code>LOAD DATA</code>, но по умолчанию используются
символы табуляции и перевода строки. Воспринимая их, команда сможет
корректно прочитать файл <tt>`pet.txt'</tt>.

</P>
<P>
При добавлении одиночных записей используется команда <code>INSERT</code>. В самом
простом варианте ее применения необходимо задать значения каждого столбца,
в том порядке, в каком они были перечислены в команде <code>CREATE TABLE</code>.
Предположим, Диана (Diane) купила хомячка по имени Puffball.
Соответствующую запись в таблицу с можно внести с помощью команды <code>INSERT</code>
примерно так:

</P>

<pre>
mysql&#62; INSERT INTO pet
    -&#62; VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
</pre>

<P>
Обратите внимание на то, что здесь строковые выражения и даты представлены
в виде ограниченных кавычками строк. Кроме того, в команде <code>INSERT</code>
отсутствующие данные можно прямо заменять на <code>NULL</code>. Пользоваться эвфемизмом
<code>\N</code>, как в команде <code>LOAD DATA</code>, нужды нет.

</P>
<P>
Этот пример наглядно показывает, что если бы с самого начала все данные
вносились в базу при помощи нескольких команд <code>INSERT</code>, а не одной команды
<code>LOAD DATA</code>, то набирать пришлось бы гораздо больше текста.

</P>


<H3><A NAME="Retrieving_data" HREF="manual.ru_toc.html#Retrieving_data">3.3.4  Выборка информации из таблицы</A></H3>

<P>
<A NAME="IDX383"></A>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>
<A NAME="IDX386"></A>

</P>

<P>
Информация извлекается из таблиц при помощи команды <code>SELECT</code>. Вызывается она
так:

</P>

<pre>
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy
</pre>

<P>
где <code>what_to_select</code> обозначает нужные данные. Это может быть список
столбцов или символ <code>*</code> (``все столбцы''). which_table указывает таблицу, из
которой должны быть извлечены данные. Условие <code>WHERE</code> использовать
необязательно, но если оно все же присутствует в вызове команды, то
параметр <code>conditions_to_satisfy</code> задает условия, которым должны
соответствовать нужные строки.

</P>


<H4><A NAME="Selecting_all" HREF="manual.ru_toc.html#Selecting_all">3.3.4.1  Выборка всех данных</A></H4>

<P>
В самом простом варианте вызова <code>SELECT</code> из таблицы извлекаются сразу все
данные:

</P>

<pre>
mysql&#62; SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1998-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</pre>

<P>
Использовать <code>SELECT</code> таким образом удобно, когда нужно просмотреть всю
таблицу, например, после того, как в нее была загружена первая порция
данных. Как часто случается, в выведенных на экран данных сразу можно
увидеть ошибку в таблице: <code>Bowser</code>, оказывается, успел умереть еще до того,
как родился! Заглянув в его родословную обнаруживаем, что пес родился в
1989, а не в 1998 году.

</P>
<P>
Исправить ошибку можно как минимум двумя способами:

</P>

<ul>
<LI>

Отредактировать файл pet.txt, затем очистить таблицу и снова заполнить
ее командами DELETE и LOAD DATA:


<pre>
mysql&#62; SET AUTOCOMMIT=1;  # Used for quick re-create of the table
mysql&#62; DELETE FROM pet;
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</pre>

Однако в таком случае придется снова ввести запись о Puffball.

<LI>

Исправить только ошибочно введенные данные при помощи команды <code>UPDATE</code>:


<pre>
mysql&#62; UPDATE pet SET birth = "1989-08-31" WHERE name = "Bowser";
</pre>

</ul>

<P>
Как видно из приведенного выше примера, загрузить всю таблицу сразу очень
просто. Но на практике обычно этого не требуется, особенно когда таблица
достигает значительных размеров. Чаще всего нужно просто ответить на
какой-нибудь вопрос, для чего необходимо ввести ограничения, указывающие,
какая же информация вам нужна. Давайте рассмотрим несколько запросов с
точки зрения вопросов, на которые они отвечают.

</P>



<H4><A NAME="Selecting_rows" HREF="manual.ru_toc.html#Selecting_rows">3.3.4.2  Выборка определенных строк</A></H4>

<P>
<A NAME="IDX387"></A>
<A NAME="IDX388"></A>

</P>
<P>
Из таблицы можно выбрать и только нужные строки. Например, если вы хотите
проверить правильность внесенных в дату рождения собаки Bowser изменений,
соответствующую запись можно получить следующим способом:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name = "Bowser";
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</pre>

<P>
Теперь видно, что год рождения теперь записан правильно -1989, а не 1998.

</P>
<P>
В операции сравнения строк обычно не учитывается регистр символов, так что
имя можно записать как <code>"bowser"</code>, <code>"BOWSER"</code> и т.п. Результаты запросов будут
идентичными.

</P>
<P>
В условиях может указываться любой из столбцов, а не только <code>name</code>. Если,
например, вам нужно узнать, какие их животных родились после 1998 года, в
условие вводится значение столбца <code>birth</code>:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE birth &#62;= "1998-1-1";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
</pre>

<P>
Условия можно и комбинировать, например для того, чтобы выделить всех
собак женского пола:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE species = "dog" AND sex = "f";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<P>
В предыдущем запросе использован оператор <code>AND</code>. Существует еще и оператор
<code>OR</code>:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE species = "snake" OR species = "bird";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</pre>

<P>
Операторы <code>AND</code> и <code>OR</code> можно использовать совместно. В таком случае с помощью
скобок можно указать порядок группировки условий:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE (species = "cat" AND sex = "m")
    -&#62; OR (species = "dog" AND sex = "f");
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>



<H4><A NAME="Selecting_columns" HREF="manual.ru_toc.html#Selecting_columns">3.3.4.3  Выборка определенных столбцов</A></H4>

<P>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>

</P>
<P>
Если строки целиком вам не нужны, достаточно просто перечислить имена
нужных столбцов, разделив их запятыми. Например, если вы хотите узнать,
когда родились животные, выберите столбцы с именами и датами рождения:

</P>

<pre>
mysql&#62; SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</pre>

<P>
Получить имена владельцев животных можно с помощью следующего запроса:

</P>

<pre>
mysql&#62; SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</pre>

<P>
<A NAME="IDX391"></A>
Однако этот запрос просто загружает поля с именем владельца из каждой
записи, а некоторые имена встречаются более одного раза. Сократить
количество выводимых строк можно, воспользовавшись ключевым словом
<code>DISTINCT</code> - тогда будут выводиться только уникальные записи:

</P>


<pre>
mysql&#62; SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</pre>

<P>
При помощи выражения <code>WHERE</code> можно комбинировать выбор строк и столбцов.
Например для того, чтобы загрузить даты рождения только кошек и собак,
можно воспользоваться следующим запросом:

</P>

<pre>
mysql&#62; SELECT name, species, birth FROM pet
    -&#62; WHERE species = "dog" OR species = "cat";
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
</pre>



<H4><A NAME="Sorting_rows" HREF="manual.ru_toc.html#Sorting_rows">3.3.4.4  Сортировка строк</A></H4>

<P>
<A NAME="IDX392"></A>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>
<A NAME="IDX395"></A>

</P>
<P>
Вы уже, наверное, заметили, что результаты, выдававшиеся запросами из
предыдущих примеров, выводились без какой-либо сортировки. Но ведь часто
разобраться в результатах легче, если они отсортированы. Для этого
используется выражение <code>ORDER BY</code>.

</P>
<P>
Так выглядят даты рождения животных в отсортированном виде:

</P>

<pre>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</pre>

<P>
Над столбцами с символьными значениями операция сортировки - как и все
другие операции сравнения - обычно проводится без учета регистра символов.
Это значит, что порядок расположения столбцов, совпадающих во всем, кроме
регистра символов, относительно друг друга будет не определен. Провести
сортировку с учетом регистра символов можно при помощи команды <code>BINARY</code>:
<code>ORDER BY BINARY(поле)</code>.

</P>
<P>
Для сортировки в обратном порядке к имени столбца следует добавить
ключевое слово <code>DESC</code> (по убыванию):

</P>

<pre>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</pre>

<P>
Сортировку можно проводить по нескольким столбцам сразу. Например для
того, чтобы отсортировать таблицу сначала по типу животного, потом - по
дате рождения и затем - расположить наиболее молодых животных определенного
типа в начале списка, выполните следующий запрос:

</P>

<pre>
mysql&#62; SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</pre>

<P>
Обратите внимание: действие ключевого слова <code>DESC</code> распространяется только
на тот столбец, имя которого располагается в запросе прямо перед этим
словом (в данном случае - <code>birth</code>); значения поля species по-прежнему
отсортированы в возрастающем порядке.

</P>



<H4><A NAME="Date_calculations" HREF="manual.ru_toc.html#Date_calculations">3.3.4.5  Вычисление  дат</A></H4>

<P>
<A NAME="IDX396"></A>
<A NAME="IDX397"></A>
<A NAME="IDX398"></A>
<A NAME="IDX399"></A>

</P>
<P>
В MySQL имеется несколько функций, реализующих арифметические операции над
датами. Эти функции позволяют, например, вычислять возраст или получать
части даты.

</P>
<P>
Определить возраст любого из животных в базе можно, если вычислить разницу
между текущим годом и годом его рождения, а из результата вычесть единицу,
если текущий день находится к началу календаря ближе, нежели день рождения
животного. Приведенный ниже запрос выводит дату рождения каждого
животного, его возраст и текущую дату.

</P>

<pre>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; - (RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
+----------+------------+--------------+------+
</pre>

<P>
В этом примере функция <code>YEAR()</code> выделяет из даты год, а <code>RIGHT()</code> - пять
крайних справа символов, представляющих календарный день (MM-DD). Часть
выражения, сравнивающая даты, выдает 1 или 0, что позволяет уменьшить
результат на единицу, если текущий день (<code>CURRENT_DATE</code>) находится к началу
календаря ближе, нежели день рождения животного. Все выражение смотрится
несколько неуклюже, поэтому вместо него в заголовке соответствующего
столбца результатов выводится псевдоним (<code>age</code> - "возраст").

</P>
<P>
Запрос неплохо работает, но разобраться в результатах было бы проще, если
бы строки располагались в определенном порядке. Этого можно достичь,
добавив в запрос выражение <code>ORDER BY</code> name и отсортировав таким образом
результаты по имени:

</P>

<pre>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; - (RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet ORDER BY name;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
+----------+------------+--------------+------+
</pre>

<P>
Отсортировать результаты по возрасту также можно при помощи выражения
<code>ORDER BY</code>:

</P>

<pre>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; - (RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet ORDER BY age;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
+----------+------------+--------------+------+
</pre>

<P>
подобный же запрос поможет определить возраст, которого достигли умершие
животные на момент смерти. Выделить умерших животных можно, проверив
значение поля <code>death</code> на предмет равенства <code>NULL</code>. Затем для записей, значения
поля <code>death</code> которых не равно <code>NULL</code>, можно вычислить разницу между датами
смерти и рождения:

</P>


<pre>
mysql&#62; SELECT name, birth, death,
    -&#62; (YEAR(death)-YEAR(birth)) - (RIGHT(death,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
</pre>

<P>
В этом запросе используется выражение <code>death IS NOT NULL</code>, а не death &#60;&#62;
<code>NULL</code>, так как <code>NULL</code> - особое значение (более подробные пояснения приведены
в разделе see section <A HREF="manual.ru_Tutorial.html#Working_with_NULL">3.3.4.6  Работа с значениями NULL</A>).

</P>
<P>
А как поступать, если потребуется определить, дни рождения каких животных
наступят в следующем месяце? Для таких расчетов день и год значения не
имеют; из столбца, содержащего дату рождения, нас интересует только месяц.
В MySQL предусмотрено несколько функций для получения частей дат - <code>YEAR()</code>,
<code>MONTH()</code>, и <code>DAYOFMONTH()</code>. В данном случае нам подойдет функция <code>MONTH()</code>.
Увидеть работу этой функции можно с помощью простого запроса, выводящего
дату рождения <code>birth</code> и <code>MONTH(birth)</code>:

</P>

<pre>
mysql&#62; SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</pre>

<P>
Найти животных, дни рождения которых наступят в следующем месяце, тоже
несложно. Предположим, что сейчас на дворе апрель. Тогда номер текущего
месяца - 4, а искать надо животных, родившихся в мае (5-м месяце), таким
образом:

</P>

<pre>
mysql&#62; SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</pre>

<P>
Конечно, в декабре возникают некоторые осложнения. Если просто добавить
единицу к номеру месяца (12) и поискать животных, родившихся в тринадцатом
месяце, найти что-нибудь вряд ли удастся. Вместо этого нужно искать
животных, родившихся в январе (1-м месяце).

</P>
<P>
Можно даже написать небольшой запрос, который будет работать вне
зависимости от того, какой нынче месяц. Функция <code>DATE_ADD()</code> позволяет
прибавить к дате некоторый интервал времени. Если добавить к значению,
возвращаемому функцией <code>NOW()</code>, месяц, а затем извлечь из получившейся даты
номер месяца при помощи функции <code>MONTH()</code>, мы получим именно тот месяц,
который нам нужен:

</P>

<pre>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MONTH(DATE_ADD(NOW(), INTERVAL 1 MONTH));
</pre>

<P>
Ту же задачу можно решить и другим методом - для этого нужно прибавить
единицу к номеру месяца, следующего за текущим (воспользовавшись функцией
расчета по модулю (MOD) для перехода к 0, если номер текущего месяца равен
12):

</P>

<pre>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MOD(MONTH(NOW()), 12) + 1;
</pre>

<P>
Функция <code>MONTH</code> возвращает число от 1 до 12, а выражение <code>MOD(число,12)</code> -
число от 0 до 11. Поэтому операцию сложения нужно проводить после <code>MOD()</code>,
иначе результат перепрыгнет с ноября (11) сразу на январь (1).

</P>


<H4><A NAME="Working_with_NULL" HREF="manual.ru_toc.html#Working_with_NULL">3.3.4.6  Работа с значениями NULL</A></H4>

<P>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>

</P>
<P>
К <code>NULL</code>-значениям нужно привыкнуть. По идее, <code>NULL</code> обозначает отсутствующее
или неизвестное значение и обрабатывается отличным от других значений
образом. Проверить значение на равенство <code>NULL</code> с помощью обычных
арифметических операторов сравнения (=, &#60; или &#60;&#62;) нельзя. Это отлично
иллюстрирует следующий запрос:

</P>

<pre>
mysql&#62; SELECT 1 = NULL, 1 &#60;&#62; NULL, 1 &#60; NULL, 1 &#62; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 &#60;&#62; NULL | 1 &#60; NULL | 1 &#62; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</pre>

<P>
Очевидно, что от таких сравнений значащих результатов ожидать нечего.
Вместо этого нужно пользоваться операторами <code>IS NULL</code> и <code>IS NOT NULL</code>:

</P>

<pre>
mysql&#62; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</pre>

<P>
Отметим: в MySQL 0 или <code>NULL</code> приравнивается к логическому false, а все остальное - к
true. По умолчанию значение "истина" для булевого оператора равно 1.

</P>
<P>
Именно из-за того, что при работе с <code>NULL</code> действуют особые правила, в
предыдущем разделе для поиска умерших животных использовалось выражение
<code>death IS NOT NULL</code>, а не <code>death &#60;&#62; NULL</code>.

</P>
<P>
Два <code>NULL</code>-значения считаются одинаковыми в <code>GROUP BY</code>.

</P>
<P>
При выполнении <code>ORDER BY</code>, <code>NULL</code>-значения идут в первую очередь если вы выполняете
<code>ORDER ... ASC</code> и в последнюю - если <code>ORDER BY ... DESC</code>.

</P>
<P>
Обратите внимание, что в MySQL 4.0.2 - 4.0.10, <code>NULL</code>-значения всегда возвращались в первую
очередь, вне зависимости от сортировки. 

</P>


<H4><A NAME="Pattern_matching" HREF="manual.ru_toc.html#Pattern_matching">3.3.4.7  Сравнение по шаблонам</A></H4>

<P>
<A NAME="IDX402"></A>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>

</P>
<P>
В MySQL реализовано стандартное для SQL сравнение по шаблонам, а также
особый тип такого сравнения - он основан на использовании выражений,
подобных применяющимся в служебных программах Unix (таких, как vi, grep и
sed).

</P>
<P>
В SQL при сравнении по шаблону символ <samp>`_'</samp> обозначает любой одиночный
символ, а <samp>`%'</samp> - определенное количество символов (включая ноль символов).
В MySQL в SQL-шаблонах по умолчанию не учитывается регистр символов. При
работе с шаблонами SQL использование операторов <code>=</code> или <code>&#60;&#62;</code> не допускается,
вместо этого применяются операторы сравнения <code>LIKE</code> или <code>NOT LIKE</code>.

</P>
<P>
Найти все имена, начинающиеся с <samp>`b'</samp>, можно следующим образом:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name LIKE "b%";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</pre>

<P>
Найти все имена, заканчивающиеся на <samp>`fy'</samp>, можно следующим образом:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%fy";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</pre>

<P>
Найти все имена, содержащие <samp>`w'</samp>, можно следующим образом:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%w%";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</pre>

<P>
Найти все имена, содержащие ровно пять символов, можно при помощи
шаблонного символа <samp>`_'</samp>:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name LIKE "_____";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<P>
Во втором типе шаблонов, предусмотренных в MySQL, используются расширенные
регулярные выражения. При поиске совпадений на основе такого шаблона
шаблоном нужно пользоваться операторами <code>REGEXP</code> и <code>NOT REGEXP</code> (или их
синонимами - <code>RLIKE</code> и <code>NOT RLIKE</code>).

</P>
<P>
Ниже приведены некоторые характеристики расширенных регулярных выражений:

</P>

<ul>
<LI>

<samp>`.'</samp> обозначает любой символ.

<LI>

Класс символов <samp>`[...]'</samp> обозначает любой из символов в скобках.
Например, <samp>`[abc]'</samp> обозначает <samp>`a'</samp>, <samp>`b'</samp> или <samp>`c'</samp>. Набор символов можно
обозначить с помощью дефиса. <samp>`[a-z]'</samp> обозначает любую букву нижнего
регистра, а <samp>`[0-9]'</samp> - любую цифру.

<LI>

<samp>`*'</samp> обозначает ноль или более экземпляров символа, стоящего перед ним.
Например, <samp>`x*'</samp> обозначает любое количество символов <samp>`x'</samp>, <samp>`[0-9]*'</samp>
обозначает любое количество цифр, а <samp>`.*'</samp> - любое количество любых
символов.

<LI>

Для шаблона выдается совпадение, если поисковый контекст обнаружен в
любой из частей значения, в котором производится поиск (для шаблонов
SQL совпадение выдается только в случае, если совпадает все значение).

<LI>

``Закрепить'' шаблон так, чтобы проверять совпадения с началом или
концом значения можно с помощью символов <samp>`^'</samp> (начало) или <samp>`$'</samp> (конец),
которые располагаются в начале или в конце шаблона соответственно.
</ul>

<P>
Чтобы продемонстрировать работу регулярных выражений, приведенные выше
запросы <code>LIKE</code> здесь переписаны с использованием <code>REGEXP</code>.

</P>
<P>
Найти все имена, начинающиеся с <samp>`b'</samp>, можно при помощи символа <samp>`^'</samp>,
привязывающего шаблон к началу имени:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^b";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</pre>

<P>
В версиях MySQL до 3.23.4 <code>REGEXP</code> учитывает регистр символов, и приведенный
запрос не возвратит никаких результатов. Для поиска символов <samp>`b'</samp> верхнего
или нижнего регистра воспользуйтесь следующим запросом:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^[bB]";
</pre>

<P>
Начиная с версии MySQL 3.23.4, заставить <code>REGEXP</code> учитывать регистр символов
можно с помощью ключевого слова <code>BINARY</code>. В этом запросе положительный
результат поиска будет получен только при обнаружении символа 'b' нижнего
регистра в начале имени:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP BINARY "^b";
</pre>

<P>
Найти все имена, заканчивающиеся на <samp>`fy'</samp>, можно при помощи символа <samp>`$'</samp>,
привязывающего шаблон к концу имени:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "fy$";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</pre>

<P>
Найти все имена, содержащие символ <samp>`w'</samp> любого регистра, можно так:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "w";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</pre>

<P>
Поскольку регулярное выражение выдает положительный результат при
совпадении шаблона с любым фрагментом значения, в приведенном выше примере
привязывать поиск к любому из концов имени для сравнения полного значения
с шаблоном, как это пришлось бы делать для шаблона SQL, не нужно.

</P>
<P>
Найти все имена, содержащие ровно пять символов, можно, если привязать
поиск к началу и концу имени с помощью символов <samp>`^'</samp> и <samp>`$'</samp> и поставить пять
символов <samp>`.'</samp> между ними:

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.....$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<P>
Предыдущий запрос можно записать и при помощи оператора <samp>`{n}'</samp>
(``повторить-<code>n</code>-раз''):

</P>

<pre>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.{5}$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>



<H4><A NAME="Counting_rows" HREF="manual.ru_toc.html#Counting_rows">3.3.4.8  Подсчет строк</A></H4>

<P>
<A NAME="IDX405"></A>
<A NAME="IDX406"></A>
<A NAME="IDX407"></A>

</P>
<P>
Базы данных часто используются для получения ответа на вопросы типа:
``как часто данные определенного типа встречаются в таблице?'' Вам,
например, может понадобиться узнать общее количество животных, или то,
сколько животных имеется у каждого из владельцев, или провести
статистические исследования на базе хранящейся информации.

</P>
<P>
Процедура подсчета количества животных в сущности идентична подсчету
количества строк в таблице, так как на каждое животное приходится по одной
записи. Функция <code>COUNT()</code> подсчитает количество непустых результатов, и с ее
помощью можно составить следующий запрос для определения числа животных:

</P>


<pre>
mysql&#62; SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</pre>

<P>
Ранее мы уже извлекали из таблицы имена владельцев животных. При помощи
функции <code>COUNT()</code> можно узнать, сколько животных принадлежит каждому из
владельцев:

</P>

<pre>
mysql&#62; SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</pre>

<P>
Обратите внимание на использование команды <code>GROUP BY</code> для объединения всех
записей по каждому из владельцев. Без этой команды запрос выдал бы только
сообщение об ошибке:

</P>

<pre>
mysql&#62; SELECT owner, COUNT(owner) FROM pet;
ERROR 1140 at line 1: Mixing of GROUP columns (MIN(),MAX(),COUNT()...)
with no GROUP columns is illegal if there is no GROUP BY clause
</pre>

<P>
Команды <code>COUNT()</code> и <code>GROUP BY</code> очень помогают характеризовать данные
различными способами. В примерах, приведенных ниже, вы увидите и другие
способы проведения статистических подсчетов.

</P>
<P>
Количество животных каждого вида:

</P>

<pre>
mysql&#62; SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</pre>

<P>
Количество животных каждого пола:

</P>

<pre>
mysql&#62; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</pre>

<P>
(в этой таблице результатов <code>NULL</code> обозначает, что пол животного неизвестен)

</P>
<P>
Количество животных каждого вида с учетом пола:

</P>

<pre>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</pre>

<P>
При использовании функции <code>COUNT()</code> вовсе не обязательно загружать всю
таблицу. Например, предыдущий запрос, в котором учитываются только кошки и
собаки, выглядит следующим образом:

</P>

<pre>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE species = "dog" OR species = "cat"
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</pre>

<P>
Можно узнать и количество животных каждого пола с учетом только тех
экземпляров, пол которых известен:

</P>

<pre>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE sex IS NOT NULL
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</pre>



<H4><A NAME="Multiple_tables" HREF="manual.ru_toc.html#Multiple_tables">3.3.4.9  Использование нескольких таблиц</A></H4>

<P>
<A NAME="IDX408"></A>

</P>
<P>
В таблице <code>pet</code> хранятся только основные данные о животных. Если же нужно
держать в базе какую-либо дополнительную информацию о них (скажем, записи
о событиях наподобие посещения ветеринара или рождения потомства),
понадобится еще одна таблица. Давайте определимся с ее структурой. Эта
таблица должна содержать:

</P>

<ul>
<LI>

имена животных, чтобы не путаться с тем, к какому животному относится
какое событие

<LI>

дата события

<LI>

поле для описания события

<LI>

поле, отражающее тип события, для того, чтобы можно было распределить
их по категориям
</ul>

<P>
С учетом всех приведенных выше требований можно составить примерно такую
команду <code>CREATE TABLE</code>:

</P>

<pre>
mysql&#62; CREATE TABLE event (name VARCHAR(20), date DATE,
    -&#62; type VARCHAR(15), remark VARCHAR(255));
</pre>

<P>
Как и в случае с таблицей <code>pet</code>, начальные данные в таблицу проще всего
загрузить, создав текстовый файл с информацией, разделенной символами
табуляции:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>name</strong> </TD><TD> <strong>date</strong> </TD><TD> <strong>type</strong> </TD><TD> <strong>remark</strong>
</TD></TR>
<TR><TD>Fluffy </TD><TD> 1995-05-15 </TD><TD> litter </TD><TD> 4 kittens, 3 female, 1 male
</TD></TR>
<TR><TD>Buffy </TD><TD> 1993-06-23 </TD><TD> litter </TD><TD> 5 puppies, 2 female, 3 male
</TD></TR>
<TR><TD>Buffy </TD><TD> 1994-06-19 </TD><TD> litter </TD><TD> 3 puppies, 3 female
</TD></TR>
<TR><TD>Chirpy </TD><TD> 1999-03-21 </TD><TD> vet </TD><TD> needed beak straightened
</TD></TR>
<TR><TD>Slim </TD><TD> 1997-08-03 </TD><TD> vet </TD><TD> broken rib
</TD></TR>
<TR><TD>Bowser </TD><TD> 1991-10-12 </TD><TD> kennel </TD><TD>
</TD></TR>
<TR><TD>Fang </TD><TD> 1991-10-12 </TD><TD> kennel </TD><TD>
</TD></TR>
<TR><TD>Fang </TD><TD> 1998-08-28 </TD><TD> birthday </TD><TD> Gave him a new chew toy
</TD></TR>
<TR><TD>Claws </TD><TD> 1998-03-17 </TD><TD> birthday </TD><TD> Gave him a new flea collar
</TD></TR>
<TR><TD>Whistler </TD><TD> 1998-12-09 </TD><TD> birthday </TD><TD> First birthday
</TD></TR>
</TABLE>

<P>
Загрузите записи с помощью следующей команды:

</P>

<pre>
mysql&#62; LOAD DATA LOCAL INFILE "event.txt" INTO TABLE event;
</pre>

<P>
Используя знания, усвоенные при работе с таблицей <code>pet</code>, вы сможете
загружать данные из таблицы <code>event</code>; принципы здесь те же. Но что если самой
по себе таблицы <code>event</code> перестанет хватать для получения нужных вам ответов?

</P>
<P>
Предположим, нужно узнать, в каком возрасте животные давали приплод. В
таблице <code>event</code> указаны даты родов, но для того, чтобы рассчитать возраст
матери, нужно знать и дату ее рождения. Так как даты рождения хранятся в
таблице <code>pet</code>, в этом запросе нужно использовать обе таблицы:

</P>

<pre>
mysql&#62; SELECT pet.name,
    -&#62; (TO_DAYS(date) - TO_DAYS(birth))/365 AS age,
    -&#62; remark
    -&#62; FROM pet, event
    -&#62; WHERE pet.name = event.name AND type = "litter";
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy | 2.27 | 4 kittens, 3 female, 1 male |
| Buffy  | 4.12 | 5 puppies, 2 female, 3 male |
| Buffy  | 5.10 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</pre>

<P>
На некоторые аспекты этого запроса следует обратить особое внимание:

</P>

<ul>
<LI>

В выражении <code>FROM</code> указаны две таблицы, так как запрос будет получать
информацию из обеих.

<LI>

При комбинировании (объединении) информации из нескольких таблиц
необходимо указать, как строки одной таблицы связываются с записями
другой. Это просто, так как в обеих таблицах есть столбец с именами. В
этом запросе выражение <code>WHERE</code> используется для сопоставления записей из
двух таблиц по значениям имен.

<LI>

Так как столбец name присутствует в обеих таблицах, нужно явно
указать, какую именно таблицу вы имеете в виду, ссылаясь на данный
столбец. Это можно сделать, связав имя таблицы с именем столбца.
</ul>

<P>
Для объединения не  обязательно иметь две отдельные таблицы; иногда можно
объединить таблицу с самой собой - если нужно сравнить одни записи таблицы
с другими записями той же таблицы. Например, для того, чтобы обнаружить
среди животных ``семейные пары'', можно объединить таблицу <code>pet</code> с ней
самой, составив пары животных разного пола, но одного вида:

</P>

<pre>
mysql&#62; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -&#62; FROM pet AS p1, pet AS p2
    -&#62; WHERE p1.species = p2.species AND p1.sex = "f" AND p2.sex = "m";
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
</pre>

<P>
В этом запросе мы указываем псевдонимы имен таблицы, для обращения к
столбцам и определения, к какой из таблиц относится каждая ссылка на
столбец.

</P>


<H2><A NAME="Getting_information" HREF="manual.ru_toc.html#Getting_information">3.4  Получение информации о базах данных и таблицах</A></H2>

<P>
<A NAME="IDX409"></A>
<A NAME="IDX410"></A>
<A NAME="IDX411"></A>

</P>
<P>
Как быть, если вы забыли имя базы или таблицы, или структуру какой-либо из
таблиц (например имена столбцов)? В MySQL эта проблема  решается при
помощи нескольких команд, выводящих информацию о базе данных и
содержащихся в ней таблицах.

</P>
<P>
Вы уже познакомились с командой <code>SHOW DATABASES</code>, выводящей список
управляемых сервером баз данных. Определить, какая из них выбрана в данный
момент, можно с помощью функции <code>DATABASE()</code>:

</P>

<pre>
mysql&#62; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</pre>

<P>
Если ни одна из баз не выбрана, результат будет пуст.

</P>
<P>
Выяснить, какие таблицы содержит текущая база данных (что необходимо,
если, например, никак не получается вспомнить имя нужной таблицы), можно
при помощи следующей команды:

</P>

<pre>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</pre>

<P>
Узнать структуру таблицы можно при помощи команды <code>DESCRIBE</code>, которая
выводит информацию о каждом из столбцов таблицы:

</P>

<pre>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre>

<P>
<code>Field</code> - имя столбца, <code>Type</code> - тип данных, к которому относится этот столбец,
<code>NULL</code> указывает, может ли данный столбец содержать значения <code>NULL</code>, Key -
является ли этот столбец индексным, и, наконец, <code>Default</code> указывает значение
данного столбца по умолчанию.

</P>
<P>
Если для таблицы созданы индексы, информацию о них можно получить с
помощью команды <code>SHOW INDEX FROM tbl_name</code>.

</P>



<H2><A NAME="Examples" HREF="manual.ru_toc.html#Examples">3.5  Примеры стандартных запросов</A></H2>

<P>
<A NAME="IDX412"></A>
<A NAME="IDX413"></A>

</P>
<P>
Здесь представлены примеры решения некоторых стандартных задач средствами
MySQL.

</P>
<P>
В некоторых из примеров используется таблица <code>shop</code> (магазин), в которой
содержатся цены по каждому изделию (<code>item number</code>)для определенных
продавцов (<code>dealer</code>). Предположим, что каждый продавец имеет одну
фиксированную цену для каждого изделия; тогда пара изделие-продавец
(<code>article, dealer</code>) является первичным ключом для записей таблицы.

</P>
<P>
Запустите клиента <code>mysql</code>:

</P>

<pre>
mysql имя-вашей-базы-данных
</pre>

<P>
(Для большинства инсталляций MySQL можно использовать базу данных '<code>test</code>'.)

</P>
<P>
Таблицу примера можно создать таким образом:

</P>


<pre>
CREATE TABLE shop (
 article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
 dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
 price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
 PRIMARY KEY(article, dealer));

INSERT INTO shop VALUES
(1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),(3,'C',1.69),
(3,'D',1.25),(4,'D',19.95);
</pre>

<P>
Ну и, скажем, данные для примера будут такими:

</P>

<pre>
mysql&#62; SELECT * FROM shop;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre>



<H3><A NAME="example-Maximum-column" HREF="manual.ru_toc.html#example-Maximum-column">3.5.1  Максимальное значение столбца</A></H3>

<P>
"Как определить наибольшее значение в столбце?"

</P>

<pre>
SELECT MAX(article) AS article FROM shop

+---------+
| article |
+---------+
|       4 |
+---------+
</pre>



<H3><A NAME="example-Maximum-row" HREF="manual.ru_toc.html#example-Maximum-row">3.5.2  Строка, содержащая максимальное значение некоторого столбца</A></H3>

<P>
"Как определить номер, дилера и цену самого дорогого изделия?"

</P>
<P>
В ANSI SQL (и MySQL 4.1) это легко делается при помощи вложенного запроса:

</P>

<pre>
SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop)
</pre>

<P>
В версиях MySQL до 4.1 такая задача выполняется в два этапа:

</P>

<ol>
<LI>

Следует получить максимальное значение цены из таблицы при помощи
оператора SELECT.

<LI>

Используя это значение, необходимо составить следующий запрос:


<pre>
SELECT article, dealer, price
FROM   shop
WHERE  price=19.95
</pre>

</ol>

<P>
Существует еще одно решение: отсортировать все строки по убыванию цен и
после этого получить первую строку, используя специальный оператор <code>LIMIT</code>:

</P>

<pre>
SELECT article, dealer, price
FROM   shop
ORDER BY price DESC
LIMIT 1
</pre>

<P>
<strong>Примечание:</strong> если существует несколько самых дорогих изделий (например,
каждое из них стоит 19,95), запрос, использующий <code>LIMIT</code>, возвращает лишь
одно из них!

</P>


<H3><A NAME="example-Maximum-column-group" HREF="manual.ru_toc.html#example-Maximum-column-group">3.5.3  Максимальное значение столбца для группы</A></H3>

<P>
"Как определить наибольшую цену по каждому изделию?"

</P>

<pre>
SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</pre>



<H3><A NAME="example-Maximum-column-group-row" HREF="manual.ru_toc.html#example-Maximum-column-group-row">3.5.4  Строка, содержащая максимальное значение некоторого столбца</A></H3>

<P>
"Для каждого изделия, как определить дилер(ов) с самыми высокими ценами?"

</P>
<P>
В ANSI SQL (и MySQL 4.1) это легко делается при помощи вложенного запроса:

</P>

<pre>
SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
</pre>

<P>
В MySQL до 4.1 такая задача выполняется в два этапа:

</P>

<ol>
<LI>

Следует получить список (изделие, максимальная цена)

<LI>

Для каждого изделия, получить соответствующие записи, в которых цена соответствует 
максимальной. 
</ol>

<P>
Это легко делается с помощью временной таблицы: 

</P>


<pre>
CREATE TEMPORARY TABLE tmp (
        article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
        price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL);

LOCK TABLES shop read;

INSERT INTO tmp SELECT article, MAX(price) FROM shop GROUP BY article;

SELECT shop.article, dealer, shop.price FROM shop, tmp
WHERE shop.article=tmp.article AND shop.price=tmp.price;

UNLOCK TABLES;

DROP TABLE tmp;
</pre>

<P>
Если вы не используете ключевое слово <code>TEMPORARY</code>, вам также следует поставить блокировку
на таблицу <code>tmp</code>.

</P>
<P>
"А можно ли это сделать одним запросом?"

</P>

<P>
Да, но только используя совершенно неэффективный трюк, который я называю "Трюк MAX-CONCAT": 

</P>

<pre>
SELECT article,
       SUBSTRING( MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 7) AS dealer,
  0.00+LEFT(      MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 6) AS price
FROM   shop
GROUP BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre>

<P>
Разумеется, последний пример можно сделать чуть эффективнее, если разбиение катенизированной
строки делать на стороне клиента. 

</P>


<H3><A NAME="example-user-variables" HREF="manual.ru_toc.html#example-user-variables">3.5.5  Использование пользовательских переменных</A></H3>

<P>
В MySQL для хранения результатов, чтобы не держать их во временных
переменных на клиенте, можно применять пользовательские переменные (see section <A HREF="manual.ru_Reference.html#Variables">6.1.4  Переменные пользователя</A>).

</P>
<P>
Например, для того чтобы найти изделия с максимальной или минимальной
ценой, можно выполнить следующие действия:

</P>


<pre>
mysql&#62; SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;
mysql&#62; SELECT * FROM shop WHERE price=@min_price OR price=@max_price;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre>



<H3><A NAME="example-Foreign_keys" HREF="manual.ru_toc.html#example-Foreign_keys">3.5.6  Использование внешних ключей</A></H3>

<P>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>

</P>
<P>
В MySQL 3.23.44 и выше в таблицах <code>InnoDB</code> осуществляется проверка
ограничений целостности внешних ключей (обратитесь к разделам 
section <A HREF="manual.ru_Table_types.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A> и section <A HREF="manual.ru_Introduction.html#ANSI_diff_Foreign_Keys">1.9.4.5  Внешние ключи</A>).

</P>
<P>
Фактически для соединения двух таблиц внешние ключи не нужны.

</P>
<P>
Единственное, что MySQL в настоящее время не осуществляет (в типах таблиц,
отличных от <code>InnoDB</code>), это проверку (<code>CHECK</code>) что ключи, которые вы
используете, действительно существуют в таблице(ах) на которые вы
ссылаетесь, и не удаляет автоматически записи из таблиц с определением
внешних ключей. Если же ключи используются обычным образом, все будет
работать просто чудесно:

</P>


<pre>
CREATE TABLE person (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirt (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);

INSERT INTO person VALUES (NULL, 'Antonio Paz');

INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', LAST_INSERT_ID()),
(NULL, 'dress', 'white', LAST_INSERT_ID()),
(NULL, 't-shirt', 'blue', LAST_INSERT_ID());

INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');

INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', LAST_INSERT_ID()),
(NULL, 'polo', 'red', LAST_INSERT_ID()),
(NULL, 'dress', 'blue', LAST_INSERT_ID()),
(NULL, 't-shirt', 'white', LAST_INSERT_ID());

SELECT * FROM person;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+

SELECT * FROM shirt;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+

SELECT s.* FROM person p, shirt s
 WHERE p.name LIKE 'Lilliana%'
   AND s.owner = p.id
   AND s.color &#60;&#62; 'white';

+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</pre>



<H3><A NAME="Searching_on_two_keys" HREF="manual.ru_toc.html#Searching_on_two_keys">3.5.7  Поиск по двум ключам</A></H3>

<P>
<A NAME="IDX416"></A>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>

</P>
<P>
MySQL пока не осуществляет оптимизации, если поиск производится по двум
различным ключам, которые связаны при помощи оператора <code>OR</code> (поиск по одному
ключу с различными частями <code>OR</code>  оптимизируется хорошо):

</P>

<pre>
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1'
OR  field2_index = '1'
</pre>

<P>
Причина заключается в том, что у нас не было времени, чтобы придумать
эффективный способ обработки этого случая (сравните: обработка оператора
<code>AND</code> теперь работает хорошо)

</P>
<P>
В настоящее время данную проблему очень эффективно можно решить при помощи
временной таблицы. Этот способ оптимизации также хорошо подходит, если вы
запускаете очень сложные запросы, когда SQL-сервер делает оптимизацию в
неправильном порядке.

</P>

<pre>
CREATE TEMPORARY TABLE tmp
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1';
INSERT INTO tmp
SELECT field1_index, field2_index FROM test_table WHERE field2_index = '1';
SELECT * from tmp;
DROP TABLE tmp;
</pre>

<P>
Вышеупомянутый способ выполнения этого запроса - это фактически <code>UNION</code>
(объединение) двух запросов. See section <A HREF="manual.ru_Reference.html#UNION">6.4.1.2  Синтаксис оператора  <code>UNION</code></A>.

</P>


<H3><A NAME="Calculating_days" HREF="manual.ru_toc.html#Calculating_days">3.5.8  Подсчет посещений за день</A></H3>

<P>
<A NAME="IDX419"></A>
<A NAME="IDX420"></A>
<A NAME="IDX421"></A>
<A NAME="IDX422"></A>

</P>
<P>
В этом разделе представлен пример использования групповых побитовых
функций для вычисления дней месяца, когда пользователь заходил на
веб-сайт.

</P>

<pre>
CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL,
             day INT(2) UNSIGNED ZEROFILL);
INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);
SELECT year,month,BIT_COUNT(BIT_OR(1&#60;&#60;day)) AS days FROM t1
       GROUP BY year,month;

Which returns:

+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |    01 |    3 |
| 2000 |    02 |    2 |
+------+-------+------+
</pre>

<P>
Этот запрос подсчитывает, сколько различных дней входит в данную
комбинацию год/месяц, автоматически исключая дублирующиеся значения.

</P>


<H3><A NAME="example-AUTO_INCREMENT" HREF="manual.ru_toc.html#example-AUTO_INCREMENT">3.5.9  Использование атрибута AUTO_INCREMENT</A></H3>

<P>
<A NAME="IDX423"></A>

</P>
<P>
Атрибут <code>AUTO_INCREMENT</code> может использоваться для генерации уникального
идентификатора для новых строк:

</P>

<pre>
CREATE TABLE animals (
             id MEDIUMINT NOT NULL AUTO_INCREMENT,
             name CHAR(30) NOT NULL,
             PRIMARY KEY (id)
             );
INSERT INTO animals (name) VALUES ("dog"),("cat"),("penguin"),
                                  ("lax"),("whale");
SELECT * FROM animals;
</pre>

<P>
Что вернет: 

</P>

<pre>
+----+---------+
| id | name    |
+----+---------+
|  1 | dog     |
|  2 | cat     |
|  3 | penguin |
|  4 | lax     |
|  5 | whale   |
+----+---------+
</pre>

<P>
Вы можете получить <code>AUTO_INCREMENT</code> ключ с помощью функции SQL <code>LAST_INSERT_ID()</code> или
с помощью функции <code>mysql_insert_id()</code> интерфейса C. 

</P>
<P>
Для многострочной вставки, <code>LAST_INSERT_ID()</code>/<code>mysql_insert_id()</code> на самом деле вернут
<code>AUTO_INCREMENT</code> значение для первой вставленной записи. Это сделано для того, чтобы
многострочные вставки можно было повторить на других серверах. 

</P>
<P>
В таблицах <code>MyISAM</code> и <code>BDB</code> можно определить <code>AUTO_INCREMENT</code> для вторичного 
столбца составного ключа. В этом случае значение, генерируемое для 
автоинкрементного столбца, вычисляется как 
<code>MAX(auto_increment_column)+1) WHERE prefix=given-prefix</code>. Столбец с
атрибутом <code>AUTO_INCREMENT</code> удобно использовать, когда данные нужно помещать
в упорядоченные группы.

</P>


<pre>
CREATE TABLE animals (
             grp ENUM('fish','mammal','bird') NOT NULL,
             id MEDIUMINT NOT NULL AUTO_INCREMENT,
             name CHAR(30) NOT NULL,
             PRIMARY KEY (grp,id)
             );
INSERT INTO animals (grp,name) VALUES("mammal","dog"),("mammal","cat"),
                  ("bird","penguin"),("fish","lax"),("mammal","whale");
SELECT * FROM animals ORDER BY grp,id;
</pre>

<P>
Что вернет: 

</P>

<pre>
+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
+--------+----+---------+
</pre>

<P>
Обратите внимание, что в этом случае значение <code>AUTO_INCREMENT</code> будет
использоваться повторно, если в какой-либо группе удаляется строка,
содержащая наибольшее значение <code>AUTO_INCREMENT</code>.

</P>


<H2><A NAME="Batch_mode" HREF="manual.ru_toc.html#Batch_mode">3.6  Использование <code>mysql</code> в пакетном режиме</A></H2>

<P>
<A NAME="IDX424"></A>
<A NAME="IDX425"></A>
<A NAME="IDX426"></A>
<A NAME="IDX427"></A>
<A NAME="IDX428"></A>

</P>
<P>
В предыдущих разделах было показано, как использовать <code>mysql</code> в
интерактивном режиме, вводя запросы и тут же просматривая результаты.
Запускать <code>mysql</code> можно и в пакетном режиме. Для этого нужно собрать все
команды в один файл и передать его на исполнение <code>mysql</code>:

</P>

<pre>
shell&#62; mysql &#60; batch-file
</pre>

<P>
Если вы работаете с <code>mysql</code> в ОС Windows, и некоторые из специальных
символов, содержащихся в пакетном файле, могут вызвать проблемы,
воспользуйтесь следующей командой:

</P>

<pre>
dos&#62; mysql -e "source batch-file"
</pre>

<P>
Если необходимо указать параметры соединения в командной строке, она может
иметь следующий вид:

</P>

<pre>
shell&#62; mysql -h host -u user -p &#60; batch-file
Enter password: ********
</pre>

<P>
Работая с <code>mysql</code> таким образом, вы, в сущности, создаете сценарий и затем
исполняете его.

</P>
<P>
Если нужно продолжать обработку сценария даже при обнаружении в нем
ошибок, воспользуйтесь параметром командной строки <code>--force</code>.

</P>
<P>
Зачем вообще нужны сценарии? Причин тому несколько:

</P>

<ul>
<LI>

При необходимости частого (ежедневного или хотя бы еженедельного)
запуска одного и того же запроса сценарий позволяет избавиться от
многократного набора этого запроса.

<LI>

Можно создавать новые запросы, подобные уже существующим, просто
копируя и затем изменяя файлы сценариев.

<LI>

Пакетный режим может пригодиться и при разработке особенно длинных
запросов, а именно - многострочных команд или больших
последовательностей команд. В таком деле одна допущенная ошибка может
привести к необходимости повторного набора большого количества текста.
Зато при работе со сценарием легко исправить ошибку  и запустить
запрос на повторное исполнение.

<LI>

Если ваш запрос выводит на экран много текста, его можно просмотреть
постранично, не мучаясь догадками относительно убежавшей за край
экрана части результатов:


<pre>
shell&#62; mysql &#60; batch-file | more
</pre>

<LI>

Выводимые запросом результаты можно сохранить в файле для последующей
обработки:


<pre>
shell&#62; mysql &#60; batch-file &#62; mysql.out
</pre>

<LI>

Свой сценарий вы можете дать кому-нибудь еще, чтобы он тоже мог
воспользоваться содержащимися в сценарии командами.

<LI>

В некоторых случаях работать в интерактивном режиме просто не
получается. И здесь без пакетного режима не обойтись.
</ul>

<P>
По умолчанию при работе с <code>mysql</code> в пакетном режиме используется более
сжатый формат вывода результатов, чем при интерактивной работе. В
интерактивном режиме результаты работы запроса <code>SELECT DISTINCT species
FROM pet</code> выглядят так:

</P>


<pre>
+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</pre>

<P>
А в пакетном - вот так:

</P>

<pre>
species
bird
cat
dog
hamster
snake
</pre>

<P>
Если вам нужно, чтобы в пакетном режиме программа выводила данные так же,
как и в интерактивном, воспользуйтесь ключом <code>mysql -t</code>. Включить "эхо"
исполняемых команд можно с помощью ключа <code>mysql -vvv</code>.

</P>
<P>
В командную строку <code>mysql</code> можно включать и сценарии - при помощи команды
<code>source</code>:

</P>

<pre>
mysql&#62; source filename;
</pre>



<H2><A NAME="Twin" HREF="manual.ru_toc.html#Twin">3.7  Запросы проекта "Близнецы" (Twin Project)</A></H2>

<P>
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>

</P>
<P>
В Analytikerna и Lentus мы проводили сбор и систематизацию данных в рамках
крупного исследовательского проекта. Этот проект разрабатывается совместно
Институтом экологической медицины Karolinska Institutet, Стокгольм и
отделением клинических исследований в области старения и психологии
университета Южной Калифорнии.

</P>
<P>
В проекте предусмотрен этап опросов, на котором происходит опрос по
телефону всех проживающих в Швеции близнецов старше 65 лет. Близнецы,
отвечающие критериям отбора, переходят на следующий этап. На этом этапе
желающих участвовать в проекте близнецов посещает врач с медсестрой.
Проводятся физические и нейропсихологические исследования, лабораторные
анализы, неврологическое обследование, оценка психологического состояния,
а также собираются данные по истории семьи. Кроме того, осуществляется
сбор информации о медицинских и экологических факторах риска.

</P>
<P>
Дополнительную информацию о проекте вы можете получить по адресу:
<a HREF="http://www.imm.ki.se/TWIN/TWINUKW.HTM">http://www.imm.ki.se/TWIN/TWINUKW.HTM</a>

</P>
<P>
На поздних этапах администрирование проекта осуществляется с помощью
web-интерфейса, написанного на <code>Perl</code> и <code>MySQL</code>.

</P>
<P>
Каждую ночь собранные во время интервью данные заносятся в базу данных
MySQL.

</P>



<H3><A NAME="Twin_pool" HREF="manual.ru_toc.html#Twin_pool">3.7.1  Поиск нераспределенных близнецов</A></H3>

<P>
Этот запрос определяет, которые из близнецов переходят во второй этап
проекта:

</P>

<pre>
SELECT
        CONCAT(p1.id, p1.tvab) + 0 AS tvid,
        CONCAT(p1.christian_name, " ", p1.surname) AS Name,
        p1.postal_code AS Code,
        p1.city AS City,
        pg.abrev AS Area,
        IF(td.participation = "Aborted", "A", " ") AS A,
        p1.dead AS dead1,
        l.event AS event1,
        td.suspect AS tsuspect1,
        id.suspect AS isuspect1,
        td.severe AS tsevere1,
        id.severe AS isevere1,
        p2.dead AS dead2,
        l2.event AS event2,
        h2.nurse AS nurse2,
        h2.doctor AS doctor2,
        td2.suspect AS tsuspect2,
        id2.suspect AS isuspect2,
        td2.severe AS tsevere2,
        id2.severe AS isevere2,
        l.finish_date
FROM
        twin_project AS tp
        /* For Twin 1 */
        LEFT JOIN twin_data AS td ON tp.id = td.id
                  AND tp.tvab = td.tvab
        LEFT JOIN informant_data AS id ON tp.id = id.id
                  AND tp.tvab = id.tvab
        LEFT JOIN harmony AS h ON tp.id = h.id
                  AND tp.tvab = h.tvab
        LEFT JOIN lentus AS l ON tp.id = l.id
                  AND tp.tvab = l.tvab
        /* For Twin 2 */
        LEFT JOIN twin_data AS td2 ON p2.id = td2.id
                  AND p2.tvab = td2.tvab
        LEFT JOIN informant_data AS id2 ON p2.id = id2.id
                  AND p2.tvab = id2.tvab
        LEFT JOIN harmony AS h2 ON p2.id = h2.id
                  AND p2.tvab = h2.tvab
        LEFT JOIN lentus AS l2 ON p2.id = l2.id
                  AND p2.tvab = l2.tvab,
        person_data AS p1,
        person_data AS p2,
        postal_groups AS pg
WHERE
        /* p1 gets main twin and p2 gets his/her twin. */
        /* ptvab is a field inverted from tvab */
        p1.id = tp.id AND p1.tvab = tp.tvab AND
        p2.id = p1.id AND p2.ptvab = p1.tvab AND
        /* Just the sceening survey */
        tp.survey_no = 5 AND
        /* Skip if partner died before 65 but allow emigration (dead=9) */
        (p2.dead = 0 OR p2.dead = 9 OR
         (p2.dead = 1 AND
          (p2.death_date = 0 OR
           (((TO_DAYS(p2.death_date) - TO_DAYS(p2.birthday)) / 365)
            &#62;= 65))))
        AND
        (
        /* Twin is suspect */
        (td.future_contact = 'Yes' AND td.suspect = 2) OR
        /* Twin is suspect - Informant is Blessed */
        (td.future_contact = 'Yes' AND td.suspect = 1
                                   AND id.suspect = 1) OR
        /* No twin - Informant is Blessed */
        (ISNULL(td.suspect) AND id.suspect = 1
                            AND id.future_contact = 'Yes') OR
        /* Twin broken off - Informant is Blessed */
        (td.participation = 'Aborted'
         AND id.suspect = 1 AND id.future_contact = 'Yes') OR
        /* Twin broken off - No inform - Have partner */
        (td.participation = 'Aborted' AND ISNULL(id.suspect)
                                      AND p2.dead = 0))
        AND
        l.event = 'Finished'
        /* Get at area code */
        AND SUBSTRING(p1.postal_code, 1, 2) = pg.code
        /* Not already distributed */
        AND (h.nurse IS NULL OR h.nurse=00 OR h.doctor=00)
        /* Has not refused or been aborted */
        AND NOT (h.status = 'Refused' OR h.status = 'Aborted'
        OR h.status = 'Died' OR h.status = 'Other')
ORDER BY
        tvid;
</pre>

<P>
Дадим к этому запросу некоторые пояснения:

</P>
<DL COMPACT>

<DT><code>CONCAT(p1.id, p1.tvab) + 0 AS tvid</code>
<DD>
Сортируем по взаимосвязи <code>id</code> и <code>tvab</code> в числовом порядке. Прибавление нуля к
результату заставляет MySQL обращаться с результатом как с числом.

<DT>column <code>id</code>
<DD>
Определяет пару близнецов. Является ключевым полем всех таблиц.

<DT>column <code>tvab</code>
<DD>
Определяет близнеца в паре. Принимает значение 1 или 2.

<DT>column <code>ptvab</code>
<DD>
Отрицание <code>tvab</code>. Если значение <code>tvab</code> равно 1, значение этого поля - 2, и
наоборот. Данное поле облегчает MySQL задачу оптимизации запроса и
экономит время ввода данных.
</DL>

<P>
Этот запрос иллюстрирует, помимо всего прочего, сравнение значений одной
таблицы с помощью команды <code>JOIN (p1 и p2)</code>. В этом примере таким образом
проверяется, не умер ли один из близнецов до достижения им 65-летнего
возраста. Если так и произошло, строка не попадает в список возвращаемых.

</P>
<P>
Все вышеприведенные поля имеются во всех таблицах, в которых хранится
относящаяся к близнецам информация. Ключевыми полями для ускорения работы
запросов назначены <code>id,tvab</code> (во всех таблицах), а также <code>id,ptvab
(person_data)</code>.

</P>
<P>
На нашем рабочем компьютере (200МГц UltraSPARC) этот запрос возвращает
150-200 строк, и его выполнение занимает менее секунды.

</P>
<P>
Текущее количество строк в таблицах, использовавшихся выше:
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Таблица</strong> </TD><TD> <strong>Строки</strong>
</TD></TR>
<TR><TD><code>person_data</code> </TD><TD> 71074
</TD></TR>
<TR><TD><code>lentus</code> </TD><TD> 5291
</TD></TR>
<TR><TD><code>twin_project</code> </TD><TD> 5286
</TD></TR>
<TR><TD><code>twin_data</code> </TD><TD> 2012
</TD></TR>
<TR><TD><code>informant_data</code> </TD><TD> 663
</TD></TR>
<TR><TD><code>harmony</code> </TD><TD> 381
</TD></TR>
<TR><TD><code>postal_groups</code> </TD><TD> 100
</TD></TR>
</TABLE>

</P>



<H3><A NAME="Twin_event" HREF="manual.ru_toc.html#Twin_event">3.7.2  Вывод таблицы состояний пар близнецов</A></H3>

<P>
Каждый опрос оканчивается кодом состояния, называющимся <code>event</code>
(``событие''). Приведенный здесь запрос выводит данные обо всех парах
близнецов, объединенные по полю <code>event</code>. Таблица наглядно показывает, с
каким количеством пар близнецов работа полностью завершена, а в каком
количестве пар работа с одним близнецом завершена, а с другим - нет и т.п.

</P>

<pre>
SELECT
        t1.event,
        t2.event,
        COUNT(*)
FROM
        lentus AS t1,
        lentus AS t2,
        twin_project AS tp
WHERE
        /* We are looking at one pair at a time */
        t1.id = tp.id
        AND t1.tvab=tp.tvab
        AND t1.id = t2.id
        /* Just the sceening survey */
        AND tp.survey_no = 5
        /* This makes each pair only appear once */
        AND t1.tvab='1' AND t2.tvab='2'
GROUP BY
        t1.event, t2.event;
</pre>



<H2><A NAME="Apache" HREF="manual.ru_toc.html#Apache">3.8  Использование MySQL совместно с Apache</A></H2>

<P>
<A NAME="IDX431"></A>

</P>
<P>
Существуют программы, позволяющие проводить идентификацию пользователей с
помощью базы данных MySQL, а также записывать журналы в таблицу MySQL.

</P>
<P>
Формат записи журналов Apache можно привести в легко понятную MySQL форму,
введя в файл настроек Apache следующие строки:

</P>

<pre>
LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%&#62;s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
</pre>

<P>
В MySQL же можно сделать примерно следующее:

</P>

<pre>
LOAD DATA INFILE '/local/access_log' INTO TABLE table_name
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
</pre>

<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Installing.html">previous</A>, <A HREF="manual.ru_MySQL_Database_Administration.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
