  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - 9  Расширение MySQL</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Clients.html">previous</A>, <A HREF="manual.ru_Problems.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Extending_MySQL" HREF="manual.ru_toc.html#Extending_MySQL">9  Расширение MySQL</A></H1>



<H2><A NAME="MySQL_internals" HREF="manual.ru_toc.html#MySQL_internals">9.1  Внутреннее устройство MySQL</A></H2>

<P>
<A NAME="IDX1687"></A>
<A NAME="IDX1688"></A>
<A NAME="IDX1689"></A>

</P>
<P>
В этом разделе рассматривается многое из того, что необходимо знать при
работе над кодом MySQL. Если вы намерены принять участие в разработке
MySQL, желаете получить доступ к самому последнему промежуточному коду
версий или просто хотите

</P>
<P>
оставаться в курсе процесса разработки, необходимо выполнять инструкции из
раздела See section <A HREF="manual.ru_Installing.html#Installing_source_tree">2.3.4  Установка из экспериментального набора исходных кодов</A>. Тем, кого интересует
внутреннее устройство MySQL, следует подписаться на наш список рассылки
<code>internals</code>. Активность этого списка сравнительно невысока. За подробностями
относительно подписки, пожалуйста, обращайтесь к разделу See section <A HREF="manual.ru_Introduction.html#Mailing-list">1.8.1.1  Списки рассылки MySQL</A>. Все разработчики из MySQL AB участвуют в списке <code>internals</code>, помогая
другим людям, работающим над кодом MySQL. Не стесняйтесь использовать этот
список как для того, чтобы задавать вопросы по коду, так и для посылки
патчей, которые вы бы хотели приобщить к проекту MySQL!

</P>



<H3><A NAME="MySQL_threads" HREF="manual.ru_toc.html#MySQL_threads">9.1.1  Потоки MySQL</A></H3>

<P>
Сервер создает следующие потоки:

</P>

<ul>

<LI>

Поток TCP/IP-соединений обрабатывает все запросы подключения и создает
новые выделенные потоки для проведения аутентификации и обработки SQL
запросов для каждого соединения.

<LI>

В Windows NT есть поток обслуживания именованного канала, который
выполняет ту же работу, что и поток TCP/IP-соединений, но только по
запросам на соединение именованного канала.

<LI>

Поток сигналов обрабатывает все сигналы. Обычно этот поток также
обрабатывает сигналы таймера и обращается к <code>process_alarm()</code> для
принудительного объявления таймаутов на соединениях, которые слишком долго
простаивали.

<LI>

Если <code>mysqld</code> скомпилирован с <code>-DUSE_ALARM_THREAD</code>, то создается выделенный
поток, обрабатывающий сигналы таймера. Используется только в некоторых
системах, в которых возникают проблемы с <code>sigwait()</code>, или если есть
необходимость использовать код <code>thr_alarm()</code> в приложении без выделенного
потока обработки сигналов.

<LI>

Если применяется опция <code>--flush_time=#</code>, то создается выделенный поток для
периодического сбрасывания на диск всех таблиц с заданным интервалом.

<LI>

Каждое соединение имеет свой поток.

<LI>

Каждая отдельная таблица, на которой используется <code>INSERT DELAYED</code>,
получает свой отдельный поток.

<LI>

Если применяется <code>--master-host</code>, то запускается поток репликации
подчиненного сервера для чтения и применения обновлений от головного.
</ul>

<P>
<code>mysqladmin processlist</code> выводит только потоки соединений, <code>INSERT DELAYED</code> и
поток репликации.

</P>


<H3><A NAME="MySQL_test_suite" HREF="manual.ru_toc.html#MySQL_test_suite">9.1.2  Пакет тестирования MySQL</A></H3>

<P>
<A NAME="IDX1690"></A>
<A NAME="IDX1691"></A>

</P>
<P>
До последнего времени наш основной всесторонний пакет для тестирования
основывался на конфиденциальных данных заказчиков и по этой причине не был
общедоступным. Процесс тестирования был открытым только частично -
доступными являлись тест <code>crash-me</code>, содержащийся в каталоге <tt>`sql-bench'</tt> код
оценки производительности на Perl <code>DBI</code>/<code>DBD</code>, и различные тесты,
расположенные в каталоге <tt>`tests'</tt>. Из-за отсутствия стандартизованного
доступного пакета как нашим пользователям, так и разработчикам было сложно
выполнять регрессионные тесты кода MySQL. Чтобы решить эту проблему, мы
создали новую систему тестирования, которая включается в поставку
исходного кода и в двоичную поставку начиная с версии 3.23.29.

</P>
<P>
При помощи текущего набора контрольных тестов нельзя выполнить
всестороннюю проверку MySQL, однако он позволяет обнаружить большинство
очевидных ошибок в коде обработки SQL, проблемы ОС/библиотек, а также
достаточно полно протестировать репликацию. Нашей конечной целью является
создание тестов, охватывающих 100% кода. Мы приветствуем разработки,
дополняющие наш тестовый пакет. Пользователи должны быть заинтересованы в
том, чтобы добавить к этому пакету тесты, исследующие критические для их
систем функциональные возможности, поскольку это будет гарантировать
работу всех будущих версий MySQL с их собственными приложениями.

</P>



<H4><A NAME="running_mysqltest" HREF="manual.ru_toc.html#running_mysqltest">9.1.2.1  Выполнение тестового пакета MySQL</A></H4>

<P>
Система тестирования включает в себя интерпретатор языка тестирования
(<code>mysqltest</code>), shell-сценарий для выполнения всех тестов (<code>mysql-test-run</code>),
сами контрольные тесты, написанные на специальном языке тестирования, и
ожидаемые для них результаты. Чтобы запустить тестовый пакет в системе
после сборки, необходимо, находясь в корне каталога исходных текстов,
ввести <code>make test</code> или <code>mysql-test/mysql-test-run</code>. Если же у вас установлена
бинарная поставка, то следует перейти при помощи <code>cd</code> в корень инсталляции
(например <code>/usr/local/mysql</code>) и выполнить <code>scripts/mysql-test-run</code>. Все тесты
должны пройти успешно. В противном случае следует попробовать отыскать
причину неудачи и, если это ошибка MySQL, сообщить о ней. Обращайтесь  к 
разделу See section <A HREF="manual.ru_Extending_MySQL.html#Reporting_mysqltest_bugs">9.1.2.3  Отчет об ошибках в тестовом пакете MySQL</A>.

</P>
<P>
Если на машине, которую необходимо протестировать, работает экземпляр
<code>mysqld</code>, то останавливать его не обязательно, лишь бы он не использовал
порты <code>9306</code> и <code>9307</code>. Если один из этих портов занят, то нужно
отредактировать <code>mysql-test-run</code> и изменить значения для порта головного
и/или вспомогательного серверов на номер доступного порта.

</P>
<P>
Можно выполнить один отдельный контрольный тест посредством
<code>mysql-test/mysql-test-run test_name</code>.

</P>
<P>
Если один из тестов окончился неуспешно, то чтобы узнать, как обстоит дело
с оставшимися тестами, следует проводить тестирование, запуская
<code>mysql-test-run</code> с опцией <code>--force</code>.

</P>


<H4><A NAME="extending_mysqltest" HREF="manual.ru_toc.html#extending_mysqltest">9.1.2.2  Расширение тестового пакета MySQL</A></H4>

<P>
Для создания собственных контрольных тестов можно использовать язык
<code>mysqltest</code>. К сожалению, полная документация по языку пока еще не написана,
но мы планируем в скором времени это сделать. Можно, однако, обратиться к
имеющимся контрольным тестам и использовать их в качестве примера. В
качестве отправных точек должны служить следующие моменты:

</P>

<ul>
<LI>

Тесты должны быть расположены в <code>mysql-test/t/*.test</code> 

<LI>

Контрольные тесты должны состоять из завершающихся точкой с запятой
<code>;</code> команд и должны соответствовать вводу для клиента командной строки
<code>mysql</code>. Команда по умолчанию является запросом, который предназначен
для посылки серверу MySQL, за исключением тех случаев, когда она
распознается как внутренняя команда (напр. <code>sleep</code>).

<LI>

Все запросы, выдающие результаты, - например <code>SELECT</code>, <code>SHOW</code>, <code>EXPLAIN</code> и
т.д. должны предваряться <code>@/path/to/result/file</code>. Файл должен содержать
ожидаемые результаты. Такой файл результатов можно легко
сгенерировать, запустив <code>mysqltest -r &#60; t/test-case-name.test</code> из
каталога <code>mysql-test</code>, а затем при необходимости можно отредактировать
сгенерированные файлы результатов для подгонки вывода к ожидаемому
виду. В этом случае следует быть особенно внимательным, чтобы не
добавить или удалить каких-либо невидимых символов - внимательно
следите за тем, чтобы только изменялся текст и/или удалялись строки.
Если необходимо вставить строку, то нужно следить за тем, чтобы поля
были разделены символами жесткой табуляции, и такой же символ жесткой
табуляции должен присутствовать в конце. Для проверки того, что
текстовый редактор ничего не напутал в процессе редактирования, может
пригодиться <code>od -c</code>. Мы, конечно, надеемся, что никому не придется
редактировать вывод <code>mysqltest -r</code>, поскольку потребность в этом
возникает только в случае обнаружения ошибки.

<LI>

Чтобы получить соответствие нашей конфигурации, следует разместить
файлы результатов в каталоге <code>mysql-test/r</code> и назвать их
<code>test_name.result</code>. Если тест производит более одного результата,
следует использовать <code>test_name.a.result</code>, <code>test_name.b.result</code> и т.д.

<LI>

Если команда возвращает ошибку, то необходимо в предыдущей строке
указать <code>--error error-number</code>. <code>error-number может</code> быть списком номеров
возможных ошибок, разделенных <code>','</code>.

<LI>

При написании контрольного теста репликации необходимо в первой строке
тестового файла поместить <code>source include/master-slave.inc;</code>. Для
переключения между головным и подчиненным серверами используется
<code>connection master;</code> и <code>connection slave;</code>. Если что-то требуется сделать
на дополнительном соединении, то можно выполнить <code>connection master1</code>;
для головного и <code>connection slave1;</code> для подчиненного.

<LI>

Если необходимо что-либо выполнять в цикле, то можно использовать
нечто в таком духе:


<pre>
let $1=1000;
while ($1)
{
	# здесь выполняются ваши запросы
	dec $1;
}
</pre>

<LI>

Для паузы между запросами используется команда <code>sleep</code>. Она поддерживает
десятые  доли  секунды, таким образом можно, например, делать <code>sleep
1.3;</code> для временной задержки в 1,3 секунды.

<LI>

Чтобы для определенного контрольного теста запускать подчиненный
сервер с дополнительными опциями, нужно поместить эти опции в формате
командной строки в <code>mysql-test/t/test_name-slave.opt</code>. Для головного
сервера опции помещаются в <code>mysql-test/t/test_name-master.opt</code>.

<LI>

Если у вас возникнут вопросы по тестовому пакету или если вы хотите
добавить контрольный тест, шлите e-mail на <a HREF="mailto:internals@lists.mysql.com">internals@lists.mysql.com</a>.
Поскольку в списке не допускаются присоединенные файлы, все нужные
файлы следует положить на: <a HREF="ftp://support.mysql.com/pub/mysql/Incoming/">ftp://support.mysql.com/pub/mysql/Incoming/</a> 
</ul>



<H4><A NAME="Reporting_mysqltest_bugs" HREF="manual.ru_toc.html#Reporting_mysqltest_bugs">9.1.2.3  Отчет об ошибках в тестовом пакете MySQL</A></H4>

<P>
Если используемая версия MySQL не проходит через тестовый пакет, следует
поступать следующим образом:

</P>

<ul>
<LI>

Прежде всего, не отсылайте отчет об ошибке, пока не соберете
максимального количества сведений по проблеме, с которой вы столкнулись!
Большая просьба к вам - используйте для этого сценарий <code>mysqlbug</code>, чтобы мы
имели возможность получить как можно больше информации о вашей системе и
версии MySQL (see section <A HREF="manual.ru_Introduction.html#Bug_reports">1.8.1.3  Как отправлять отчеты об ошибках или проблемах</A>).
<LI>

Проследите за тем, чтобы в отчет был включен вывод <code>mysql-test-run</code>, а
также содержимое всех файлов <code>.reject</code> из каталога <code>mysql-test/r</code>.
<LI>

Если тест из тестового пакета терпит неудачу, проверьте, будет ли он
также неуспешным при выполнении его самого по себе:


<pre>
cd mysql-test
mysql-test-run --local test-name
</pre>

Если тест не проходит, то следует сконфигурировать MySQL с <code>--with-debug</code> и
запустить <code>mysql-test-run</code> с опцией <code>--debug</code>. Если он не пройдет и в этом
случае, следует положить трассировочный файл <tt>`var/tmp/master.trace'</tt> на
<a HREF="ftp://support.mysql.com/pub/mysql/secret">ftp://support.mysql.com/pub/mysql/secret</a>, чтобы мы могли его изучить.
Пожалуйста, не забудьте также включить полное описание используемой
системы, версию исполняемого файла <code>mysqld</code> и описание того, как он был
скомпилирован.
<LI>

Попробуйте также выполнить <code>mysql-test-run</code> с опцией <code>--force</code>, чтобы
выяснить, есть ли еще тесты, которые система не проходит.
<LI>

Если вы компилировали MySQL собственноручно, сверьтесь с нашим
руководством в той его части, где дается описание компиляции MySQL на
используемой платформе или (что более предпочтительно) используйте одну из
откомпилированных нами для вас бинарных поставок
<a HREF="http://www.mysql.com/downloads/">http://www.mysql.com/downloads/</a>. Все наши стандартные бинарные
дистрибутивы должны проходить тестовый пакет!
<LI>

Если получена ошибка, подобная <code>Result length mismatch</code> или <code>Result content
mismatch</code>, то это означает, что нет точного совпадения между выходными
данными теста и контрольными выходными данными. Это может говорить об
ошибке в MySQL или о том, что при некоторых обстоятельствах используемая
версия <code>mysqld</code> выдает слегка отличающиеся результаты. Результаты неудачных
тестов помещаются в файл с тем же именем, что и у файла результатов, но с
расширением <code>.reject</code>. Если контрольный тест терпит неудачу, то по этим двум
файлам следует выполнить <code>diff</code>. Если не удается обнаружить, в чем их
отличия, исследуйте оба файла с помощью <code>od -c</code>, а также проверьте их
размеры.
<LI>

Если тест полностью потерпел фиаско, то для выяснения причины неполадок
следует обратиться к файлам журналов в каталоге <code>mysql-test/var/log</code>.
<LI>

Если MySQL был скомпилирован в отладочном режиме, то можно попробовать
выполнить отладку, запустив <code>mysql-test-run</code> с опциями <code>--gdb</code> и/или <code>-debug</code> 
(see section <A HREF="manual.ru_Porting.html#Making_trace_files">E.1.2  Создание трассировочных файлов</A>). Если MySQL не был скомпилирован для
отладки, то это стоит сделать - просто задайте опции <code>--with-debug</code> для
<code>configure</code>! Обращайтесь к разделу See section <A HREF="manual.ru_Installing.html#Installing_source">2.3  Установка исходного дистрибутива MySQL</A>.
</ul>



<H2><A NAME="Adding_functions" HREF="manual.ru_toc.html#Adding_functions">9.2  Добавление новых функций в MySQL</A></H2>

<P>
<A NAME="IDX1692"></A>
<A NAME="IDX1693"></A>
<A NAME="IDX1694"></A>
<A NAME="IDX1695"></A>
<A NAME="IDX1696"></A>

</P>
<P>
Существует два способа добавления функций в MySQL:

</P>

<ul>
<LI>Можно добавить функцию посредством интерфейса определяемых пользователем

функций (user-definable function - <code>UDF</code>). Определяемые пользователем
функции добавляются и удаляются динамически с помощью команд <code>CREATE
FUNCTION</code> и <code>DROP FUNCTION</code> (see section <A HREF="manual.ru_Extending_MySQL.html#CREATE_FUNCTION">9.2.1  Синтаксис <code>CREATE FUNCTION/DROP FUNCTION</code></A>).

<LI>Можно добавить функцию как ``родную'' (встроенную) функцию MySQL.

``Родные'' функции компилируются вместе с остальным кодом сервера <code>mysqld</code> и
становятся постоянно доступными.
</ul>

<P>
Каждый метод имеет преимущества и недостатки:

</P>

<ul>
<LI>

Если вы пишете определяемую пользователем функцию, то помимо сервера
необходимо инсталлировать объектный файл. В этом нет необходимости при
компиляции функции вместе с сервером.
<LI>

UDFы можно добавить в бинарную поставку MySQL. Для ``родных'' функций
необходимо изменять поставку исходного кода.
<LI>

При обновлении поставки MySQL можно продолжать использовать ранее
инсталлированные UDFы. Для ``родных функций нужно при каждом обновлении
вносить изменения повторно.
</ul>

<P>
Независимо от выбранного метода добавления новых функций, их можно
использовать точно так же, как и встроенные функции, подобные <code>ABS()</code> или
<code>SOUNDEX()</code>.

</P>



<H3><A NAME="CREATE_FUNCTION" HREF="manual.ru_toc.html#CREATE_FUNCTION">9.2.1  Синтаксис <code>CREATE FUNCTION/DROP FUNCTION</code></A></H3>

<P>
<A NAME="IDX1697"></A>
<A NAME="IDX1698"></A>
<A NAME="IDX1699"></A>
<A NAME="IDX1700"></A>
<A NAME="IDX1701"></A>
<A NAME="IDX1702"></A>
<A NAME="IDX1703"></A>

</P>


<pre>
CREATE [AGGREGATE] FUNCTION function_name RETURNS {STRING|REAL|INTEGER}
       SONAME shared_library_name

DROP FUNCTION function_name
</pre>

<P>
Определяемая пользователем функция (UDF) - это средство, позволяющее
расширить MySQL за счет новой функции, которая работает подобно ``родным''
(встроенным) функциям MySQL, таким как <code>ABS()</code> и <code>CONCAT()</code>.

</P>
<P>
<code>AGGREGATE</code> - новая опция для версии MySQL 3.23. <code>AGGREGATE</code> - функция работает
точно так же, как и ``родные'' <code>GROUP</code>-функции MySQL <code>GROUP</code> вроде <code>SUM</code> или
<code>COUNT()</code>.

</P>
<P>
<code>CREATE FUNCTION</code> сохраняет имя, тип и имя разделяемой библиотеки функции в
системной таблице <code>mysql.func</code>. Чтобы создавать и удалять функции,
необходимо обладать привилегиями <code>INSERT</code> и <code>DELETE</code> для базы данных <code>mysql</code>.

</P>
<P>
Все активные функции подгружаются при каждом запуске сервера, за
исключением случая, когда <code>mysqld</code> запускается с опцией <code>--skip-grant-tables</code>.
Тогда инициализация UDF пропускается и UDFы недоступны (активная функция -
это функция, которая была загружена посредством <code>CREATE FUNCTION</code> и не
удалена с помощью <code>DROP FUNCTION</code>).

</P>
<P>
Инструкции по написанию определяемых пользователем функций находятся в
разделе See section <A HREF="manual.ru_Extending_MySQL.html#Adding_functions">9.2  Добавление новых функций в MySQL</A>. Чтобы механизм UDF работал, функции
должны быть написаны на C или C++, используемая операционная система
должна поддерживать динамическую загрузку и <code>mysqld</code> должен быть
скомпилирован динамически (а не статически).

</P>
<P>
Отметим, что для того, чтобы работала <code>AGGREGATE</code>, таблица <code>mysql.func</code> должна
содержать столбец <code>type</code>. В противном случае следует запустить сценарий
<code>mysql_fix_privilege_tables</code>, чтобы внести нужные исправления.

</P>


<H3><A NAME="Adding_UDF" HREF="manual.ru_toc.html#Adding_UDF">9.2.2  Добавление новой определяемой пользователем функции</A></H3>

<P>
<A NAME="IDX1704"></A>
<A NAME="IDX1705"></A>
<A NAME="IDX1706"></A>

</P>

<P>
Для того чтобы работал  механизм UDF, функции должны быть написаны на C
или на C++, а используемая операционная система должна поддерживать
динамическую загрузку. В поставку исходного кода входит файл
<tt>`sql/udf_example.cc'</tt>, в котором определены пять новых функций. К этому файлу
следует обращаться, если нужно узнать, как работает соглашение о вызовах
UDF.

</P>
<P>
Чтобы <code>mysqld</code> имел возможность использовать UDF-функции, необходимо
сконфигурировать MySQL с <code>--with-mysqld-ldflags=-rdynamic</code>. Причина здесь в
том, что на многих платформах (включая Linux) можно загружать динамическую
библиотеку (посредством <code>dlopen()</code>) из статически скомпонованной программы,
получаемой при использовании <code>--with-mysqld-ldflags=-all-static</code>. Если есть
потребность использовать UDF, которой нужно обращаться к символам из
mysqld (как в примере функции <code>methaphone</code> из <tt>`sql/udf_example.cc'</tt>, которая
использует <code>default_charset_info</code>), то программу необходимо компоновать с
<code>-rdynamic</code> (обращайтесь к <code>man dlopen</code>).

</P>
<P>
Для каждой функции, которую предполагается использовать в командах SQL,
следует определять соответствующие функции C (или C++). В дальнейшем в
качестве имени для примера функции мы будем использовать имя xxx. Чтобы
различать применение в SQL и C/C++, для вызова SQL-функции мы будем
использовать обозначение <code>XXX()</code> (прописными), а <code>xxx()</code> (строчными) - для
вызова функции C/C++.

</P>
<P>
Для реализации интерфейса для <code>XXX()</code> требуются следующие функции C/C++:

</P>
<DL COMPACT>

<DT><code>xxx()</code> (обязательная)
<DD>
Главная функция. Она вычисляет результат функции. Соответствие между
типами SQL и возвращаемым типом функции C/C++ показано в приведенной ниже
таблице:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип SQL</strong> </TD><TD> <strong>Тип C/C++</strong>
</TD></TR>
<TR><TD><code>STRING</code> </TD><TD> <code>char *</code>
</TD></TR>
<TR><TD><code>INTEGER</code> </TD><TD> <code>long long</code>
</TD></TR>
<TR><TD><code>REAL</code> </TD><TD> <code>double</code>
</TD></TR>
</TABLE>

<DT><code>xxx_init()</code> (необязательная)
<DD>
Функция инициализации для <code>xxx()</code>. Может быть использована:


<ul>
<LI>

для проверки количества аргументов к <code>XXX()</code>;
<LI>

для проверки того, что аргументы имеют требуемый тип или, в противном
случае, для указания MySQL приводить аргументы к нужным типам при вызове
главной функции;
<LI>

для распределения всей памяти, требуемой основной функцией;
<LI>

для задания максимальной длины результата;
<LI>

для задания (для REAL-функций) максимального числа десятичных знаков
после запятой;
<LI>

для указания, может ли результатом быть NULL.
</ul>

<DT><code>xxx_deinit()</code> (необязательная)
<DD>
Функция деинициализации для <code>xxx()</code>. Должна освобождать всю память,
выделенную функцией инициализации.
</DL>

<P>
При запуске SQL-команды <code>XXX()</code> MySQL вызывает функцию инициализации
<code>xxx_init()</code>, чтобы дать ей возможность выполнить все необходимые установки,
такие как проверка аргументов и распределение памяти. Если <code>xxx_init()</code> 
возвращает ошибку, то выполнение SQL-команды прерывается с сообщением об
ошибке, а главная функция и функция деинициализации не вызываются. В
противном случае для каждой строки вызывается главная функция <code>xxx()</code>. После
того как будут обработаны все строки, вызывается функция деинициализации
<code>xxx_deinit()</code>, чтобы выполнить необходимую очистку.

</P>
<P>
Для агрегатных функций (подобных <code>SUM()</code>) необходимо также подготовить
следующие функции:

</P>
<DL COMPACT>

<DT><code>xxx_reset()</code> (обязательная)
<DD>
Сбрасывает сумму и обрабатывает аргумент как начальное значение для новой
группы.
<DT><code>xxx_add()</code> (обязательная)
<DD>
Добавляет аргумент к имеющейся сумме.
</DL>

<P>
При использовании агрегатных UDF-функций MySQL работает следующим образом:

</P>

<ol>
<LI>

Вызывается <code>xxx_init()</code>, чтобы агрегатная функция могла распределить
память, которая понадобится для хранения результатов.
<LI>

Таблица сортируется в соответствии с выражением <code>GROUP BY</code>.
<LI>

Для первой строки новой группы вызывается функция <code>xxx_reset()</code>.
<LI>

Для каждой новой строки, принадлежащей к той же группе, вызывается
функция <code>xxx_add()</code>.
<LI>

Когда группа меняется, или после завершения обработки последней строки
вызывается <code>xxx()</code> для получения итога.
<LI>

Повторяются шаги 3-5, пока не будут обработаны все строки.
<LI>

Вызывается <code>xxx_deinit()</code>, чтобы UDF могла освободить всю распределенную
ею память.
</ol>

<P>
Все функции должны поддерживать многопоточность (не только главная, но
также и функции инициализации и деинициализации). Это означает, что
непозволительно распределять какие-либо глобальные или статические
переменные с изменяющимися значениями! Если требуется память, то ее
следует распределять в <code>xxx_init()</code> и освобождать в <code>xxx_deinit()</code>.

</P>


<H4><A NAME="UDF_calling" HREF="manual.ru_toc.html#UDF_calling">9.2.2.1  Последовательность вызова UDF для простых функций</A></H4>

<P>
<A NAME="IDX1707"></A>

</P>

<P>
Главная функция должна быть определена, как это показано здесь. Обратите
внимание на то, что тип возвращаемого значения и параметры варьируются в
зависимости от того, как определена SQL-функция <code>XXX()</code> в команде <code>CREATE
FUNCTION</code> - как возвращающая <code>STRING</code>, <code>INTEGER</code> или <code>REAL</code>:

</P>
<P>
Для <code>STRING</code>-функций:

<pre>
char *xxx(UDF_INIT *initid, UDF_ARGS *args,
	  char *result, unsigned long *length,
	  char *is_null, char *error);
</pre>

<P>
Для <code>INTEGER</code>-функций:

<pre>
long long xxx(UDF_INIT *initid, UDF_ARGS *args,
	      char *is_null, char *error);
</pre>

<P>
Для <code>REAL</code>-функций:

<pre>
double xxx(UDF_INIT *initid, UDF_ARGS *args,
	   char *is_null, char *error);
</pre>

<P>
Функции инициализации и деинициализации объявляются следующим образом:

</P>

<pre>
my_bool xxx_init(UDF_INIT *initid, UDF_ARGS *args, char *message);

void xxx_deinit(UDF_INIT *initid);
</pre>

<P>
Параметр <code>initid</code> передается всем трем функциям. Он указывает на структуру
<code>UDF_INIT</code>, используемую для передачи информации между функциями. Поля
структуры <code>UDF_INIT</code> перечислены ниже. Функция инициализации должна
заполнять все поля, которые ей следует изменить (чтобы использовать для
поля значение по умолчанию, его необходимо оставить в неизменном виде):

</P>
<DL COMPACT>

<DT><code>my_bool maybe_null</code>
<DD>
<code>xxx_init()</code> должна устанавливать <code>maybe_null</code> в <code>1</code>, если <code>xxx()</code> может
возвращать <code>NULL</code>. Значение по умолчанию будет <code>1</code>, если хоть один аргумент
объявлен как <code>maybe_null</code>.

<DT><code>unsigned int decimals</code>
<DD>
Количество знаков после запятой. По умолчанию используется максимальное
количество знаков для аргументов, переданных в основную функцию.
(Например, если функции передаются 1,34, 1,345 и 1,3, то значением по
умолчанию будет 3, поскольку 1,345 имеет 3 знака после запятой.

<DT><code>unsigned int max_length</code>
<DD>
Максимальная длина строкового результата. Значение по умолчанию зависит от
типа результата функции. Для строковых функций по умолчанию используется
размер наиболее длинного аргумента. Для целочисленных функций значение по
умолчанию составляет 21 цифру. Для вещественных функций по умолчанию
берется 13 плюс количество знаков после запятой, которое задается
<code>initid-&#62;decimals</code> (для числовых функций длина включает знак и символ
десятичной точки). Если требуется возвращать значение типа <code>BLOB</code>, то поле
можно установить равным либо 65  Kб либо 16  Mб; эта память не
распределяется, а применяется для определения того, какой использовать тип
столбцов, если понадобится временно хранить данные.

<DT><code>char *ptr</code>
<DD>
Указатель, используемый функцией по своему усмотрению. Например, функции
могут применять <code>initid-&#62;ptr</code> для передачи между функциями распределенной
памяти. В <code>xxx_init()</code> память распределяется и назначается этому указателю:


<pre>
initid-&#62;ptr = allocated_memory;
</pre>

В <code>xxx()</code> и <code>xxx_deinit()</code> должны обращаться к <code>initid-&#62;ptr</code> для использования
или освобождения памяти.
</DL>



<H4><A NAME="UDF_aggr._calling" HREF="manual.ru_toc.html#UDF_aggr._calling">9.2.2.2  Последовательность вызова UDF для агрегатных функций</A></H4>

<P>
<A NAME="IDX1708"></A>

</P>
<P>
Ниже приведено описание функций, которые необходимо определить при
создании агрегатной UDF-функции.

</P>

<pre>
char *xxx_reset(UDF_INIT *initid, UDF_ARGS *args,
		char *is_null, char *error);
</pre>

<P>
Эта функция вызывается, когда MySQL находит первую строку в новой группе.
В функции необходимо сбросить все внутренние переменные, в которых
накапливаются значения, и затем установить переданный аргумент как первый
аргумент в группе.

</P>
<P>
Во многих случаях это реализуется путем сброса всех переменных и
последующего вызова <code>xxx_add()</code>.

</P>

<pre>
char *xxx_add(UDF_INIT *initid, UDF_ARGS *args,
	      char *is_null, char *error);
</pre>

<P>
Эта функция вызывается для всех строк, принадлежащих к одной группе, за
исключением первой. В функции к внутренней накопительной переменной
следует добавить значение <code>UDF_ARGS</code>.

</P>
<P>
Функция <code>xxx()</code> должна быть объявлена точно так же, как это делается при
определении простой UDF-функции (see section <A HREF="manual.ru_Extending_MySQL.html#UDF_calling">9.2.2.1  Последовательность вызова UDF для простых функций</A>).

</P>
<P>
Вызов этой функции происходит, когда все строки в группе обработаны.
Обычно функция не должна обращаться к переменной <code>args</code>, а возвращаемое
значение должно базироваться на внутренних накопительных переменных.

</P>
<P>
Какая бы то ни было, обработка аргументов в <code>xxx_reset()</code> и <code>xxx_add()</code> должна
проводиться точно так же, как для нормальных UDF-функций (see section <A HREF="manual.ru_Extending_MySQL.html#UDF_arguments">9.2.2.3  Обработка  аргументов</A>).

</P>
<P>
Организация возврата значений в <code>xxx()</code> эквивалентна  используемой для
нормальной UDF (see section <A HREF="manual.ru_Extending_MySQL.html#UDF_return_values">9.2.2.4  Возвращаемые значения и обработка ошибок</A>).

</P>
<P>
Аргументы-указатели <code>is_null</code> и <code>error</code> одинаковы для всех вызовов
<code>xxx_reset()</code>, <code>xxx_add()</code> и <code>xxx()</code>. Их можно использовать для запоминания
того, что произошла ошибка, или когда функция <code>xxx()</code> должна возвращать
<code>NULL</code>. Заметьте, что сохранять строку в <code>*error</code> нельзя! Это всего лишь
1-байтовый флаг!

</P>
<P>
<code>is_null</code> сбрасывается для каждой группы (перед вызовом <code>xxx_reset()</code>). <code>error</code>
не сбрасывается никогда.

</P>
<P>
Если <code>is_null</code> или <code>error</code> окажется установленным после <code>xxx()</code>, MySQL вернет
<code>NULL</code> в качестве результата групповой функции.

</P>


<H4><A NAME="UDF_arguments" HREF="manual.ru_toc.html#UDF_arguments">9.2.2.3  Обработка  аргументов</A></H4>

<P>
<A NAME="IDX1709"></A>

</P>
<P>
Параметр args указывает на структуру UDF_ARGS, содержащую перечисленные
ниже поля:

</P>
<DL COMPACT>

<DT><code>unsigned int arg_count</code>
<DD>
Количество аргументов. Это значение следует проверять в функции
инициализации, если необходимо, чтобы функция вызывалась с определенным
количеством аргументов. Например:


<pre>
if (args-&#62;arg_count != 2)
{
	strcpy(message,"XXX() requires two arguments");
	return 1;
}
</pre>

<DT><code>enum Item_result *arg_type</code>
<DD>
Тип для каждого аргумента. Возможные  значения  типа: <code>STRING_RESULT</code>,
<code>INT_RESULT</code> и <code>REAL_RESULT</code>. Чтобы контролировать принадлежность аргументов к
нужному типу и возвращать ошибку, если это не так, следует проверить
массив <code>arg_type</code> в функции инициализации. Например:


<pre>
if (args-&#62;arg_type[0] != STRING_RESULT ||
args-&#62;arg_type[1] != INT_RESULT)
{
	strcpy(message,"XXX() requires a string and an integer");
	return 1;
}
</pre>

В качестве альтернативы требованию, чтобы аргументы были определенного
типа, можно использовать функцию инициализации для назначения элементам
<code>arg_type</code> выбранных типов. В этом случае MySQL будет приводить аргументы к
этим типам для каждого вызова <code>xxx()</code>. Например, чтобы указать на приведение
первых двух аргументов к строковому и целочисленному типам, выполните в
<code>xxx_init()</code>:


<pre>
args-&#62;arg_type[0] = STRING_RESULT;
args-&#62;arg_type[1] = INT_RESULT;
</pre>

<DT><code>char **args</code>
<DD>
<code>args-&#62;args</code> передает в функцию инициализации информацию общего характера об
аргументах, с которыми была вызвана функция. Для константного аргумента <code>i</code>
<code>args-&#62;args[i]</code> указывает на значение аргумента (ниже приведены инструкции о
том, как правильно получать доступ к значениям). Для неконстантого
аргумента <code>args-&#62;args[i]</code> есть <code>0</code>. Константный аргумент - это выражение, в
котором используются только константы, вроде <code>3</code> или <code>4*7-2</code> или <code>SIN(3.14)</code>.
Неконстантный аргумент - это выражение, ссылающееся на значения, которые
могут изменяться от строки к строке, такие как имена столбцов или
обращения к функциям с неконстантными аргументами.

Для каждого вызова главной функции <code>args-&#62;args</code> содержит фактические аргументы, переданные для
обрабатываемой в данный момент строки.

Функции могут ссылаться на аргумент <code>i</code> следующим образом:


<ul>
<LI>

Аргумент типа <code>STRING_RESULT</code> передается в виде указателя на строку плюс
длина, чтобы обеспечить обработку двоичных данных или данных произвольной
длины. Содержимое строки доступно посредством <code>args-&#62;args[i]</code>, а длина
строки представляет собой <code>args-&#62;lengths[i]</code>. Не следует исходить из
предположения, что символ <code>\0</code> отмечает конец строки.
<LI>

Для аргумента типа <code>INT_RESULT</code> необходимо привести <code>args-&#62;args[i]</code> к
значению типа <code>long long</code>:


<pre>
long long int_val;
int_val = *((long long*) args-&#62;args[i]);
</pre>

<LI>

Для аргумента типа <code>REAL_RESULT</code> необходимо привести <code>args-&#62;args[i]</code> к
значению типа <code>double</code>:


<pre>
double real_val;
real_val = *((double*) args-&#62;args[i]);
</pre>

</ul>

<DT><code>unsigned long *lengths</code>
<DD>
Для функции инициализации массив <code>lengths</code> указывает максимальную длину
строки для каждого аргумента. Изменять этот массив нельзя. При каждом
вызове главной функции <code>lengths</code> содержит фактические длины всех строковых
аргументов, переданных для обрабатываемой в текущий момент строки. Для
типов аргументов <code>INT_RESULT</code> или <code>REAL_RESULT</code> <code>lengths</code> также содержит
максимальную длину аргумента (как для функции инициализации).
</DL>



<H4><A NAME="UDF_return_values" HREF="manual.ru_toc.html#UDF_return_values">9.2.2.4  Возвращаемые значения и обработка ошибок</A></H4>

<P>
<A NAME="IDX1710"></A>
<A NAME="IDX1711"></A>
<A NAME="IDX1712"></A>

</P>
<P>
Функция инициализации должна возвращать <code>0</code>, если ошибок нет, и <code>1</code> в
противном случае. Если происходит ошибка, <code>xxx_init()</code> должна поместить
сообщение об ошибке с завершающим <code>'\0'</code> в параметр message. Сообщение будет
возвращено клиенту. Буфер сообщения имеет длину <code>MYSQL_ERRMSG_SIZE</code>
символов, но надо стараться, чтобы сообщение не превышало 80 символов -
для соответствия  ширине стандартного экрана терминала.

</P>
<P>
Возвращаемое главной функцией <code>xxx()</code> значение является значением функции
для функций <code>long long</code> и <code>double</code>. Строковые функции должны возвращать
указатель на результат и помещать длину строки в аргумент <code>length</code>.

</P>
<P>
Эти величины следует устанавливать равными содержимому и длине
возвращаемого значения. К  примеру:

</P>

<pre>
memcpy(result, "result string", 13);
*length = 13;
</pre>

<P>
Размер буфера <code>result</code>,  передаваемого вычислительной функции, составляет
255 байтов. Если этого достаточно для полученного результата, то о
распределении памяти для результатов беспокоиться нечего.

</P>
<P>
Если строковая функция должна возвращать строку длиннее, чем 255 байтов,
то для строки необходимо выделять память с помощью <code>malloc()</code> в функции
<code>xxx_init()</code> или в <code>функции xxx()</code> и освобождать ее в функции <code>xxx_deinit()</code>.
Указатель на распределенную память можно сохранить в поле <code>ptr</code> структуры
<code>UDF_INIT</code>, чтобы в последующих вызовах <code>xxx()</code> использовать эту память
повторно (see section <A HREF="manual.ru_Extending_MySQL.html#UDF_calling">9.2.2.1  Последовательность вызова UDF для простых функций</A>.

</P>
<P>
Чтобы указать в главной функции на возврат значения <code>NULL</code>, <code>is_null</code>
устанавливается в <code>1</code>:

</P>

<pre>
*is_null = 1;
</pre>

<P>
Чтобы указать в главной функции на возврат ошибки, в <code>1</code> устанавливается
параметр <code>error</code>:

</P>

<pre>
*error = 1;
</pre>

<P>
Если <code>xxx()</code> устанавливает для какой-либо строки <code>*error</code> в <code>1</code>, то значение
функции будет <code>NULL</code> для этой и всех последующих строк, обрабатываемых
командой, в которой вызывается <code>XXX()</code> (для последующих строк <code>xxx()</code> даже не
будет вызываться). <strong>Примечание</strong>: в версиях MySQL до 3.22.10 было необходимо
устанавливать как <code>*error</code> так и <code>*is_null</code>:

</P>

<pre>
*error = 1;
*is_null = 1;
</pre>



<H4><A NAME="UDF_compiling" HREF="manual.ru_toc.html#UDF_compiling">9.2.2.5  Компиляция и установка определяемых пользователем функций</A></H4>

<P>
<A NAME="IDX1713"></A>
<A NAME="IDX1714"></A>

</P>
<P>
Файлы, реализующие UDFы, должны компилироваться и устанавливаться на
машине, где работает сервер. Эта процедура описана ниже для файла примеров
UDF <tt>`udf_example.cc'</tt>, входящего в поставку исходного кода MySQL. Данный файл
содержит следующие функции:

</P>

<ul>
<LI>

<code>metaphon()</code> возвращает <code>metaphon</code>-строку для строкового аргумента. Эта
строка в общем напоминает <code>soundex</code>-строку, но более приспособлена для
английского языка.
<LI>

<code>myfunc_double()</code> возвращает отношение суммы ASCII-значений символов своих
аргументов к суммарной длине аргументов.
<LI>

<code>myfunc_int()</code> возвращает суммарную длину своих аргументов.
<LI>

<code>sequence([const int])</code> возвращает последовательность, начиная с заданного
номера, либо с 1, если номер не задан.
<LI>

<code>lookup()</code> возвращает IP-адрес для имени удаленного компьютера.
<LI>

<code>reverse_lookup()</code> возвращает имя удаленного компьютера для IP-адреса.
Функция может вызываться для строки <code>"xxx.xxx.xxx.xxx"</code> либо для четырех
чисел.
</ul>

<P>
Динамически загружаемый файл должен компилироваться как разделяемый
объектный файл с помощью команды следующего вида:

</P>

<pre>
shell&#62; gcc -shared -o udf_example.so myfunc.cc
</pre>

<P>
Корректные опции компилятора для своей системы можно легко получить,
запустив следующую команду в каталоге <tt>`sql'</tt> дерева исходных текстов MySQL:

</P>

<pre>
shell&#62; make udf_example.o
</pre>

<P>
Следует выполнить команду компиляции, подобную приведенной выше <code>make</code>, с
той разницей, что надо удалить опцию <code>-c</code> ближе к концу строки и добавить <code>-o</code> 
<tt>`udf_example.so'</tt> в конце строки (в некоторых системах, возможно, <code>-c</code> придется
оставить в команде).

</P>
<P>
После компиляции разделяемого объектного файла, содержащего UDFы, следует
установить его и дать о нем знать MySQL. В результате компиляции
разделяемого объектного модуля из <tt>`udf_example.cc'</tt> получается файл с именем
наподобие <tt>`udf_example.so'</tt> (точное имя может на разных платформах может быть
различным). Скопируйте этот файл в какой-нибудь просматриваемый <code>ld</code>
каталог, вроде <tt>`/usr/lib'</tt>. Во многих системах можно устанавливать переменную
окружения <code>LD_LIBRARY</code> или <code>LD_LIBRARY_PATH</code> для указания каталога, в котором
размещены файлы UDF-функций. В руководстве по <code>dlopen</code> указывается, какую
переменную следует использовать в данной системе. Необходимо сделать
соответствующие установки в скриптах запуска <code>mysql.server</code> или <code>safe_mysqld</code> и перезапустить
<code>mysqld</code>.

</P>
<P>
После установки библиотеки следует уведомить <code>mysqld</code> о новых функциях
следующими командами:

</P>

<pre>
mysql&#62; CREATE FUNCTION metaphon RETURNS STRING SONAME "udf_example.so";
mysql&#62; CREATE FUNCTION myfunc_double RETURNS REAL SONAME "udf_example.so";
mysql&#62; CREATE FUNCTION myfunc_int RETURNS INTEGER SONAME "udf_example.so";
mysql&#62; CREATE FUNCTION lookup RETURNS STRING SONAME "udf_example.so";
mysql&#62; CREATE FUNCTION reverse_lookup
    -&#62; RETURNS STRING SONAME "udf_example.so";
mysql&#62; CREATE AGGREGATE FUNCTION avgcost
    -&#62; RETURNS REAL SONAME "udf_example.so";
</pre>

<P>
Функции могут быть удалены с помощью <code>DROP FUNCTION</code>:

</P>

<pre>
mysql&#62; DROP FUNCTION metaphon;
mysql&#62; DROP FUNCTION myfunc_double;
mysql&#62; DROP FUNCTION myfunc_int;
mysql&#62; DROP FUNCTION lookup;
mysql&#62; DROP FUNCTION reverse_lookup;
mysql&#62; DROP FUNCTION avgcost;
</pre>

<P>
Команды <code>CREATE FUNCTION</code> и <code>DROP FUNCTION</code> обновляют  системную  таблицу <code>func</code>
в  базе данных <code>mysql</code>. В таблицу записываются имя функции, ее тип и имя
разделяемой библиотеки. Для создания и удаления функций необходимо
обладать привилегиями <code>INSERT</code> и <code>DELETE</code> для базы данных <code>mysql</code>.

</P>
<P>
Недопустимо использовать <code>CREATE FUNCTION</code> для добавления функции, которая
уже была создана. Если необходимо переустановить функцию, ее следует
удалить с помощью <code>DROP FUNCTION</code> и затем переустановить посредством <code>CREATE
FUNCTION</code>. Эти действия приходится выполнять, например, когда компилируется
новая версия данной функции, и надо, чтобы <code>mysqld</code> получил новую версию.
Иначе сервер будет продолжать пользоваться старой версией.

</P>
<P>
Активные функции подгружаются при каждом запуске сервера, за исключением
случая, когда <code>mysqld</code> запускается с опцией <code>--skip-grant-tables</code>. Тогда
инициализация UDF пропускается и UDFы недоступны (активная функция - это
функция, которая была загружена посредством <code>CREATE FUNCTION</code> и не удалена с
помощью <code>DROP FUNCTION</code>).

</P>


<H3><A NAME="Adding_native_function" HREF="manual.ru_toc.html#Adding_native_function">9.2.3  Добавление новых родных функции</A></H3>

<P>
<A NAME="IDX1715"></A>
<A NAME="IDX1716"></A>

</P>
<P>
В этом разделе приведена процедура добавления новой ``родной'' функции.
Следует учитывать, что в бинарную поставку ``родные'' функции добавить
невозможно, поскольку эта процедура требует изменения исходного кода
MySQL. Поэтому необходимо собственноручно компилировать MySQL из поставки
исходного текста. Кроме того, при переходе на другую версию MySQL
(например, при выпуске новой версии) все изменения придется повторить для
этой новой версии.

</P>
<P>
Чтобы добавить новую ``родную'' функцию MySQL, необходимо выполнить
следующие действия:

</P>

<ol>
<LI>

Добавьте в <tt>`lex.h'</tt> одну строку, определяющую имя новой функции в
массиве <code>sql_functions[]</code>.
<LI>

Если прототип функции простой (вообще без аргументов или принимает
один, два или три аргумента), то в <tt>`lex.h'</tt> вторым аргументом в массиве
<code>sql_functions[]</code> следует указать <code>SYM(FUNC_ARG#)</code> (где # количество
аргументов) и добавить в <tt>`item_create.cc'</tt> функцию, создающую объект
функции. В качестве примеров можно рассмотреть <code>ABS</code> и
<code>create_funcs_abs()</code>. Если прототип функции сложный (например,
принимает переменное число аргументов), то следует добавить две
строки в <tt>`sql_yacc.yy'</tt>. Одна строка служит для указания препроцессору,
какой символ должен определить <code>yacc</code> (строку следует добавить в
начало файла). Затем определяются параметры функции и правило
разбора <code>simple_expr</code> пополняется "элементом" с этими параметрами.
Чтобы получить представление о том, как это делается, в качестве
примера просмотрите все вхождения <code>ATAN</code> в <tt>`sql_yacc.yy'</tt>.
<LI>

В <tt>`item_func.h'</tt> объявляется класс, наследуемый от <code>Item_num_func</code> или
<code>Item_str_func</code>, в зависимости от того, какое значение возвращает
функция - числовое или строковое.
<LI>

В <tt>`item_func.cc'</tt> добавьте одно из следующих объявлений, в зависимости
от того, какая функция определяется - числовая или строковая:


<pre>
double Item_func_newname::val()
longlong Item_func_newname::val_int()
String *Item_func_newname::Str(String *str)
</pre>

Если объект наследуется от любого стандартного элемента (подобного
<code>Item_num_func</code>), то, возможно, потребуется определить только одну из
перечисленных выше функций и возложить на родительский объект заботу об
остальных функциях. Например, класс <code>Item_str_func</code> определяет функцию
<code>val()</code>, выполняющую <code>atof()</code> над значением, возвращенным <code>::str()</code>.
<LI>

Возможно, понадобится также определить следующую функцию объекта:


<pre>
void Item_func_newname::fix_length_and_dec()
</pre>

Эта функция должна как минимум вычислять <code>max_length</code> на основе переданных
аргументов. <code>max_length</code> является максимальным количеством символов, которое
может возвращать функция. Эта функция также должна устанавливать
<code>maybe_null = 0</code>, если невозможно, чтобы главная функция возвратила значение
<code>NULL</code>. Узнать, может ли какой-либо аргумент функции возвращать <code>NULL</code>,
функция может путем проверки поля/переменной <code>maybe_null</code> аргумента. В
качестве типичного примера того, как это делается, можно рассмотреть
<code>Item_func_mod::fix_length_and_dec</code>.
</ol>

<P>
Все функции должны поддерживать многопоточность (другими словами,
непозволительно использовать какие-либо глобальные или статические
переменные в функции без их защиты  примитивами взаимного исключения).

</P>
<P>
Если желательно возвращать <code>NULL</code>, из <code>::val()</code>, <code>::val_int()</code> или <code>::str()</code>, то
необходимо устанавливать <code>null_value</code> в <code>1</code> и возвращать <code>0</code>.

</P>
<P>
Для функции объекта <code>::str()</code> существуют следующие дополнительные аспекты:

</P>

<ul>
<LI>

Аргумент <code>String *str</code> обеспечивает строковый буфер, который может быть
использован для размещения результата (дополнительную информацию о типе
<code>String</code> можно найти в файле <tt>`sql_string.h'</tt>).
<LI>

Функция <code>::str()</code> должна возвращать строку, содержащую результат, или
<code>(char*) 0</code>, если результат <code>NULL</code>.
<LI>

На сегодняшний день при написании всех строковых функций принято
избегать какого бы то ни было распределения памяти, за исключением
случаев, когда это абсолютно необходимо!
</ul>



<H2><A NAME="Adding_procedures" HREF="manual.ru_toc.html#Adding_procedures">9.3  Добавление новой процедуры в MySQL</A></H2>

<P>
<A NAME="IDX1717"></A>
<A NAME="IDX1718"></A>
<A NAME="IDX1719"></A>

</P>
<P>
В MySQL, можно определить процедуру на C++, которая обращается к данным в
запросе и изменяет их до того, как они будут посланы клиенту. Изменение
может быть выполнено на построчном уровне, либо на уровне <code>GROUP BY</code>.

</P>
<P>
Чтобы продемонстрировать то, как это можно сделать, мы создали пример
процедуры в версии MySQL 3.23.

</P>
<P>
Дополнительно мы рекомендуем обратить внимание <code>mylua</code>. Располагая <code>mylua</code>,
можно использовать язык <code>LUA</code> для загрузки процедуры в <code>mysqld</code> во время
выполнения.

</P>



<H3><A NAME="procedure_analyse" HREF="manual.ru_toc.html#procedure_analyse">9.3.1  Процедура Analyse</A></H3>

<P>
<code>analyse([max elements,[max memory]])</code> 

</P>
<P>
Эта процедура определена в <tt>`sql/sql_analyse.cc'</tt>. Она исследует результат
запроса и возвращает анализ результатов:

</P>

<ul>
<LI>

<code>max elements</code> (по умолчанию 256) - максимальное число различных значений,
которые analyse будет распознавать в столбце. Аргумент используется
<code>analyse</code> для проверки того, является ли тип <code>ENUM</code> оптимальным типом столбца.
<LI>

<code>max memory</code> (по умолчанию 8192) - максимальное количество памяти, которую
должна выделять <code>analyse</code> для столбца  в процессе поиска всех различных
значений.
</ul>


<pre>
SELECT ... FROM ... WHERE ... PROCEDURE ANALYSE([max elements,[max memory]])
</pre>



<H3><A NAME="Writing_a_procedure" HREF="manual.ru_toc.html#Writing_a_procedure">9.3.2  Написание  процедуры</A></H3>

<P>
На данный момент единственной документацией по этой теме является исходный
код.

</P>
<P>
Всю информацию о процедурах можно найти, изучив следующие файлы:

</P>

<ul>
<LI><tt>`sql/sql_analyse.cc'</tt>

<LI><tt>`sql/procedure.h'</tt>

<LI><tt>`sql/procedure.cc'</tt>

<LI><tt>`sql/sql_select.cc'</tt>

</ul>

<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Clients.html">previous</A>, <A HREF="manual.ru_Problems.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
