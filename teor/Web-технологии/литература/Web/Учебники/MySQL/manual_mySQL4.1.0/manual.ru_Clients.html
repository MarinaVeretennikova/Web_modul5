  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - 8  Интерфейсы для MySQL</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Table_types.html">previous</A>, <A HREF="manual.ru_Extending_MySQL.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Clients" HREF="manual.ru_toc.html#Clients">8  Интерфейсы для MySQL</A></H1>

<P>
<A NAME="IDX1495"></A>
<A NAME="IDX1496"></A>
<A NAME="IDX1497"></A>
<A NAME="IDX1498"></A>
<A NAME="IDX1499"></A>
<A NAME="IDX1500"></A>

</P>

<P>
Эта глава описывает доступные для MySQL интерфейсы, а также разъясняет,
где их можно получить и как их использовать. Интерфейс C API охвачен
наиболее широко, так как он был разработан командой MySQL и является базой
для большинства других интерфейсов.

</P>


<H2><A NAME="PHP" HREF="manual.ru_toc.html#PHP">8.1  Интерфейс PHP  API для MySQL</A></H2>

<P>
<A NAME="IDX1501"></A>
<A NAME="IDX1502"></A>

</P>
<P>
PHP представляет собой серверный язык программирования скриптов со
встраиваемым кодом HTML, который может использоваться для создания
динамических веб-страниц. Он содержит поддержку для доступа к нескольким
базам данных, включая MySQL. PHP может запускаться как отдельная программа
или компилироваться как модуль для использования с веб-сервером Apache.

</P>
<P>
Дистрибутив и документацию можно найти на веб-сайте PHP
(<a HREF="http://www.php.net/">http://www.php.net/</a>).

</P>



<H3><A NAME="PHP_problems" HREF="manual.ru_toc.html#PHP_problems">8.1.1  Общие проблемы MySQL и PHP</A></H3>


<ul>
<LI>Ошибка: "Максимальное время исполнения превышено" ("Maximum Execution

Time Exceeded"). Это ограничение PHP; откройте файл <tt>`php3.ini'</tt> и
измените максимальное время исполнения с 30 секунд на более высокую
величину, такую, какая вам необходима. Есть еще один неплохой способ -
удвоить разрешенный объем оперативной памяти с 8 Мб до 16 Мб на
скрипт.

<LI>Ошибка: "Неисправимая ошибка: Вызов неподдерживаемой или

неопределенной функции mysql_connect() в .." ("Fatal error: Call to
unsupported or undefined function mysql_connect() in ..") Это
означает, что ваша версия PHP не скомпилирована с поддержкой MySQL.
Можно либо скомпилировать динамический модуль MySQL и загрузить его в
PHP, либо перекомпилировать PHP со встроенной поддержкой MySQL. Это
подробно описывается в руководстве по PHP.

<LI>Ошибка: "неопределенная ссылка на `uncompress' (несжатый) "

("undefined reference to `uncompress'"). Это означает, что данная
клиентская библиотека скомпилирована с поддержкой сжатого
клиент-серверного протокола. Устранение этой проблемы заключается в
добавлении <code>-lz</code> в конце при линковании с <code>-lmysqlclient</code>.
</ul>



<H2><A NAME="Perl" HREF="manual.ru_toc.html#Perl">8.2  Интерфейс Perl  API для MySQL</A></H2>

<P>
<A NAME="IDX1503"></A>

</P>
<P>
Этот раздел снабжает документами для работы с интерфейсом Perl <code>DBI</code>. Более
ранний интерфейс назывался <code>mysqlperl</code>. В настоящее время интерфейс <code>DBI</code>/<code>DBD</code>
является рекомендуемым интерфейсом Perl, так что <code>mysqlperl</code> здесь не
документируется как устаревший.

</P>



<H3><A NAME="DBI_with_DBD" HREF="manual.ru_toc.html#DBI_with_DBD">8.2.1  <code>DBI</code> с помощью <code>DBD::mysql</code></A></H3>

<P>
<A NAME="IDX1504"></A>

</P>
<P>
<code>DBI</code> представляет собой общий интерфейс для многих баз данных. Это
означает, что можно написать скрипт, работающий со многими различными
процессорами баз данных без изменения. При этом для каждого типа базы
данных необходим определенный драйвер (DBD - это абревиатура DataBase 
Driver). Для MySQL этот драйвер называется <code>DBD::mysql</code>.

</P>
<P>
Для более подробной информации об интерфейсе Perl5 DBI, пожалуйста,
посетите веб-страницу <code>DBI</code> и прочитайте документацию:

<pre>
<a HREF="http://dbi.perl.org/">http://dbi.perl.org/</a> 
</pre>

<P>
Для более подробной информации об объектно ориентированном
программировании (OOП), описанном в Perl5, смотрите веб-страницу Perl 
OOP:

<pre>
<a HREF="http://language.perl.com/info/documentation.html">http://language.perl.com/info/documentation.html</a> 
</pre>

<P>
Следует учитывать, что, если вы хотите использовать транзакции с Perl, то
необходимо иметь модуль <code>Msql-Mysql-modules</code> версии 1.2216 или новее.

</P>
<P>
Рекомендуемый модуль для Perl: <code>DBD-mysql-2.1022</code> или новее.

</P>
<P>
Инструкции по установке поддержки Perl в MySQL даются в разделе See section <A HREF="manual.ru_Installing.html#Perl_support">2.7  Замечания по установке Perl</A>.

</P>
<P>
Если у вас уже установлены модули MySQL, то вы можете найти информацию о
специфике функциональности MySQL при помощи одной из следующих команд:

</P>

<pre>
shell&#62; perldoc DBD/mysql
shell&#62; perldoc mysql
</pre>



<H3><A NAME="Perl_DBI_Class" HREF="manual.ru_toc.html#Perl_DBI_Class">8.2.2  Интерфейс <code>DBI</code></A></H3>

<P>
<A NAME="IDX1505"></A>

</P>
<P>
<strong>Унифицированные методы DBI</strong>
 
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Метод</strong> </TD><TD> <strong>Описание</strong>

</TD></TR>
<TR><TD><code>connect</code> </TD><TD> Создает соединение с сервером
</TD></TR>
<TR><TD><code>disconnect</code> </TD><TD> Разрывает соединение с сервером
</TD></TR>
<TR><TD><code>prepare</code> </TD><TD> Готовит SQL-запрос к выполнению
</TD></TR>
<TR><TD><code>execute</code> </TD><TD> Выполняет приготовленный запрос
</TD></TR>
<TR><TD><code>do</code> </TD><TD> Готовит и выполняет запрос
</TD></TR>
<TR><TD><code>quote</code> </TD><TD> Заключает в символы цитирования строки или <code>BLOB</code>-значения, которые вы собираетесь внести
</TD></TR>
<TR><TD><code>fetchrow_array</code> </TD><TD> Возвращает следующую запись как массив
</TD></TR>
<TR><TD><code>fetchrow_arrayref</code> </TD><TD> Возвращает следующую запись как ссылку на массив
</TD></TR>
<TR><TD><code>fetchrow_hashref</code> </TD><TD> Возвращает следующую запись как ссылку на хеш
</TD></TR>
<TR><TD><code>fetchall_arrayref</code> </TD><TD> Возвращает всю информацию как массив массивов
</TD></TR>
<TR><TD><code>finish</code> </TD><TD> Завершает выражение и освобождает системные ресурсы
</TD></TR>
<TR><TD><code>rows</code> </TD><TD> Возвращает количество измененных/удаленных строк
</TD></TR>
<TR><TD><code>data_sources</code> </TD><TD> Возвращает массив, список баз данных, доступных на сервере
</TD></TR>
<TR><TD><code>ChopBlanks</code> </TD><TD> Определяет, будут ли методы <code>fetchrow_*</code> убирать начальные и оконечные пробелы
</TD></TR>
<TR><TD><code>NUM_OF_PARAMS</code> </TD><TD> Количество символов-заполнителей в приготовленном выражении
</TD></TR>
<TR><TD><code>NULLABLE</code> </TD><TD> Возвращает ссылку на массив значений, которые определяют, могут ли столбцы содержать значения <code>NULL</code>. Возможные значения для каждого элемента массива: 0 или пустая строка, если столбец не может быть <code>NULL</code>, 1 - если может, и 2, если статус <code>NULL</code> для столбца неизвестен
</TD></TR>
<TR><TD><code>trace</code> </TD><TD> Производит трассировку для отладки
</TD></TR>
</TABLE>

</P>
<P>
<strong>Методы, определенные только для MySQL</strong>

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Метод</strong> </TD><TD> <strong>Описание</strong>

</TD></TR>
<TR><TD><code>insrtid</code> </TD><TD> Значение <code>AUTO_INCREMENT</code>, которое было присвоено последним
</TD></TR>
<TR><TD><code>is_blob</code> </TD><TD> Какие столбцы имеют тип <code>BLOB</code>
</TD></TR>
<TR><TD><code>is_key</code> </TD><TD> Какие столбцы являются ключами
</TD></TR>
<TR><TD><code>is_num</code> </TD><TD> Какие столбцы имеют числовой тип
</TD></TR>
<TR><TD><code>is_pri_key</code> </TD><TD> Какие столбцы являются первичными ключами
</TD></TR>
<TR><TD><code>is_not_null</code> </TD><TD> Столбцы, которые НЕ МОГУТ иметь значение <code>NULL</code>. См. <code>NULLABLE</code>
</TD></TR>
<TR><TD><code>length</code> </TD><TD> Максимально допустимые размеры содержимого столбцов
</TD></TR>
<TR><TD><code>max_length</code> </TD><TD> Максимальные размеры столбцов, присутствующих в результате
</TD></TR>
<TR><TD><code>NAME</code> </TD><TD> Имена столбцов
</TD></TR>
<TR><TD><code>NUM_OF_FIELDS</code> </TD><TD> Количество полей, возвращенных в результате операции
</TD></TR>
<TR><TD><code>table</code> </TD><TD> Имена таблиц в результате
</TD></TR>
<TR><TD><code>type</code> </TD><TD> Типы всех столбцов
</TD></TR>
</TABLE>

<P>
Более детально методы Perl DBI описаны в следующих разделах. Возвращаемые
переменные:
<DL COMPACT>

<DT><code>$dbh</code>
<DD>
Дескриптор базы данных

<DT><code>$sth</code>
<DD>
Дескриптор выражения

<DT><code>$rc</code>
<DD>
Код возврата (часто статус)

<DT><code>$rv</code>
<DD>
Возвращенное значение (часто количество строк)
</DL>

<P>
<strong>Унифицированные методы DBI</strong>

</P>
<P>
<A NAME="IDX1506"></A>
<A NAME="IDX1507"></A>
<DL COMPACT>

<DT><code>connect($data_source, $username, $password)</code>
<DD>
Метод <code>connect</code> используется для подсоединения к источнику данных
(СУБД). Строка <code>$data_source</code> должна начинаться с <code>DBI:имя драйвера:</code>. Примеры
вызова connect с драйвером <code>DBD::mysql</code>:

<pre>
$dbh = DBI-&#62;connect("DBI:mysql:$database", $user, $password);
$dbh = DBI-&#62;connect("DBI:mysql:$database:$hostname", $user,
		$password);
$dbh = DBI-&#62;connect("DBI:mysql:$database:$hostname:$port", $user,
		$password);
</pre>

Если не определены имя пользователя либо пароль, <code>DBI</code> использует
значения переменных окружения <code>DBI_USER</code> и <code>DBI_PASS</code>. Если не указано имя
хоста, используется значение по умолчанию - <code>localhost</code>. Если не указан
номер порта, также используется   значение по умолчанию (3306).

Начиная с <code>Msql-Mysql-modules</code> версии 1.2009, доступны следующие модификаторы
<code>$data_source</code>:

<DL COMPACT>

<DT><code>mysql_read_default_file=file_name</code>
<DD>
Читать файл <tt>`file_name'</tt> как файл настроек. За более подробной
информацией о файлах настройки обращайтесь к разделу See section <A HREF="manual.ru_MySQL_Database_Administration.html#Option_files">4.1.2  Файлы параметров <tt>`my.cnf'</tt></A>.

<DT><code>mysql_read_default_group=group_name</code>
<DD>
По умолчанию используется группа <code>[client]</code> файла настроек. Опцией
<code>mysql_read_default_group</code>, группа по умолчанию устанавливается в
<code>[group_name]</code>.

<DT><code>mysql_compression=1</code>
<DD>
Использовать сжатие при обмене клиента и сервера (MySQL версий
3.22.3 и выше).

<DT><code>mysql_socket=/path/to/socket</code>
<DD>
Указывает путь к Unix-сокету, который будет использоваться для
соединения с сервером. (MySQL версии 3.21.15 и более поздние).
</DL>

Можно указывать не один модификатор, а несколько; при этом каждый
должен предваряться точкой с запятой.

Например, если вы не хотите явно
указывать имя пользователя и пароль в программе, использующей <code>DBI</code>, можно
внести эту информацию в файл <tt>`~/.my.cnf'</tt>, написав вызов <code>connect</code>. Это
делается следующим образом:

<pre>
$dbh = DBI -&#62; connect("DBI:mysql:$database",
		  ";mysql_read_default_file=$ENV{HOME}/.my.cnf",
  		  $user, $password);
</pre>

Данный пример считает настройки из группы <code>[client]</code> файла <tt>`~/.my.cnf'</tt>.
Чтобы выполнить те же действия, но с настройками, взятыми из группы
<code>[perl]</code>, нужно использовать следующую форму записи:

<pre>
$dbh = DBI -&#62; connect("DBI:mysql:$database",
		  ";mysql_read_default_file=$ENV{HOME}/.my.cnf"
		  . ";mysql_read_default_group=perl",
		  $user, $password);
</pre>

<A NAME="IDX1508"></A>
<A NAME="IDX1509"></A>
<DT><code>disconnect</code>
<DD>
Метод disconnect разрывает соединение с базой данных. Это стоит делать
перед выходом из программы.
Пример:

<pre>
$rc = $dbh-&#62;disconnect;
</pre>

<A NAME="IDX1510"></A>
<A NAME="IDX1511"></A>

<DT><code>prepare($statement)</code>
<DD>
Подготавливает SQL-запрос <code>$statement</code> к исполнению сервером. Возвращает
дескриптор  выражения (<code>$sth</code>), который затем используется для вызова метода
<code>execute</code>. Обычно работа с запросами типа <code>SELECT</code> (так же, как и
аналогичными, такими как <code>SHOW</code>, <code>DESCRIBE</code>, <code>EXPLAIN</code>) сводится к вызову
методов <code>prepare</code> и <code>execute</code>.
Пример:

<pre>
$sth = $dbh -&#62; prepare($statement)
or die "Не  могу  подготовить $statement: $dbh -&#62; errstr\n";
</pre>

Если вы хотите считывать большие результаты вашим клиентом, вы можете указать
использование <code>mysql_use_result()</code> в Perl:


<pre>
my $sth = $dbh-&#62;prepare($statement { "mysql_use_result" =&#62; 1});
</pre>

<A NAME="IDX1512"></A>
<A NAME="IDX1513"></A>
<DT><code>execute</code>
<DD>
Метод <code>execute</code> выполняет приготовленный запрос. Если запрос не <code>SELECT</code>,
метод возвращает количество строк, которые были подверглись воздействию
запроса. Если таковых нет, <code>execute</code> возвращает <code>"0E0"</code>, что Perl
интерпретирует как нуль, но воспринимает как значение ``истина'' (true).
Если возникает ошибка, execute возвращает <code>undef</code>. Для запросов SELECT метод
только инициирует выполнение запроса SQL-сервером и для получения данных
необходимо использовать один из методов <code>fetch_*</code>.
Пример:

<pre>
$rv = $sth -&#62; execute or die "Не могу выполнить: $sth -&#62; errstr";
</pre>

<A NAME="IDX1514"></A>
<A NAME="IDX1515"></A>
<DT><code>do($statement)</code>
<DD>
Метод <code>do</code> готовит SQL-запрос к выполнению, выполняет его и возвращает
количество строк, подвергшихся воздействию. Если  нет ни одной такой
строки, как результат возвращается значение <code>"0E0"</code>, что Perl интерпретирует
как нуль, но воспринимает как значение ``истина'' (true).. Этот метод
обычно используется для выражений, не являющихся операторами <code>SELECT</code>,
которые не могут быть подготовлены заранее (из-за ограничений драйвера)
или же выполняются только один раз (операции вставки, удаления и т.д.).
Например:

<pre>
$rv = $dbh-&#62;do($statement)
or die "Не могу выполнить: $sth -&#62; errstr";
</pre>

Обычно использование 'do' существенно быстрей (и предпочтительней) для
запросов без параметров, чем пара <code>prepare</code>/<code>execute</code>.

<A NAME="IDX1516"></A>
<A NAME="IDX1517"></A>
<A NAME="IDX1518"></A>

<DT><code>quote($string)</code>
<DD>
Метод <code>quote</code> используется для экранирования специальных символов в
запросе символами экранирования, а также заключения данных в необходимые
внешние символы цитирования (например кавычки).
Пример:

<pre>
$sql = $dbh-&#62;quote($string)
</pre>

<A NAME="IDX1519"></A>
<A NAME="IDX1520"></A>
<DT><code>fetchrow_array</code>
<DD>
Этот метод выбирает очередную строку данных и возвращает ее как массив
значений полей.
Пример:

<pre>
while(@row = $sth -&#62; fetchrow_array) {
print qw($row[0]\t$row[1]\t$row[2]\n);
}
</pre>

<A NAME="IDX1521"></A>
<A NAME="IDX1522"></A>
<DT><code>fetchrow_arrayref</code>
<DD>
Этот метод выбирает очередную строку данных и возвращает ссылку на
массив значений полей.
Пример:

<pre>
while($row_ref = $sth -&#62; fetchrow_arrayref) {
print qw($row_ref -&#62; [0]\t$row_ref -&#62; [1]\t$row_ref -&#62;
[2]\n);
}
</pre>

<A NAME="IDX1523"></A>
<A NAME="IDX1524"></A>
<DT><code>fetchrow_hashref</code>
<DD>
Этот метод выбирает строку данных и возвращает ссылку на хеш,
содержащий пары имя/значение. Данный метод намного менее эффективен, чем
использование пописанных выше ссылок на массивы.
Пример:

<pre>
while($hash_ref = $sth -&#62; fetchrow_hashref) {
print qw($hash_ref -&#62; {firstname}\t$hash_ref -&#62;
{lastname}\t$hash_ref -&#62;{title}\n);
}
</pre>

<A NAME="IDX1525"></A>
<A NAME="IDX1526"></A>
<DT><code>fetchall_arrayref</code>
<DD>
Этот метод выдает все данные (все строки), получаемые как результат
SQL-запроса. Он возвращает ссылку на массив ссылок на массивы отдельных
строк. Соответственно, для обращения к этим данным нужно использовать
вложенный цикл.
Пример:

<pre>
my $table = $sth -&#62; fetchall_arrayref
or die "$sth -&#62; errstr\n";
my($i, $j);
for $i ( 0 .. $#{$table}} ) {
for $j ( 0 .. $#{$table -&#62; [$i]} )  {
print "$table -&#62; [$i][$j]\t";
}
print "\n";
}
</pre>

<A NAME="IDX1527"></A>
<A NAME="IDX1528"></A>
<DT><code>finish</code>
<DD>
Указывает, что данные этого дескриптора запроса больше не нужны. После
вызова этого метода программа освобождает дескриптор запроса и все
системные ресурсы, которые используются для работы с ним.
Пример:

<pre>
$rc = $sth -&#62; finish;
</pre>

<A NAME="IDX1529"></A>
<A NAME="IDX1530"></A>
<DT><code>rows</code>
<DD>
Возвращает число измененных/удаленных последней командой (<code>UPDATE</code>,
<code>DELETE</code> и т.д.) строк. Это обычно требуется после выполнения метода <code>execute</code>
над запросами, не являющимися запросами <code>SELECT</code>.
Например:

<pre>
$rv = $sth -&#62; rows;
</pre>

<A NAME="IDX1531"></A>
<A NAME="IDX1532"></A>
<DT><code>NULLABLE</code>
<DD>
Возвращает ссылку на массив значений, которые указывают, может столбец
принимать значения <code>NULL</code> или нет. Возможные значения для каждого элемента
массива - это 0 или пустая строка, если столбец не может содержать значения
<code>NULL</code>, 1 - если может и 2 - если статус столбца относительно значения
<code>NULL</code> не определен.

Например:

<pre>
$null_possible = $sth -&#62; {NULLABLE};
</pre>

<A NAME="IDX1533"></A>
<A NAME="IDX1534"></A>
<DT><code>NUM_OF_FIELDS</code>
<DD>
Значение этого атрибута равно числу полей в результате запроса (<code>SELECT</code>
или <code>SHOW FIELDS</code>). Его можно использовать его для проверки, возвращает ли
запрос результат вообще: нулевое значение соответствует запросам типа
<code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code> - т.е. всем, кроме <code>SELECT</code>.
Например:

<pre>
$nr_of_fields = $sth -&#62; {NUM_OF_FIELDS};
</pre>

<A NAME="IDX1535"></A>
<A NAME="IDX1536"></A>
<DT><code>data_sources($driver_name)</code>
<DD>
Этот метод возвращает массив с именами баз данных, доступных на
локальном MySQL-сервере (на <code>localhost</code>).
Пример:

<pre>
@dbs = DBI-&#62;data_sources("mysql");
</pre>

<A NAME="IDX1537"></A>
<A NAME="IDX1538"></A>
<DT><code>ChopBlanks</code>
<DD>
Этот атрибут определяет, будут ли методы <code>fetchrow_*</code> убирать начальные
и оконечные пробелы из результатов.
Пример:

<pre>
$sth -&#62; {'ChopBlanks'} = 1;
</pre>

<A NAME="IDX1539"></A>
<A NAME="IDX1540"></A>
<DT><code>trace($trace_level)</code>
<DD>
<DT><code>trace($trace_level, $trace_filename)</code>
<DD>
Метод trace разрешает  или  запрещает  трассировку. Если он вызывается
как метод класса <code>DBI</code>, он влияет на разрешение трассировки всех
дескрипторов. В случае же обращения к нему как к методу дескриптора
запроса либо базы данных он разрешает/запрещает трассировку для этой базы
данных или этого запроса (и всех будущих потомков). <code>$trace_level</code> указывает
уровень детализации трассировочной информации, так установка <code>$trace_level</code> 
в 2 включает детализированную трассировку. Установка <code>$trace_level</code> в 0
запрещает трассировку. По умолчанию вывод трассировочной информации
осуществляется на стандартное устройство вывода ошибок (<code>stderr</code>). Если
указан параметр <code>$trace_filename</code>, его значение используется как имя файла,
в который выводится трассировочная информация <strong>ВСЕХ</strong> дескрипторов, для
которых разрешена трассировка.
Пример:

<pre>
DBI-&#62;trace(2);                # трассировка всего
DBI-&#62;trace(2,"/tmp/dbi.out"); # трассировка всего в /tmp/dbi.out
$dth-&#62;trace(2);               # трассировка всех запросов к этой базе
данных
$sth-&#62;trace(2);               # трассировка этого запроса
</pre>

<A NAME="IDX1541"></A>
<A NAME="IDX1542"></A>

Трассировку <code>DBI</code> можно также включить при помощи переменной окружения
<code>DBI_TRACE</code>. Присвоение числового значения эквивалентно вызову
<code>DBI-&#62;trace(значение)</code>. Строковое значение (имя файла) эквивалентно вызову
<code>DBI-&#62;trace(2,значение)</code>.
</DL>

<P>
<strong>Методы, специфичные для MySQL</strong>

</P>
<P>
Описанные здесь методы специфичны для MySQL и не являются частью стандарта
<code>DBI</code>. Сейчас считается, что часть из них использовать не стоит: <code>is_blob</code>,
<code>is_key</code>, <code>is_num</code>, <code>is_pri_key</code>, <code>is_not_null</code>, <code>length</code>, <code>max_length</code> и <code>table</code>. Ниже
указаны возможные стандартные альтернативы, если они существуют:

</P>
<DL COMPACT>

<DT><code>insertid</code>
<DD>
<A NAME="IDX1543"></A>
 <A NAME="IDX1544"></A>
 <A NAME="IDX1545"></A>
 
Если вы используете специфичную для MySQL функцию <code>AUTO_INCREMENT</code>,
здесь будут сохраняться автоматически увеличенные значения.
Пример:

<pre>
$new_id = $sth-&#62;{insertid};
</pre>

В качестве альтернативы можно использовать <code>$dbh -&#62; {'mysql_insertid'}</code>.

<A NAME="IDX1546"></A>
<A NAME="IDX1547"></A>
<DT><code>is_blob</code>
<DD>
Возвращает ссылку на массив булевых значений; для каждого элемента
массива значение ``истина'' указывает, что соответствующий столбец имеет
тип <code>BLOB</code>.
Например:

<pre>
$keys = $sth -&#62; {is_blob};
</pre>

<A NAME="IDX1548"></A>
<A NAME="IDX1549"></A>
<DT><code>is_key</code>
<DD>
Возвращает ссылку на массив булевых значений; для каждого элемента
массива значение ``истина'' указывает, что соответствующий столбец
является ключом.
Пример:

<pre>
$keys = $sth -&#62; {is_key};
</pre>

<A NAME="IDX1550"></A>
<A NAME="IDX1551"></A>
<DT><code>is_num</code>
<DD>
Возвращает ссылку на массив булевых значений; для каждого элемента
массива, значение ``истина'' указывает, что соответствующий столбец
содержит числовые значения.
Например:

<pre>
$nums = $sth -&#62; {is_num};
</pre>

<A NAME="IDX1552"></A>
<A NAME="IDX1553"></A>
<DT><code>is_pri_key</code>
<DD>
Возвращает ссылку на массив булевых значений; для каждого элемента
массива, значение ``истина'' указывает, что соответствующий столбец
является первичным ключом.
Пример:

<pre>
$pri_keys = $sth -&#62; {is_pri_key};
</pre>

<A NAME="IDX1554"></A>
<A NAME="IDX1555"></A>
<DT><code>is_not_null</code>
<DD>
Возвращает ссылку на массив б булевых значений; для каждого элемента
массива значение ``ложь'' указывает на то, что столбец может содержать
значения <code>NULL</code>.
Например:

<pre>
$not_nulls = $sth -&#62; {is_not_null};
</pre>

<code>is_not_null</code> не рекомендуется к применению; предпочтительно
использование <code>NULLABLE</code> (описан ранее), поскольку это стандартный для <code>DBI</code>
метод.

<A NAME="IDX1556"></A>
<A NAME="IDX1557"></A>
<A NAME="IDX1558"></A>
<A NAME="IDX1559"></A>
<DT><code>length</code>
<DD>
<DT><code>max_length</code>
<DD>
Каждый из этих методов возвращает ссылку на массив размеров столбцов.
Массив, соответствующий <code>length</code>, содержит максимальные допустимые размеры
каждого столбца (из описания таблицы). Массив <code>max_length</code> содержит
максимальные размеры элементов, присутствующих в результирующей таблице.
Например:

<pre>
$lengths = $sth -&#62; {length};
$max_lengths = $sth -&#62; {max_length};
</pre>

<A NAME="IDX1560"></A>
<A NAME="IDX1561"></A>
<DT><code>NAME</code>
<DD>
Возвращает ссылку на массив имен столбцов.
Например:

<pre>
$names = $sth -&#62; {NAME};
</pre>

<A NAME="IDX1562"></A>
<A NAME="IDX1563"></A>
<DT><code>table</code>
<DD>
Возвращает ссылку на массив названий таблиц.
Например:

<pre>
$tables = $sth -&#62; {table};
</pre>

<A NAME="IDX1564"></A>
<A NAME="IDX1565"></A>
<DT><code>type</code>
<DD>
Возвращает ссылку на массив типов столбцов.
Пример:

<pre>
$types = $sth -&#62; {type};
</pre>

</DL>



<H3><A NAME="DBI-info" HREF="manual.ru_toc.html#DBI-info">8.2.3  Больше информации по <code>DBI</code>/<code>DBD</code></A></H3>

<P>
<A NAME="IDX1566"></A>

</P>
<P>
Вы можете использовать команду <code>perldoc</code> для получения больше информации по
<code>DBI</code>.

</P>

<pre>
perldoc DBI
perldoc DBI::FAQ
perldoc DBD::mysql
</pre>

<P>
Конечно, вы можете использовать <code>pod2man</code>, <code>pod2html</code> и другие утилиты для
трансляции в другие форматы.

</P>
<P>
Самая свежая информация по <code>DBI</code> живет на веб-сайте <code>DBI</code>:
<a HREF="http://dbi.perl.org/">http://dbi.perl.org/</a>.

</P>


<H2><A NAME="ODBC" HREF="manual.ru_toc.html#ODBC">8.3  Поддержка ODBC в MySQL</A></H2>

<P>
<A NAME="IDX1567"></A>
<A NAME="IDX1568"></A>
<A NAME="IDX1569"></A>

</P>

<P>
MySQL обеспечивает поддержку для ODBC посредством программы <code>MyODBC</code>. В этом
разделе показано, как устанавливать и использовать <code>MyODBC</code>. Здесь также
приведен список программ общего применения, о которых известно, что они
работают с <code>MyODBC</code>.

</P>


<H3><A NAME="Installing_MyODBC" HREF="manual.ru_toc.html#Installing_MyODBC">8.3.1  Как установить MyODBC</A></H3>

<P>
<code>MyODBC</code> 2.50 представляет собой 32-разрядный драйвер ODBC спецификации уровня 0 (с
возможностями уровней 1 и 2) для подсоединения совместимого с ODBC
приложения к MySQL. <code>MyODBC</code> работает под Windows 9x/Me/NT/2000/XP и на
большинстве платформ Unix.

</P>
<P>
<code>MyODBC</code> 3.51 это усовершенствованная версия ODBC со спецификационным
уровнем 1 (полностью ядро API + уровень возможности 2).

</P>
<P>
<code>MyODBC</code> является свободно доступным. Самую свежую версию можно найти на
<a HREF="http://www.mysql.com/downloads/api-myodbc.html">http://www.mysql.com/downloads/api-myodbc.html</a>.

</P>
<P>
Обратите внимание, что версии 2.50.х распространяются под <code>LGPL</code>
лицензией, тогда как 3.51.х версии под лицензией <code>GPL</code>.

</P>
<P>
Если существуют проблемы с <code>MyODBC</code>, а программа также работает и с OLEDB,
то следует попробовать работать с драйвером OLEDB.

</P>
<P>
Обычно установка <code>MyODBC</code> требуется только на компьютерах под Windows. Для
Unix необходимость в <code>MyODBC</code> возникает только для программ, подобных
ColdFusion, которые работают на Unix-машинах и используют ODBC для
подключения к базам данных.

</P>
<P>
Для установки <code>MyODBC</code> на Unix-машину понадобится также программа управления
ODBC. MyODBC, как известно, работает с большинством программ управления
ODBC для Unix.

</P>
<P>
Для того чтобы установить <code>MyODBC</code> на Windows, необходимо загрузить
соответствующий файл <code>MyODBC</code> <tt>`.zip'</tt>, распаковать его с помощью <code>WinZIP</code> или
другой подобной программы и выполнить исполняемый файл <tt>`SETUP.EXE'</tt>.

</P>
<P>
При попытке установить <code>MyODBC</code> под Windows/NT/XP можно получить следующую
ошибку:

</P>

<pre>
An error occurred while copying C:\WINDOWS\SYSTEM\MFC30.DLL. Restart
Windows and try installing again (before running any applications which
use  ODBC)
</pre>

<P>
Проблема здесь заключается в том, что некоторая другая программа в это же
время использует ODBC и из-за конструктивных особенностей Windows в данном
случае может оказаться невозможным установить новый драйвер ODBC с помощью
поставляемой Microsoft программы установки. В большинстве случаев можно
продолжать установку, просто нажимая <code>Ignore</code> для копирования оставшихся
файлов <code>MyODBC</code>, при этом заключительная установка должна работать. Если она
не работает, то выход состоит в следующем: перезагрузите систему в
безопасном режиме (safe mode) (для перехода в этот режим следует нажать
F8 непосредственно перед тем, как компьютер начинает запускать Windows во
время перезагрузки), установите <code>MyODBC</code> и перезагрузите Windows в обычном
режиме.

</P>

<ul>
<LI>

Чтобы установить подсоединение к Unix-компьютеру от Windows-компьютера
с помощью приложения ODBC (которое само по себе не поддерживает
MySQL), необходимо вначале установить MyODBC на Windows-машине.

<LI>

Данный пользователь и Windows-машина должны обладать привилегиями
доступа к серверу MySQL на Unix-машине. Это устанавливается с помощью
команды GRANT (see section <A HREF="manual.ru_MySQL_Database_Administration.html#GRANT">4.3.1  Синтаксис команд <code>GRANT</code> и <code>REVOKE</code></A>).

<LI>

Необходимо создать новую запись DSN  ODBC следующим образом:

<LI>

Открыть Control  Panel (Панель управления) на Windows-компьютере.

<LI>

Выполнить двойной щелчок на пиктограмме ODBC  Data  Sources
32-bit (Источники данных ODBC (32бит)).

<LI>

Щелкнуть на закладке User  DSN (Пользовательский DSN).

<LI>

Щелкнуть на кнопке Add (Добавить).

<LI>

Выбрать MySQL в окне Create  New  Data  Source (Создание нового
источника данных) и щелкнуть на кнопке Finish (Готово).

<LI>

Откроется окно конфигурации драйвера MySQL по умолчанию (see section <A HREF="manual.ru_Clients.html#ODBC_administrator">8.3.2  Как заполнять различные поля в Администраторе ODBC</A>).

<LI>

Теперь запустите свое приложение и выберите драйвер ODBC с помощью
DSN, заданного вами в Администраторе источников данных ODBC.
</ul>

<P>
Обратите внимание: существуют и другие возможности конфигурации в окне
MySQL (трассировка, не подсказывать соединение и так далее), которые вы
можете опробовать, если столкнетесь с какими-либо проблемами.

</P>


<H3><A NAME="ODBC_administrator" HREF="manual.ru_toc.html#ODBC_administrator">8.3.2  Как заполнять различные поля в Администраторе ODBC</A></H3>

<P>
<A NAME="IDX1570"></A>

</P>
<P>
Для Windows 95 существует три возможности задания имени сервера:

</P>

<ul>
<LI>

Использовать IP-адрес сервера.

<LI>

Добавить файл \windows\lmhosts  со следующей информацией:


<pre>
ip hostname
</pre>

Например:


<pre>
194.216.84.21 my_hostname
</pre>

<LI>

Сконфигурировать ПК для использования DNS.
</ul>

<P>
Пример заполнения при установке ODBC:

</P>

<pre>
Windows DSN name:   test
Description:        This is my test database
MySql Database:     test
Server:             194.216.84.21
User:               monty
Password:           my_password
Port:
</pre>

<P>
Значением поля <code>Windows DSN name</code> может быть любое имя, уникальное для
данной установки ODBC.

</P>
<P>
Не обязательно указывать значения для полей <code>Server</code>, <code>User</code>, <code>Password</code> или
<code>Port</code> в окне установки ODBC. Однако если вы это сделали, данные величины в
дальнейшем при установке соединения будут использованы как значения по
умолчанию. Тогда же можно будет изменить эти значения.

</P>
<P>
Если номер порта не задан, то используется его значение по умолчанию 
(3306).

</P>
<P>
Если задается опция <code>Read options from C:\my.cnf</code>, то группы <code>client</code> и
<code>odbc</code> будут читаться из файла <tt>`C:\my.cnf'</tt>. Можно применять все опции,
используемые в <code>mysql_options()</code> (see section <A HREF="manual.ru_Clients.html#mysql_options">8.4.3.163  <code>mysql_options()</code></A>).

</P>


<H3><A NAME="MyODBC_connect_parameters" HREF="manual.ru_toc.html#MyODBC_connect_parameters">8.3.3  Параметры подключения для MyODBC</A></H3>

<P>
Можно указать следующие параметры для <code>MyODBC</code> в разделе <code>[Servername]</code> файла
<tt>`ODBC.INI'</tt> или через аргумент <code>InConnectionString</code> при вызове функции
<code>SQLDriverConnect()</code>.
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Параметр</strong> </TD><TD> <strong>Величина по умолчанию</strong> </TD><TD> <strong>Комментарий</strong>
</TD></TR>
<TR><TD>user </TD><TD> ODBC (под Windows)@tab Имя пользователя, используемое для подключения к MySQL.
</TD></TR>
<TR><TD>server </TD><TD> localhost </TD><TD> Имя хоста сервера MySQL.
</TD></TR>
<TR><TD>database@tab </TD><TD> База данных по умолчанию.
</TD></TR>
<TR><TD>option </TD><TD> 0 </TD><TD> Целое число, с помощью которого можно указать, как должен работать драйвер MyODBC (см. ниже).
</TD></TR>
<TR><TD>port </TD><TD> 3306 </TD><TD> Используемый порт TCP/IP, если значением <code>server</code> не является <code>localhost</code>.
</TD></TR>
<TR><TD>stmt </TD><TD> </TD><TD> Команда, которая будет выполняться при подключении к MySQL.
</TD></TR>
<TR><TD>password@tab </TD><TD> Пароль для комбинации <code>server user</code>.
</TD></TR>
<TR><TD>socket </TD><TD> </TD><TD> Сокет или канал Windows для подключения.
</TD></TR>
</TABLE>

</P>
<P>
Аргумент ``option'' используется для указания <code>MyODBC</code>, что данный клиент
не на 100% соответствует ODBC. Под Windows обычно устанавливается флаг
опций путем переключения различных опций в окне данного соединения, но
можно также установить это в аргументе ``option''. Следующие опции
перечислены в том же порядке, в котором они перечислены в окне подключения
<code>MyODBC</code>:
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Бит</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>1 </TD><TD> Данный клиент не может отследить, что драйвер <code>MyODBC</code> возвращает реальную ширину столбца.
</TD></TR>
<TR><TD>2 </TD><TD> Данный клиент не может отследить, что драйвер <code>MyODBC</code> возвращает реальную величину подвергшихся воздействию строк. Если этот флаг установлен, то взамен MySQL возвращает ``найденные строки''. Необходима версия MySQL 3.21.14 или более новая, чтобы эта опция работала.
</TD></TR>
<TR><TD>4 </TD><TD> Создает журнал отладки в c:\myodbc.log. Это то же самое, что задать <code>MYSQL_DEBUG=d:t:O,c::\myodbc.log</code> в <tt>`AUTOEXEC.BAT'</tt>
</TD></TR>
<TR><TD>8 </TD><TD> Не устанавливать никаких пакетных ограничений для результатов и параметров.
</TD></TR>
<TR><TD>16 </TD><TD> Не выводить подсказки для вопросов, даже если драйвер захотел бы предложить это
</TD></TR>
<TR><TD>32 </TD><TD> Имитировать драйвер ODBC 1.0 в определенной ситуации.
</TD></TR>
<TR><TD>64 </TD><TD> Игнорировать использование имени базы данных в <code>database.table.column</code>.
</TD></TR>
<TR><TD>128 </TD><TD> Заставляет использовать указатели менеджера ODBC (экспериментальная).
</TD></TR>
<TR><TD>256 </TD><TD> Отключить использование расширенной выборки (экспериментальная).
</TD></TR>
<TR><TD>512 </TD><TD> Заполнить поля <code>CHAR</code> до полной длины столбца.
</TD></TR>
<TR><TD>1024 </TD><TD> Функция SQLDescribeCol() будет возвращать полностью уточненные имена столбцов
</TD></TR>
<TR><TD>2048 </TD><TD> Использовать сжатие в клиент-серверном протоколе
</TD></TR>
<TR><TD>4096 </TD><TD> Предписывает серверу игнорировать пробел после имени функции и перед <samp>`('</samp> (необходимо для PowerBuilder). Это сделает имена всех функций ключевыми словами!
</TD></TR>
<TR><TD>8192 </TD><TD> Соединяет с именованными каналами сервер <code>mysqld</code>, работающий под NT.
</TD></TR>
<TR><TD>16384 </TD><TD> Изменяет тип столбцов <code>LONGLONG</code> на <code>INT</code> (некоторые приложения не могут обрабатывать LONGLONG).
</TD></TR>
<TR><TD>32768 </TD><TD> Возвращает параметр <code>user</code> как <code>Table_qualifier</code> и <code>Table_owner</code> из SQL-таблиц (экспериментальная)
</TD></TR>
<TR><TD>65536 </TD><TD> Читает параметры из групп <code>client</code> и <code>odbc</code> из файла <tt>`my.cnf'</tt>
</TD></TR>
<TR><TD>131072 </TD><TD> Добавляет некоторые дополнительные проверки безопасности (не должно понадобиться, но...)
</TD></TR>
</TABLE>

</P>
<P>
Если необходимо иметь много опций, следует добавить вышеуказанные флаги!
Например, установка опции в 12 (4+8) дает отладку без ограничений пакетов!

</P>
<P>
По умолчанию <tt>`MYODBC.DLL'</tt> компилируется для оптимальной производительности.
Если необходимо отладить <code>MyODBC</code> (например, включить трассировку), следует
вместо этого использовать <tt>`MYODBCD.DLL'</tt>. Для установки этого файла следует
скопировать <tt>`MYODBCD.DLL'</tt> поверх установленного файла <tt>`MYODBC.DLL'</tt>.

</P>


<H3><A NAME="ODBC_Problems" HREF="manual.ru_toc.html#ODBC_Problems">8.3.4  Как сообщать о проблемах с MyODBC</A></H3>

<P>
Драйвер <code>MyODBC</code> был протестирован с Access, Admndemo.exe, C++-Builder,
Borland  Builder 4, Centura  Team  Developer (первоначально Gupta 
SQL/Windows), ColdFusion (под Solaris и NT с пакетом обновлений svc  pack
5), Crystal  Reports, DataJunction, Delphi, ERwin, Excel, iHTML, FileMaker
Pro, FoxPro, Notes 4.5/4.6, SBSS, Perl  DBD-ODBC, Paradox, Powerbuilder,
32-разрядным Powerdesigner, VC++ и Visual  Basic.

</P>
<P>
Если вам известны какие- либо другие приложения, работающие с MyODBC,
пожалуйста, пошлите сообщение об этом по адресу <a HREF="mailto:myodbc@lists.mysql.com">myodbc@lists.mysql.com</a>!

</P>
<P>
При работе с некоторыми программами можно получить ошибку вроде:
<code>Another user has modifies the record that you have modified</code>.

</P>
<P>
В большинстве случаев эту проблему можно устранить одним из следующих способов:

</P>

<ul>
<LI>

Добавить первичный ключ для данной таблицы, если он еще не создан.
<LI>

Добавить столбец <code>TIMESTAMP</code>, если он еще не создан.
<LI>

Использовать поля только с числами с плавающей запятой двойной
точности. Некоторые программы могут не срабатывать при сравнении чисел
с плавающей запятой одинарной точности.
</ul>

<P>
Если перечисленные выше способы не помогают, необходимо сделать
трассировочный файл <code>MyODBC</code> и попробовать определить, в чем дело.

</P>


<H3><A NAME="MyODBC_clients" HREF="manual.ru_toc.html#MyODBC_clients">8.3.5  Программы, работающие с MyODBC</A></H3>

<P>
Большинство программ должно работать с <code>MyODBC</code>, но для каждой из
перечисленных ниже мы либо провели тестирование сами, либо получили
подтверждение от пользователей, что она действительно работает:

</P>
<DL COMPACT>

<DT><strong>Программа</strong>
<DD>
<strong>Комментарий</strong>
<A NAME="IDX1571"></A>
<DT>Access
<DD>
Чтобы заставить Access работать:

<ul>
<LI>

При использовании Access 2000 необходимо установить самую последнюю
версию (2.6 или выше) Microsoft MDAC (<code>Microsoft Data Access 
Components</code>), которую можно найти на <a HREF="http://www.microsoft.com/data/">http://www.microsoft.com/data/</a>.
Это позволит устранить ошибку в Access, которая проявляется в том, что
при экспорте данных в MySQL не указываются имена таблиц и столбцов.
Еще один способ обойти эту ошибку заключается в модернизации <code>MyODBC</code> до
версии 2.50.33 и MySQL до версии 3.23.x - оба апгрейда вместе
обеспечивают обход данной ошибки!

Необходимо также получить и
использовать Microsoft  Jet 4.0 Service  Pack 5 (SP5), который можно
найти на <a HREF="http://support.microsoft.com/support/kb/articles/Q
239/1/14.ASP">http://support.microsoft.com/support/kb/articles/Q
239/1/14.ASP</a>. Это позволит исключить некоторые случаи, когда столбцы в
Access отмечаются как <code>#deleted#</code>. Следует учитывать, что при
использовании версии MySQL 3.22 необходимо применять патч для MDAC и
использовать MyODBC 2.50.32 или 2.50.34 и выше, чтобы обойти эту
проблему.
<LI>

Для всех версий Access необходимо включить для MyODBC флаг опции
<code>Return matching rows</code>. Для Access 2.0 следует дополнительно включить
Simulate  ODBC 1.0.
<LI>

Все таблицы, в которых вы хотите иметь возможность обновления, должны
содержать столбец типа <code>TIMESTAMP</code> для временных меток. Для максимальной
переносимости рекомендуется <code>TIMESTAMP(14)</code> или просто <code>TIMESTAMP</code> вместо
других вариантов <code>TIMESTAMP(X)</code>.
<LI>

Таблица должна иметь первичный ключ. Если не имеет, то новые или
обновленные строки могут выводиться как <code>#DELETED#</code>.
<LI>

Используйте поля с числами с плавающей запятой только двойной точности
(типа <code>DOUBLE</code>). Access отказывается работать при сравнении чисел с
плавающей запятой одинарной точности. Проявляется это обычно в том,
что новые или обновленные строки могут выводиться как <code>#DELETED#</code> или в
том, что вы не можете найти или обновить строки.
<LI>

При связывании через MyODBC таблицы, один из столбцов которой имеет
тип <code>BIGINT</code>, результат будет выводиться как <code>#DELETED#</code>. Обходное решение
заключается в следующем:

<ul>
<LI>

Добавьте еще один пустой столбец с <code>TIMESTAMP</code> в качестве типа
данных, предпочтительно <code>TIMESTAMP(14)</code>.
<LI>

Проверьте <code>Change BIGINT columns to INT</code> в диалоговом окне
опций подключения в Администраторе источников данных ODBC  DSN
<LI>

Удалите данную табличную связь из Access и создайте ее вновь.
</ul>

После этого старые записи все равно будут представлены как <code>#DELETED#</code>, а
заново добавленные/обновленные записи будут уже выводиться правильно.
<LI>

Если после добавления столбца <code>TIMESTAMP</code> все еще появляется ошибка
<code>Another user has changed your data</code>, то, возможно, поможет
следующий трюк. Не используйте режим работы ``Таблица''. Вместо этого
создайте форму с желаемыми полями и используйте режим работы
``Форма''. Следует установить свойство <code>DefaultValue</code> для столбца
<code>TIMESTAMP</code> в <code>NOW()</code>. Возможно, было бы неплохо убрать столбец <code>TIMESTAMP</code>
из поля зрения, чтобы не смущать пользователей.
<LI>

В некоторых случаях Access может создавать недопустимые запросы SQL,
которые MySQL не может понять. Это можно устранить путем выбора в меню
Access опции <code>Query|SQLSpecific|Pass-Through</code>.
<LI>

Access под NT будет сообщать о столбцах <code>BLOB</code> как об объектах OLE. Если
вместо этого вы хотите иметь столбцы <code>MEMO</code>, то необходимо изменить тип
столбца на <code>TEXT</code> с помощью <code>ALTER TABLE</code>.
<LI>

Access не всегда может правильно обработать столбцы типа <code>DATE</code>. Если с
ними возникают проблемы, следует изменить тип этих столбцов на
<code>DATETIME</code>.
<LI>

Если Access содержит столбец, определенный как <code>BYTE</code>, то Access будет
пытаться экспортировать его как <code>TINYINT</code> вместо <code>TINYINT UNSIGNED</code>. Это
будет вызывать проблемы, если величины в данном столбце превышают 127!
</ul>

<A NAME="IDX1572"></A>
<DT>ADO
<DD>
При написании программ с привлечением интерфейса ADO API и <code>MyODBC</code>
необходимо обратить внимание на некоторые исходные свойства, которые не
поддерживаются сервером MySQL. Например, использование свойства
<code>CursorLocation</code>  как <code>adUseServer</code> будет возвращать для свойства <code>RecordCount</code>
результат -1. Чтобы получить правильную величину, необходимо установить
данное свойство в <code>adUseClient</code>, как показано в коде VB ниже:


<pre>
Dim myconn As New ADODB.Connection
Dim myrs As New Recordset
Dim mySQL As String
Dim myrows As Long

myconn.Open "DSN=MyODBCsample"
mySQL = "SELECT * from user"
myrs.Source = mySQL
Set myrs.ActiveConnection = myconn
myrs.CursorLocation = adUseClient
myrs.Open
myrows = myrs.RecordCount

myrs.Close
myconn.Close
</pre>

Еще один обходной путь состоит в том, чтобы для такого запроса
использовать команду <code>SELECT COUNT(*)</code>, чтобы получить правильное
количество строк.

<DT>Активные серверные страницы (ASP)
<DD>
Необходимо использовать флаг опции <code>Return matching rows</code>.

<DT>BDE-приложения
<DD>
Чтобы заставить их работать, следует установить флаги опций <code>Don't 
optimize column widths</code> и <code>Return matching rows</code>.

<A NAME="IDX1573"></A>
<DT>Borland Builder 4
<DD>
При запуске запроса можно использовать свойство <code>Active</code> или метод <code>Open</code>.
Следует учитывать, что <code>Active</code> будет начинать работу при автоматической
выдаче запроса <code>SELECT * FROM ...</code>, что может оказаться не так уж и хорошо
для больших таблиц!

<DT>ColdFusion (Под Unix)
<DD>
Приведенные далее сведения взяты из документации по ColdFusion. Для
применения драйвера unixODBC с источником данных <code>MyODBC</code> следует
использовать следующую информацию. Корпорация Allaire подтвердила, что
версия MyODBC 2.50.26 работает с версией MySQL 3.22.27 и ColdFusion для
Linux (любая более новая версия также должна работать). Драйвер <code>MyODBC</code>
можно загрузить с <a HREF="http://www.mysql.com/downloads/api-myodbc.html">http://www.mysql.com/downloads/api-myodbc.html</a> 

<A NAME="IDX1574"></A>
В версии
ColdFusion 4.5.1 можно использовать Администратор источников данных
ColdFusion для добавления источника данных MySQL. Однако данный драйвер не
включен в версию ColdFusion 4.5.1. Чтобы драйвер MySQL появился в
выпадающем списке источников данных ODBC, необходимо создать драйвер
<code>MyODBC</code> и скопировать его в каталог <tt>`/opt/coldfusion/lib/libmyodbc.so'</tt>.
Каталог <tt>`Contrib'</tt> содержит программу <tt>`mydsn-xxx.zip'</tt>, которая позволяет
создавать и удалять файл реестра DSN для драйвера <code>MyODBC</code> для приложений
Coldfusion.

<A NAME="IDX1575"></A>
<DT>DataJunction
<DD>
Необходимо изменить эту программу для вывода <code>VARCHAR</code> вместо <code>ENUM</code>,
поскольку экспорт <code>ENUM</code> происходит таким образом, что вызывает неприятности
в MySQL.

<A NAME="IDX1576"></A>
<DT>Excel
<DD>
Работает. Несколько замечаний:

<ul>
<LI>

Если существуют проблемы с датами, попробуйте выбирать их как строки,
используя функцию <code>CONCAT()</code>. Например:

<pre>
select CONCAT(rise_time), CONCAT(set_time)
	from sunrise_sunset;
</pre>

Величины, извлеченные как строки этим способом, должны корректно
распознаваться программой Excel97 как значения времени. Назначение функции
<code>CONCAT()</code> в этом примере состоит в том, чтобы ``обмануть'' ODBC, заставив
интерпретировать столбец как столбец ``строкового типа''. Без функции
<code>CONCAT()</code> ODBC будет считать, что это столбец временного типа, и Excel не
распознает его. Следует заметить, что это является ошибкой Excel,
поскольку он автоматически преобразует строку в значения времени. Это
замечательно если источником является текстовый файл, но это глупо, когда источником является подключение ODBC, дающее точные
типы данных для каждого столбца.
</ul>

<A NAME="IDX1577"></A>
<DT>Word
<DD>
Для извлечения данных из MySQL в документы Word/Excel следует использовать
драйвер <code>MyODBC</code> и помощь встроенной программы Microsoft Query. Для
создания, например, базы данных <code>db</code> с таблицей, содержащей 2 столбца с
текстом, необходимо выполнить следующие действия:


<ul>
<LI>

Вставьте строки, используя командную строку клиента <code>mysql</code>.
<LI>

Создайте файл DSN, используя менеджер ODBC, например, my для созданной
выше базы данных <code>db</code>.
<LI>

Откройте приложение Word.
<LI>

Создайте новый пустой документ.
<LI>

Используя панель инструментов вызванной базы данных, нажмите кнопку
Insert database.
<LI>

Нажмите кнопку Get Data.
<LI>

В окне Get Data справа нажмите кнопку Ms Query.
<LI>

В окне Ms Query создайте новый источник данных, используя файл DSN 
my.
<LI>

Выберите новый запрос.
<LI>

Выберите желаемый столбец.
<LI>

Создайте фильтр (при желании).
<LI>

Создайте сортировку (при желании).
<LI>

Выберите Return Data to Microsoft Word.
<LI>

Нажмите кнопку Finish.
<LI>

Нажмите Insert data и выбирайте записи.
<LI>

Нажмите Ok. Вы увидите выбранные строки в своем документе в Word.
</ul>

<A NAME="IDX1578"></A>
<DT>odbcadmin
<DD>
Тестовая программа для ODBC.

<A NAME="IDX1579"></A>
<DT>Delphi
<DD>
Необходимо использовать версию BDE 3.2 или более новую. Установите поле
опции <code>Don't optimize column width</code> при подключении к MySQL. Кроме того,
ниже приводится потенциально полезный код Delphi, который устанавливает
вхождения для драйвера MyODBC как в ODBC, так и в BDE. (Запись в BDE
требует наличия редактора псевдонимов BDE  Alias  Editor, который доступен
бесплатно на Delphi Super Page. Спасибо за это Брайену Брантону (Bryan 
Brunton <a HREF="mailto:bryan@flesherfab.com">bryan@flesherfab.com</a>)):


<pre>
fReg:= TRegistry.Create;
fReg.OpenKey('\Software\ODBC\ODBC.INI\DocumentsFab', True);
fReg.WriteString('Database', 'Documents');
fReg.WriteString('Description', ' ');
fReg.WriteString('Driver', 'C:\WINNT\System32\myodbc.dll');
fReg.WriteString('Flag', '1');
fReg.WriteString('Password', '');
fReg.WriteString('Port', ' ');
fReg.WriteString('Server', 'xmark');
fReg.WriteString('User', 'winuser');
fReg.OpenKey('\Software\ODBC\ODBC.INI\ODBC Data Sources', True);
fReg.WriteString('DocumentsFab', 'MySQL');
fReg.CloseKey;
fReg.Free;

Memo1.Lines.Add('DATABASE NAME=');
Memo1.Lines.Add('USER NAME=');
Memo1.Lines.Add('ODBC DSN=DocumentsFab');
Memo1.Lines.Add('OPEN MODE=READ/WRITE');
Memo1.Lines.Add('BATCH COUNT=200');
Memo1.Lines.Add('LANGDRIVER=');
Memo1.Lines.Add('MAX ROWS=-1');
Memo1.Lines.Add('SCHEMA CACHE DIR=');
Memo1.Lines.Add('SCHEMA CACHE SIZE=8');
Memo1.Lines.Add('SCHEMA CACHE TIME=-1');
Memo1.Lines.Add('SQLPASSTHRU MODE=SHARED AUTOCOMMIT');
Memo1.Lines.Add('SQLQRYMODE=');
Memo1.Lines.Add('ENABLE SCHEMA CACHE=FALSE');
Memo1.Lines.Add('ENABLE BCD=FALSE');
Memo1.Lines.Add('ROWSET SIZE=20');
Memo1.Lines.Add('BLOBS TO CACHE=64');
Memo1.Lines.Add('BLOB SIZE=32');
AliasEditor.Add('DocumentsFab','MySQL',Memo1.Lines);
</pre>

<A NAME="IDX1580"></A>
<DT>C++ Builder
<DD>
Проведено тестирование с версией BDE 3.0. Единственная обнаруженная
проблема состоит в том, что при изменениях схемы таблиц не обновляются
поля запросов. Хотя BDE не распознает первичных ключей, а только индекс
<code>PRIMARY</code>, тем не менее, это не было проблемой.

<DT>Vision
<DD>
Необходимо использовать флаг опции <code>Return matching rows</code>.

<A NAME="IDX1581"></A>
<DT>Visual Basic
<DD>
Чтобы обеспечить возможность обновить таблицу, для нее необходимо
определить первичный ключ. Visual Basic с ADO не обрабатывает больших
целых чисел. Это означает, что некоторые запросы вроде <code>SHOW PROCESSLIST</code> 
не будут работать правильно. Для устранения данной проблемы нужно добавить
опцию <code>OPTION=16384</code> в строке подключения ODBC или установить опцию <code>Change
BIGINT columns to INT</code> в окне подключения <code>MyODBC</code>. Можно также установить
опцию <code>Return matching rows</code>.

<DT>VisualInterDev
<DD>
Если возникает ошибка <code>[Microsoft][ODBC Driver Manager] Driver does not
support this parameter</code>, то ее причина может заключаться в том, что
результат содержит данные типа <code>BIGINT</code>. Попробуйте установить опцию <code>Change
BIGINT columns to INT</code> в окне подключения <code>MyODBC</code>.

<DT>Visual Objects
<DD>
Необходимо использовать флаг опции <code>Don't optimize column widths</code>.
</DL>



<H3><A NAME="ODBC_and_last_insert_id" HREF="manual.ru_toc.html#ODBC_and_last_insert_id">8.3.6  Как получить значение столбца AUTO_INCREMENT в ODBC</A></H3>

<P>
<A NAME="IDX1582"></A>

</P>
<P>
Существует распространенная проблема, заключающаяся в том, как получить
значение автоматически сгенерированного <code>ID</code> из <code>INSERT</code>. С помощью ODBC можно
сделать что-то наподобие следующего (предполагается, что auto представляет
собой поле <code>AUTO_INCREMENT</code> ):

</P>

<pre>
INSERT INTO foo (auto,text) VALUES(NULL,'text');
SELECT LAST_INSERT_ID();
</pre>

<P>
Или, если вы просто собираетесь вставить данный <code>ID</code> в другую таблицу, то
можно сделать так:

</P>

<pre>
INSERT INTO foo (auto,text) VALUES(NULL,'text');
INSERT INTO foo2 (id,text) VALUES(LAST_INSERT_ID(),'text');
</pre>

<P>
See section <A HREF="manual.ru_Clients.html#Getting_unique_ID">8.4.6.3  Как получить уникальный идентификатор для последней внесенной строки?</A>.

</P>
<P>
Для некоторых приложений ODBC (по крайней мере, для Delphi и Access),
чтобы найти недавно вставленную строку, можно использовать следующий
запрос:

</P>

<pre>
SELECT * FROM tbl_name WHERE auto IS NULL;
</pre>



<H3><A NAME="MyODBC_bug_report" HREF="manual.ru_toc.html#MyODBC_bug_report">8.3.7  Составление отчетов о проблемах с MyODBC</A></H3>

<P>
<A NAME="IDX1583"></A>
<A NAME="IDX1584"></A>
<A NAME="IDX1585"></A>

</P>
<P>
Если встречаются трудности с применением <code>MyODBC</code>, то следует начинать с
получения системного журнала менеджера ODBC (журнал, получаемый при
затребовании записей в Администраторе ODBC) и журнала <code>MyODBC</code>.

</P>
<P>
Чтобы получить журнал <code>MyODBC</code>, необходимо выполнить следующие действия:

</P>

<ol>
<LI>

Убедитесь, что вы используете <tt>`myodbcd.dll'</tt>, а не <tt>`myodbc.dll'</tt>. Наиболее
простой способ - получить файл <tt>`myodbcd.dll'</tt> из дистрибутива <code>MyODBC</code> и
скопировать его поверх файла <tt>`myodbc.dll'</tt>, который должен находиться в
вашем каталоге <tt>`C:\windows\system32'</tt> или <tt>`C:\winnt\system32'</tt>. Однако после
окончания тестирования целесообразно восстановить старый файл
<tt>`myodbc.dll'</tt>, поскольку он намного быстрее, чем <tt>`myodbcd.dll'</tt>.
<LI>

Включите опцию <code>Trace</code> <code>MyODBC</code> в окне подключения/конфигурации <code>MyODBC</code>.
Информация будет записываться в файл <tt>`C:\myodbc.log'</tt>. Если опция
трассировки не запоминается при возвращении к предыдущему окну, то это
означает, что сейчас драйвер <tt>`myodbcd.dll'</tt> не используется (см. пункт
выше).
<LI>

Запустите свое приложение и попытайтесь получить отказ в работе.
</ol>

<P>
Проверьте трассировочный файл <code>MyODBC</code>, что бы попытаться выяснить, в чем
дело. Можно также найти сделанные вами запросы в файле <tt>`myodbc.log'</tt> -
поищите в нем строку  <code>&#62;mysql_real_query</code>.

</P>
<P>
Попробуйте также выполнить дублирование этих запросов с помощью монитора
<code>mysql</code> или <code>admndemo</code>, чтобы определить, где возникает ошибка - в MyODBC или
в MySQL.

</P>
<P>
Если вы обнаружите какую-либо ошибку, то присылайте, пожалуйста, только
строки, имеющие отношение к ней (максимум 40 строк), по адресу
<a HREF="mailto:myodbc@lists.mysql.com">myodbc@lists.mysql.com</a>. Просьба никогда не присылать полностью весь
системный журнал MyODBC или ODBC!

</P>
<P>
Если у вас нет возможности определить, что именно у вас не так, остается
последняя возможность - создать архив (tar или zip), содержащий
трассировочный файл MyODBC, системный журнал ODBC и файл README с
описанием своей проблемы. Вы можете послать это по адресу
<a HREF="ftp://support.mysql.com/pub/mysql/secret/">ftp://support.mysql.com/pub/mysql/secret/</a>. В MySQL  AB только мы будем
иметь доступ к присланным вами файлам. Гарантируем, что с ними мы будем
обращаться очень осторожно!

</P>
<P>
Если вы можете создать программу для демонстрации данной проблемы,
присылайте, пожалуйста, и ее тоже!

</P>
<P>
Если эта программа работает с некоторыми другими серверами SQL, следует
сделать системный журнал ODBC, где вы делаете в точности то же самое в
другом сервере SQL.

</P>
<P>
Помните, что чем больше информации вы нам предоставите, тем больше
вероятность, что мы сможем решить данную проблему!

</P>


<H2><A NAME="C" HREF="manual.ru_toc.html#C">8.4  Интерфейс C для MySQL</A></H2>

<P>
<A NAME="IDX1586"></A>
<A NAME="IDX1587"></A>
<A NAME="IDX1588"></A>
<A NAME="IDX1589"></A>

</P>

<P>
Исходный код программного интерфейса (API) C распространяется вместе с
MySQL. Он включает в себя библиотеку <code>mysqlclient</code> и обеспечивает
возможность доступа к базе данных программам на С.

</P>
<P>
Многие клиенты исходного дистрибутива MySQL написаны на C. Они являются
хорошими примерами для демонстрации использования интерфейса C. Их можно
найти их в каталоге <code>clients</code> исходного дистрибутива MySQL.

</P>
<P>
Большинство других клиентских интерфейсов (за исключением Java) для
соединения с сервером MySQL используют библиотеку <code>mysqlclient</code>. Это
означает, что, например, можно извлечь определенную выгоду, используя те
же переменные окружения, что и в других клиентских программах, поскольку
на них есть ссылки из библиотеки (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  Клиентские сценарии и утилиты MySQL</A>, где приведен список этих переменных).

</P>
<P>
Клиент имеет максимальный размер буфера связи. Начальный размер этого
буфера составляет 16 Kб и автоматически увеличивается до максимального
значения 16 Mб. Поскольку размеры буфера увеличиваются только при
подтверждении запроса на это, то просто увеличение максимального предела
по умолчанию само по себе не обеспечит увеличения используемых ресурсов.
Проверка этого размера в основном используется для ошибочных запросов и
коммуникационных пакетов.

</P>
<P>
Буфер связи должен быть достаточно большим, чтобы вмещать целую
SQL-команду (для потока клиент-сервер) и целую строку возвращенных данных
(для потока сервер-клиент). Буфер связи для каждого из потоков динамически
увеличивается до максимального значения, чтобы обработать любой запрос или
строку. Например, для данных типа <code>BLOB</code> объемом до 16 Mб необходим предел
буфера связи по меньшей мере в 16 Mб (как для сервера, так и для клиента).
Максимальное значение по умолчанию для клиента составляет 16 Mб, а для
сервера максимум по умолчанию равен 1Mб. Можно увеличить этот объем,
изменив величину параметра <code>max_allowed_packet</code> при запуске сервера (see section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>).

</P>
<P>
Сервер MySQL сжимает каждый буфер связи до величины <code>net_buffer_length</code>
байтов после каждого запроса. Для клиентов размер буфера, связанного с
соединением, не уменьшается, пока не будет закрыто данное соединение и при
этом не будет освобождена выделенная клиенту память.

</P>
<P>
Программирование с учетом потоков описано в разделе See section <A HREF="manual.ru_Clients.html#Threaded_clients">8.4.8  Как создать клиентскую программу с потоками</A>. При создании автономного приложения, включающего и "сервер", и
"клиент" в одной и той же программе (и не взаимодействующего с внешним
сервером MySQL), обращайтесь к разделу See section <A HREF="manual.ru_Clients.html#libmysqld">8.4.9  libmysqld, встраиваемая библиотека сервера MySQL</A>.

</P>



<H3><A NAME="C_API_datatypes" HREF="manual.ru_toc.html#C_API_datatypes">8.4.1  Типы данных C API</A></H3>

<DL COMPACT>

<DT><code>MYSQL</code>
<DD>
<A NAME="IDX1590"></A>
 
Данная структура представляет дескриптор соединения с базой данных.
Используется почти во всех функциях MySQL.

<A NAME="IDX1591"></A>
<DT><code>MYSQL_RES</code>
<DD>
Эта структура содержит результат запроса, возвратившего строки (<code>SELECT</code>,
<code>SHOW</code>, <code>DESCRIBE</code>, <code>EXPLAIN</code>). Возвращенная из запроса информация далее в этом
разделе называется результирующим набором данных.

<A NAME="IDX1592"></A>
<DT><code>MYSQL_ROW</code>
<DD>
Является ``типобезопасным'' представлением данных одной строки.
В настоящее время этот тип реализован как массив строк с фиксированным
количеством байтов (их нельзя трактовать как строки с нулевым символом в
конце, если величины полей могут содержать двоичные данные, поскольку они
могут содержать ноль байтов). Строки можно получить вызовом функции
<code>mysql_fetch_row()</code>.

<A NAME="IDX1593"></A>
<DT><code>MYSQL_FIELD</code>
<DD>
Данная структура содержит информацию об отдельном поле таблицы: имя поля,
тип и его размер. Элементы данной структуры детально описаны в этом
разделе ниже. Для каждого поля можно получить структуру <code>MYSQL_FIELD</code>,
последовательно вызывая функцию <code>mysql_fetch_field()</code>. Величины полей не
являются частью данной структуры, они содержатся в структуре <code>MYSQL_ROW</code>.

<A NAME="IDX1594"></A>
<DT><code>MYSQL_FIELD_OFFSET</code>
<DD>
``Типобезопасное'' представление позиции поля в списке полей MySQL.
(используется функцией <code>mysql_field_seek()</code>). Позиции представляют собой
номера полей внутри строки, причем нумерация начинается с нуля.

<A NAME="IDX1595"></A>
<A NAME="IDX1596"></A>
<DT><code>my_ulonglong</code>
<DD>
Данный тип используется для возврата количества строк, а также в функциях
<code>mysql_affected_rows()</code>, <code>mysql_num_rows()</code> и <code>mysql_insert_id()</code>. Этот тип
обеспечивает диапазон изменений величин от 0 до 1.84e19. Может не работать
в некоторых системах при выводе величины типа <code>my_ulonglong</code>. Для вывода
подобной величины следует преобразовать ее в тип <code>unsigned long</code> и
использовать формат <code>%lu</code>. Пример:

<pre>
printf (Количество  строк: %lu\n", (unsigned long) mysql_num_rows(result));
</pre>

</DL>

<P>
Структура <code>MYSQL_FIELD</code> содержит следующие перечисленные ниже элементы:

</P>
<DL COMPACT>

<DT><code>char * name</code>
<DD>
Имя данного поля, заданное строкой с нулевым символом в конце.

<DT><code>char * table</code>
<DD>
Имя таблицы, содержащей это поле, если оно невычисляемое. Для полей,
получаемых в результате вычислений, величина <code>table</code> представляет собой
пустую строку.

<DT><code>char * def</code>
<DD>
Значение по умолчанию этого поля, заданное строкой с нулевым символом в
конце. Задается только при использовании функции <code>mysql_list_fields()</code>.

<DT><code>enum enum_field_types type</code>
<DD>
Тип данного поля. Величина <code>type</code> может быть одной из следующих:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип величины</strong> </TD><TD> <strong>Описание типа</strong>
</TD></TR>
<TR><TD><code>FIELD_TYPE_TINY</code> </TD><TD> Поле <code>TINYINT</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_SHORT</code> </TD><TD> Поле <code>SMALLINT</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_LONG</code> </TD><TD> Поле <code>INTEGER</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_INT24</code> </TD><TD> Поле <code>MEDIUMINT</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_LONGLONG</code> </TD><TD> Поле <code>BIGINT</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_DECIMAL</code> </TD><TD> Поле <code>DECIMAL</code> или <code>NUMERIC</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_FLOAT</code> </TD><TD> Поле <code>FLOAT</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_DOUBLE</code> </TD><TD> Поле <code>DOUBLE</code> или <code>REAL</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_TIMESTAMP</code> </TD><TD> Поле <code>TIMESTAMP</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_DATE</code> </TD><TD> Поле <code>DATE</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_TIME</code> </TD><TD> Поле <code>TIME</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_DATETIME</code> </TD><TD> Поле <code>DATETIME</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_YEAR</code> </TD><TD> Поле <code>YEAR</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_STRING</code> </TD><TD> Строка поля (<code>CHAR</code> или <code>VARCHAR</code>)
</TD></TR>
<TR><TD><code>FIELD_TYPE_BLOB</code> </TD><TD> <code>BLOB</code> или <code>TEXT</code> поле (используется <code>max_length</code> для определения максимальной длинны)
</TD></TR>
<TR><TD><code>FIELD_TYPE_SET</code> </TD><TD> Поле типа <code>SET</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_ENUM</code> </TD><TD> Поле типа <code>ENUM</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_NULL</code> </TD><TD> Поле типа <code>NULL</code>
</TD></TR>
<TR><TD><code>FIELD_TYPE_CHAR</code> </TD><TD> Не рекомендуется; лучше использовать <code>FIELD_TYPE_TINY</code>
</TD></TR>
</TABLE>

Можно использовать макрос <code>IS_NUM()</code> для проверки, является ли тип поля
числовым. В макросе <code>IS_NUM()</code> следует указать величину <code>type</code> и, если поле
имеет числовой тип, будет возвращено значение <code>TRUE</code>:


<pre>
if (IS_NUM(field-&#62;type))
   printf("Field is numeric\n");
</pre>

<DT><code>unsigned int length</code>
<DD>
Размер данного поля в том виде, в каком он указан в определении таблицы.

<DT><code>unsigned int max_length</code>
<DD>
Максимальный размер данного поля в результирующем наборе данных (длина
самой большой величины поля для строк в текущем результирующем наборе
данных). При использовании <code>mysql_store_result()</code> или <code>mysql_list_fields()</code> 
данная переменная содержит максимальную длину для данного поля. При
использовании <code>mysql_use_result()</code> значение этой переменной равно нулю.

<DT><code>unsigned int flags</code>
<DD>
Различные двоичные флаги для данного поля. Величина <code>flags</code> может иметь ноль
или больше двоичных значений следующего набора флагов:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Значение флага</strong> </TD><TD> <strong>описание флага</strong>
</TD></TR>
<TR><TD><code>NOT_NULL_FLAG</code> </TD><TD> Поле не может содержать значение <code>NULL</code>
</TD></TR>
<TR><TD><code>PRI_KEY_FLAG</code> </TD><TD> Поле является частью первичного ключа
</TD></TR>
<TR><TD><code>UNIQUE_KEY_FLAG</code> </TD><TD> Поле является частью уникального ключа
</TD></TR>
<TR><TD><code>MULTIPLE_KEY_FLAG</code> </TD><TD> Поле является частью не уникального ключа
</TD></TR>
<TR><TD><code>UNSIGNED_FLAG</code> </TD><TD> Поле  имеет  атрибут <code>UNSIGNED</code>
</TD></TR>
<TR><TD><code>ZEROFILL_FLAG</code> </TD><TD> Поле  имеет  атрибут <code>ZEROFILL</code>
</TD></TR>
<TR><TD><code>BINARY_FLAG</code> </TD><TD> Поле  имеет  атрибут <code>BINARY</code>
</TD></TR>
<TR><TD><code>AUTO_INCREMENT_FLAG</code> </TD><TD> Поле  имеет  атрибут <code>AUTO_INCREMENT</code>
</TD></TR>
<TR><TD><code>ENUM_FLAG</code> </TD><TD> Поле имеет тип <code>ENUM</code> (не рекомендуется)
</TD></TR>
<TR><TD><code>SET_FLAG</code> </TD><TD> Поле имеет тип <code>SET</code> (не рекомендуется)
</TD></TR>
<TR><TD><code>BLOB_FLAG</code> </TD><TD> Поле имеет тип <code>BLOB</code> или <code>TEXT</code> (не рекомендуется)
</TD></TR>
<TR><TD><code>TIMESTAMP_FLAG</code> </TD><TD> Поле имеет тип <code>TIMESTAMP</code> (не рекомендуется)
</TD></TR>
</TABLE>

Использование флагов <code>BLOB_FLAG</code>, <code>ENUM_FLAG</code>, <code>SET_FLAG</code> и <code>TIMESTAMP_FLAG</code> не
рекомендуется, поскольку они указывают скорее тип поля, чем атрибут этого
типа. Вместо этого более предпочтительно определять тип поля описанным
выше способом <code>field-&#62;type</code> в отношении полей <code>FIELD_TYPE_BLOB</code>,
<code>FIELD_TYPE_ENUM</code>, <code>FIELD_TYPE_SET</code> или <code>FIELD_TYPE_TIMESTAMP</code>. Следующий пример
иллюстрирует типичное использование величины <code>flags</code>:


<pre>
if (field-&#62;flags &#38; NOT_NULL_FLAG)
   printf("Field can't be null\n");
</pre>

Можно использовать следующие возможности макросов для определения булевого
значения величины <code>flags</code>:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Статус флага</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>IS_NOT_NULL(flags)</code> </TD><TD> Возвращает TRUE, если данное поле определено как <code>NOT NULL</code>
</TD></TR>
<TR><TD><code>IS_PRI_KEY(flags)</code> </TD><TD> Возвращает TRUE, если данное поле является первичным ключом
</TD></TR>
<TR><TD><code>IS_BLOB(flags)</code> </TD><TD> Возвращает TRUE, если данное поле имеет тип <code>BLOB</code> или <code>TEXT</code> (не рекомендуется; более предпочтительно <code>field-&#62;type</code>)
</TD></TR>
</TABLE>

<DT><code>unsigned int decimals</code>
<DD>
Возвращает число десятичных знаков для числовых полей.
</DL>



<H3><A NAME="C_API_function_overview" HREF="manual.ru_toc.html#C_API_function_overview">8.4.2  Обзор функций интерфейса C</A></H3>

<P>
<A NAME="IDX1597"></A>
<A NAME="IDX1598"></A>

</P>
<P>
В приведенной ниже таблице перечислены доступные в интерфейсе C функции.
Более детально они описаны в следующем разделе (see section <A HREF="manual.ru_Clients.html#C_API_functions">8.4.3  Описание функций интерфейса C</A>).
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Функция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><strong>mysql_affected_rows()</strong> </TD><TD>
Возвращает количество строк, измененных/удаленных/вставленных последним запросом <code>UPDATE</code>, <code>DELETE</code> или <code>INSERT</code>.
</TD></TR>
<TR><TD><strong>mysql_change_user()</strong> </TD><TD> Переключает пользователя и базу данных для открытого соединения.

</TD></TR>
<TR><TD><strong>mysql_character_set_name()</strong> </TD><TD> Возвращает название кодировки, установленной для данного соединения.

</TD></TR>
<TR><TD><strong>mysql_close()</strong> </TD><TD> Закрывает соединение с сервером.

</TD></TR>
<TR><TD><strong>mysql_connect()</strong> </TD><TD> Создает соединение с сервером баз данных MySQL. Данная функция не рекомендуется; вместо нее следует использовать функцию <code>mysql_real_connect()</code>.

</TD></TR>
<TR><TD><strong>mysql_create_db()</strong> </TD><TD> Создает базу данных. Данная функция не рекомендуется; вместо нее следует использовать команду SQL <code>CREATE DATABASE</code>.

</TD></TR>
<TR><TD><strong>mysql_data_seek()</strong> </TD><TD> Ищет произвольную строку в результирующем наборе запроса.

</TD></TR>
<TR><TD><strong>mysql_debug()</strong> </TD><TD> Выполняет отладочные операции <code>DBUG_PUSH</code> с заданной строкой.

</TD></TR>
<TR><TD><strong>mysql_drop_db()</strong> </TD><TD> Удаляет базу данных. Эта функция не рекомендуется; вместо нее следует использовать команду SQL <code>DROP DATABASE</code>.

</TD></TR>
<TR><TD><strong>mysql_dump_debug_info()</strong> </TD><TD> Заставляет сервер записывать отладочную информацию в журнал.

</TD></TR>
<TR><TD><strong>mysql_eof()</strong> </TD><TD> Определяет, была ли данная строка последней из прочитанных в результирующем наборе данных. Эта функция не рекомендуется; <code>mysql_errno()</code> или <code>mysql_error()</code> могут быть использованы вместо нее.

</TD></TR>
<TR><TD><strong>mysql_errno()</strong> </TD><TD> Возвращает номер ошибки для последней запущенной функции MySQL.

</TD></TR>
<TR><TD><strong>mysql_error()</strong> </TD><TD> Возвращает сообщение об ошибке для последней запущенной функции MySQL.

</TD></TR>
<TR><TD><strong>mysql_escape_string()</strong> </TD><TD> Экранирует специальные символы в строке, чтобы ее было возможно использовать в команде SQL.

</TD></TR>
<TR><TD><strong>mysql_fetch_field()</strong> </TD><TD> Возвращает тип следующего поля таблицы.

</TD></TR>
<TR><TD><strong>mysql_fetch_field_direct()</strong> </TD><TD> Возвращает тип поля таблицы по заданному номеру поля.

</TD></TR>
<TR><TD><strong>mysql_fetch_fields()</strong> </TD><TD> Возвращает массив структур, содержащих информацию обо всех полях.

</TD></TR>
<TR><TD><strong>mysql_fetch_lengths(</strong>) </TD><TD> Возвращает массив длин всех столбцов в текущей строке.

</TD></TR>
<TR><TD><strong>mysql_fetch_row()</strong> </TD><TD> Извлекает следующую строку из результирующего набора.

</TD></TR>
<TR><TD><strong>mysql_field_seek()</strong> </TD><TD> Устанавливает курсор столбцов на заданный столбец.

</TD></TR>
<TR><TD><strong>mysql_field_count()</strong> </TD><TD> Возвращает количество столбцов в результате для последнего запроса.

</TD></TR>
<TR><TD><strong>mysql_field_tell()</strong> </TD><TD> Возвращает значение положения курсора поля для последнего вызова <code>mysql_fetch_field()</code>.

</TD></TR>
<TR><TD><strong>mysql_free_result(</strong>) </TD><TD> Освобождает память, использованную для результирующего набора.

</TD></TR>
<TR><TD><strong>mysql_get_client_info()</strong> </TD><TD> Возвращает информацию о версии клиента.

</TD></TR>
<TR><TD><strong>mysql_get_host_info()</strong> </TD><TD> Возвращает строку, описывающую параметры текущего соединения.

</TD></TR>
<TR><TD><code>mysql_get_server_version()</code> </TD><TD> Возвращает номер версии сервера как целое число (новое с 4.1)

</TD></TR>
<TR><TD><strong>mysql_get_proto_info()</strong> </TD><TD> Возвращает версию протокола, используемого для данного соединения.

</TD></TR>
<TR><TD><strong>mysql_get_server_info()</strong> </TD><TD> Возвращает номер версии сервера баз данных.

</TD></TR>
<TR><TD><strong>mysql_info()</strong> </TD><TD> Возвращает информацию о последнем выполненном запросе.

</TD></TR>
<TR><TD><strong>mysql_init()</strong> </TD><TD> Выделяет или инициализирует какую-либо структуру MYSQL.

</TD></TR>
<TR><TD><strong>mysql_insert_id()</strong> </TD><TD> Возвращает идентификатор, сгенерированный для столбца <code>AUTO_INCREMENT</code> предыдущим запросом.

</TD></TR>
<TR><TD><strong>mysql_kill()</strong> </TD><TD> Уничтожает заданный поток.

</TD></TR>
<TR><TD><strong>mysql_list_dbs()</strong> </TD><TD> Возвращает имена баз данных, совпадающие с простым регулярным выражением.

</TD></TR>
<TR><TD><strong>mysql_list_fields()</strong> </TD><TD> Возвращает имена полей, совпадающих с простым регулярным выражением.

</TD></TR>
<TR><TD><strong>mysql_list_processes()</strong> </TD><TD> Возвращает список текущих потоков на сервере.

</TD></TR>
<TR><TD><strong>mysql_list_tables()</strong> </TD><TD> Возвращает имена таблиц, совпадающих с простым регулярным выражением.

</TD></TR>
<TR><TD><strong>mysql_num_fields()</strong> </TD><TD> Возвращает количество столбцов в результирующем наборе.

</TD></TR>
<TR><TD><strong>mysql_num_rows()</strong> </TD><TD> Возвращает количество строк в результирующем наборе.

</TD></TR>
<TR><TD><strong>mysql_options()</strong> </TD><TD> Устанавливает параметры соединения для <code>mysql_connect()</code>.

</TD></TR>
<TR><TD><strong>mysql_ping()</strong> </TD><TD> Проверяет, работает ли данное соединение с сервером, и восстанавливает соединение при необходимости.

</TD></TR>
<TR><TD><strong>mysql_query()</strong> </TD><TD> Выполняет SQL-запрос, заданный в виде строки с нулевым символом в конце.

</TD></TR>
<TR><TD><strong>mysql_real_connect()</strong> </TD><TD> Создает соединение с сервером баз данных MySQL.

</TD></TR>
<TR><TD><strong>mysql_real_escape_string()</strong> </TD><TD> Экранирует специальные символы в строке, чтобы обеспечить возможность использования ее в команде SQL, с учетом установленной для данного соединения кодировки.

</TD></TR>
<TR><TD><strong>mysql_real_query()</strong> </TD><TD> Выполняет SQL-запрос, заданный в виде фиксированной строки.

</TD></TR>
<TR><TD><strong>mysql_reload()</strong> </TD><TD> Предписывает серверу перегрузить таблицы привилегий.

</TD></TR>
<TR><TD><strong>mysql_row_seek()</strong> Устанавливает курсор на заданную строку в результирующем наборе, используя величину, возвращенную из <code>mysql_row_tell()</code>.

</TD></TR>
<TR><TD><strong>mysql_row_tell()</strong> </TD><TD> Возвращает положение курсора строки.

</TD></TR>
<TR><TD><strong>mysql_select_db()</strong> </TD><TD> Выбирает базу данных.

</TD></TR>
<TR><TD><strong>mysql_shutdown()</strong> </TD><TD> Останавливает сервер баз данных.

</TD></TR>
<TR><TD><strong>mysql_stat()</strong> </TD><TD> Возвращает информацию о текущем статусе сервера баз данных в виде строки.

</TD></TR>
<TR><TD><strong>mysql_store_result()</strong> </TD><TD> Извлекает полный результирующий набор для данного клиента.

</TD></TR>
<TR><TD><strong>mysql_thread_id()</strong> </TD><TD> Возвращает идентификатор текущего потока.

</TD></TR>
<TR><TD><strong>mysql_thread_safe()</strong> </TD><TD> Возвращает 1, если клиенты скомпилированы как поддерживающие потоки.

</TD></TR>
<TR><TD><strong>mysql_use_result()</strong> </TD><TD> Инициализирует построчное извлечение результирующего набора.
</TD></TR>
</TABLE>

</P>
<P>
При подсоединения к серверу необходимо вызвать функцию <code>mysql_init()</code> для
инициализации дескриптора соединения, затем с этим дескриптором вызвать
функцию <code>mysql_real_connect()</code> (которая содержит такую информацию, как имя
данного хоста, имя пользователя и пароль). После соединения функция
<code>mysql_real_connect()</code> устанавливает флаг <code>reconnect</code> (часть данной структуры
MYSQL) в значение <code>1</code>. Этот флаг указывает, что в случае, если запрос не
может быть выполнен из-за потери соединения, следует попытаться
восстановить соединение с сервером до окончательного отказа от него. Для
закрытия соединения вызывается функция <code>mysql_close()</code>.

</P>
<P>
При активном соединении клиент может посылать SQL-запросы на сервер,
используя функции <code>mysql_query()</code> или <code>mysql_real_query()</code>. Разница между
этими двумя функциями состоит в том, что <code>mysql_query()</code> работает с
запросом, представленным в виде строки с нулевыми окончаниями, в то время,
как <code>mysql_real_query()</code> работает со строками фиксированной длины. Если
данная строка содержит двоичные данные (которые могут состоять из нуля
байтов), то необходимо использовать <code>mysql_real_query()</code>.

</P>
<P>
Для каждого запроса без выборки данных (т.е. не вида <code>SELECT</code>, а, например,
<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) можно узнать количество измененных (затронутых)
строк путем вызова функции <code>mysql_affected_rows()</code>.

</P>
<P>
Для запросов <code>SELECT</code> можно извлечь выбранные строки как результирующий
набор. (Следует учитывать, что некоторые команды сходны с <code>SELECT</code> в том
смысле, что они тоже возвращают строки. Это команды <code>SHOW</code>, <code>DESCRIBE</code> и
<code>EXPLAIN</code>. Они должны трактоваться тем же образом, что и команды <code>SELECT</code>.)

</P>
<P>
Для клиента существует два способа обработки результирующих наборов
данных. Первый состоит в извлечении сразу всего результирующего набора
целиком вызовом функции <code>mysql_store_result()</code>. Эта функция забирает с
сервера все строки, возвращенные запросом, и хранит их в данном клиенте.
Второй способ заключается в инициализации для клиента построчного
извлечения результирующего набора путем вызова функции <code>mysql_use_result()</code>.
Эта функция инициализирует указанное извлечение, но фактически не получает
с сервера ни одной строки.

</P>
<P>
В обоих случаях доступ к строкам происходит с помощью функции
<code>mysql_fetch_row()</code>. Совместно с <code>mysql_store_result()</code> <code>mysql_fetch_row()</code> 
осуществляет доступ к строкам, уже извлеченным с сервера. Совместно с
<code>mysql_use_result()</code> <code>mysql_fetch_row()</code> реально получает данную строку с
сервера. Информацию о размере данных в каждой строке можно получить
вызовом функции <code>mysql_fetch_lengths()</code>.

</P>
<P>
После выполнения операций с результирующим набором необходимо вызвать
функцию <code>mysql_free_result()</code>, чтобы освободить использованную для этого
память.

</P>
<P>
Два описанных выше механизма извлечения данных являются
взаимодополняющими. Клиентские программы должны выбирать наиболее
подходящий для их требований способ. На практике клиенты обычно стремятся
использовать функцию <code>mysql_store_result()</code>.

</P>
<P>
Преимущество функции <code>mysql_store_result()</code> состоит в том, что, поскольку
все строки выбраны и находятся у клиента, то возможен не только
последовательный доступ к строкам. В результирующем наборе данных можно
перемещаться назад и вперед в, используя функции <code>mysql_data_seek()</code> или
<code>mysql_row_seek()</code>, чтобы изменить положение текущей строки внутри
результирующего набора. Можно также узнать количество находящихся в нем
строк, вызвав функцию <code>mysql_num_rows()</code>. С другой стороны, для
<code>mysql_store_result()</code> требования к памяти могут быть очень высокими для
обширных результирующих наборов, что может привести к нехватке памяти.

</P>
<P>
Преимущество функции <code>mysql_use_result()</code> заключается в том, что клиент
требует меньше памяти для результирующего набора, поскольку он сохраняет
только одну строку единовременно (и, так как это меньше перегружает
память, то функция <code>mysql_use_result()</code> может быть быстрее). Недостатками
являются: необходимость обрабатывать каждую строку быстро, чтобы избежать
связывания сервера, невозможность произвольного доступа к строкам внутри
результирующего набора (возможен только последовательный доступ к
строкам), невозможность узнать количество строк в результирующем наборе до
его полного извлечения. Более того, необходимо извлекать все строки, даже
если в середине извлечения станет ясно, что искомая информация найдена.

</P>
<P>
Благодаря интерфейсу клиенты получают возможность соответствующим образом
реагировать на запросы (извлекать строки только при необходимости) без
уточнения, являлся или нет данный запрос выборкой. Это можно делать,
вызывая функцию <code>mysql_store_result()</code> после каждого вызова <code>mysql_query()</code> 
(или <code>mysql_real_query()</code>). Если вызов результирующего набора был успешным,
то данный запрос принадлежал к виду <code>SELECT</code> и можно производить чтение
строк. Если вызов результирующего набора не удался, можно вызвать функцию
<code>mysql_field_count()</code> для определения, можно ли было действительно ожидать
результат. Если <code>mysql_field_count()</code> возвращает нуль, то данный запрос не
возвратил никаких данных (это указывает, что запрос был вида <code>INSERT</code>,
<code>UPDATE</code>, <code>DELETE</code> и т.д.), и не следовало ожидать возвращенных строк. Если
функция <code>mysql_field_count()</code> является ненулевой, данный запрос должен был
возвратить результат, но не сделал этого. Это указывает, что данный запрос
был типа <code>SELECT</code>, но его выполнение оказалось неуспешным (см. пример в
описании функции <code>mysql_field_count()</code>).

</P>
<P>
Как <code>mysql_store_result()</code> так и <code>mysql_use_result()</code> позволяют получить
информацию о полях, составляющих результирующий набор (количество полей,
их имена и типы и т.д.). Можно получить последовательный доступ к
информации о полях внутри строки путем повторного вызова функции
<code>mysql_fetch_field()</code> или к номеру поля внутри строки с помощью функции
<code>mysql_fetch_field_direct()</code>. Текущее положение курсора поля может быть
изменено вызовом функции <code>mysql_field_seek()</code>. Установка курсора
производится последующим вызовом функции <code>mysql_fetch_field()</code>. Можно также
получить информацию для всех полей сразу с помощью функции
<code>mysql_fetch_fields()</code>.

</P>
<P>
Для обнаружения ошибок и сообщения о них MySQL обеспечивает доступ к
информации об ошибках посредством функций <code>mysql_errno()</code> и <code>mysql_error()</code>.
Они возвращают код ошибки или сообщение об ошибке для последней запущенной
функции (которая может быть успешной или не выполниться), позволяя
определить место возникновения и характер ошибки.

</P>


<H3><A NAME="C_API_functions" HREF="manual.ru_toc.html#C_API_functions">8.4.3  Описание функций интерфейса C</A></H3>

<P>
В приведенных здесь описаниях параметр или возвращаемая величина,
обозначенная как <code>NULL</code>, означает <code>NULL</code> в терминах языка программирования C,
а не величину <code>NULL</code> в MySQL.

</P>
<P>
Функции, возвращающие величину, обычно возвращают указатель или целое
число. Если не указано иначе, то функции, возвращающие указатель,
возвращают величину не-<code>NULL</code> при успешном выполнении или величину <code>NULL</code>,
указывающую на ошибку, а функции, возвращающие целое число, возвращают
нуль при успешном выполнении или ненулевую величину при возникновении
ошибки. Следует учитывать, что термин ``ненулевая величина'' означает
именно это. Если в описании функции не сказано иначе, то не следует
пробовать интерпретировать эту величину иначе, чем нуль:

</P>

<pre>
if (result)		 /* правильно */
   ... error ...
if (result &#60; 0)		 /* неправильно */
   ... error ...
if (result == -1)	 /* неправильно */
   ... error ...
</pre>

<P>
Если функция возвращает ошибку, то возможные типы ошибок представлены в ее
описании в подраздел <strong>Ошибки</strong>. Вызвав функцию <code>mysql_errno()</code>, можно узнать,
какие именно ошибки произошли. Строковое представление ошибки можно
получить, вызывая функцию <code>mysql_error()</code>.

</P>


<H4><A NAME="mysql_affected_rows" HREF="manual.ru_toc.html#mysql_affected_rows">8.4.3.1  <code>mysql_affected_rows()</code></A></H4>

<P>
<A NAME="IDX1599"></A>

</P>
<P>
<code>my_ulonglong mysql_affected_rows(MYSQL *mysql)</code>

</P>

<H4>8.4.3.2  Описание</H4>

<P>
Возвращает количество строк, измененных последней командой <code>UPDATE</code>,
удаленных последней командой <code>DELETE</code> или вставленных последней командой
<code>INSERT</code>. Может быть вызвана немедленно после <code>mysql_query()</code> для команд
<code>UPDATE</code>, <code>DELETE</code> или <code>INSERT</code>. Для команд <code>SELECT</code> <code>mysql_affected_rows()</code> 
работает аналогично <code>mysql_num_rows()</code>.

</P>

<H4>8.4.3.3  Возвращаемые значения</H4>

<P>
Целое число больше нуля равно количеству строк, подвергшихся воздействию
или извлеченных. Нуль указывает, что ни одна из записей не была обновлена
для команды <code>UPDATE</code>, ни одна из строк не совпала с утверждением <code>WHERE</code> в
данном запросе или что ни один запрос еще не был выполнен. Значение -1
показывает, что данный запрос возвратил ошибку или что для запроса <code>SELECT</code>
функция <code>mysql_affected_rows()</code> была вызвана прежде вызова функции
<code>mysql_store_result()</code>.

</P>

<H4>8.4.3.4  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.5  Пример</H4>


<pre>
mysql_query(&#38;mysql,"UPDATE products SET cost=cost*1.25 WHERE group=10");
printf("%ld products updated",(long) mysql_affected_rows(&#38;mysql));
</pre>

<P>
Если указывается флаг <code>CLIENT_FOUND_ROWS</code> при подключении к <code>mysqld</code>, то
<code>mysql_affected_rows()</code> возвратит количество строк, соответствующих
выражению <code>WHERE</code> для команд <code>UPDATE</code>.

</P>
<P>
Следует отметить, что при использовании команды <code>REPLACE</code> функция
<code>mysql_affected_rows()</code> возвратит значение 2, если новая строка заменила
старую. Это происходит по той причине, что в данном случае одна строка
была внесена после того как дублирующая была удалена.

</P>


<H4><A NAME="mysql_change_user" HREF="manual.ru_toc.html#mysql_change_user">8.4.3.6  <code>mysql_change_user()</code></A></H4>

<P>
<A NAME="IDX1600"></A>

</P>
<P>
<code>my_bool mysql_change_user(MYSQL *mysql, const char *user, const
char *password, const char *db)</code>

</P>

<H4>8.4.3.7  Описание</H4>

<P>
Изменяет пользователя и устанавливает базу данных, указанную в аргументе
<code>db</code> в качестве текущей по базы данных для соединения, заданного в аргументе
<code>mysql</code>. В последующих запросах эта база данных является текущей по
умолчанию для табличных ссылок, которые не содержат явного указателя базы
данных.

</P>
<P>
Эта функция была введена в версию MySQL 3.23.3.

</P>
<P>
Функция <code>mysql_change_user()</code> не выполняется, если подключенный пользователь
не может быть аутентифицирован или если он не имеет разрешения на
использование этой базы данных. В таком случае данный пользователь и база
данных не изменяются.

</P>
<P>
Параметр <code>db</code> может быть установлен в <code>NULL</code>, если база данных по умолчанию не
нужна.

</P>
<P>
Начиная с версии 4.0.6 будет всегда производить откат любой начатой транзакции,
закрывать все временные таблицы, снимать блокировку со всех заблокированных
таблиц и переустанавливать состояние, если произошло новое соединение. Это
будет происходить даже в том случае, если имя пользователя не изменится.

</P>

<H4>8.4.3.8  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении. Ненулевая величина, если возникла ошибка.

</P>

<H4>8.4.3.9  Ошибки</H4>

<P>
Те же, что и для <code>mysql_real_connect()</code>.

</P>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.

<DT><code>ER_UNKNOWN_COM_ERROR</code>
<DD>
Сервер MySQL не обеспечивает выполнение этой команды (возможно, старая
версия сервера)

<DT><code>ER_ACCESS_DENIED_ERROR</code>
<DD>
Пользователь или пароль ошибочны.

<DT><code>ER_BAD_DB_ERROR</code>
<DD>
Данная база данных не существует.

<DT><code>ER_DBACCESS_DENIED_ERROR</code>
<DD>
Данный пользователь не имеет прав доступа к этой базе данных.

<DT><code>ER_WRONG_DB_NAME</code>
<DD>
Имя базы данных было слишком длинным.
</DL>


<H4>8.4.3.10  Пример</H4>


<pre>
if (mysql_change_user(&#38;mysql, "user", "password", "new_database"))
{
  fprintf(stderr, "Failed to change user. Error: %s\n",
  mysql_error(&#38;mysql));
}
</pre>



<H4><A NAME="mysql_character_set_name" HREF="manual.ru_toc.html#mysql_character_set_name">8.4.3.11  <code>mysql_character_set_name()</code></A></H4>
<P>
<A NAME="IDX1601"></A>

</P>
<P>
<code>const char *mysql_character_set_name(MYSQL *mysql)</code>

</P>

<H4>8.4.3.12  Описание</H4>

<P>
Возвращает установленную кодировку для текущего подключения.

</P>

<H4>8.4.3.13  Возвращаемые значения</H4>

<P>
Кодировка, установленная по умолчанию.

</P>

<H4>8.4.3.14  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_close" HREF="manual.ru_toc.html#mysql_close">8.4.3.15  <code>mysql_close()</code></A></H4>
<P>
<A NAME="IDX1602"></A>

</P>
<P>
<code>void mysql_close(MYSQL *mysql)</code>

</P>

<H4>8.4.3.16  Описание</H4>

<P>
Закрывает ранее открытое соединение. Функция <code>mysql_close()</code> также
освобождает дескриптор данного соединения, указанный в <code>mysql</code>, если данный
дескриптор был выделен автоматически функциями <code>mysql_init()</code> или
<code>mysql_connect()</code>.

</P>

<H4>8.4.3.17  Возвращаемые значения</H4>

<P>
Нет.

</P>

<H4>8.4.3.18  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_connect" HREF="manual.ru_toc.html#mysql_connect">8.4.3.19  <code>mysql_connect()</code></A></H4>
<P>
<A NAME="IDX1603"></A>

</P>
<P>
<code>MYSQL *mysql_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd)</code>

</P>

<H4>8.4.3.20  Описание</H4>

<P>
Данная функция не рекомендуется. Вместо нее предпочтительно использовать
функцию <code>mysql_real_connect()</code>.

</P>
<P>
<code>mysql_connect()</code> пытается установить соединение с сервером баз данных MySQL
, работающим на хосте <code>host</code>. До успешного завершения функции
<code>mysql_connect()</code> нельзя выполнять никакие другие функции интерфейса, за
исключением <code>mysql_get_client_info()</code>.

</P>
<P>
Значения параметров являются теми же самыми, что и для соответствующих
параметров функции <code>mysql_real_connect()</code>, с той разницей, что параметр
соединения может быть <code>NULL</code>. В этом случае интерфейс C автоматически
выделяет память для структуры соединения и освобождает ее при вызове
функции <code>mysql_close()</code>. Недостаток данного подхода состоит в том, что при
падении соединения нельзя получить сообщение об ошибке (чтобы получить
информацию об ошибке из функций <code>mysql_errno()</code> или <code>mysql_error()</code>,
необходимо обеспечить адекватный указатель структуры MYSQL).

</P>

<H4>8.4.3.21  Возвращаемые значения</H4>

<P>
Те же, что и для <code>mysql_real_connect()</code>.

</P>

<H4>8.4.3.22  Ошибки</H4>

<P>
Те же, что и для <code>mysql_real_connect()</code>.

</P>


<H4><A NAME="mysql_create_db" HREF="manual.ru_toc.html#mysql_create_db">8.4.3.23  <code>mysql_create_db()</code></A></H4>
<P>
<A NAME="IDX1604"></A>

</P>
<P>
<code>int mysql_create_db(MYSQL *mysql, const char *db)</code>

</P>

<H4>8.4.3.24  Описание</H4>

<P>
Создает базу данных, указанную в параметре <code>db</code>.

</P>
<P>
Данная функция не рекомендуется. Вместо нее предпочтительно использовать
функцию <code>mysql_query()</code> для выполнения SQL-команды <code>CREATE DATABASE</code>.

</P>

<H4>8.4.3.25  Возвращаемые значения</H4>

<P>
Нуль, если база данных создана успешно. Ненулевая величина, если произошла
ошибка.

</P>

<H4>8.4.3.26  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>


<H4>8.4.3.27  Пример</H4>


<pre>
if(mysql_create_db(&#38;mysql, "my_database"))
{
  fprintf(stderr, "Failed to create new database. Error: %s\n", mysql_error(&#38;mysql));
}
</pre>



<H4><A NAME="mysql_data_seek" HREF="manual.ru_toc.html#mysql_data_seek">8.4.3.28  <code>mysql_data_seek()</code></A></H4>
<P>
<A NAME="IDX1605"></A>

</P>
<P>
<code>void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)</code>

</P>

<H4>8.4.3.29  Описание</H4>

<P>
Ищет произвольную строку в результирующем наборе запроса. Для этого
требуется, чтобы структура результирующего набора содержала целиком весь
результат данного запроса, поэтому <code>mysql_data_seek()</code> может использоваться
только в сочетании с <code>mysql_store_result()</code>, но не с <code>mysql_use_result()</code>.

</P>
<P>
Адрес смещения должен быть величиной в диапазоне от 0 до
<code>mysql_num_rows(result)-1</code>.

</P>

<H4>8.4.3.30  Возвращаемые значения</H4>

<P>
Нет.

</P>

<H4>8.4.3.31  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_debug" HREF="manual.ru_toc.html#mysql_debug">8.4.3.32  <code>mysql_debug()</code></A></H4>
<P>
<A NAME="IDX1606"></A>

</P>
<P>
<code>void mysql_debug(const char *debug)</code>

</P>

<H4>8.4.3.33  Описание</H4>

<P>
Выполняет отладочные операции <code>DBUG_PUSH</code> с заданной строкой. Функция
<code>mysql_debug()</code> использует отладочную библиотеку <code>Fred Fish debug</code>. Для
использования этой функции необходимо компилировать библиотеку клиента с
поддержкой отладки (см. разделы section <A HREF="manual.ru_Porting.html#Debugging_server">E.1  Отладка сервера MySQL</A> и see section <A HREF="manual.ru_Porting.html#Debugging_client">E.2  Отладка клиента MySQL</A>).

</P>

<H4>8.4.3.34  Возвращаемые значения</H4>

<P>
Нет.

</P>

<H4>8.4.3.35  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.36  Пример</H4>

<P>
Представленный здесь вызов функции заставляет библиотеку клиента
генерировать трассировочный файл в каталоге <tt>`/tmp/client.trace'</tt> на
клиентской машине:

</P>

<pre>
mysql_debug("d:t:O,/tmp/client.trace");
</pre>



<H4><A NAME="mysql_drop_db" HREF="manual.ru_toc.html#mysql_drop_db">8.4.3.37  <code>mysql_drop_db()</code></A></H4>
<P>
<A NAME="IDX1607"></A>

</P>
<P>
<code>int mysql_drop_db(MYSQL *mysql, const char *db)</code>

</P>

<H4>8.4.3.38  Описание</H4>

<P>
Уничтожает базу данных, указанную в параметре <code>db</code>.

</P>
<P>
Данная функция не рекомендуется. Вместо нее предпочтительно использовать
функцию <code>mysql_query()</code> для выполнения SQL-команды <code>DROP DATABASE</code>.

</P>

<H4>8.4.3.39  Возвращаемые значения</H4>

<P>
Нуль, если база данных удалена успешно. Ненулевая величина, если произошла
ошибка.

</P>

<H4>8.4.3.40  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>


<H4>8.4.3.41  Пример</H4>


<pre>
if(mysql_drop_db(&#38;mysql, "my_database"))
fprintf(stderr, "Failed to drop the database: Error: %s\n", mysql_error(&#38;mysql));
</pre>



<H4><A NAME="mysql_dump_debug_info" HREF="manual.ru_toc.html#mysql_dump_debug_info">8.4.3.42  <code>mysql_dump_debug_info()</code></A></H4>
<P>
<A NAME="IDX1608"></A>

</P>
<P>
<code>int mysql_dump_debug_info(MYSQL *mysql)</code>

</P>

<H4>8.4.3.43  Описание</H4>

<P>
Предписывает серверу производить запись отладочной информации в журнал.
Для работы функции необходимо, чтобы подключенный пользователь имел
привилегию <code>SUPER</code>.

</P>

<H4>8.4.3.44  Возвращаемые значения</H4>

<P>
Нуль, если команда выполнена успешно. Ненулевая величина, если произошла
ошибка.

</P>

<H4>8.4.3.45  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_eof" HREF="manual.ru_toc.html#mysql_eof">8.4.3.46  <code>mysql_eof()</code></A></H4>
<P>
<A NAME="IDX1609"></A>

</P>
<P>
<A NAME="IDX1610"></A>

</P>
<P>
<code>my_bool mysql_eof(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.47  Описание</H4>

<P>
Данная функция не рекомендуется. Вместо нее можно использовать функции
<code>mysql_errno()</code> или <code>mysql_error()</code>.

</P>
<P>
Функция <code>mysql_eof()</code> определяет, была ли данная строка последней из
прочитанных в результирующем наборе данных.

</P>
<P>
Если результирующий набор получен путем успешного вызова функции
<code>mysql_store_result()</code>, то данный клиент получает полный набор данных за
одну операцию. В этом случае возврат <code>NULL</code> из <code>mysql_fetch_row()</code> всегда
означает, что достигнут конец результирующего набора и нет необходимости в
вызове функции <code>mysql_eof()</code>. При использовании совместно с
<code>mysql_store_result()</code> функция <code>mysql_eof()</code> всегда будет возвращать <code>TRUE</code>.

</P>
<P>
С другой стороны, при использовании <code>mysql_use_result()</code> для инициализации
извлечения результирующего набора, клиент получает строки набора с сервера
поочередно при повторных вызовах функции <code>mysql_fetch_row()</code>. Поскольку в
этом процессе может возникнуть ошибка в соединении, <code>NULL</code>, полученный от
<code>mysql_fetch_row()</code>, не всегда означает что конец результата был достигнут
корректно. В этом случае вы можете использовать <code>mysql_eof()</code>, чтобы
выяснить, что же случилось. <code>mysql_eof()</code> вернет ненулевую величину, если
конец результирующего набора был достигнут, и нуль, если произошла ошибка.

</P>
<P>
Исторически сложилось так, что <code>mysql_eof()</code> по своим задачам сходна со
стандартными функциями обработки ошибок MySQL <code>mysql_errno()</code> и
<code>mysql_error()</code>. Поскольку эти функции дают одну и ту же информацию, их
использование более предпочтительно чем <code>mysql_eof()</code>, которая сейчас
выведена из употребления (в действительности они предоставляют еще больше
информации, т.к. <code>mysql_eof()</code> возвращает только булево значение, в то время
как функции обработки ошибок сообщают причину, по которой ошибка
произошла).

</P>

<H4>8.4.3.48  Возвращаемые значения</H4>

<P>
Нуль, если ошибок не произошло. Ненулевая величина, если конец
результирующего набора данных достигнут.

</P>

<H4>8.4.3.49  Ошибки</H4>

<P>
Никаких.

</P>

<H4>8.4.3.50  Пример</H4>

<P>
Следующий пример иллюстрирует применение <code>mysql_eof()</code>:

</P>

<pre>
mysql_query(&#38;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&#38;mysql);
while((row = mysql_fetch_row(result)))
{
	// делаем что-то с данными
}
if(!mysql_eof(result)) // mysql_fetch_row() сбойнул из-за ошибки
{
	fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
}
</pre>

<P>
Того же эффекта вы можете достичь с помощью стандартных функций ошибок
MySQL:

</P>

<pre>
mysql_query(&#38;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&#38;mysql);
while((row = mysql_fetch_row(result)))
{
	// что-то делаем с данными
}
if(mysql_errno(&#38;mysql)) // mysql_fetch_row() сбойнул из-за ошибки
{
fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
}
</pre>



<H4><A NAME="mysql_errno" HREF="manual.ru_toc.html#mysql_errno">8.4.3.51  <code>mysql_errno()</code></A></H4>
<P>
<A NAME="IDX1611"></A>

</P>
<P>
<code>unsigned int mysql_errno(MYSQL *mysql)</code>

</P>

<H4>8.4.3.52  Описание</H4>

<P>
Для соединения, указанного в <code>mysql</code>, функция <code>mysql_errno()</code> возвращает код
ошибки для последней запущенной функции интерфейса, которая может быть
успешной или не выполниться. Возвращение нулевой величины означает, что
ошибка не возникала. Номера сообщений об ошибке для клиентов перечислены в
заголовочном файле MySQL <tt>`errmsg.h'</tt>. Номера серверных сообщений об ошибке
даны в файле <tt>`mysqld_error.h'</tt>. В исходном дистрибутиве MySQL можно найти
полный список сообщений об ошибках и номеров ошибок в файле
<tt>`Docs/mysqld_error.txt'</tt>.

</P>

<H4>8.4.3.53  Возвращаемые значения</H4>

<P>
Значение кода ошибки. Нуль, если ошибка не возникала.

</P>

<H4>8.4.3.54  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_error" HREF="manual.ru_toc.html#mysql_error">8.4.3.55  <code>mysql_error()</code></A></H4>
<P>
<A NAME="IDX1612"></A>

</P>
<P>
<code>char *mysql_error(MYSQL *mysql)</code>

</P>

<H4>8.4.3.56  Описание</H4>

<P>
Для соединения, указанного в <code>mysql</code>, функция <code>mysql_error()</code> возвращает
сообщение об ошибке для последней вызванной функции интерфейса, которая
может быть успешной или не выполниться. Если ошибка не возникала, то
возвращается пустая строка (<code>""</code>). Это означает, что следующие две проверки
эквивалентны:

</P>

<pre>
if(mysql_errno(&#38;mysql))
{
	// ошибка  возникла
}
if(mysql_error(&#38;mysql)[0] != '\0')
{
	// ошибка возникла
}
</pre>

<P>
Язык клиентских сообщений об ошибке может быть изменен путем
перекомпилирования клиентской библиотеки MySQL. В настоящее время можно
выбирать для вывода сообщений об ошибке один из нескольких различных
естественных языков (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Languages">4.6.2  Сообщения об ошибках на языках, отличных от английского</A>).

</P>

<H4>8.4.3.57  Возвращаемые значения</H4>

<P>
Символьная строка с описанием ошибки. Пустая строка, если ошибка не
возникала.

</P>

<H4>8.4.3.58  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_escape_string" HREF="manual.ru_toc.html#mysql_escape_string">8.4.3.59  <code>mysql_escape_string()</code></A></H4>
<P>
<A NAME="IDX1613"></A>

</P>
<P>
Вместо этой функции следует использовать функцию
<code>mysql_real_escape_string()</code>!

</P>
<P>
Данная функция идентична функции <code>mysql_real_escape_string()</code>, за
исключением  того, что <code>mysql_real_escape_string()</code> принимает дескриптор
соединения в качестве своего первого аргумента и экранирует строку в
соответствии с текущей кодировкой. Функция <code>mysql_escape_string()</code> не
требует параметров соединения в качестве аргумента и не учитывает
установки текущей кодировки.

</P>


<H4><A NAME="mysql_fetch_field" HREF="manual.ru_toc.html#mysql_fetch_field">8.4.3.60  <code>mysql_fetch_field()</code></A></H4>
<P>
<A NAME="IDX1614"></A>

</P>
<P>
<code>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.61  Описание</H4>

<P>
Возвращает определение одного столбца из результирующего набора в виде
структуры <code>MYSQL_FIELD</code>. Для извлечения информации обо всех столбцах в
результирующем наборе следует вызывать эту функцию повторно. Если полей
больше не остается, функция <code>mysql_fetch_field()</code> возвращает <code>NULL</code>.

</P>
<P>
Каждый раз при выполнении нового запроса <code>SELECT</code> функция
<code>mysql_fetch_field()</code> сбрасывается в исходное состояние, чтобы возвращать
информацию о первом поле. На поле, возвращенное функцией
<code>mysql_fetch_field()</code>, также  можно воздействовать, вызвав функцию
<code>mysql_field_seek()</code>.

</P>
<P>
Если вызвана функция <code>mysql_query()</code> для выполнения команды <code>SELECT</code> на
таблице, но не вызвана функция <code>mysql_store_result</code>(), то MySQL возвращает
установленную по умолчанию длину данных типа <code>BLOB</code> (8 Kб) при вызове
функции <code>mysql_fetch_field</code>() для выяснения длины поля <code>BLOB</code> (Размер 8 Kб
выбран потому, что MySQL в этом случае не знает максимальной длины для
<code>BLOB</code>. Когда-нибудь эта конфигурация будет сделана перестраиваемой.)
Поскольку результирующий набор извлечен, то выражение <code>field-&#62;max_length</code> 
содержит длину наибольшей величины для данного столбца в указанном
запросе.

</P>

<H4>8.4.3.62  Возвращаемые значения</H4>

<P>
Структура <code>MYSQL_FIELD</code> для текущего столбца. <code>NULL</code>, если полей больше не
остается.

</P>

<H4>8.4.3.63  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.64  Пример</H4>


<pre>
MYSQL_FIELD *field;
while((field = mysql_fetch_field(result)))
{
	printf("field name %s\n", field-&#62;name);
}
</pre>



<H4><A NAME="mysql_fetch_field_direct" HREF="manual.ru_toc.html#mysql_fetch_field_direct">8.4.3.65  <code>mysql_fetch_field_direct()</code></A></H4>
<P>
<A NAME="IDX1615"></A>

</P>
<P>
<code>MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES *result, unsigned int fieldnr)</code>

</P>

<H4>8.4.3.66  Описание</H4>

<P>
По заданному номеру поля <code>fieldnr</code> для столбца внутри результирующего набора
возвращает определение данного поля столбца как структуру <code>MYSQL_FIELD</code>. Эту
функцию можно использовать для извлечения определения для произвольного
столбца. Величина <code>fieldnr</code> должна находиться в диапазоне от 0 до
<code>mysql_num_fields(result)-1</code>.

</P>

<H4>8.4.3.67  Возвращаемые значения</H4>

<P>
Структура <code>MYSQL_FIELD</code> для указанного столбца.

</P>

<H4>8.4.3.68  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.69  Пример</H4>


<pre>
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *field;
num_fields = mysql_num_fields(result);
for(i = 0; i &#60; num_fields; i++)
{
	field = mysql_fetch_field_direct(result, i);
	printf("Field %u is %s\n", i, field-&#62;name);
}
</pre>



<H4><A NAME="mysql_fetch_fields" HREF="manual.ru_toc.html#mysql_fetch_fields">8.4.3.70  <code>mysql_fetch_fields()</code></A></H4>
<P>
<A NAME="IDX1616"></A>

</P>
<P>
<code>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.71  Описание</H4>

<P>
Возвращает массив всех структур <code>MYSQL_FIELD</code> для результирующего набора
данных. Каждая структура предоставляет определение данного поля в одном
столбце результирующего набора.

</P>

<H4>8.4.3.72  Возвращаемые значения</H4>

<P>
Массив структур <code>MYSQL_FIELD</code> для всех столбцов результирующего набора.

</P>

<H4>8.4.3.73  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.74  Пример</H4>


<pre>
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *fields;

num_fields = mysql_num_fields(result);
fields = mysql_fetch_fields(result);
for(i = 0; i &#60; num_fields; i++)
{
	printf("Field %u is %s\n", i, fields[i].name);
}
</pre>



<H4><A NAME="mysql_fetch_lengths" HREF="manual.ru_toc.html#mysql_fetch_lengths">8.4.3.75  <code>mysql_fetch_lengths()</code></A></H4>
<P>
<A NAME="IDX1617"></A>

</P>
<P>
<code>unsigned long *mysql_fetch_lengths(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.76  Описание</H4>

<P>
Возвращает длины столбцов текущей строки внутри результирующего набора
данных. Если вы планируете копировать величины столбцов, то эта информация
о длинах полезна также для оптимизации, поскольку помогает избежать вызова
функции <code>strlen()</code>. Кроме того, если результирующий набор содержит двоичные
данные, то необходимо использовать рассматриваемую функцию для определения
размера этих данных, поскольку функция <code>strlen()</code> возвращает некорректные
результаты для поля, содержащего символы <code>NULL</code>.

</P>
<P>
Искомая длина для пустых столбцов и для столбцов, содержащих величины
<code>NULL</code>, равна нулю. Чтобы увидеть, как следует различать эти два случая, см.
описание для функции <code>mysql_fetch_row()</code>.

</P>

<H4>8.4.3.77  Возвращаемые значения</H4>

<P>
Массив беззнаковых целых чисел, представляющий собой размер каждого
столбца (не включая конечные нулевые символы). <code>NULL</code> если произошла ошибка.

</P>

<H4>8.4.3.78  Ошибки</H4>

<P>
Функция <code>mysql_fetch_lengths()</code> действительна только для данной текущей
строки в результирующем наборе данных. Она возвращает <code>NULL</code>, если ее вызов
происходит до вызова функции <code>mysql_fetch_row()</code> или после извлечения всех
строк в результате.

</P>

<H4>8.4.3.79  Пример</H4>

<pre>
MYSQL_ROW row;
unsigned long *lengths;
unsigned int num_fields;
unsigned int i;

row = mysql_fetch_row(result);
if (row)
{
	num_fields = mysql_num_fields(result);
	lengths = mysql_fetch_lengths(result);
	for(i = 0; i &#60; num_fields; i++)
	{
		printf("Column %u is %lu bytes in length.\n", i, lengths[i]);
	}
}
</pre>



<H4><A NAME="mysql_fetch_row" HREF="manual.ru_toc.html#mysql_fetch_row">8.4.3.80  <code>mysql_fetch_row()</code></A></H4>
<P>
<A NAME="IDX1618"></A>

</P>
<P>
<code>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.81  Описание</H4>

<P>
Извлекает следующую строку в результирующем наборе данных. При
использовании после функции <code>mysql_store_result()</code> функция <code>mysql_fetch_row()</code> 
возвращает <code>NULL</code>, если больше не осталось строк для извлечения. При
использовании после функции <code>mysql_use_result()</code> функция
<code>mysql_fetch_row()</code> возвращает <code>NULL</code>, если больше не осталось строк для
извлечения или если произошла ошибка.

</P>
<P>
Количество величин в данной строке задается в <code>mysql_num_fields(result)</code>.
Если параметр <code>row</code> содержит возвращенные значения из вызова функции
<code>mysql_fetch_row()</code>, то указатели на эти величины имеют значения от <code>row[0]</code> 
до <code>row[mysql_num_fields(result)-1]</code>. Величины <code>NULL</code> в данной строке
отмечаются указателями <code>NULL</code>.

</P>
<P>
Размеры полей в данной строке можно получить, вызывая функцию
<code>mysql_fetch_lengths()</code>. Пустые поля и поля, содержащие <code>NULL</code>, в обоих
случаях имеют длину 0; их можно различить, проверив указатель для данной
величины поля. Если указатель равен <code>NULL</code>, то данное поле содержит <code>NULL</code>; в
противном случае, данное поле является пустым.

</P>

<H4>8.4.3.82  Возвращаемые значения</H4>

<P>
Структура <code>MYSQL_ROW</code> для следующей строки. <code>NULL</code>, если нет больше строк для
извлечения или произошла ошибка.

</P>

<H4>8.4.3.83  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>


<H4>8.4.3.84  Пример</H4>


<pre>
MYSQL_ROW row;
unsigned int num_fields;
unsigned int i;

num_fields = mysql_num_fields(result);
while ((row = mysql_fetch_row(result)))
{
	unsigned long *lengths;
	lengths = mysql_fetch_lengths(result);
	for(i = 0; i &#60; num_fields; i++)
	{
		printf("[%.*s] ", (int) lengths[i], row[i] ? row[i] : "NULL");
	}
	printf("\n");
}
</pre>



<H4><A NAME="mysql_field_count" HREF="manual.ru_toc.html#mysql_field_count">8.4.3.85  <code>mysql_field_count()</code></A></H4>
<P>
<A NAME="IDX1619"></A>

</P>
<P>
<code>unsigned int mysql_field_count(MYSQL *mysql)</code>

</P>
<P>
При использовании более ранней, чем 3.22.24, версии MySQL необходимо
вместо этого выражения использовать следующее: <code>unsigned int mysql_num_fields(MYSQL *mysql)</code>.

</P>

<H4>8.4.3.86  Описание</H4>

<P>
Возвращает количество столбцов для последнего запроса в данном соединении.

</P>
<P>
Обычно эту функцию используют в случае, когда функция <code>mysql_store_result()</code> 
возвращает <code>NULL</code> (и, следовательно, нет ни одного указателя для
результирующего набора). В этом случае можно вызвать функцию
<code>mysql_field_count()</code> для определения, может ли функция <code>mysql_store_result()</code> 
выдать непустой результат. Это дает возможность данной клиентской
программе выполнить соответствующее действие без уточнения, был ли данный
запрос командой вида <code>SELECT</code> (или похожей на <code>SELECT</code>). Приведенный ниже
пример иллюстрирует, как это можно сделать.

</P>
<P>
See section <A HREF="manual.ru_Clients.html#NULL_mysql_store_result">8.4.6.1  Почему после успешных возвратов функции <code>mysql_query()</code> функция <code>mysql_store_result()</code> иногда возвращает <code>NULL</code>?</A>.

</P>

<H4>8.4.3.87  Возвращаемые значения</H4>

<P>
Беззнаковое целое число, представляющее количество полей в результирующем
наборе.

</P>

<H4>8.4.3.88  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.89  Пример</H4>

<pre>
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&#38;mysql,query_string))
{
	// ошибка
}
else // запрос выполнен, обработка возвращенных им данных
{
	result = mysql_store_result(&#38;mysql);
	if (result) // содержит строки
	{
		num_fields = mysql_num_fields(result);
		// извлечение строк, затем вызов mysql_free_result(result)
	}
	else // mysql_store_result() не вернула ничего; может ли что-либо вернуть?
	{
		if(mysql_field_count(&#38;mysql) == 0)
		{
			// запрос не возвращает данные
			// (запрос не был вида SELECT)
			num_rows = mysql_affected_rows(&#38;mysql);
		}
		else // mysql_store_result() должна была вернуть данные
		{
			fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
		}
	}
}
</pre>

<P>
Альтернатива состоит в замене вызова функции <code>mysql_field_count(&#38;mysql)</code> 
вызовом функции <code>mysql_errno(&#38;mysql)</code>. В этом случае можно проверить, была
ли данная команда вида <code>SELECT</code>, непосредственно по ошибке от
<code>mysql_store_result()</code>, а не делать логический вывод по величине функции
<code>mysql_field_count()</code>.

</P>


<H4><A NAME="mysql_field_seek" HREF="manual.ru_toc.html#mysql_field_seek">8.4.3.90  <code>mysql_field_seek()</code></A></H4>
<P>
<A NAME="IDX1620"></A>

</P>
<P>
<code>MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET offset)</code>

</P>

<H4>8.4.3.91  Описание</H4>

<P>
Устанавливает курсор поля в заданную позицию. Дальнейший вызов функции
<code>mysql_fetch_field()</code> будет извлекать определение данного поля в столбце,
ассоциированном с данной позицией курсора.

</P>
<P>
Для поиска начала строки необходимо установить величину <code>offset</code> в нуль.

</P>

<H4>8.4.3.92  Возвращаемые значения</H4>

<P>
Предыдущая величина курсора поля.

</P>

<H4>8.4.3.93  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_field_tell" HREF="manual.ru_toc.html#mysql_field_tell">8.4.3.94  <code>mysql_field_tell()</code></A></H4>
<P>
<A NAME="IDX1621"></A>

</P>
<P>
<code>MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.95  Описание</H4>

<P>
Возвращает позицию курсора поля, использованную для последнего вызова
функции <code>mysql_fetch_field()</code>. Эта величина может использоваться как
аргумент в функции <code>mysql_field_seek()</code>.

</P>

<H4>8.4.3.96  Возвращаемые значения</H4>

<P>
Текущая позиция курсора поля.

</P>

<H4>8.4.3.97  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_free_result" HREF="manual.ru_toc.html#mysql_free_result">8.4.3.98  <code>mysql_free_result()</code></A></H4>
<P>
<A NAME="IDX1622"></A>

</P>
<P>
<code>void mysql_free_result(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.99  Описание</H4>

<P>
Освобождает память, выделенную для результирующего набора данных функциями
<code>mysql_store_result()</code>, <code>mysql_use_result()</code>, <code>mysql_list_dbs()</code> и т.д. После
выполнения операций с результирующим набором необходимо освободить
используемую под него память вызовом функции <code>mysql_free_result()</code>.

</P>

<H4>8.4.3.100  Возвращаемые значения</H4>

<P>
Нет.

</P>

<H4>8.4.3.101  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_get_client_info" HREF="manual.ru_toc.html#mysql_get_client_info">8.4.3.102  <code>mysql_get_client_info()</code></A></H4>
<P>
<A NAME="IDX1623"></A>

</P>
<P>
<code>char *mysql_get_client_info(void)</code>

</P>

<H4>8.4.3.103  Описание</H4>

<P>
Возвращает строку, представляющую версию библиотеки данного клиента.

</P>

<H4>8.4.3.104  Возвращаемые значения</H4>

<P>
Символьная строка, которая представляет версию библиотеки данного клиента
MySQL.

</P>

<H4>8.4.3.105  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_get_server_version" HREF="manual.ru_toc.html#mysql_get_server_version">8.4.3.106  <code>mysql_get_server_version()</code></A></H4>

<P>
<A NAME="IDX1624"></A>

</P>
<P>
<code>unsigned long mysql_get_server_version(MYSQL *mysql)</code>

</P>

<H4>8.4.3.107  Описание</H4>

<P>
Возвращает номер версии сервера как целое число (новое с 4.1)

</P>

<H4>8.4.3.108  Возвращаемые значения</H4>

<P>
Число, представляющее версию сервера MySQL, в следующем формате:

</P>
<P>
main_version*10000 + minor_version *100 + sub_version

</P>
<P>
Например, 4.1.0 будет возвращена как 40100.

</P>
<P>
Это полезно для быстрого определения версии сервера в клиентской программе
для того, чтобы узнать, поддерживаются ли некоторые возможности.

</P>

<H4>8.4.3.109  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_get_host_info" HREF="manual.ru_toc.html#mysql_get_host_info">8.4.3.110  <code>mysql_get_host_info()</code></A></H4>
<P>
<A NAME="IDX1625"></A>

</P>
<P>
<code>char *mysql_get_host_info(MYSQL *mysql)</code>

</P>

<H4>8.4.3.111  Описание</H4>

<P>
Возвращает строку, описывающую тип используемого соединения, включая имя
серверного хоста.

</P>

<H4>8.4.3.112  Возвращаемые значения</H4>

<P>
Символьная строка, представляющая имя серверного хоста и тип данного
соединения.

</P>

<H4>8.4.3.113  Ошибки</H4>

<P>
Нет.


<H4><A NAME="mysql_get_proto_info" HREF="manual.ru_toc.html#mysql_get_proto_info">8.4.3.114  <code>mysql_get_proto_info()</code></A></H4>
<P>
<A NAME="IDX1626"></A>

</P>
<P>
<code>unsigned int mysql_get_proto_info(MYSQL *mysql)</code>

</P>

<H4>8.4.3.115  Описание</H4>

<P>
Возвращает версию протокола, используемую для текущего соединения.

</P>

<H4>8.4.3.116  Возвращаемые значения</H4>

<P>
Беззнаковое целое число, представляющее версию протокола, используемую для
текущего соединения.

</P>

<H4>8.4.3.117  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_get_server_info" HREF="manual.ru_toc.html#mysql_get_server_info">8.4.3.118  <code>mysql_get_server_info()</code></A></H4>
<P>
<A NAME="IDX1627"></A>

</P>
<P>
<code>char *mysql_get_server_info(MYSQL *mysql)</code>

</P>

<H4>8.4.3.119  Описание</H4>

<P>
Возвращает строку, представляющую номер версии сервера.

</P>

<H4>8.4.3.120  Возвращаемые значения</H4>

<P>
Символьная строка, представляющая номер версии сервера.

</P>

<H4>8.4.3.121  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_info" HREF="manual.ru_toc.html#mysql_info">8.4.3.122  <code>mysql_info()</code></A></H4>
<P>
<A NAME="IDX1628"></A>

</P>
<P>
<code>char *mysql_info(MYSQL *mysql)</code>

</P>

<H4>8.4.3.123  Описание</H4>

<P>
Извлекает строку, представляющую информацию о последнем выполненном
запросе, но только для команд, перечисленных ниже. Для других команд
функция <code>mysql_info()</code> возвращает <code>NULL</code>. Строка имеет различный формат в
зависимости от типа запроса, как описано ниже. Числа приведены только для
иллюстрации; данная строка будет содержать величины, соответствующие
конкретному запросу.

</P>
<DL COMPACT>

<DT><code>INSERT INTO ... SELECT ...</code>
<DD>
Формат  строки: <code>Records: 100 Duplicates: 0 Warnings: 0</code> 

<DT><code>INSERT INTO ... VALUES (...),(...),(...)...</code>
<DD>
Формат  строки: <code>Records: 3 Duplicates: 0 Warnings: 0</code> 

<DT><code>LOAD DATA INFILE ...</code>
<DD>
Формат  строки: <code>Records: 1 Deleted: 0 Skipped: 0 Warnings: 0</code> 

<DT><code>ALTER TABLE</code>
<DD>
Формат  строки: <code>Records: 3 Duplicates: 0 Warnings: 0</code> 

<DT><code>UPDATE</code>
<DD>
Формат  строки: <code>Rows matched: 40 Changed: 40 Warnings: 0</code> 
</DL>

<P>
Следует учитывать, что функция <code>mysql_info()</code> возвращает величину не-<code>NULL</code>
для команды <code>INSERT ... VALUES</code>, только если в данной команде заданы
множественные списки величин.

</P>

<H4>8.4.3.124  Возвращаемые значения</H4>

<P>
Символьная строка, представляющая дополнительную информацию о последнем
выполненном запросе. <code>NULL</code>, если нет никакой доступной информации по
данному запросу.

</P>

<H4>8.4.3.125  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_init" HREF="manual.ru_toc.html#mysql_init">8.4.3.126  <code>mysql_init()</code></A></H4>
<P>
<A NAME="IDX1629"></A>

</P>
<P>
<code>MYSQL *mysql_init(MYSQL *mysql)</code>

</P>

<H4>8.4.3.127  Описание</H4>

<P>
Выделяет или инициализирует объект MYSQL, подходящий для функции
<code>mysql_real_connect()</code>. Если аргумент <code>mysql</code> представляет собой указатель
<code>NULL</code>, то эта функция выделяет, инициализирует и возвращает новый объект. В
противном случае инициализируется указанный объект и возвращается его
адрес. Если функция <code>mysql_init()</code> выделяет новый объект, то он будет
освобожден при вызове функции <code>mysql_close()</code>, чтобы закрыть данное
соединение.

</P>

<H4>8.4.3.128  Возвращаемые значения</H4>

<P>
Инициализированный дескриптор <code>MYSQL*</code>. <code>NULL</code> при недостатке памяти для
выделения нового объекта.

</P>

<H4>8.4.3.129  Ошибки</H4>

<P>
В случае нехватки памяти возвращается <code>NULL</code>.

</P>


<H4><A NAME="mysql_insert_id" HREF="manual.ru_toc.html#mysql_insert_id">8.4.3.130  <code>mysql_insert_id()</code></A></H4>
<P>
<A NAME="IDX1630"></A>

</P>
<P>
<code>my_ulonglong mysql_insert_id(MYSQL *mysql)</code>

</P>

<H4>8.4.3.131  Описание</H4>

<P>
Возвращает идентификатор <code>ID</code>, сгенерированный для столбца <code>AUTO_INCREMENT</code>
предыдущим запросом. Эту функцию следует использовать после выполнения
запроса <code>INSERT</code> в таблице, содержащей поле <code>AUTO_INCREMENT</code>.

</P>
<P>
Следует учитывать, что функция <code>mysql_insert_id()</code> возвращает 0, если
предыдущий запрос не сформировал величину <code>AUTO_INCREMENT</code>. Если необходимо
сохранить эту величину в дальнейшем, то следует позаботиться о вызове
функции <code>mysql_insert_id()</code> немедленно после запроса, который создает
указанную величину.

</P>
<P>
Функция <code>mysql_insert_id()</code> обновляется после команд <code>INSERT</code> и <code>UPDATE</code>,
которые генерируют величину <code>AUTO_INCREMENT</code> или устанавливают величину
столбца в значение <code>LAST_INSERT_ID(expr)</code>. See section <A HREF="manual.ru_Reference.html#Miscellaneous_functions">6.3.6.2  Разные функции</A>.

</P>
<P>
Следует также иметь в виду, что величина SQL-функции <code>LAST_INSERT_ID()</code> 
всегда содержит самое последнее сгенерированное значение <code>AUTO_INCREMENT</code> и
не обновляется между запросами, так как величина этой функции сохраняется
сервером.

</P>

<H4>8.4.3.132  Возвращаемые значения</H4>

<P>
Величина поля <code>AUTO_INCREMENT</code>, обновленного предыдущим запросом.
Возвращает нуль, если перед этим не было запроса в данном соединении или
если данный запрос не обновил величину <code>AUTO_INCREMENT</code>.

</P>

<H4>8.4.3.133  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_kill" HREF="manual.ru_toc.html#mysql_kill">8.4.3.134  <code>mysql_kill()</code></A></H4>
<P>
<A NAME="IDX1631"></A>

</P>
<P>
<code>int mysql_kill(MYSQL *mysql, unsigned long pid)</code>

</P>

<H4>8.4.3.135  Описание</H4>

<P>
Предписывает серверу уничтожить поток, указанный в аргументе <code>pid</code>.

</P>

<H4>8.4.3.136  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении. Отличная от нуля величина при ошибке.

</P>

<H4>8.4.3.137  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_list_dbs" HREF="manual.ru_toc.html#mysql_list_dbs">8.4.3.138  <code>mysql_list_dbs()</code></A></H4>
<P>
<A NAME="IDX1632"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_dbs(MYSQL *mysql, const char *wild)</code>

</P>

<H4>8.4.3.139  Описание</H4>

<P>
Возвращает результирующий набор, состоящий из имен баз данных на сервере,
которые встречаются в простом регулярном выражении, указанном в параметре
<code>wild</code>. Параметр <code>wild</code> может содержать шаблонные символы <samp>`%'</samp> или <samp>`_'</samp>, а также
может быть указателем <code>NULL</code>, что соответствует всем базам данных. Вызов
функции <code>mysql_list_dbs()</code>аналогичен выполнению запроса <code>SHOW databases [LIKE
wild]</code>.

</P>
<P>
Результирующий набор необходимо освободить с помощью функции
<code>mysql_free_result()</code>.

</P>

<H4>8.4.3.140  Возвращаемые значения</H4>

<P>
Результирующий набор <code>MYSQL_RES</code> при успешном выполнении. <code>NULL</code>, если
произошла ошибка.

</P>

<H4>8.4.3.141  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Нехватка  памяти.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_list_fields" HREF="manual.ru_toc.html#mysql_list_fields">8.4.3.142  <code>mysql_list_fields()</code></A></H4>
<P>
<A NAME="IDX1633"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)</code>

</P>

<H4>8.4.3.143  Описание</H4>

<P>
Возвращает результирующий набор, состоящий из имен полей в заданной
таблице, встречающихся в простом регулярном выражении, указанном в
параметре <code>wild</code>. Параметр <code>wild</code> может содержать шаблонные символы <samp>`%'</samp> или
<samp>`_'</samp>, а также может быть указателем <code>NULL</code>, что соответствует всем полям.
Вызов функции <code>mysql_list_fields()</code> аналогичен выполнению запроса <code>SHOW
COLUMNS FROM tbl_name [LIKE wild]</code>.

</P>
<P>
Следует учитывать, что рекомендуется использовать команду <code>SHOW COLUMNS
FROM tbl_nam</code>e вместо функции <code>mysql_list_fields()</code>.

</P>
<P>
Результирующий набор необходимо освободить с помощью функции
<code>mysql_free_result()</code>.

</P>

<H4>8.4.3.144  Возвращаемые значения</H4>

<P>
Результирующий набор <code>MYSQL_RES</code> при успешном выполнении. <code>NULL</code>, если
произошла ошибка.

</P>

<H4>8.4.3.145  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил  работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_list_processes" HREF="manual.ru_toc.html#mysql_list_processes">8.4.3.146  <code>mysql_list_processes()</code></A></H4>
<P>
<A NAME="IDX1634"></A>

</P>
<P>
<A NAME="IDX1635"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_processes(MYSQL *mysql)</code>

</P>

<H4>8.4.3.147  Описание</H4>

<P>
Возвращает результирующий набор, описывающий текущие потоки на сервере.
Предоставляет тот же тип информации, который выдается утилитой <code>mysqladmin</code>
processlist или запросом <code>SHOW PROCESSLIST</code>.

</P>
<P>
Результирующий набор необходимо освободить с помощью функции
<code>mysql_free_result()</code>.

</P>

<H4>8.4.3.148  Возвращаемые значения</H4>

<P>
Результирующий набор <code>MYSQL_RES</code> при успешном выполнении. <code>NULL</code>, если
произошла ошибка.

</P>

<H4>8.4.3.149  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_list_tables" HREF="manual.ru_toc.html#mysql_list_tables">8.4.3.150  <code>mysql_list_tables()</code></A></H4>
<P>
<A NAME="IDX1636"></A>

</P>
<P>
<A NAME="IDX1637"></A>

</P>
<P>
<code>MYSQL_RES *mysql_list_tables(MYSQL *mysql, const char *wild)</code>

</P>

<H4>8.4.3.151  Описание</H4>

<P>
Возвращает результирующий набор, состоящий из имен таблиц в текущей базе
данных, которые встречаются в простом регулярном выражении, указанном в
параметре <code>wild</code>. Параметр <code>wild</code> может содержать шаблонные символы <samp>`%'</samp> или
<samp>`_'</samp>, а также может быть указателем <code>NULL</code>, что соответствует всем таблицам.
Вызов функции <code>mysql_list_tables()</code>аналогичен выполнению запроса <code>SHOW tables
[LIKE wild]</code>.

</P>
<P>
Результирующий набор необходимо освободить с помощью функции
<code>mysql_free_result()</code>.

</P>

<H4>8.4.3.152  Возвращаемые значения</H4>

<P>
Результирующий набор <code>MYSQL_RES</code> при успешном выполнении. <code>NULL</code>, если
произошла ошибка.

</P>

<H4>8.4.3.153  Ошибки</H4>

<DL COMPACT>

CR_COMMANDS_OUT_OF_SYNC
Команды были выполнены в ненадлежащем порядке.

CR_SERVER_GONE_ERROR
Сервер MySQL неожиданно завершил работу.

CR_SERVER_LOST
Соединение с сервером прервалось в процессе данного запроса.

CR_UNKNOWN_ERROR
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_num_fields" HREF="manual.ru_toc.html#mysql_num_fields">8.4.3.154  <code>mysql_num_fields()</code></A></H4>

<P>
<A NAME="IDX1638"></A>
<A NAME="IDX1639"></A>

</P>
<P>
<code>unsigned int mysql_num_fields(MYSQL_RES *result)</code>

</P>
<P>
или

</P>
<P>
<code>unsigned int mysql_num_fields(MYSQL *mysql)</code> 

</P>
<P>
Вторая форма не работает на версии MySQL 3.22.24 или более новой. Вместо
аргумента в параметре <code>MYSQL*</code> необходимо использовать выражение <code>unsigned
int mysql_field_count(MYSQL *mysql)</code> 

</P>

<H4>8.4.3.155  Описание</H4>

<P>
Возвращает количество столбцов в результирующем наборе.

</P>
<P>
Следует отметить, что можно получить искомое количество столбцов с помощью
указателя или на результирующий набор, или на дескриптор соединения.
Дескриптор соединения необходимо использовать, если функции
<code>mysql_store_result()</code> или <code>mysql_use_result()</code> возвратили <code>NULL</code> (и,
следовательно, отсутствует указатель результирующего набора). В этом
случае можно вызвать функцию <code>mysql_field_count()</code>для определения, может ли
функция <code>mysql_store_result()</code>выдать непустой результат. Это дает
возможность данной клиентской программе выполнить соответствующее действие
без уточнения, был ли данный запрос командой вида <code>SELECT</code> (или похожей на
<code>SELECT</code>). В приведенном ниже примере иллюстрируется, как это можно сделать.

</P>
<P>
See section <A HREF="manual.ru_Clients.html#NULL_mysql_store_result">8.4.6.1  Почему после успешных возвратов функции <code>mysql_query()</code> функция <code>mysql_store_result()</code> иногда возвращает <code>NULL</code>?</A>.

</P>

<H4>8.4.3.156  Возвращаемые значения</H4>

<P>
Беззнаковое целое число, представляющее количество полей в результирующем
наборе.

</P>

<H4>8.4.3.157  Ошибки</H4>

<P>
Нет.

</P>

<H4>8.4.3.158  Пример</H4>


<pre>
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&#38;mysql,query_string))
{
	// ошибка
}
else // запрос выполнен, обработка возвращенных им данных
{
	result = mysql_store_result(&#38;mysql);
	if (result) // содержит строки {
		num_fields = mysql_num_fields(result);
		// извлечение строк, затем вызов mysql_free_result(result)
	}
	else // mysql_store_result()не вернула ничего; может ли что-либо вернуть?
	{
		if (mysql_errno(&#38;mysql))
		{
			fprintf(stderr, "Error: %s\n", mysql_error(&#38;mysql));
		}
		else if (mysql_field_count(&#38;mysql) == 0)
		{
			// запрос не возвращает данные
			// (запрос не был вида SELECT)
			num_rows = mysql_affected_rows(&#38;mysql);
		}
	}
}
</pre>

<P>
Альтернатива (если известно, что данный запрос должен вернуть
результирующий набор) состоит в замене вызова функции <code>mysql_errno(&#38;mysql)</code> 
на проверку, равна ли 0 функция <code>mysql_field_count(&#38;mysql)</code>. Это может
случиться, только если что-нибудь происходило не так.

</P>


<H4><A NAME="mysql_num_rows" HREF="manual.ru_toc.html#mysql_num_rows">8.4.3.159  <code>mysql_num_rows()</code></A></H4>
<P>
<A NAME="IDX1640"></A>

</P>
<P>
<code>my_ulonglong mysql_num_rows(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.160  Описание</H4>

<P>
Возвращает количество строк в результирующем наборе.

</P>
<P>
Использование функции <code>mysql_num_rows()</code> зависит от того, какая функция -
<code>mysql_store_result()</code> или <code>mysql_use_result()</code> применяется для возвращения
результирующего набора. Если используется <code>mysql_store_result()</code>, то функция
<code>mysql_num_rows()</code> может вызываться немедленно. Если используется
<code>mysql_use_result()</code>,то функция <code>mysql_num_rows()</code> не будет возвращать
правильную величину до тех пор, пока все строки в результирующем наборе не
будут извлечены.

</P>

<H4>8.4.3.161  Возвращаемые значения</H4>

<P>
Количество строк в результирующем наборе.

</P>

<H4>8.4.3.162  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_options" HREF="manual.ru_toc.html#mysql_options">8.4.3.163  <code>mysql_options()</code></A></H4>
<P>
<A NAME="IDX1641"></A>

</P>
<P>
<code>int mysql_options(MYSQL *mysql, enum mysql_option option, const char *arg)</code>

</P>

<H4>8.4.3.164  Описание</H4>

<P>
Может использоваться для установки дополнительных опций соединения и
влияет на режим работы соединения. Эта функция может вызываться
многократно для установки нескольких опций.

</P>
<P>
Функция <code>mysql_options()</code> должна вызываться после функции <code>mysql_init()</code> и
перед функцией <code>mysql_connect()</code> или <code>mysql_real_connect()</code>.

</P>
<P>
Аргумент <code>option</code> представляет собой опцию, которую требуется установить;
аргумент <code>arg</code> является величиной этой опции. Если данная опция является
целым числом, то аргумент arg должен указывать на величину целого числа.

</P>
<P>
Возможные значения опций:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Тип аргумента</strong> </TD><TD> <strong>Функция</strong>
</TD></TR>
<TR><TD><code>MYSQL_OPT_CONNECT_TIMEOUT</code> </TD><TD> <code>unsigned int *</code> </TD><TD> Время ожидания для соединения в секундах.
</TD></TR>
<TR><TD><code>MYSQL_OPT_COMPRESS</code> </TD><TD> Не используется </TD><TD> Использовать сжатие в клиент-серверном протоколе.
</TD></TR>
<TR><TD><code>MYSQL_OPT_LOCAL_INFILE</code> </TD><TD> Опциональный указатель на uint </TD><TD> Если указатель не задан или указывает на <code>unsigned int != 0</code> команда <code>LOAD LOCAL INFILE</code> разрешена.
</TD></TR>
<TR><TD><code>MYSQL_OPT_NAMED_PIPE</code> </TD><TD> Не используется </TD><TD> Использовать именованные каналы для соединения с сервером MySQL на NT.
</TD></TR>
<TR><TD><code>MYSQL_INIT_COMMAND</code> </TD><TD> <code>char *</code> </TD><TD> Команда для исполнения при подключении к серверу MySQL. При восстановлении соединения будет снова автоматически выполнена.
</TD></TR>
<TR><TD><code>MYSQL_READ_DEFAULT_FILE</code> </TD><TD> <code>char *</code> </TD><TD> Читать опции из указанного файла опций вместо чтения из файла <tt>`my.cnf'</tt>.
</TD></TR>
<TR><TD><code>MYSQL_READ_DEFAULT_GROUP</code> </TD><TD> <code>char *</code> </TD><TD> Читать опции из указанной группы из файла <tt>`my.cnf'</tt> или из файла заданного в <code>MYSQL_READ_DEFAULT_FILE</code>.
</TD></TR>
</TABLE>

<P>
Следует помнить, что группа <code>client</code> читается всегда при использовании
<code>MYSQL_READ_DEFAULT_FILE</code> или <code>MYSQL_READ_DEFAULT_GROUP</code>.

</P>
<P>
Упомянутая группа в файле опций может содержать следующие опции:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>connect-timeout</code> </TD><TD> Время ожидания для соединения в секундах. Для Linux это время ожидания используется также для ожидания первого ответа с сервера.
</TD></TR>
<TR><TD><code>compress</code> </TD><TD> Использовать сжатие в клиент-серверном протоколе.
</TD></TR>
<TR><TD><code>database</code> </TD><TD> Подключиться к этой базе данных, если никакая база данных не была указана в данной команде подключения.
</TD></TR>
<TR><TD><code>debug</code> </TD><TD> Опции отладки.
</TD></TR>
<TR><TD><code>disable-local-infile</code> </TD><TD> Блокировка использования <code>LOAD DATA LOCAL</code>.
</TD></TR>
<TR><TD><code>host</code> </TD><TD> Имя хоста по умолчанию.
</TD></TR>
<TR><TD><code>init-command</code> </TD><TD> Команда для исполнения при подключении к серверу MySQL. При восстановлении соединения будет снова автоматически выполнена.
</TD></TR>
<TR><TD><code>interactive-timeout</code> </TD><TD> Аналогично  заданию  <code>CLIENT_INTERACTIVE</code>  в <code>mysql_real_connect()</code>. See section <A HREF="manual.ru_Clients.html#mysql_real_connect">8.4.3.175  <code>mysql_real_connect()</code></A>.
</TD></TR>
<TR><TD><code>local-infile[=(0|1)]</code> </TD><TD> Если аргумент не задан или указан аргумент <code>!= 0</code>, то разрешено использование <code>LOAD DATA LOCAL</code>.
</TD></TR>
<TR><TD><code>max_allowed_packet</code> </TD><TD> Максимальный размер пакета, который клиент может читать с сервера.
</TD></TR>
<TR><TD><code>password</code> </TD><TD> Пароль по умолчанию.
</TD></TR>
<TR><TD><code>pipe</code> </TD><TD> Использовать именованные каналы для соединения с сервером MySQL на NT.
</TD></TR>
<TR><TD><code>protocol=(TCP | SOCKET | PIPE | MEMORY)</code> </TD><TD> Какой протокол использовать для подключения к серверу (новшество 4.1.0).
</TD></TR>
<TR><TD><code>port</code> </TD><TD> Номер порта по умолчанию.
</TD></TR>
<TR><TD><code>return-found-rows</code> </TD><TD> Предписывает <code>mysql_info()</code> возвращать найденные строки вместо обновления их при выполнении <code>UPDATE</code>.
</TD></TR>
<TR><TD><code>shared-memory-base-name=name</code> </TD><TD> Имя блока общей памяти (shared memory name), которое следует использовать для подключения к серверу (по умолчанию "MySQL"). Новшество в MySQL 4.1.
</TD></TR>
<TR><TD><code>socket</code> </TD><TD> Номер сокета по умолчанию.
</TD></TR>
<TR><TD><code>user</code> </TD><TD> Пользователь по умолчанию.
</TD></TR>
</TABLE>

<P>
Следует помнить, что <code>timeout</code> замещен на <code>connect-timeout</code>, но <code>timeout</code>
временно еще работает.

</P>
<P>
Для более подробной информации о файлах опций см. раздел See section <A HREF="manual.ru_MySQL_Database_Administration.html#Option_files">4.1.2  Файлы параметров <tt>`my.cnf'</tt></A>.

</P>

<H4>8.4.3.165  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении. Величина, отличная от нуля, если
используется неизвестная опция.

</P>

<H4>8.4.3.166  Пример</H4>


<pre>
MYSQL mysql;

mysql_init(&#38;mysql);
mysql_options(&#38;mysql,MYSQL_OPT_COMPRESS,0);
mysql_options(&#38;mysql,MYSQL_READ_DEFAULT_GROUP,"odbc");
if
(!mysql_real_connect(&#38;mysql,"host","user","passwd","database",0,NULL,0))
{
	fprintf(stderr, "Failed to connect to database: Error: %s\n",
	mysql_error(&#38;mysql));
}
</pre>

<P>
Вышеприведенный пример запрашивает клиента использовать сжатый
клиент-серверный протокол и читать дополнительные опции из секции <code>odbc</code> в
файле <tt>`my.cnf'</tt>.

</P>


<H4><A NAME="mysql_ping" HREF="manual.ru_toc.html#mysql_ping">8.4.3.167  <code>mysql_ping()</code></A></H4>
<P>
<A NAME="IDX1642"></A>

</P>
<P>
<code>int mysql_ping(MYSQL *mysql)</code>

</P>

<H4>8.4.3.168  Описание</H4>

<P>
Проверяет, работает ли данное соединение с сервером. Если соединение
прервано, то пытается автоматически восстановить его.

</P>
<P>
Эта функция может использоваться клиентами, долгое время находящимися в
состоянии простоя, для проверки, закрыл ли сервер данное соединение, и для
восстановления соединения при необходимости.

</P>

<H4>8.4.3.169  Возвращаемые значения</H4>

<P>
Нуль, если сервер в активном состоянии. Величина, отличная от нуля, если
произошла ошибка.

</P>

<H4>8.4.3.170  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_query" HREF="manual.ru_toc.html#mysql_query">8.4.3.171  <code>mysql_query()</code></A></H4>
<P>
<A NAME="IDX1643"></A>

</P>
<P>
<code>int mysql_query(MYSQL *mysql, const char *query)</code>

</P>

<H4>8.4.3.172  Описание</H4>

<P>
Выполняет запрос SQL, указанный в аргументе <code>query</code> в виде строки с нулевыми
окончаниями. Данный запрос должен состоять из одной команды SQL. Нельзя
добавлять к этой команде в качестве завершающих элементов точку с запятой
(<samp>`;'</samp>) или <code>\g</code>.

</P>
<P>
Функция <code>mysql_query()</code> не может использоваться для запросов, содержащих
двоичные данные; вместо этого необходимо использовать функцию
<code>mysql_real_query()</code> (двоичные данные могут содержать символ <samp>`\0'</samp>, который
<code>mysql_query()</code> интерпретирует как окончание строки запроса).

</P>
<P>
Для проверки, вернул данный запрос результирующий набор или нет, можно
использовать функцию <code>mysql_field_count()</code>. See section <A HREF="manual.ru_Clients.html#mysql_field_count">8.4.3.85  <code>mysql_field_count()</code></A>.

</P>

<H4>8.4.3.173  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении запроса. Величина, отличная от нуля, если
произошла ошибка.

</P>

<H4>8.4.3.174  Ошибки</H4>

<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_real_connect" HREF="manual.ru_toc.html#mysql_real_connect">8.4.3.175  <code>mysql_real_connect()</code></A></H4>
<P>
<A NAME="IDX1644"></A>

</P>
<P>
<code>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host,
   const char *user, const char *passwd, const char *db,
   unsigned int port, const char *unix_socket,
   unsigned int client_flag)</code>
						   


<P><STRONG>8.4.3.176  Описание</STRONG></P>

</P>
<P>
Функция <code>mysql_real_connect()</code> пытается установить соединение с сервером баз
данных MySQL, работающим на хосте <code>host</code>. До успешного завершения функции
<code>mysql_real_connect()</code> нельзя выполнять никакие другие функции интерфейса, за
исключением <code>mysql_get_client_info()</code>.

</P>
<P>
Параметры этой функции указываются следующим образом:

</P>

<ul>
<LI>

Первым параметром должен быть указатель существующей структуры <code>MYSQL</code>.
До вызова функции <code>mysql_real_connect</code>() необходимо вызвать функцию
<code>mysql_init()</code> для инициализации данной структуры <code>MYSQL</code>. Вызов функции
<code>mysql_options()</code> позволяет изменить многие опции данного соединения.
See section <A HREF="manual.ru_Clients.html#mysql_options">8.4.3.163  <code>mysql_options()</code></A>.

<LI>

<code>host</code> может быть как именем хоста, так и IP-адресом. Если host равен
<code>NULL</code> или строке <code>"localhost"</code>, то подразумевается соединение с локальным
хостом. Если операционная система поддерживает сокеты (Unix) или
именованные каналы (Windows), то они используются вместо протокола
TCP/IP для соединения с сервером.

<LI>

Параметр user содержит имя данного пользователя MySQL. Если параметр
user равен <code>NULL</code>, то подразумевается текущий пользователь. Под
операционной системой Unix, это будет текущее имя входа в систему. Под
Windows ODBC имя пользователя должно быть указано явным образом. См.
раздел See section <A HREF="manual.ru_Clients.html#ODBC_administrator">8.3.2  Как заполнять различные поля в Администраторе ODBC</A>.

<LI>

Параметр <code>passwd</code> содержит пароль для user. Если параметр <code>passwd</code> равен
<code>NULL</code>, то только записи в таблице <code>user</code> для пользователя, имеющего
чистое (пустое) поле пароля, будут проверяться на совпадение. Это дает
возможность администратору базы данных устанавливать систему прав
MySQL таким образом, что пользователи получают различные права, в
зависимости от того, имеют они или нет установленный пароль.

Замечание: не следует пытаться шифровать пароль перед вызовом функции
<code>mysql_real_connect()</code>; шифрование пароля производится автоматически
библиотекой.

<LI>

Параметр <code>db</code> представляет собой имя базы данных. Если параметр <code>db</code> не
равен <code>NULL</code>, то данное соединение установит эту величину в качестве
базы данных по умолчанию.

<LI>

Если параметр <code>port</code> не равен 0, то данная величина будет использована в
качестве порта для соединения TCP/IP. Следует учитывать, что тип
соединения определяется параметром <code>host</code>.

<LI>

Если параметр <code>unix_socket</code> не равен <code>NULL</code>, то данная строка указывает
сокет или именованный канал, который следует использовать. Следует
учитывать, что тип соединения определяется параметром <code>host</code>.

<LI>

Величина параметра <code>client_flag</code> обычно равна 0, но при особых
обстоятельствах может быть установлена как комбинация следующих
флагов:
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Имя флага</strong> </TD><TD> <strong>Описание флага</strong>
</TD></TR>
<TR><TD><code>CLIENT_COMPRESS</code> </TD><TD> Использовать сжатие в протоколе.
</TD></TR>
<TR><TD><code>CLIENT_FOUND_ROWS</code> </TD><TD> Возвращать количество найденных (совпавших) строк, а не количество строк, подвергшихся воздействию.
</TD></TR>
<TR><TD><code>CLIENT_IGNORE_SPACE</code> </TD><TD> Допускать пробелы после имен функций. Сделать имена всех функций зарезервированными словами.
</TD></TR>
<TR><TD><code>CLIENT_INTERACTIVE</code> </TD><TD> Допускать простой длительностью <code>interactive_timeout</code> секунд (вместо <code>wait_timeout</code> секунд) перед закрытием данного соединения.
</TD></TR>
<TR><TD><code>CLIENT_NO_SCHEMA</code> </TD><TD> Запретить использование формы <code>db_name.tbl_name.col_name</code>. Это делается для ODBC и заставляет  синтаксический анализатор генерировать ошибку при использовании данного синтаксиса, который полезен для выявления ошибок в некоторых программах ODBC.
</TD></TR>
<TR><TD><code>CLIENT_ODBC</code> </TD><TD> Клиентом является клиент ODBC. Настраивает <code>mysqld</code> для большей совместимости с ODBC.
</TD></TR>
<TR><TD><code>CLIENT_SSL</code> </TD><TD> Использовать SSL (протокол шифрования).
</TD></TR>
</TABLE>
</ul>


<H4>8.4.3.177  Возвращаемые значения</H4>

<P>
Дескриптор соединения <code>MYSQL*</code>, если соединение было успешным, <code>NULL</code> если
соединение было неудачным. Для успешного соединения возвращаемая величина
та же, что и величина первого параметра.

</P>

<H4>8.4.3.178  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_CONN_HOST_ERROR</code>
<DD>
Не удалось соединиться с сервером MySQL.

<DT><code>CR_CONNECTION_ERROR</code>
<DD>
Не удалось соединиться с локальным сервером MySQL.

<DT><code>CR_IPSOCK_ERROR</code>
<DD>
Не удалось создать IP-сокет.

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Недостаток  памяти.

<DT><code>CR_SOCKET_CREATE_ERROR</code>
<DD>
Не удалось создать Unix сокет.

<DT><code>CR_UNKNOWN_HOST</code>
<DD>
Не удалось найти IP-адрес для данного имени хоста.

<DT><code>CR_VERSION_ERROR</code>
<DD>
Несоответствие протокола, что явилось результатом попытки соединения с
сервером с клиентской библиотекой, использующей иную версию протокола. Это
может произойти при использовании очень старой клиентской библиотеки для
подключения к новому серверу, при запуске которого не была установлена
опция <code>--old-protocol</code>.

<DT><code>CR_NAMEDPIPEOPEN_ERROR</code>
<DD>
Не удалось создать именованный канал на Windows.

<DT><code>CR_NAMEDPIPEWAIT_ERROR</code>
<DD>
Не удалось дождаться именованного канала на Windows.

<DT><code>CR_NAMEDPIPESETSTATE_ERROR</code>
<DD>
Не удалось получить обработчик канала на Windows.

<DT><code>CR_SERVER_LOST</code>
<DD>
Если connect_timeout &#62; 0 и требовалось больше, чем connect_timeout секунд
для соединения с сервером или если сервер прекратил работу во время
выполнения init-command.
</DL>


<H4>8.4.3.179  Пример</H4>


<pre>
MYSQL mysql;

mysql_init(&#38;mysql);
mysql_options(&#38;mysql,MYSQL_READ_DEFAULT_GROUP,"your_prog_name");
if
(!mysql_real_connect(&#38;mysql,"host","user","passwd","database",0,NULL,0))
{
	fprintf(stderr, "Failed to connect to database: Error: %s\n",
	mysql_error(&#38;mysql));
}
</pre>

<P>
Используя функцию <code>mysql_options()</code>, библиотека MySQL будет читать секции
<code>[client]</code> и <code>[your_prog_name]</code> в конфигурационном файле <tt>`my.cnf'</tt>, что будет
гарантировать нормальную работу данной программы, даже если MySQL будет
установлен нестандартным образом.

</P>
<P>
Следует заметить, что во время соединения функция <code>mysql_real_connect()</code> 
устанавливает флаг <code>reconnect</code> (часть данной структуры <code>MYSQL</code>) в значение,
равное <code>1</code>. Этот флаг показывает, что в случае, если запрос не может быть
выполнен из-за потери соединения, то следует попытаться восстановить
соединение прежде, чем отказаться от него.

</P>


<H4><A NAME="mysql_real_escape_string" HREF="manual.ru_toc.html#mysql_real_escape_string">8.4.3.180  <code>mysql_real_escape_string()</code></A></H4>
<P>
<A NAME="IDX1645"></A>

</P>
<P>
<code>unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length)</code>

</P>

<H4>8.4.3.181  Описание</H4>

<P>
Эта функция используется для создания допустимой SQL- строки, которую
можно использовать в команде SQL. See section <A HREF="manual.ru_Reference.html#String_syntax">6.1.1.1  Cтроки</A>.

</P>
<P>
Строка из секции <code>from</code> кодируется в экранированную SQL-строку, принимая во
внимание текущую кодировку данного соединения. Результат помещается в
секцию to с добавлением концевого нулевого байта. Кодируются  следующие 
символы: <code>NUL</code> (ASCII 0), <samp>`\n'</samp>, <samp>`\r'</samp>, <samp>`\'</samp>, <samp>`''</samp>, <samp>`"'</samp>  и Ctrl-Z (see section <A HREF="manual.ru_Reference.html#Literals">6.1.1  Литералы: представление строк и чисел</A>).
(Строго говоря, MySQL требует только чтобы обратная косая черта и кавычки,
используемые для квотинга строк в запросе, были проэкранированы. Эта функция
экранирует и другие символы, делая их более легкими для чтения в журнальных
файлах.)

</P>
<P>
Строка, указанная в секции <code>from</code>, должна быть длиной <code>length</code> байтов.
Необходимо выделить для секции to буфер величиной по меньшей мере
<code>length*2+1</code> байтов (в наихудшем случае каждый символ может потребовать
кодировки с использованием двух байтов и, кроме того, необходимо место для
концевого нулевого байта). При возврате функции <code>mysql_real_escape_string()</code> 
содержимое секции to будет представлять собой строку с нулевым окончанием.
Возвращаемая величина представляет собой длину данной кодированной строки,
не включая концевой нулевой символ.

</P>

<H4>8.4.3.182  Пример</H4>

<pre>

char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
*end++ = '\'';
end += mysql_real_escape_string(&#38;mysql, end,"What's this",11);
*end++ = '\'';
*end++ = ',';
*end++ = '\'';
end += mysql_real_escape_string(&#38;mysql, end,"binary data: \0\r\n",16);
*end++ = '\'';
*end++ = ')';

if (mysql_real_query(&#38;mysql,query,(unsigned int) (end - query)))
{
	fprintf(stderr, "Failed to insert row, Error: %s\n",
	mysql_error(&#38;mysql));
}
</pre>

<P>
Функция <code>strmov()</code>, использованная в этом примере, присутствует в библиотеке
<code>mysqlclient</code> и работает подобно функции <code>strcpy()</code>, но возвращает указатель
на концевой нуль первого параметра.

</P>

<H4>8.4.3.183  Возвращаемые значения</H4>

<P>
Длина величины, помещенной в секции to, не включая концевой нулевой
символ.

</P>

<H4>8.4.3.184  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_real_query" HREF="manual.ru_toc.html#mysql_real_query">8.4.3.185  <code>mysql_real_query()</code></A></H4>
<P>
<A NAME="IDX1646"></A>

</P>
<P>
<code>int mysql_real_query(MYSQL *mysql, const char *query, unsigned long length)</code>

</P>

<H4>8.4.3.186  Описание</H4>

<P>
Выполняет SQL-запрос, указанный в query, который должен быть строкой
длиною <code>length</code> байтов. Данный запрос должен состоять из одной команды SQL.
Нельзя добавлять к этой команде в качестве завершающих элементов точку с
запятой (<samp>`;'</samp>) или <code>\g</code>.

</P>
<P>
Необходимо использовать функцию <code>mysql_real_query()</code> вместо функции
<code>mysql_query()</code>для запросов, содержащих двоичные данные, поскольку двоичные
данные могут содержать символ <samp>`\0'</samp>. Кроме того, функция <code>mysql_real_query()</code> 
быстрее, чем <code>mysql_query()</code> так как она не вызывает функцию <code>strlen()</code> в
строке запроса.

</P>
<P>
Для проверки того, вернул данный запрос результирующий набор или нет,
можно использовать функцию <code>mysql_field_count()</code>. 
See section <A HREF="manual.ru_Clients.html#mysql_field_count">8.4.3.85  <code>mysql_field_count()</code></A>.

</P>

<H4>8.4.3.187  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении запроса. Величина, отличная от нуля, если
произошла ошибка.

</P>

<H4>8.4.3.188  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_reload" HREF="manual.ru_toc.html#mysql_reload">8.4.3.189  <code>mysql_reload()</code></A></H4>
<P>
<A NAME="IDX1647"></A>

</P>
<P>
<code>int mysql_reload(MYSQL *mysql)</code>

</P>

<H4>8.4.3.190  Описание</H4>

<P>
Запрашивает сервер MySQL перегрузить таблицы привилегий. Подключенный
пользователь должен обладать правом <code>RELOAD</code>.

</P>
<P>
Данная функция не рекомендуется. Вместо нее предпочтительно использовать
функцию <code>mysql_query()</code> для вызова SQL-команды <code>FLUSH PRIVILEGES</code>.

</P>

<H4>8.4.3.191  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении запроса. Величина, отличная от нуля, если
произошла ошибка.

</P>

<H4>8.4.3.192  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_row_seek" HREF="manual.ru_toc.html#mysql_row_seek">8.4.3.193  <code>mysql_row_seek()</code></A></H4>
<P>
<A NAME="IDX1648"></A>

</P>
<P>
<code>MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET offset)</code>

</P>

<H4>8.4.3.194  Описание</H4>

<P>
Устанавливает курсор строки на произвольную заданную строку в
результирующем наборе запроса. Это требует, чтобы структура
результирующего набора содержала целиком весь результат данного запроса,
поэтому функция <code>mysql_row_seek()</code> может использоваться только в соединении с
<code>mysql_store_result()</code>, но не с <code>mysql_use_result()</code>.

</P>
<P>
Адрес смещения должен быть величиной, возвращенной в результате вызова
функций <code>mysql_row_tell()</code> или <code>mysql_row_seek()</code>. Эта величина не является
номером строки, поэтому для проведения поиска строки внутри
результирующего набора по номеру строки вместо данной функции следует
использовать функцию <code>mysql_data_seek()</code>.

</P>

<H4>8.4.3.195  Возвращаемые значения</H4>

<P>
Предыдущая позиция курсора строки. Эта величина может быть получена
последовательным вызовом <code>mysql_row_seek()</code>.

</P>

<H4>8.4.3.196  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_row_tell" HREF="manual.ru_toc.html#mysql_row_tell">8.4.3.197  <code>mysql_row_tell()</code></A></H4>
<P>
<A NAME="IDX1649"></A>

</P>
<P>
<code>MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</code>

</P>

<H4>8.4.3.198  Описание</H4>

<P>
Возвращает позицию курсора строки, использованную для последнего вызова
функции <code>mysql_fetch_row()</code>.Эта величина может использоваться как аргумент в
функции <code>mysql_row_seek()</code>.

</P>
<P>
Функцию <code>mysql_row_tell()</code> следует использовать только после функции
<code>mysql_store_result()</code>, но не после <code>mysql_use_result()</code>.

</P>

<H4>8.4.3.199  Возвращаемые значения</H4>

<P>
Текущая позиция курсора строки.

</P>

<H4>8.4.3.200  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_select_db" HREF="manual.ru_toc.html#mysql_select_db">8.4.3.201  <code>mysql_select_db()</code></A></H4>
<P>
<A NAME="IDX1650"></A>

</P>
<P>
<code>int mysql_select_db(MYSQL *mysql, const char *db)</code>

</P>

<H4>8.4.3.202  Описание</H4>

<P>
Устанавливает базу данных, указанную в <code>db</code>, в качестве текущей базы данных
по умолчанию для соединения, указанного в <code>mysql</code>. В последующих запросах
эта база данных является текущей по умолчанию для табличных ссылок,
которые не содержат явного указателя базы данных.

</P>
<P>
Функция <code>mysql_select_db()</code> не работает, пока подключенный пользователь не
сможет быть аутентифицирован как имеющий право на использование
запрашиваемой базы данных.

</P>

<H4>8.4.3.203  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении запроса. Величина, отличная от нуля, если
произошла ошибка.

</P>

<H4>8.4.3.204  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_shutdown" HREF="manual.ru_toc.html#mysql_shutdown">8.4.3.205  <code>mysql_shutdown()</code></A></H4>
<P>
<A NAME="IDX1651"></A>

</P>
<P>
<code>int mysql_shutdown(MYSQL *mysql)</code>

</P>

<H4>8.4.3.206  Описание</H4>

<P>
Останавливает сервер баз данных. Подключенный пользователь должен иметь
права <code>SHUTDOWN</code>.

</P>

<H4>8.4.3.207  Возвращаемые значения</H4>

<P>
Нуль при успешном выполнении запроса. Величина, отличная от нуля, если
произошла ошибка.

</P>

<H4>8.4.3.208  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_stat" HREF="manual.ru_toc.html#mysql_stat">8.4.3.209  <code>mysql_stat()</code></A></H4>
<P>
<A NAME="IDX1652"></A>

</P>
<P>
<code>char *mysql_stat(MYSQL *mysql)</code>

</P>

<H4>8.4.3.210  Описание</H4>

<P>
Возвращает символьную строку, содержащую информацию, подобную
предоставляемой командой <code>mysqladmin status</code>. Информация включает в себя
время работы сервера в секундах, а также количество запущенных потоков,
запросов, перегрузок и открытых таблиц.

</P>

<H4>8.4.3.211  Возвращаемые значения</H4>

<P>
Символьная строка с описанием статуса сервера. <code>NULL</code>, если возникла ошибка.

</P>

<H4>8.4.3.212  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_store_result" HREF="manual.ru_toc.html#mysql_store_result">8.4.3.213  <code>mysql_store_result()</code></A></H4>
<P>
<A NAME="IDX1653"></A>

</P>
<P>
<code>MYSQL_RES *mysql_store_result(MYSQL *mysql)</code>

</P>

<H4>8.4.3.214  Описание</H4>

<P>
Функцию <code>mysql_store_result()</code> или <code>mysql_use_result()</code> необходимо вызывать
после каждого выполненного запроса, извлекающего данные (<code>SELECT</code>, <code>SHOW</code>,
<code>DESCRIBE</code>, <code>EXPLAIN</code>).

</P>
<P>
Нет необходимости в вызове функции <code>mysql_store_result()</code> или
<code>mysql_use_result()</code> для других запросов, но не будет никакого вреда или
заметной потери производительности, если функция <code>mysql_store_result()</code> 
будет вызываться во всех случаях. Можно определить, вернул ли данный
запрос результирующий набор, проверкой, возвращает ли 0 функция
<code>mysql_store_result()</code> (более подробно об этом см. дальше).

</P>
<P>
Для проверки того, вернул данный запрос результирующий набор или нет,
можно использовать функцию <code>mysql_field_count()</code>. 
See section <A HREF="manual.ru_Clients.html#mysql_field_count">8.4.3.85  <code>mysql_field_count()</code></A>.

</P>
<P>
Функция <code>mysql_store_result()</code> читает весь результат запроса данного
клиента, выделяет структуру <code>MYSQL_RES</code> и помещает результат в эту
структуру.

</P>
<P>
Функция <code>mysql_store_result()</code> возвращает нулевой указатель, если данный
запрос не вернул результирующий набор (если этот запрос был, например,
командой <code>INSERT</code>).

</P>
<P>
Функция <code>mysql_store_result()</code> также возвращает нулевой указатель, если
чтение результирующего набора завершилось неудачно. Выяснить, произошла ли
ошибка, можно следующим образом: если <code>mysql_error()</code> не возвращает нулевой
указатель, если <code>mysql_errno()</code> возвращает величину &#60;&#62; 0 или если
<code>mysql_field_count()</code>возвращает величину &#60;&#62; 0.

</P>
<P>
Пустой результирующий набор возвращается в случае, если нет ни одной
возвращенной строки. (Пустой результирующий набор и нулевой указатель -
разные вещи в контексте возвращаемых величин.)

</P>
<P>
Если была вызвана функция <code>mysql_store_result()</code> и полученный результат не
является нулевым указателем, то можно вызвать функцию <code>mysql_num_rows()</code> для
определения количества строк в результирующем наборе.

</P>
<P>
Можно вызвать функцию <code>mysql_fetch_row()</code> для выборки строк из
результирующего набора или функции <code>mysql_row_seek()</code> и <code>mysql_row_tell()</code> для
получения или установки положения текущей строки внутри данного
результирующего набора.

</P>
<P>
Необходимо вызвать функцию <code>mysql_free_result()</code> сразу же после окончания
действий с результирующим набором.

</P>
<P>
See section <A HREF="manual.ru_Clients.html#NULL_mysql_store_result">8.4.6.1  Почему после успешных возвратов функции <code>mysql_query()</code> функция <code>mysql_store_result()</code> иногда возвращает <code>NULL</code>?</A>.

</P>

<H4>8.4.3.215  Возвращаемые значения</H4>

<P>
Результирующая структура <code>MYSQL_RES</code> с результатами. <code>NULL</code>, если произошла
ошибка.

</P>

<H4>8.4.3.216  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Нехватка  памяти.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H4><A NAME="mysql_thread_id" HREF="manual.ru_toc.html#mysql_thread_id">8.4.3.217  <code>mysql_thread_id()</code></A></H4>
<P>
<A NAME="IDX1654"></A>

</P>
<P>
<code>unsigned long mysql_thread_id(MYSQL *mysql)</code>

</P>

<H4>8.4.3.218  Описание</H4>

<P>
Возвращает идентификатор данного потока для текущего соединения. Эта
величина может быть использована как аргумент для функции <code>mysql_kill()</code> для
уничтожения данного потока.

</P>
<P>
Если соединение прерывается и осуществляется его восстановление с помощью
функции <code>mysql_ping()</code>, то идентификатор данного потока изменится. Это
означает, что нельзя получить идентификатор данного потока и хранить его
для последующего использования. Следует определять его, когда в этом есть
необходимость.

</P>

<H4>8.4.3.219  Возвращаемые значения</H4>

<P>
Идентификатор данного потока для текущего соединения.

</P>

<H4>8.4.3.220  Ошибки</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_use_result" HREF="manual.ru_toc.html#mysql_use_result">8.4.3.221  <code>mysql_use_result()</code></A></H4>
<P>
<A NAME="IDX1655"></A>

</P>
<P>
<code>MYSQL_RES *mysql_use_result(MYSQL *mysql)</code>

</P>

<H4>8.4.3.222  Описание</H4>

<P>
Функцию <code>mysql_store_result()</code> или <code>mysql_use_result()</code> необходимо вызывать
после каждого выполненного запроса, извлекающего данные (<code>SELECT</code>, <code>SHOW</code>,
<code>DESCRIBE</code>, <code>EXPLAIN</code>).

</P>
<P>
Функция <code>mysql_use_result()</code> инициализирует извлечение результирующего
набора, но фактически не производит чтение в клиенте подобно тому, как это
делает функция <code>mysql_store_result()</code>. Вместо этого каждая строка должна
извлекаться индивидуально посредством вызова функции <code>mysql_fetch_row()</code>.
При этом методе результат запроса читается непосредственно на сервере без
промежуточного хранения его во временной таблице или локальном буфере, что
быстрее и требует намного меньше памяти, чем использование функции
<code>mysql_store_result()</code>. Клиент будет выделять память только для текущей
строки и буфер связи может расти до величины <code>max_allowed_packet</code> байтов.

</P>
<P>
С другой стороны, функцию <code>mysql_use_result()</code> нельзя использовать, если
выполняется много операций по обработке каждой строки на клиентской
стороне, или если вывод делается на терминал, на котором пользователь
может нажать <code>^S</code> (остановить вывод).

</P>
<P>
Это будет ограничивать работу сервера и будет мешать другим потокам в
обновлении таблиц, из которых выбираются данные.

</P>
<P>
При использовании <code>mysql_use_result()</code> необходимо выполнять
<code>mysql_fetch_row()</code>, пока не возвратится величина <code>NULL</code>, в противном случае
невыбранные строки данного запроса будут возвращены как часть
результирующего набора для следующего запроса. Если вы забыли сделать это,
то интерфейс C будет выдавать ошибку <code>Commands out of sync; you can't run
this command now!</code> 

</P>
<P>
Нельзя использовать функции <code>mysql_data_seek()</code>, <code>mysql_row_seek()</code>,
<code>mysql_row_tell()</code>, <code>mysql_num_rows()</code> или <code>mysql_affected_rows()</code> для обработки
результата, возвращенного функцией <code>mysql_use_result()</code>, а также нельзя
запускать другие запросы, пока функция <code>mysql_use_result()</code> не завершится
(однако после выборки всех строк функция <code>mysql_num_rows()</code> будет корректно
возвращать количество выбранных строк).

</P>
<P>
Необходимо вызвать функцию <code>mysql_free_result()</code> сразу же после окончания
действий с результирующим набором.

</P>

<H4>8.4.3.223  Возвращаемые значения</H4>

<P>
Результирующая структура <code>MYSQL_RES</code> с результатами. <code>NULL</code>, если произошла
ошибка.

</P>

<H4>8.4.3.224  Ошибки</H4>
<DL COMPACT>

<DT><code>CR_COMMANDS_OUT_OF_SYNC</code>
<DD>
Команды были выполнены в ненадлежащем порядке.

<DT><code>CR_OUT_OF_MEMORY</code>
<DD>
Нехватка  памяти.

<DT><code>CR_SERVER_GONE_ERROR</code>
<DD>
Сервер MySQL неожиданно завершил работу.

<DT><code>CR_SERVER_LOST</code>
<DD>
Соединение с сервером прервалось в процессе данного запроса.

<DT><code>CR_UNKNOWN_ERROR</code>
<DD>
Произошла неизвестная ошибка.
</DL>



<H3><A NAME="C_Thread_functions" HREF="manual.ru_toc.html#C_Thread_functions">8.4.4  Описания функций C, связанных с потоками</A></H3>

<P>
Эти функции необходимо вызывать для сборки клиента с поддержкой потоков.
See section <A HREF="manual.ru_Clients.html#Threaded_clients">8.4.8  Как создать клиентскую программу с потоками</A>.

</P>



<H4><A NAME="my_init" HREF="manual.ru_toc.html#my_init">8.4.4.1  <code>my_init()</code></A></H4>
<P>
<A NAME="IDX1656"></A>

</P>
<P>
<code>void my_init(void)</code>

</P>

<H4>8.4.4.2  Описание</H4>

<P>
Данную функцию необходимо вызывать однажды во время запуска программы
перед вызовом любой функции MySQL. Ее вызовом инициализируются необходимые
для MySQL глобальные переменные. При использовании клиентской библиотеки,
поддерживающей потоки, эта функция будет также вызывать функцию
<code>mysql_thread_init()</code> для этого потока.

</P>
<P>
Данная функция вызывается автоматически функциями <code>mysql_init()</code>,
<code>mysql_server_init()</code> и <code>mysql_connect()</code>.

</P>

<H4>8.4.4.3  Возвращаемые величины</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_thread_init" HREF="manual.ru_toc.html#mysql_thread_init">8.4.4.4  <code>mysql_thread_init()</code></A></H4>
<P>
<A NAME="IDX1657"></A>

</P>
<P>
<code>my_bool mysql_thread_init(void)</code>

</P>

<H4>8.4.4.5  Описание</H4>

<P>
Эту функцию необходимо вызывать для каждого созданного потока - для
инициализации его специфических переменных.

</P>
<P>
Данная функция вызывается автоматически функциями <code>my_init()</code> и
<code>mysql_connect()</code>.

</P>

<H4>8.4.4.6  Возвращаемые величины</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_thread_end" HREF="manual.ru_toc.html#mysql_thread_end">8.4.4.7  <code>mysql_thread_end()</code></A></H4>
<P>
<A NAME="IDX1658"></A>

</P>
<P>
<code>void mysql_thread_end(void)</code>

</P>

<H4>8.4.4.8  Описание</H4>

<P>
Данную функцию необходимо вызывать перед вызовом функции <code>pthread_exit()</code> 
для освобождения памяти, выделенной функцией <code>mysql_thread_init()</code>.

</P>
<P>
Следует учитывать, что эта функция не вызывается автоматически клиентской
библиотекой. Во избежание утечки памяти она должна вызываться явно.

</P>

<H4>8.4.4.9  Возвращаемые величины</H4>

<P>
Нет.

</P>


<H4><A NAME="mysql_thread_safe" HREF="manual.ru_toc.html#mysql_thread_safe">8.4.4.10  <code>mysql_thread_safe()</code></A></H4>
<P>
<A NAME="IDX1659"></A>

</P>
<P>
<code>unsigned int mysql_thread_safe(void)</code>

</P>

<H4>8.4.4.11  Описание</H4>

<P>
Эта функция возвращает значение, показывающее, компилировался ли данный
клиент как поддерживающий потоки.

</P>

<H4>8.4.4.12  Возвращаемые величины</H4>

<P>
1 - если данный клиент поддерживает потоки, 0 - в противном случае.

</P>


<H3><A NAME="C_Embedded_Server_func" HREF="manual.ru_toc.html#C_Embedded_Server_func">8.4.5  Описания функций C, доступных во встраиваемом сервере</A></H3>

<P>
Эти функции можно использовать при линковании с библиотекой встраиваемого
сервера MySQL.

</P>
<P>
See section <A HREF="manual.ru_Clients.html#libmysqld">8.4.9  libmysqld, встраиваемая библиотека сервера MySQL</A>.

</P>
<P>
Если данная программа слинкована с <code>-lmysqlclient</code>, а не с  <code>-lmysqld</code>, то эти
функции не делают ничего. Это обеспечивает возможность выбора между
встраиваемым сервером MySQL и автономным без какой-либо модификации кода.

</P>



<H4><A NAME="mysql_server_init" HREF="manual.ru_toc.html#mysql_server_init">8.4.5.1  <code>mysql_server_init()</code></A></H4>
<P>
<A NAME="IDX1660"></A>

</P>
<P>
<code>int mysql_server_init(int argc, char **argv, char **groups)</code>

</P>

<H4>8.4.5.2  Описание</H4>

<P>
Данную функцию необходимо вызывать только один раз во время работы
программы, использующей встроенный сервер. Это функцию следует вызвать
перед вызовом любой другой функции MySQL. Она запускает сервер
и инициализирует все подсистемы (<code>mysys</code>, InnoDB и т.д.), используемые
сервером. Без вызова этой функции произойдет аварийное завершение данной
программы. При использовании пакета <code>DBUG</code>, поставляемого вместе с MySQL,
данную функцию следует вызывать после функции <code>MY_INIT()</code>.

</P>
<P>
Аргументы <code>argc</code> и <code>argv</code> аналогичны аргументам в <code>main</code>(). Первый элемент
аргумента <code>argv</code> игнорируется (обычно он содержит имя программы). Для
удобства аргумент argc может быть равен 0 (нуль) - если не задано ни
одного аргумента командной строки для данного сервера.
<code>mysql_server_init()</code> делает копию аргументов, т.е. она безопастна для
уничтожения <code>argv</code> или <code>groups</code> после вызова.

</P>
<P>
Аргумент <code>groups</code> представляет собой список строк, заканчивающийся <code>NULL</code>.
Этот аргумент задает активные группы в файлах опций (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Option_files">4.1.2  Файлы параметров <tt>`my.cnf'</tt></A>). Для удобства аргумент groups может быть равен <code>NULL</code> - в
этом случае будут активны группы <code>[server]</code> и <code>[emedded]</code>.

</P>

<H4>8.4.5.3  Пример</H4>


<pre>
#include &#60;mysql.h&#62;
#include &#60;stdlib.h&#62;

static char *server_args[] = {
  "this_program", /* эта строка не используется */
  "--datadir=.",
  "--key_buffer_size=32M"
};

static char *server_groups[] = {
  "embedded",
  "server",
  "this_program_SERVER",
  (char *)NULL
};

int main(void) {
  mysql_server_init(sizeof(server_args) / sizeof(char *),
  server_args, server_groups);
  /* Здесь используются любые функции MySQL  API */
  mysql_server_end();
  return EXIT_SUCCESS;
}
</pre>


<H4>8.4.5.4  Возвращаемые значения</H4>

<P>
0 - если все в порядке, 1 - если произошла ошибка.

</P>


<H4><A NAME="mysql_server_end" HREF="manual.ru_toc.html#mysql_server_end">8.4.5.5  <code>mysql_server_end()</code></A></H4>
<P>
<A NAME="IDX1661"></A>

</P>
<P>
<code>void mysql_server_end(void)</code>

</P>

<H4>8.4.5.6  Описание</H4>

<P>
Эту функцию в программе необходимо вызывать только единожды, после всех
остальных функций MySQL. Она останавливает <code>libmysqld</code>, встраиваемый сервер
MySQL.

</P>

<H4>8.4.5.7  Возвращаемые значения</H4>

<P>
Нет.

</P>


<H3><A NAME="C_API_problems" HREF="manual.ru_toc.html#C_API_problems">8.4.6  Основные вопросы и проблемы в использовании интерфейса C</A></H3>

<P>
<A NAME="IDX1662"></A>
<A NAME="IDX1663"></A>

</P>



<H4><A NAME="NULL_mysql_store_result" HREF="manual.ru_toc.html#NULL_mysql_store_result">8.4.6.1  Почему после успешных возвратов функции <code>mysql_query()</code> функция <code>mysql_store_result()</code> иногда возвращает <code>NULL</code>?</A></H4>

<P>
Для функции <code>mysql_store_result()</code> после успешного вызова функции
<code>mysql_query()</code> возможен возврат величины <code>NULL</code>. Это может означать
следующее:

</P>

<ul>
<LI>

Произошел сбой в выполнении функции <code>mallow()</code> (например, если
результирующий набор данных слишком велик).
<LI>

Данные не могли быть прочитаны (возникла ошибка в соединении).

Запрос не вернул никаких данных (например, это был запрос вида <code>INSERT</code>,
<code>UPDATE</code> или <code>DELETE</code>).
</ul>

<P>
Проверить, вернула ли данная команда не пустой результирующий набор,
всегда можно с помощью вызова функции <code>mysql_field_count()</code>. Если функция
<code>mysql_field_count()</code> возвращает нуль, то данный результирующий набор
является пустым и последний запрос представлял собой команду, которая не
возвращает результирующие величины (например, <code>INSERT</code> или <code>DELETE</code>). Если
функция <code>mysql_field_count()</code> возвращает величину, отличную от нуля, то
данная команда должна была вернуть не пустой результат (см. описание
функции <code>mysql_field_count()</code>).

</P>
<P>
Можно протестировать описанные ситуации на ошибку, вызывая функции
<code>mysql_error()</code> или <code>mysql_errno()</code>.

</P>


<H4><A NAME="Query_results" HREF="manual.ru_toc.html#Query_results">8.4.6.2  Какие результаты можно получить из запроса?</A></H4>

<P>
В дополнение к возвращенному запросом результирующему набору данных можно
также получить следующую информацию:

</P>

<ul>
<LI>

Функция <code>mysql_affected_rows()</code> возвращает количество строк,
подвергшихся воздействию во время последнего запроса при выполнении
<code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code>. Исключение составляет случай использования
команды <code>DELETE</code> без выражения <code>WHERE</code>, когда таблица воссоздается как
пустая, а это намного быстрее! В таком случае функция
<code>mysql_affected_rows()</code> в качестве количества подвергшихся воздействию
записей возвращает нуль.

<LI>

Функция <code>mysql_num_rows()</code> возвращает количество строк в результирующем
наборе данных. Функция <code>mysql_num_rows()</code> может вызываться сразу же
после возвращения функции <code>mysql_store_result()</code>. Совместно с функцией
<code>mysql_use_result()</code> функция <code>mysql_num_rows()</code> может вызываться только
после того, как извлечены все строки с помощью функции
<code>mysql_fetch_row()</code>.

<LI>

Функция <code>mysql_insert_id()</code> возвращает идентификатор, созданный
последним запросом, внесшим строку в таблицу с автоинкрементным полем
(<code>AUTO_INCREMENT</code>, <code>mysql_insert_id()</code>).

<LI>

Некоторые запросы (<code>LOAD DATA INFILE ...</code>, <code>INSERT INTO ... SELECT ...</code>,
<code>UPDATE</code>) возвращают дополнительную информацию. Ее можно получить с помощью
функции <code>mysql_info()</code>. Описание формата возвращаемой строки смотрите в
описании функции <code>mysql_info()</code>. Если дополнительная информация отсутствует,
то функция <code>mysql_info()</code> возвращает указатель <code>NULL</code>.
</ul>



<H4><A NAME="Getting_unique_ID" HREF="manual.ru_toc.html#Getting_unique_ID">8.4.6.3  Как получить уникальный идентификатор для последней внесенной строки?</A></H4>

<P>
<A NAME="IDX1664"></A>
<A NAME="IDX1665"></A>
<A NAME="IDX1666"></A>

</P>
<P>
При внесении записи в таблицу, содержащую столбец с атрибутом
<code>AUTO_INCREMENT</code>, последний сгенерированный идентификатор можно получить,
вызвав функцию <code>mysql_insert_id()</code>.

</P>
<P>
Для извлечения этого <code>id</code> можно также использовать функцию <code>LAST_INSERT_ID()</code> 
в строке запроса, передаваемой в <code>mysql_query()</code>.

</P>
<P>
Для проверки, используется или нет поле <code>AUTO_INCREMENT</code>, можно выполнить
следующий код. Этот код также проверяет, был ли данный запрос вида <code>INSERT</code>
с использованием <code>AUTO_INCREMENT</code>:

</P>

<pre>
if (mysql_error(&#38;mysql)[0] == 0 &#38;&
mysql_num_fields(result) == 0 &#38;&
mysql_insert_id(&#38;mysql) != 0)
{
	used_id = mysql_insert_id(&#38;mysql);
}
</pre>

<P>
Самое последнее сгенерированное значение идентификатора сохраняется на
сервере в течение времени жизни данного соединения. Это значение не может
быть изменено другим клиентом, более того, оно не будет изменено даже при
обновлении другого столбца <code>AUTO_INCREMENT</code> конкретной величиной (т.е. не
<code>NULL</code> или <code>0</code>).

</P>
<P>
Идентификатор, который был сгенерирован для одной таблицы, можно вставить
в другую таблицу, используя команды SQL, как показано ниже:

</P>

<pre>
INSERT INTO foo (auto,text)
    VALUES(NULL,'text'); # генерация ID вставкой NULL
INSERT INTO foo2 (id,text)
    VALUES(LAST_INSERT_ID(),'text'); # использование ID во второй таблице
</pre>



<H4><A NAME="C_API_linking_problems" HREF="manual.ru_toc.html#C_API_linking_problems">8.4.6.4  Проблемы линкования с интерфейсом C</A></H4>

<P>
<A NAME="IDX1667"></A>
<A NAME="IDX1668"></A>

</P>
<P>
При линковании программы с клиентской библиотекой C в некоторых системах
могут возникать следующие проблемы:

</P>

<pre>
gcc -g -o client test.o -L/usr/local/lib/mysql -lmysqlclient -lsocket -lnsl

Undefined        first referenced
 symbol          in file
floor            /usr/local/lib/mysql/libmysqlclient.a(password.o)
ld: fatal: Symbol referencing errors. No output written to client
</pre>

<P>
Если это случилось в вашей системе, то необходимо подключить
математическую библиотеку путем добавления параметра <code>-lm</code> в конец строки
компилирования/линкования.

</P>


<H3><A NAME="Building_clients" HREF="manual.ru_toc.html#Building_clients">8.4.7  Сборка клиентских программ</A></H3>

<P>
<A NAME="IDX1669"></A>
<A NAME="IDX1670"></A>
<A NAME="IDX1671"></A>
<A NAME="IDX1672"></A>

</P>
<P>
Клиенты MySQL, созданные собственноручно или полученные от сторонних фирм,
при компилировании должны линковаться с использованием опций <code>-lmysqlclient
-lz</code> в команде линкования. Возможно, потребуется задать опцию <code>-L</code>, чтобы
указать компоновщику местоположение данной библиотеки. Например, если
библиотека установлена в каталоге <tt>`/usr/local/mysql/lib'</tt>, следует
использовать в команде линкования выражение <code>-L/usr/local/mysql/lib
-lmysqlclient -lz</code>.

</P>
<P>
Для клиентов, использующих файлы заголовков MySQL, при компиляции,
возможно, потребуется задать опцию <code>-I</code> (например,
<code>-I/usr/local/mysql/include</code>), чтобы компилятор мог найти требуемые файлы
заголовков.

</P>
<P>
Для того что бы сделать вышеизложенное более простым под Unix мы предоставляем
для вас скрипт <code>mysql_config</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#mysql_config">4.8.9  <code>mysql_config</code>, Получение опций компиляции для компиляции клиентских программ</A>.

</P>
<P>
Вы можете использовать его, компилируя клиента MySQL следующим образом:

</P>

<pre>
CFG=/usr/local/mysql/bin/mysql_config
sh -c "gcc -o progname `$CFG --cflags` progname.c `$CFG --libs`"
</pre>

<P>
<code>sh -c</code> необходимо чтобы оболочка не воспринимала вывод
<code>mysql_config</code> как одно слово.

</P>


<H3><A NAME="Threaded_clients" HREF="manual.ru_toc.html#Threaded_clients">8.4.8  Как создать клиентскую программу с потоками</A></H3>

<P>
<A NAME="IDX1673"></A>
<A NAME="IDX1674"></A>
<A NAME="IDX1675"></A>

</P>
<P>
Клиентская библиотека почти безопасна при использовании в мультипоточном
режиме. Наибольшая проблема заключается в том, что функции в <tt>`net.c'</tt>,
читающие из сокетов, не поддерживают прерываний. Они были спроектированы
исходя из предположения, что пользователь может захотеть иметь свой
собственный аварийный сигнал, который способен прерывать слишком долгое
чтение с сервера. При установке обработчиков прерываний для прерывания
<code>SIGPIPE</code> управление сокетами должно быть поддерживающим потоки.

</P>
<P>
В более ранних бинарных поставках MySQL, которые мы (разработчики MySQL)
распространяли с нашего веб-сайта (<a HREF="http://www.mysql.com/">http://www.mysql.com/</a>), клиентские
библиотеки обычно не компилировались с возможностью поддержки потоков
(бинарные поставки для Windows по умолчанию компилируются как
поддерживающие потоки). Более новые бинарные поставки должны иметь как
нормальную, так и поддерживающую потоки клиентскую библиотеку.

</P>
<P>
Чтобы получить поддерживающую потоки клиентскую программу с возможностью
прерывать ее из других потоков и устанавливать блокировки по времени при
соединении с сервером MySQL, необходимо использовать библиотеки <code>-lmysys</code>,
<code>-lmystrings</code> и <code>-ldbug libraries</code>, а также код <tt>`net_serv.o'</tt>, используемый
данным сервером.

</P>
<P>
Если нет необходимости в прерываниях или временных блокировках, то можно
просто скомпилировать поддерживающую потоки клиентскую библиотеку
(<code>mysqlclient_r</code>) и использовать ее (see section <A HREF="manual.ru_Clients.html#C">8.4  Интерфейс C для MySQL</A>). В этом случае
нет необходимости заботиться об объектном файле net_serv.o или других
библиотеках MySQL.

</P>
<P>
Если необходимо применять временные блокировки и прерывания при
использовании поддерживающего потоки клиента, то можно с успехом
использовать подпрограммы из файла <tt>`thr_alarm.c'</tt>. При использовании
подпрограмм из библиотеки mysys  следует помнить только о том, что сначала
следует вызвать функцию  <code>my_init()</code>! See section <A HREF="manual.ru_Clients.html#C_Thread_functions">8.4.4  Описания функций C, связанных с потоками</A>.

</P>
<P>
Все функции, за исключением <code>mysql_real_connect()</code>, по умолчанию являются
поддерживающими потоки. Ниже приводятся рекомендации, как следует
компилировать поддерживающую потоки клиентскую библиотеку и использовать
ее в этом режиме (замечания по функции <code>mysql_real_connect()</code> справедливы
также и для функции <code>mysql_connect()</code>, но поскольку функция <code>mysql_connect()</code> 
не рекомендуется, то в любом случае следует использовать функцию
<code>mysql_real_connect()</code>).

</P>
<P>
Для того чтобы сделать функцию <code>mysql_real_connect()</code> поддерживающей потоки,
необходимо перекомпилировать клиентскую библиотеку со следующей командой:

</P>

<pre>
shell&#62; ./configure --enable-thread-safe-client
</pre>

<P>
Это создаст поддерживающую потоки клиентскую библиотеку <code>libmysqlclient_r</code>
(предполагается, что данная операционная система включает поддерживающую
потоки функцию <code>gethostbyname_r()</code>). Эта библиотека является поддерживающей
потоки для данного соединения. Можно позволить двум потокам использовать
одно и то же соединение со следующими оговорками:

</P>

<ul>
<LI>

Два потока не могут посылать запрос серверу MySQL в одно и то же время
на одном и том же соединении. В особенности необходимо быть уверенным,
что в промежутках между вызовом функций <code>mysql_query()</code> и
<code>mysql_store_result()</code> никакой другой поток не использует это же
соединение.
<LI>

Многие потоки имеют доступ к различным результирующим наборам данных,
извлекаемых функцией <code>mysql_store_result()</code>.
<LI>

При использовании функции <code>mysql_use_result</code> необходимо быть уверенным,
что никакой другой поток не использует это же соединение, пока данный
результирующий набор не будет обработан. Однако действительно
наилучший вариант для потоковых клиентов, совместно использующих одно
и то же соединение, - это применять функцию <code>mysql_store_result()</code>.
<LI>

Если необходимо использовать большое количество потоков на одном и том
же соединении, то следует иметь синхронизирующую блокировку в
отношении вызова комбинации функций <code>mysql_query()</code> и
<code>mysql_store_result()</code>. Как только выполнение функции
<code>mysql_store_result()</code> заканчивается, данная блокировка может сниматься
и другие потоки могут запрашивать это же самое соединение.
<LI>

Если вы программируете с использованием потоков <code>POSIX</code>, то можно
использовать функции <code>pthread_mutex_lock()</code> и <code>pthread_mutex_unlock()</code> для
установки и освобождения синхронизирующей блокировки.
</ul>

<P>
Необходимо знать следующее: если имеется вызываемый функцией MySQL поток,
который не создавал данное соединение с базой данных MySQL, то:

</P>
<P>
При вызове функций <code>mysql_init()</code> или <code>mysql_connect()</code> MySQL создаст
специальные переменные для этого потока, которые (среди прочих применений)
используются библиотекой отладки.

</P>
<P>
При вызове функции MySQL до того, как поток вызвал функции <code>mysql_init()</code> 
или <code>mysql_connect()</code>, данный поток в этом случае не будет иметь необходимых
специальных переменных потока и, вероятно, программа рано или поздно умрет
с дампом оперативной памяти.

</P>
<P>
Для более плавной работы программы необходимо выполнить следующие
действия:

</P>

<ol>
<LI>

Вызвать функцию <code>my_init()</code> при запуске данной программы, если она
вызывает какую-либо другую функцию MySQL до  вызова  функции 
<code>mysql_real_connect()</code>.
<LI>

Вызвать функцию <code>mysql_thread_init()</code> в обработчике потока до вызова
иной функции MySQL.
<LI>

В данном потоке вызвать функцию <code>mysql_thread_end()</code> перед вызовом
<code>pthread_exit()</code>. Это освободит память, занятую специальными переменными
потока для MySQL.
</ol>

<P>
Следует учитывать, что можно получить некоторые ошибки из-за наличия
неопределенных символов при связывании клиента с библиотекой
<code>libmysqlclient_r</code>. В большинстве случаев это происходит вследствие того,
что в строку связывания/компилирования не включены библиотеки потока.

</P>


<H3><A NAME="libmysqld" HREF="manual.ru_toc.html#libmysqld">8.4.9  libmysqld, встраиваемая библиотека сервера MySQL</A></H3>

<P>
<A NAME="IDX1676"></A>
<A NAME="IDX1677"></A>

</P>



<H4><A NAME="libmysqld_overview" HREF="manual.ru_toc.html#libmysqld_overview">8.4.9.1  Обзор библиотеки встраиваемого сервера MySQL</A></H4>

<P>
Библиотека встраиваемого сервера MySQL обеспечивает возможность запуска
полнофункционального сервера MySQL внутри клиентского приложения. Основные
преимущества, которые дает ее использование, - увеличение скорости и более
простое управление для встраиваемых приложений.

</P>
<P>
Интерфейсы API для встраиваемой версии MySQL и для версии клиент/сервер
идентичны. Чтобы реализовать возможность использования встраиваемого
сервера в старом приложении с потоками, обычно необходимо только добавить
вызовы следующих функций:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Функция</strong> </TD><TD> <strong>Когда вызывается</strong>
</TD></TR>
<TR><TD><code>mysql_server_init()</code> </TD><TD> Должна вызываться перед любой другой функцией MySQL, предпочтительно раньше, чем функция main().
</TD></TR>
<TR><TD><code>mysql_server_end()</code> </TD><TD> Должна вызываться перед выходом из данной программы.
</TD></TR>
<TR><TD><code>mysql_thread_init()</code> </TD><TD> Должна вызываться в каждом создаваемом потоке, который будет работать с MySQL.
</TD></TR>
<TR><TD><code>mysql_thread_end()</code> </TD><TD> Должна вызываться перед вызовом pthread_exit()
</TD></TR>
</TABLE>

<P>
После добавления функций необходимо связать данный код с библиотекой
<tt>`libmysqld.a'</tt> вместо <tt>`libmysqlclient.a'</tt>.

</P>
<P>
Вышеприведенные функции типа <code>mysql_server_xxx</code> также включены в
<tt>`libmysqlclient.a'</tt> - таким образом обеспечивается возможность переключаться
между встраиваемой и клиент-серверной версиями просто линкованием
конкретного приложения с соответствующей библиотекой. См.раздел 
See section <A HREF="manual.ru_Clients.html#mysql_server_init">8.4.5.1  <code>mysql_server_init()</code></A>.

</P>


<H4><A NAME="libmysqld_compiling" HREF="manual.ru_toc.html#libmysqld_compiling">8.4.9.2  Компиляция программ с libmysqld</A></H4>

<P>
Чтобы получить библиотеку <code>libmysqld</code>, необходимо сконфигурировать (при
помощи <code>configure</code>) сборку MySQL с опцией <code>--with-embedded-server</code>.

</P>
<P>
При связывании программы с <code>libmysqld</code> необходимо также включать
специфические для данной системы библиотеки <code>pthread</code> и другие библиотеки,
используемые сервером MySQL. Полный список библиотек можно получить,
выполнив <code>mysql_config --libmysqld-libs</code>.

</P>
<P>
Для компиляции и связывания должны использоваться флаги компиляции
потоковой программы, даже если никакие потоковые функции в данном коде
явно не вызываются.

</P>


<H4><A NAME="libmysqld_restrictions" HREF="manual.ru_toc.html#libmysqld_restrictions">8.4.9.3  Ограничения при использовании встраиваемого сервера MySQL</A></H4>

<P>
встраиваемый сервер имеет следующие ограничения:

</P>

<ul>
<LI>

Не поддерживает таблицы <code>ISAM</code> (это сделано главным образом для
уменьшения размеров библиотеки)
<LI>

Не поддерживает функции <code>UDF</code> (функции, определяемые пользователем).
<LI>

Не отслеживаются стеки на дампе оперативной памяти.
<LI>

Нет внутренней поддержки <code>RAID</code> (обычно этого не требуется, так как
большинство операционных систем в настоящее время имеют поддержку для
больших файлов).
<LI>

встраиваемый сервер MySQL нельзя установить как головной или
подчиненный сервер репликации
<LI>

К встраиваемому серверу нельзя подсоединиться из внешнего процесса
через сокеты или по протоколу TCP/IP.
</ul>

<P>
Некоторые из этих ограничений могут быть изменены путем редактирования
включаемого файла <tt>`mysql_embed.h'</tt> и перекомпилирования MySQL.

</P>


<H4><A NAME="libmysqld_options" HREF="manual.ru_toc.html#libmysqld_options">8.4.9.4  Использование файлов опций с встраиваемым сервером</A></H4>

<P>
<A NAME="IDX1678"></A>

</P>
<P>
Ниже приводятся рекомендации по использованию файлов опций для облегчения
перехода между клиент-серверным приложением и приложением с встраиваемым
MySQL (see section <A HREF="manual.ru_MySQL_Database_Administration.html#Option_files">4.1.2  Файлы параметров <tt>`my.cnf'</tt></A>).

</P>

<ul>
<LI>

Следует помещать общие опции в раздел <code>[server]</code>. Они будут читаться
обеими версиями MySQL.
<LI>

Следует помещать специфические клиент-серверные опции в раздел
<code>[mysqld]</code>.
<LI>

Следует помещать специфические опции встраиваемого MySQL в раздел
<code>[embedded]</code>.
<LI>

Следует помещать специфические опции приложения в раздел
<code>[ApplicationName_SERVER]</code>.
</ul>



<H4><A NAME="libmysqld_TODO" HREF="manual.ru_toc.html#libmysqld_TODO">8.4.9.5  Что осталось сделать по встраиваемомуому серверу (TODO)</A></H4>

<P>
<A NAME="IDX1679"></A>

</P>

<ul>
<LI>

Предполагается обеспечить возможность не включать некоторые части
MySQL, чтобы сделать библиотеку меньше.
<LI>

Многое еще нужно сделать для оптимизации скорости.
<LI>

Ошибки записываются в <code>stderr</code>. Предполагается добавить возможность
указывать для них имя файла.
<LI>

Необходимо изменить InnoDB, чтобы вывод этого обработчика не был бы
настолько подробным во встраиваемой версии.
</ul>



<H4><A NAME="libmysqld_example" HREF="manual.ru_toc.html#libmysqld_example">8.4.9.6  Пример простого встраиваемого сервера</A></H4>

<P>
Этот пример программы и сборочного файла должен работать без каких-либо
изменений под операционными системами Linux или FreeBSD. Для других
операционных систем потребуются небольшие изменения. При разработке
данного примера мы ставили перед собой цель предоставить достаточно
информации для понимания рассматриваемой темы и в то же время не
перегружать текст руководства лишними деталями, специфическими для
реального приложения.

</P>
<P>
Чтобы запустить этот пример, создайте каталог <tt>`test_libmysqld'</tt> там же, где
находится каталог исходного кода mysql-4.0. Сохраните исходный код
<tt>`test_libmysqld.c'</tt> и <tt>`GNUmakefile'</tt> в данном каталоге и запустите GNU
<tt>`make'</tt> в каталоге <tt>`test_libmysqld'</tt>.

</P>
<P>
<tt>`test_libmysqld.c'</tt> 

<pre>
/*
* Клиент простого примера с использованием библиотеки встраиваемого
сервера MySQL
*/
#include &#60;mysql.h&#62;
#include &#60;stdarg.h&#62;
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;

MYSQL *db_connect(const char *dbname);
void db_disconnect(MYSQL *db);
void db_do_query(MYSQL *db, const char *query);

const char *server_groups[] = {
    "test_libmysqld_SERVER", "embedded", "server", NULL
};

int
main(int argc, char **argv)
{
  MYSQL *one, *two;
  /* Функцию mysql_server_init() необходимо вызывать перед любыми другими *
  функциями mysql.
  * Можно задать mysql_server_init(0, NULL, NULL); тогда для
  * инициализации сервера будут использоваться группы "server",
  * "embedded", NULL
  *}.
  *
  * В файле $HOME/.my.cnf можно указать:

[test_libmysqld_SERVER]
language = /path/to/source/of/mysql/sql/share/english

* Можно было бы, конечно, модифицировать argc и argv непосредственно
  * перед передачей их в эту функцию или создать
  * новые аргументы - для этого годится любой выбранный вами способ.
  * Однако все аргументы в argv (кроме argv[0], который
  * представляет собой имя программы) должны быть допустимыми опциями
  * для сервера MySQL.
  *
  * Если данный клиент линкуется с нормальной библиотекой mysqlclient,
  * то эта функция является просто заглушкой, ничего не делающей.
  */

mysql_server_init(argc, argv, (char **)server_groups);
one = db_connect("test");
two = db_connect(NULL);
db_do_query(one, "SHOW TABLE STATUS");
db_do_query(two, "SHOW DATABASES");
mysql_close(two);
mysql_close(one);

/* Эта функция должна вызываться после всех других функций mysql */

mysql_server_end();
exit(EXIT_SUCCESS);

}

static void
die(MYSQL *db, char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  (void)putc('\n', stderr);
  if (db)
  db_disconnect(db);
  exit(EXIT_FAILURE);
}

MYSQL *
db_connect(const char *dbname)
{
  MYSQL *db = mysql_init(NULL);
  if (!db)
  die(db, "mysql_init failed: no memory");

/*
* Обратите внимание: клиент и сервер используют разные имена групп.
* Это обязательное условие, поскольку сервер не должен использовать опции
* клиента и наоборот.
*/

mysql_options(db, MYSQL_READ_DEFAULT_GROUP, "test_libmysqld_CLIENT");
if (!mysql_real_connect(db, NULL, NULL, NULL, dbname, 0, NULL, 0))
die(db, "mysql_real_connect failed: %s", mysql_error(db));
return db;
}

void
db_disconnect(MYSQL *db)
{
  mysql_close(db);
}

void
db_do_query(MYSQL *db, const char *query)
{
  if (mysql_query(db, query) != 0)
  goto err;
  if (mysql_field_count(db) &#62; 0)
  {
	MYSQL_RES *res;
	MYSQL_ROW row, end_row;
	int num_fields;
	if (!(res = mysql_store_result(db)))
	goto err;
	num_fields = mysql_num_fields(res);
	while ((row = mysql_fetch_row(res)))
	{
	   (void)fputs("&#62;&#62; ", stdout);
	   for (end_row = row + num_fields; row &#60; end_row; ++row)
	   (void)printf("%s\t", row ? (char*)*row : "NULL");
	   (void)fputc('\n', stdout);
	}
	(void)fputc('\n', stdout);
}
else
(void)printf("Affected rows: %lld\n", mysql_affected_rows(db));
return;
err:
die(db, "db_do_query failed: %s [%s]", mysql_error(db), query);
}
</pre>

<P>
<tt>`GNUmakefile'</tt>

<pre>
# Предполагается, что программное обеспечение MySQL установлено в
#/usr/local/mysql

inc := /usr/local/mysql/include/mysql
lib := /usr/local/mysql/lib

# Если программное обеспечение MySQL еще не установлено, сделайте такую
замену:

#inc := $(HOME)/mysql-4.0/include
#lib := $(HOME)/mysql-4.0/libmysqld

CC := gcc
CPPFLAGS := -I$(inc) -D_THREAD_SAFE -D_REENTRANT
CFLAGS := -g -W -Wall
LDFLAGS := -static

# Можно изменить -lmysqld на -lmysqlclient для того, чтобы использовать
# обычную клиент-серверную библиотеку

LDLIBS = -L$(lib) -lmysqld -lz -lm -lcrypt
ifneq (,$(shell grep FreeBSD /COPYRIGHT 2&#62;/dev/null))

# Для FreeBSD

LDFLAGS += -pthread
else

# Предполагается Linux

LDLIBS += -lpthread
endif

# Это работает для простых однофайловых тестовых программ

sources := $(wildcard *.c)
objects := $(patsubst %c,%o,$(sources))
targets := $(basename $(sources))
all: $(targets)
clean:
rm -f $(targets) $(objects) *.core
</pre>



<H4><A NAME="libmysqld_licensing" HREF="manual.ru_toc.html#libmysqld_licensing">8.4.9.7  Лицензирование  встраиваемого  сервера</A></H4>

<P>
Исходный  код MySQL подпадает  под  действие  лицензии GNU GPL (see section <A HREF="manual.ru_GPL_license.html#GPL_license">H  GNU General Public License</A>). Одно из следствий этого заключается в том,
что любая программа, включающая (посредством связывания с <code>libmysqld</code>)
исходный код MySQL, должна выпускаться как открытое программное
обеспечение (под лицензией, совместимой с GPL).

</P>
<P>
Мы стараемся всячески способствовать всем, кто распространяет открытое
программное обеспечение, выпуская код под GPL или совместимой лицензией.
Для тех же, кому эти условия не подходят, существует другая возможность -
покупка коммерческой лицензии для кода MySQL у компании MySQL AB. Более
подробная информация об этом находится в разделе See section <A HREF="manual.ru_Introduction.html#MySQL_licenses">1.6.3  Лицензии на ПО MySQL</A>.

</P>


<H2><A NAME="Cplusplus" HREF="manual.ru_toc.html#Cplusplus">8.5  Интерфейсы C++</A></H2>

<P>
<A NAME="IDX1680"></A>

</P>
<P>
MySQL Connector/C++ (или <code>MySQL++</code>) является официальным MySQL API для
C++. Больше информации вы можете найти на
<a HREF="http://www.mysql.com/products/mysql++/">http://www.mysql.com/products/mysql++/</a>.

</P>


<H3><A NAME="Borland_C++" HREF="manual.ru_toc.html#Borland_C++">8.5.1  Интерфейс Borland C++</A></H3>

<P>
<A NAME="IDX1681"></A>

</P>
<P>
Исходный код MySQL можно скомпилировать под Windows с Borland C++ 5.02
(исходный код Windows включает в себя только проекты для Microsoft VC++, а
для Borland C++ файлы проекта необходимо сделать самостоятельно).

</P>
<P>
Одна известная проблема, связанная с Borland C++, заключается в том, что в
нем применяется иное, чем в VC++, упорядочивание структур. Это означает,
что при попытке использовать имеющуюся по умолчанию библиотеку
<tt>`libmysql.dll'</tt> (которая была скомпилирована с VC++) совместно с Borland C++
вы столкнетесь с проблемами. Избежать этих проблем можно одним из
следующих способов.

</P>

<ul>
<LI>

Можно использовать статические библиотеки MySQL для Borland C++,
которые находятся на <a HREF="http://www.mysql.com/downloads/os-win32.html">http://www.mysql.com/downloads/os-win32.html</a>.
<LI>

Вызывать функцию <code>mysql_init()</code> только с аргументом <code>NULL</code>, не выделяя
предварительно структуру MYSQL.
</ul>



<H2><A NAME="Java" HREF="manual.ru_toc.html#Java">8.6  Взаимодействие MySQL и Java (JDBC)</A></H2>

<P>
<A NAME="IDX1682"></A>
<A NAME="IDX1683"></A>

</P>
<P>
Имеется два поддерживаемых драйвера JDBC для MySQL (драйвер Connector/J и драйвер
Reisin  JDBC). Копию драйвера Connector/J можно найти на
<a HREF="http://www.mysql.com/products/connector-j/">http://www.mysql.com/products/connector-j/</a>, а драйвера Reisin - на
<a HREF="http://www.caucho.com/projects/jdbc-mysql/index.xtp">http://www.caucho.com/projects/jdbc-mysql/index.xtp</a>. По вопросам,
касающимся документации, обращайтесь к любой документации по JDBC, а по
вопросам, касающимся присущих MySQL специфических особенностей, - к
собственной документации по конкретному драйверу.

</P>


<H2><A NAME="Python" HREF="manual.ru_toc.html#Python">8.7  Интерфейсы Python API для MySQL</A></H2>

<P>
<A NAME="IDX1684"></A>

</P>
<P>
MySQLdb предоставляет поддержку MySQL для Python, в соответствии с
интерфейсом баз данных, принятом в Python (Python DB API). Вы можете найти его
здесь: <a HREF="http://sourceforge.net/projects/mysql-python/">http://sourceforge.net/projects/mysql-python/</a>. 

</P>
<P>
Каталог MySQL Contrib (<a HREF="http://www.mysql.com/Downloads/Contrib/">http://www.mysql.com/Downloads/Contrib/</a>) содержит
интерфейс Python, написанный Джозефом Скиннером (Joseph Skinner).

</P>


<H2><A NAME="Tcl" HREF="manual.ru_toc.html#Tcl">8.8  Интерфейсы Tcl API для MySQL</A></H2>

<P>
<A NAME="IDX1685"></A>

</P>
<P>
MySQLtcl - это простой API для доступа к базам данным MySQL при помощи Tcl. Вы
можете найти его здесь: <a HREF="http://www.xdobry.de/mysqltcl/">http://www.xdobry.de/mysqltcl/</a>. 

</P>


<H2><A NAME="Eiffel" HREF="manual.ru_toc.html#Eiffel">8.9  Оболочка Eiffel для MySQL</A></H2>

<P>
<A NAME="IDX1686"></A>

</P>
<P>
Eiffel MySQL - это интерфейс к базам данным MySQL для языка 
Eiffel, написанный Майклом Рэвитсом (Michael Ravits). Вы можете найти его здесь:
<a HREF="http://efsa.sourceforge.net/archive/ravits/mysql.htm">http://efsa.sourceforge.net/archive/ravits/mysql.htm</a>. 

</P>
<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_Table_types.html">previous</A>, <A HREF="manual.ru_Extending_MySQL.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
