  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - 6  Справочник по языку MySQL</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_MySQL_Optimisation.html">previous</A>, <A HREF="manual.ru_Table_types.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Reference" HREF="manual.ru_toc.html#Reference">6  Справочник по языку MySQL</A></H1>

<P>
MySQL имеет очень сложный, но интуитивно понятный и легкий в изучении интерфейс,
основанный на SQL (структурированный язык запросов). В данном разделе
описываются различные команды, типы данных и функции этого языка, которые
необходимо знать, чтобы использовать MySQL рационально и эффективно. Данная
глава служит также справочником по всем функциональным возможностям,
реализованным в MySQL. Читатель найдет в этой главе ссылки на различные
источники информации, которые, возможно, будут полезными для ее эффективного
использования.

</P>



<H2><A NAME="Language_Structure" HREF="manual.ru_toc.html#Language_Structure">6.1  Структура языка</A></H2>



<H3><A NAME="Literals" HREF="manual.ru_toc.html#Literals">6.1.1  Литералы: представление строк и чисел</A></H3>

<P>
<A NAME="IDX941"></A>
<A NAME="IDX942"></A>
<A NAME="IDX943"></A>
<A NAME="IDX944"></A>

</P>

<P>
В этом разделе описываются различные способы представления строк и чисел в
MySQL. Здесь затронуты также различные нюансы и особенности, с которыми
могут столкнуться программисты при работе с этими базовыми типами данных в
MySQL.

</P>


<H4><A NAME="String_syntax" HREF="manual.ru_toc.html#String_syntax">6.1.1.1  Cтроки</A></H4>

<P>
Строка представляет собой последовательность символов, заключенных либо в
одинарные кавычки (<samp>`''</samp>) - апострофы, либо в двойные кавычки (<samp>`"'</samp>). При
использовании диалекта ANSI SQL допустимы только одинарные кавычки.
Например:

</P>

<pre>
'a string'
"another string"
</pre>

<P>
Внутри строки некоторые последовательности символов имеют специальное
назначение. Каждая из этих последовательностей начинается обратным слешем
(<samp>`\'</samp>), известным как escape-символ или символ перехода.  MySQL распознает
следующие escape-последовательности:

</P>
<DL COMPACT>

<DT><code>\0</code>
<DD>
<A NAME="IDX945"></A>
 <A NAME="IDX946"></A>
 
Символ 0 (<code>NUL</code>) в ASCII коде.

<A NAME="IDX947"></A>
<A NAME="IDX948"></A>
<DT><code>\'</code>
<DD>
Символ одиночной кавычки (<samp>`''</samp>).

<A NAME="IDX949"></A>
<A NAME="IDX950"></A>
<DT><code>\"</code>
<DD>
Символ двойной кавычки (<samp>`"'</samp>).

<A NAME="IDX951"></A>
<DT><code>\b</code>
<DD>
Возврат на один символ.

<A NAME="IDX952"></A>
<DT><code>\n</code>
<DD>
Символ новой строки (перевода строки).

<A NAME="IDX953"></A>
<DT><code>\r</code>
<DD>
Символ перевода каретки.

<A NAME="IDX954"></A>
<A NAME="IDX955"></A>
<DT><code>\t</code>
<DD>
Символ  табуляции.

<A NAME="IDX956"></A>
<A NAME="IDX957"></A>
<DT><code>\z</code>
<DD>
Символ (Control-Z) таблицы ASCII(26). Данный символ можно закодировать,
чтобы обойти проблему, заключающуюся в том, что под Windows ASCII(26)
означает конец файла (проблемы возникают при использовании ASCII(26) в
выражении <code>mysql database &#60; filename)</code>.

<A NAME="IDX958"></A>
<DT><code>\\</code>
<DD>
Символ обратного слеша.

<A NAME="IDX959"></A>
<DT><code>\%</code>
<DD>
Символ процентов <samp>`%'</samp>. Используется для поиска копий литерала <samp>`%'</samp> в
контекстах, где выражение <samp>`%'</samp> в противном случае интерпретировалось бы как
групповой символ (see section <A HREF="manual.ru_Reference.html#String_comparison_functions">6.3.2.1  Функции сравнения строк</A>).

<A NAME="IDX960"></A>
<DT><code>\<samp>`_'</samp></code>
<DD>
Символ  подчеркивания  <samp>`_'</samp>. Используется для поиска копий литерала <samp>`_'</samp> в
контекстах, где выражение <samp>`_'</samp> в противном случае интерпретировалось бы как
групповой символ (see section <A HREF="manual.ru_Reference.html#String_comparison_functions">6.3.2.1  Функции сравнения строк</A>).
</DL>

<P>
Обратите внимание на то, что при использовании <samp>`\%'</samp> или <samp>`\_'</samp> в контекстах
некоторых строк будут возвращаться значения строк <samp>`\%'</samp> и <samp>`\_'</samp>, а не <samp>`%'</samp> и
<samp>`_'</samp>.

</P>
<P>
Существует несколько способов включить кавычки в строку:

</P>

<ul>
<LI>

Одиночная кавычка (апостроф) <samp>`''</samp> внутри строки, заключенной в кавычки
<samp>`''</samp>, может быть записана как <samp>`'''</samp>.

<LI>

Двойная кавычка <samp>`"'</samp> внутри строки, заключенной в двойные кавычки <samp>`"'</samp>,
может быть записана как <samp>`""'</samp>.

<LI>

Можно предварить символ кавычки символом экранирования (<samp>`\'</samp>).

<LI>

Для символа <samp>`''</samp> внутри строки, заключенной в двойные кавычки,
не требуется специальной обработки; его также не требуется дублировать
или предварять обратным слешем. Точно так же не требует специальной
обработки двойная кавычка <samp>`"'</samp> внутри строки, заключенной в одиночные
кавычки <samp>`''</samp>.
</ul>

<P>
Ниже показаны возможные варианты применения кавычек и escape-символа на
примерах выполнения команды SELECT:

</P>

<pre>
mysql&#62; SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+

mysql&#62; SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql&#62; SELECT "This\nIs\nFour\nlines";
+--------------------+
| This
Is
Four
lines |
+--------------------+
</pre>

<P>
<A NAME="IDX961"></A>

</P>
<P>
Если необходимо вставить в строку двоичные данные (такие как <code>BLOB</code>),
следующие символы должны быть представлены как escape-последовательности:

</P>
<DL COMPACT>

<DT><code>NUL</code>
<DD>
ASCII 0. Необходимо представлять в виде <samp>`\0'</samp> (обратный слеш и символ ASCII
<samp>`0'</samp>).

<DT><code>\</code>
<DD>
ASCII 92, обратный слеш. Представляется как <samp>`\\'</samp>.

<DT><code>'</code>
<DD>
ASCII 39, единичная кавычка. Представляется как <samp>`\''</samp>.

<DT><code>"</code>
<DD>
ASCII 34, двойная кавычка. Представляется как <samp>`\"'</samp>.
</DL>

<P>
При написании программы на языке C для добавления символов экранирования в
команде <code>INSERT</code> можно использовать функцию <code>mysql_real_escape_string()</code> из C
API (see section <A HREF="manual.ru_Clients.html#C_API_function_overview">8.4.2  Обзор функций интерфейса C</A>). При программировании на Perl
можно использовать метод <code>quote</code> из пакета DBI для превращения специальных
символов в соответствующие escape-последовательности (see section <A HREF="manual.ru_Clients.html#Perl_DBI_Class">8.2.2  Интерфейс <code>DBI</code></A>).

</P>
<P>
Не следует забывать, что указанное свойство escape-символа должно
использоваться во всех строках, которые могут содержать любые специальные
символы, перечисленные выше.

</P>
<P>
В качестве альтернативы многие интерфейсы прикладного программирования
(API) для MySQL предоставляют определенную возможность использования
символов-заменителей, что позволяет вносить специальные маркеры в строку
запроса и затем связывать с ними значения данных при выдаче результатов
запроса.

</P>


<H4><A NAME="Number_syntax" HREF="manual.ru_toc.html#Number_syntax">6.1.1.2  Числа</A></H4>

<P>
<A NAME="IDX962"></A>
<A NAME="IDX963"></A>
<A NAME="IDX964"></A>
<A NAME="IDX965"></A>
<A NAME="IDX966"></A>

</P>
<P>
Целые числа представляются в виде последовательности цифр. Для чисел с
плавающей точкой в качестве разделителя десятичных знаков используется
символ <samp>`.'</samp>. Числа обоих типов могут предваряться символом  <samp>`-'</samp>,
обозначающим отрицательную величину.

</P>
<P>
Примеры допустимых целых чисел:

</P>

<pre>
1221
0
-32
</pre>

<P>
Примеры  допустимых  чисел с плавающей запятой:

</P>

<pre>
294.42
-32032.6809e+10
148.00
</pre>

<P>
Целое число можно использовать в контексте дробных чисел, при этом оно
будет интерпретироваться как эквивалент числа с плавающей запятой.

</P>


<H4><A NAME="Hexadecimal_values" HREF="manual.ru_toc.html#Hexadecimal_values">6.1.1.3  Шестнадцатеричные величины</A></H4>

<P>
<A NAME="IDX967"></A>

</P>
<P>
MySQL поддерживает шестнадцатеричные величины.  В числовом контексте такое
число обладает всеми свойствами целого числа с 64-разрядной точностью. В
строковом контексте шестнадцатеричная величина представляет собой двоичную
строку, в которой каждая пара шестнадцатеричных разрядов конвертируется в
символ:

</P>


<pre>
mysql&#62; SELECT x'4D7953514C';
         -&#62; MySQL
mysql&#62; SELECT 0xa+0;
         -&#62; 10
mysql&#62; SELECT 0x5061756c;
         -&#62; Paul
</pre>

<P>
Синтаксис выражений вида <code>x'hexstring'</code> (новшество в версии 4.0) базируется
на ANSI SQL, а для обозначений вида <code>0x</code> используется синтаксис ODBC.
Шестнадцатеричные строки часто применяются в ODBC для представления
двоичных типов данных вида <code>BLOB</code>. Для конвертирования строки или числа в
шестнадцатеричный вид можно применять функцию <code>HEX()</code>.

</P>


<H4><A NAME="NULL_values" HREF="manual.ru_toc.html#NULL_values">6.1.1.4  Значения <code>NULL</code></A></H4>

<P>
<A NAME="IDX968"></A>

</P>
<P>
Значение <code>NULL</code> означает ``отсутствие данных''. Они является отличным от
значения 0 для числовых типов данных или пустой строки для строковых типов
(see section <A HREF="manual.ru_Problems.html#Problems_with_NULL">A.5.3  Проблемы со значением <code>NULL</code></A>).

</P>
<P>
При использовании форматов импорта или экспорта текстовых файлов (<code>LOAD
DATA INFILE, SELECT ... INTO OUTFILE</code>) <code>NULL</code> можно представить как <code>\N</code> 
(see section <A HREF="manual.ru_Reference.html#LOAD_DATA">6.4.9  Синтаксис оператора  <code>LOAD DATA INFILE</code></A>).

</P>


<H3><A NAME="Legal_names" HREF="manual.ru_toc.html#Legal_names">6.1.2  Имена баз данных, таблиц, столбцов, индексы псевдонимы</A></H3>

<P>
<A NAME="IDX969"></A>
<A NAME="IDX970"></A>
<A NAME="IDX971"></A>
<A NAME="IDX972"></A>
<A NAME="IDX973"></A>
<A NAME="IDX974"></A>
<A NAME="IDX975"></A>

</P>
<P>
Для всех имен баз данных, таблиц, столбцов, индексов и псевдонимов в MySQL
приняты одни и те же правила.

</P>
<P>
<A NAME="IDX976"></A>
<A NAME="IDX977"></A>
<A NAME="IDX978"></A>
<A NAME="IDX979"></A>

</P>
<P>
Следует отметить, что эти правила были изменены, начиная с версии MySQL
3.23.6, когда было разрешено брать в одиночные скобки <samp>``'</samp> идентификаторы
(имена баз данных, таблиц и столбцов). Двойные скобки <samp>`"'</samp> тоже допустимы -
при работе в режиме ANSI SQL (see section <A HREF="manual.ru_Introduction.html#ANSI_mode">1.9.2  Запуск MySQL в режиме ANSI</A>).

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Идентификатор</strong> </TD><TD> <strong>Максимальная длина строки</strong> </TD><TD> <strong>Допускаемые символы</strong>
</TD></TR>
<TR><TD>База данных </TD><TD> 64 </TD><TD> Любой символ, допустимый в имени  каталога, за исключением <samp>`/'</samp>, <samp>`\'</samp> или
<samp>`.'</samp> 
</TD></TR>
<TR><TD>Таблица </TD><TD> 64 </TD><TD> Любой символ, допустимый в имени  файла, за исключением <samp>`/'</samp> или <samp>`.'</samp>
</TD></TR>
<TR><TD>Столбец </TD><TD> 64 </TD><TD> Все символы
</TD></TR>
<TR><TD>Псевдоним </TD><TD> 255 </TD><TD> Все символы
</TD></TR>
</TABLE>

<P>
Необходимо также учитывать, что не следует использовать символы <code>ASCII(0)</code>,
<code>ASCII(255)</code> или кавычки в самом идентификаторе.

</P>
<P>
Кроме того, если имя идентификатора относится к служебным словам или
содержит специальные символы, необходимо всегда заключать его в обратные
кавычки <code>`</code> при использовании в выражениях:

</P>

<pre>
mysql&#62; SELECT * FROM `select` WHERE `select`.id &#62; 100;
</pre>

<P>
See section <A HREF="manual.ru_Reference.html#Reserved_words">6.1.7  ``Придирчив'' ли MySQL к зарезервированным словам?</A>.

</P>
<P>
В предыдущих версиях MySQL (до 3.23.6) для имен существовали следующие правила:

</P>

<ul>
<LI>

 Имя может состоять из буквенно-цифровых символов установленного в
данное время алфавита и символов <samp>`_'</samp> and <samp>`$'</samp>. Тип кодировки по
умолчанию - ISO-8859-1 Latin1, он может быть изменен указанием иного
типа в аргументе параметра <code>--default-character-set</code> <code>mysqld</code> 
(see section <A HREF="manual.ru_MySQL_Database_Administration.html#Character_sets">4.6.1  Набор символов, применяющийся для записи данных и сортировки</A>).

<LI>

Имя может начинаться с любого допустимого символа, в частности, с
цифры (в этом состоит отличие от правил, принятых во многих других
базах данных). Однако имя не может состоять только из цифр.

<LI>

Не допускается использование в именах символа <samp>`.'</samp>, так как он
применяется для расширения формата имени (посредством чего можно
ссылаться на столбцы - см. в этом же разделе ниже).
</ul>

<P>
Не рекомендуется использовать имена, подобные <code>1e</code>, так как выражение
вида <code>1e+1</code> является неоднозначным. Оно может интерпретироваться и как
выражение <code>1e + 1</code>, и как число <code>1e+1</code>.

</P>
<P>
В MySQL разрешается делать ссылки на столбец, используя любую из следующих
форм:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Ссылка на столбец</strong> </TD><TD> <strong>Значение</strong>
</TD></TR>
<TR><TD><code>col_name</code> </TD><TD> Столбец <code>col_name</code> из любой используемой в запросе таблицы содержит столбец с данным именем.
</TD></TR>
<TR><TD><code>tbl_name.col_name</code> </TD><TD> Столбец <code>col_name</code> из таблицы <code>tbl_name</code> текущей базы данных.
</TD></TR>
<TR><TD><code>db_name.tbl_name.col_name</code> </TD><TD> Столбец  <code>col_name</code>  из  таблицы  <code>tbl_name</code>  базы   данных  <code>db_name</code>. Эта форма доступна в версии MySQL 3.22 или более поздних.
</TD></TR>
<TR><TD><code>`column_name`</code> </TD><TD> Имя столбца является ключевым словом или содержит специальные символы.
</TD></TR>
</TABLE>

<P>
Нет необходимости указывать префикс <code>tbl_name</code> или <code>db_name.tbl_name</code> в ссылке
на столбец в каком-либо утверждении, если эта ссылка не будет
неоднозначной. Например, предположим, что каждая из таблиц <code>t1</code> и <code>t2</code>
содержит столбец <code>c</code>, по которому производится выборка командой <code>SELECT</code>,
использующей обе таблицы - и <code>t1</code>, и  <code>t2</code>. В этом случае имя <code>столбца</code> c
является неоднозначным, так как оно не уникально для таблиц, указанных в
команде, поэтому необходимо уточнить, какая именно таблица имеется в виду,
конкретизировав - <code>t1.c</code> или <code>t2.c</code>. Аналогично, при выборке данных из таблицы
<code>t</code> в базе данных <code>db1</code> и из таблицы <code>t</code> в базе данных <code>db2</code> необходимо ссылаться
на столбцы в этих таблицах как на <code>db1.t.col_name</code> и <code>db2.t.col_name</code>.

</P>
<P>
Выражение <code>.tbl_name</code> означает таблицу <code>tbl_name</code> в текущей базе данных.
Данный синтаксис принят для совместимости с ODBC, так как некоторые
программы ODBC ставят в начале имен таблиц в качестве префикса символ <samp>`.'</samp>.

</P>


<H3><A NAME="Name_case_sensitivity" HREF="manual.ru_toc.html#Name_case_sensitivity">6.1.3  Чувствительность имен к регистру</A></H3>

<P>
<A NAME="IDX980"></A>
<A NAME="IDX981"></A>
<A NAME="IDX982"></A>
<A NAME="IDX983"></A>
<A NAME="IDX984"></A>
<A NAME="IDX985"></A>

</P>
<P>
В MySQL имена баз данных и таблиц соответствуют директориям и файлам
внутри директорий. Следовательно, чувствительность к регистру операционной
системы, под которой работает MySQL, определяет чувствительность к
регистру имен баз данных и таблиц. Это означает, что имена баз данных и
таблиц нечувствительны к регистру под Windows, а под большинством версий
Unix проявляют чувствительность к регистру.
Одно большое исключение здесь это Mac OS X, когда файловая система по умолчанию HFS+ используется.
Однако Mac OS X также поддерживает тома UFS, которые чувствительны к регистру
под Mac OS X также как и на Unix.  See section <A HREF="manual.ru_Introduction.html#Extensions_to_ANSI">1.9.3  Расширения MySQL к ANSI SQL92</A>.

</P>
<P>
Примечание: хотя имена баз данных и таблиц нечувствительны к регистру под
Windows, не следует ссылаться на конкретную базу данных или таблицу,
используя различные регистры символов внутри одного и того же запроса.
Приведенный ниже запрос не будет выполнен, поскольку в нем одна и та же
таблица указана и как <code>my_table</code>, и как <code>MY_TABLE</code>:

</P>

<pre>
mysql&#62; SELECT * FROM my_table WHERE MY_TABLE.col=1;
</pre>

<P>
Имена и псевдонимы столбцов нечувствительны к регистру во всех случаях.

</P>
<P>
Псевдонимы таблиц обладают чувствительностью к регистру. Приведенный ниже
запрос не будет выполнен, поскольку он ссылается на псевдоним и как на <code>a</code>,
и как на <code>A</code>:

</P>

<pre>
mysql&#62; SELECT col_name FROM tbl_name AS a
    -&#62; WHERE a.col_name = 1 OR A.col_name = 2;
</pre>

<P>
Если вы не хотите держать в памяти размер букв для имен базы данных и
таблиц, при создании базы данных и таблиц придерживайтесь
последовательного принципа, используя для имен только строчные буквы.

</P>
<P>
Одним из путей устранения этой проблемы является запуск демона <code>mysqld</code> с
параметром <code>-O lower_case_table_names=1</code>. По умолчанию этот параметр имеет
значение 1 для Windows и 0 для Unix.

</P>
<P>
Если значение параметра <code>lower_case_table_names</code> равно 1, MySQL при
сохранении и поиске  будет преобразовывать все имена таблиц к нижнему регистру.
С версии 4.0.2 это также касается и имен баз данных. Обратите внимание на то,
что при изменении этого параметра перед запуском <code>mysqld</code> необходимо
прежде всего преобразовать имена всех старых таблиц к нижнему регистру.

</P>
<P>
При переносе <code>MyISAM</code>-файлов с Windows на диск в Unix в некоторых случаях
будет полезна утилита <code>mysql_fix_extensions</code> для приведения в соответствие
регистров расширений файлов в каждой указанной директории базы данных (нижний
регистр <tt>`.frm'</tt>, верхний регистр <tt>`.MYI'</tt> и <tt>`.MYD'</tt>). Утилиту
<code>mysql_fix_extensions</code> можно найти в подкаталоге <tt>`scripts'</tt>.

</P>


<H3><A NAME="Variables" HREF="manual.ru_toc.html#Variables">6.1.4  Переменные пользователя</A></H3>

<P>
<A NAME="IDX986"></A>
<A NAME="IDX987"></A>
<A NAME="IDX988"></A>

</P>
<P>
Для конкретного процесса пользователь может определить локальные
переменные, которые в MySQL обозначаются как <code>@variablename</code>. Имя локальной
переменной может состоять из буквенно-цифровых символов установленного в
данное время алфавита и символов <samp>`_'</samp>, <samp>`$'</samp>, and <samp>`.'</samp>. Тип кодировки по
умолчанию - ISO-8859-1 Latin1, он может быть изменен указанием иного типа
в аргументе параметра <code>--default-character-set</code> <code>mysqld</code> 
(see section <A HREF="manual.ru_MySQL_Database_Administration.html#Character_sets">4.6.1  Набор символов, применяющийся для записи данных и сортировки</A>).

</P>
<P>
Локальные переменные не требуют инициализации. Они содержат значение <code>NULL</code>
по умолчанию; в них могут храниться целые числа, вещественные числа или
строковые величины. При запуске конкретного процесса все объявленные в нем
локальные переменные автоматически активизируются.

</P>
<P>
Локальную переменную можно объявить, используя синтаксис команды <code>SET</code>:

</P>

<pre>
SET @variable= { integer expression | real expression | string expression }
[,@variable= ...].
</pre>

<P>
Можно также определить значение переменной иным способом, без команды <code>SET</code>.
Однако в этом случае в качестве оператора присвоения более предпочтительно
использовать оператор <samp>`:='</samp>, чем оператор <samp>`='</samp>, так как последний
зарезервирован для сравнения выражений, не связанных с установкой
переменных:

</P>

<pre>
mysql&#62; SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;
+----------------------+------+------+------+
| @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |
+----------------------+------+------+------+
|                    5 |    5 |    1 |    4 |
+----------------------+------+------+------+
</pre>

<P>
Введенные пользователем переменные могут применяться только в составе
выражений и там, где выражения допустимы. Заметим, что в область их
применения в данное время не включается контекст, в котором явно требуется
число, например, условие <code>LIMIT</code> в команде <code>SELECT</code> или выражение  <code>IGNORE
number LINES</code> в команде <code>LOAD DATA</code>.

</P>
<P>
Примечание: в команде <code>SELECT</code> каждое выражение оценивается только при
отправлении клиенту. Это означает, что в условиях <code>HAVING</code>, <code>GROUP BY</code>, or
<code>ORDER BY</code> не следует ссылаться на  выражение, содержащее переменные,
которые введены в части <code>SELECT</code> этой команды. Например, следующая команда
НЕ будет выполняться так, как ожидалось:

</P>

<pre>
mysql&#62; SELECT (@aa:=id) AS a, (@aa+3) AS b FROM table_name HAVING b=5;
</pre>

<P>
Причина в том, что переменная <code>@aa</code> не будет содержать значения текущей
строки, в то время как значение <code>id</code> в предыдущем выражении является
строкой.

</P>
<P>
Действует правило никогда не создавать <code>и не использовать</code> одну и ту же переменную в одном
и том же выражении SQL.

</P>


<H3><A NAME="System_Variables" HREF="manual.ru_toc.html#System_Variables">6.1.5  Системные переменные</A></H3>

<P>
<A NAME="IDX989"></A>
<A NAME="IDX990"></A>

</P>
<P>
Начиная с MySQL 4.0.3 мы предоставляем лучший доступ к большинству системных переменных и 
переменных, относящихся к соединению. Можно менять теперь большую часть переменных без необходимости
останавливать сервер. 

</P>
<P>
Есть два типа системных переменных: специфичные для потока (или для соединения;
мы их в дальнейшем называем потоковыми переменными для краткости), которые
уникальны для данного соединения и глобальные перемененные, которые
предназначаются для управления глобальными событиями. Глобальные переменные
также используются для того, чтобы установить значения по умолчанию для
соответствующих потоковых переменных для новых соединений. 

</P>
<P>
Когда <code>mysqld</code> запускается, все глобальные переменные инициализируются из командной строки
и файлов опций. Вы можете изменять значения с помощью <code>SET GLOBAL</code>. Когда новый поток создается, 
потоковые переменные инициализируются из глобальных и они не меняются даже если вы даете новую 
команду <code>SET GLOBAL</code>.

</P>
<P>
Для установки глобальной переменной, используйте один из таких синтаксисов: 
(Здесь используется <code>sort_buffer_size</code> в качестве примера)

</P>

<pre>
SET GLOBAL sort_buffer_size=value;
SET @@global.sort_buffer_size=value;
</pre>

<P>
Чтобы установить значение для потоковой переменной, используйте такие синтаксисы: 

</P>

<pre>
SET SESSION sort_buffer_size=value;
SET @@session.sort_buffer_size=value;
SET sort_buffer_size=value;
</pre>

<P>
Если вы не указываете режим, то тогда подразумевается <code>SESSION</code>.
See section <A HREF="manual.ru_MySQL_Optimisation.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A>.

</P>
<P>
<code>LOCAL</code> - синоним для <code>SESSION</code>.

</P>
<P>
Для получения значения глобальной переменной используйте одну из этих команд: 

</P>

<pre>
SELECT @@global.sort_buffer_size;
SHOW GLOBAL VARIABLES like 'sort_buffer_size';
</pre>

<P>
Для получения значения потоковой переменной используйте одну из этих команд: 

</P>

<pre>
SELECT @@session.sort_buffer_size;
SHOW SESSION VARIABLES like 'sort_buffer_size';
</pre>

<P>
Когда вы запрашиваете значение переменной с помощью синтаксиса
<code>@@variable_name</code> и не укзываете <code>GLOBAL</code> или <code>SESSION</code>, то
тогда MySQL вернет потоковое значение этой переменное, если таковое существует.
Если нет, то MySQL вернет глобальное значение. 

</P>
<P>
Причина, по которой требуется указывать <code>GLOBAL</code> для установки только глобальных 
переменных но не для получения их значения, заключается в том, чтобы
удостовериться, что если мы в будущем не будем иметь проблем, если добавим 
потоковую переменную с таким же именем или уберем некую потоковую переменную. 
В этом случае вы можете ненароком изменить состояние сервера в целом, а не 
исключительно вашего соединения. 

</P>
<P>
Далее идет полный список всех переменных которые вы можете изменять и значения
которых можете получать, а также информация о том, можете ли вы использовать
<code>SESSION</code> или <code>GLOBAL</code> с ними. 

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Переменная</strong> </TD><TD> <strong>Тип значения</strong> </TD><TD> <strong>Тип</strong>
</TD></TR>
<TR><TD>autocommit </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>big_tables </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>binlog_cache_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>bulk_insert_buffer_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>concurrent_insert </TD><TD> булевое </TD><TD> GLOBAL
</TD></TR>
<TR><TD>connect_timeout </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>convert_character_set </TD><TD> строка </TD><TD> SESSION
</TD></TR>
<TR><TD>delay_key_write </TD><TD> OFF | ON | ALL </TD><TD> GLOBAL
</TD></TR>
<TR><TD>delayed_insert_limit </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>delayed_insert_timeout </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>delayed_queue_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>error_count </TD><TD> число </TD><TD> LOCAL
</TD></TR>
<TR><TD>flush </TD><TD> булевое </TD><TD> GLOBAL
</TD></TR>
<TR><TD>flush_time </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>foreign_key_checks </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>identity </TD><TD> число </TD><TD> SESSION
</TD></TR>
<TR><TD>insert_id </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>interactive_timeout </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>join_buffer_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>key_buffer_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>last_insert_id </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>local_infile </TD><TD> булевое </TD><TD> GLOBAL
</TD></TR>
<TR><TD>log_warnings </TD><TD> булевое </TD><TD> GLOBAL
</TD></TR>
<TR><TD>long_query_time </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>low_priority_updates </TD><TD> булевое </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>max_allowed_packet </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>max_binlog_cache_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_binlog_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_connect_errors </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_connections </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_error_count </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>max_delayed_threads </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_heap_table_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>max_join_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>max_sort_length </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>max_tmp_tables </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_user_connections </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>max_write_lock_count </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>myisam_max_extra_sort_file_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>myisam_max_sort_file_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>myisam_sort_buffer_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>net_buffer_length </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>net_read_timeout </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>net_retry_count </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>net_write_timeout </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>query_cache_limit </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>query_cache_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>query_cache_type </TD><TD> enum </TD><TD> GLOBAL
</TD></TR>
<TR><TD>read_buffer_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>read_rnd_buffer_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>rpl_recovery_rank </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>safe_show_database </TD><TD> булевое </TD><TD> GLOBAL
</TD></TR>
<TR><TD>server_id </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>slave_compressed_protocol </TD><TD> булевое </TD><TD> GLOBAL
</TD></TR>
<TR><TD>slave_net_timeout </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>slow_launch_time </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>sort_buffer_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>sql_auto_is_null </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_big_selects </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_big_tables </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_buffer_result </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_log_binlog </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_log_off </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_log_update </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_low_priority_updates </TD><TD> булевое </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>sql_max_join_size </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>sql_quote_show_create </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_safe_updates </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_select_limit </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>sql_slave_skip_counter </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>sql_warnings </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>table_cache </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>table_type </TD><TD> enum </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>thread_cache_size </TD><TD> число </TD><TD> GLOBAL
</TD></TR>
<TR><TD>timestamp </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
<TR><TD>tmp_table_size </TD><TD> enum </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>tx_isolation </TD><TD> enum </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>version </TD><TD> строка </TD><TD> GLOBAL
</TD></TR>
<TR><TD>wait_timeout </TD><TD> число </TD><TD> GLOBAL | SESSION
</TD></TR>
<TR><TD>warning_count </TD><TD> число </TD><TD> LOCAL
</TD></TR>
<TR><TD>unique_checks </TD><TD> булевое </TD><TD> SESSION
</TD></TR>
</TABLE>

<P>
Переменные, помеченные как <code>число</code> могут иметь числовое значение.
Переменные, помеченные как <code>булевое</code> могут быть установлены в <code>0</code>,
<code>1</code>, <code>ON</code> или <code>OFF</code>.  Переменные типа <code>enum</code> должны в общем
случае быть установлены в одно из возможных значений для переменной, но также
могут быть установлены в значение числа, соответствующего значению выбора enum.
Первый элемент списка enum - номер 0. 

</P>
<P>
Вот описание некоторых переменных: 

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Переменная</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>identity </TD><TD> Синоним для last_insert_id (совместимость с Sybase)
</TD></TR>
<TR><TD>sql_low_priority_updates </TD><TD> Синоним для low_priority_updates
</TD></TR>
<TR><TD>sql_max_join_size </TD><TD> Синоним для max_join_size
</TD></TR>
<TR><TD>delay_key_write_for_all_tables </TD><TD> Если это и delay_key_write установлены, то тогда все вновь открываемые таблицы MyISAM открываются с задержкой записи ключей.
</TD></TR>
<TR><TD>version </TD><TD> Синоним для VERSION() (совместимость (?) с Sybase)
</TD></TR>
</TABLE>

<P>
Описания других переменных можно найти в описании переменных запуска
<code>mysql</code>, в описании команды <code>SHOW VARIABLES</code> и в разделе <code>SET</code>.
See section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>.  See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>. See section <A HREF="manual.ru_MySQL_Optimisation.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A>.

</P>



<H3><A NAME="Comments" HREF="manual.ru_toc.html#Comments">6.1.6  Синтаксис  комментариев</A></H3>

<P>
<A NAME="IDX991"></A>

</P>
<P>
Сервер MySQL поддерживает следующие способы задания комментариев: с
помощью символа <samp>`#'</samp>, за которым следует текст комментария до конца строки; 
с помощью двух символов  <code>--</code>, за которыми идет текст комментария до конца
строки;  и (для многострочных комментариев) с помощью символов <code>/*</code> (начало
комментария) и <code>*/</code> (конец комментария):

</P>


<pre>
mysql&#62; SELECT 1+1;     # Этот комментарий продолжается до конца строки
mysql&#62; SELECT 1+1;     -- Этот комментарий продолжается до конца строки
mysql&#62; SELECT 1 /* Это комментарий в строке */ + 1;
mysql&#62; SELECT 1+
/*
Это многострочный
комментарий
*/
1;
</pre>

<P>
Обратите внимание: при использовании для комментирования способа с <code>--</code>
(двойное тире) требуется наличие хотя бы одного пробела после второго
тире!

</P>
<P>
Хотя сервер ``понимает'' все описанные выше варианты комментирования,
существует ряд ограничений на способ синтаксического анализа комментариев
вида <code>/* ... */</code>  клиентом  <code>mysql</code>:

</P>

<ul>
<LI>

Символы одинарной и двойной кавычек, даже внутри комментария,
считаются началом заключенной в кавычки строки. Если внутри
комментария не встречается вторая такая же кавычка, синтаксический
анализатор не считает комментарий законченным. При работе с <code>mysql</code> в
интерактивном режиме эта ошибка проявится в том, что окно запроса
изменит свое состояние с <code>mysql&#62;</code> на <code>'&#62;</code> или <code>"&#62;</code>.

<LI>

Точка с запятой используется для обозначения окончания данной
SQL-команды и что-либо, следующее за этим символом, указывает на
начало следующего выражения.
</ul>

<P>
Эти ограничения относятся как к интерактивному режиму работы <code>mysql</code> (из
командной строки), так и к вызову команд из файла, читаемого с ввода
командой <code>mysql &#60; some-file</code>.

</P>
<P>
MySQL поддерживает принятый в ANSI SQL способ комментирования с помощью
двойного тире <samp>`--'</samp> только в том случае, если после второго тире следует
пробел (see section <A HREF="manual.ru_Introduction.html#ANSI_diff_comments">1.9.4.7  Символы `--' как начало комментария</A>).

</P>


<H3><A NAME="Reserved_words" HREF="manual.ru_toc.html#Reserved_words">6.1.7  ``Придирчив'' ли MySQL к зарезервированным словам?</A></H3>

<P>
<A NAME="IDX992"></A>
<A NAME="IDX993"></A>
<A NAME="IDX994"></A>
<A NAME="IDX995"></A>

</P>
<P>
Это общая проблема, возникающая при попытке создать таблицу с именами
столбцов, использующих принятые в MySQL названия типов данных или функций,
такие как <code>TIMESTAMP</code> или <code>GROUP</code>. Иногда это возможно (например, <code>ABS</code> является
разрешенным именем для столбца), но не допускается пробел между именем
функции и сразу же следующей за ним скобкой <samp>`('</samp> при использовании имен
функций, совпадающих с именами столбцов.

</P>
<P>
Следующие слова являются зарезервированными в MySQL. Большинство из них не
допускаются в ANSI  SQL92 как имена столбцов и/или таблиц (например
GROUP). Некоторые зарезервированы для нужд MySQL и используются (в
настоящее время) синтаксическим анализатором <code>yacc</code>:

</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Word</strong>
 </TD><TD> <strong>Word</strong>
 </TD><TD> <strong>Word</strong>
</TD></TR>
<TR><TD><code>ADD</code>
 </TD><TD> <code>ALL</code>
 </TD><TD> <code>ALTER</code>
</TD></TR>
<TR><TD><code>ANALYZE</code>
 </TD><TD> <code>AND</code>
 </TD><TD> <code>AS</code>
</TD></TR>
<TR><TD><code>ASC</code>
 </TD><TD> <code>ASENSITIVE</code>
 </TD><TD> <code>AUTO_INCREMENT</code>
</TD></TR>
<TR><TD><code>BDB</code>
 </TD><TD> <code>BEFORE</code>
 </TD><TD> <code>BERKELEYDB</code>
</TD></TR>
<TR><TD><code>BETWEEN</code>
 </TD><TD> <code>BIGINT</code>
 </TD><TD> <code>BINARY</code>
</TD></TR>
<TR><TD><code>BLOB</code>
 </TD><TD> <code>BOTH</code>
 </TD><TD> <code>BTREE</code>
</TD></TR>
<TR><TD><code>BY</code>
 </TD><TD> <code>CALL</code>
 </TD><TD> <code>CASCADE</code>
</TD></TR>
<TR><TD><code>CASE</code>
 </TD><TD> <code>CHANGE</code>
 </TD><TD> <code>CHAR</code>
</TD></TR>
<TR><TD><code>CHARACTER</code>
 </TD><TD> <code>CHECK</code>
 </TD><TD> <code>COLLATE</code>
</TD></TR>
<TR><TD><code>COLUMN</code>
 </TD><TD> <code>COLUMNS</code>
 </TD><TD> <code>CONNECTION</code>
</TD></TR>
<TR><TD><code>CONSTRAINT</code>
 </TD><TD> <code>CREATE</code>
 </TD><TD> <code>CROSS</code>
</TD></TR>
<TR><TD><code>CURRENT_DATE</code>
 </TD><TD> <code>CURRENT_TIME</code>
 </TD><TD> <code>CURRENT_TIMESTAMP</code>
</TD></TR>
<TR><TD><code>CURSOR</code>
 </TD><TD> <code>DATABASE</code>
 </TD><TD> <code>DATABASES</code>
</TD></TR>
<TR><TD><code>DAY_HOUR</code>
 </TD><TD> <code>DAY_MINUTE</code>
 </TD><TD> <code>DAY_SECOND</code>
</TD></TR>
<TR><TD><code>DEC</code>
 </TD><TD> <code>DECIMAL</code>
 </TD><TD> <code>DECLARE</code>
</TD></TR>
<TR><TD><code>DEFAULT</code>
 </TD><TD> <code>DELAYED</code>
 </TD><TD> <code>DELETE</code>
</TD></TR>
<TR><TD><code>DESC</code>
 </TD><TD> <code>DESCRIBE</code>
 </TD><TD> <code>DISTINCT</code>
</TD></TR>
<TR><TD><code>DISTINCTROW</code>
 </TD><TD> <code>DIV</code>
 </TD><TD> <code>DOUBLE</code>
</TD></TR>
<TR><TD><code>DROP</code>
 </TD><TD> <code>ELSE</code>
 </TD><TD> <code>ELSEIF</code>
</TD></TR>
<TR><TD><code>ENCLOSED</code>
 </TD><TD> <code>ERRORS</code>
 </TD><TD> <code>ESCAPED</code>
</TD></TR>
<TR><TD><code>EXISTS</code>
 </TD><TD> <code>EXPLAIN</code>
 </TD><TD> <code>FALSE</code>
</TD></TR>
<TR><TD><code>FIELDS</code>
 </TD><TD> <code>FLOAT</code>
 </TD><TD> <code>FOR</code>
</TD></TR>
<TR><TD><code>FORCE</code>
 </TD><TD> <code>FOREIGN</code>
 </TD><TD> <code>FROM</code>
</TD></TR>
<TR><TD><code>FULLTEXT</code>
 </TD><TD> <code>GRANT</code>
 </TD><TD> <code>GROUP</code>
</TD></TR>
<TR><TD><code>HASH</code>
 </TD><TD> <code>HAVING</code>
 </TD><TD> <code>HIGH_PRIORITY</code>
</TD></TR>
<TR><TD><code>HOUR_MINUTE</code>
 </TD><TD> <code>HOUR_SECOND</code>
 </TD><TD> <code>IF</code>
</TD></TR>
<TR><TD><code>IGNORE</code>
 </TD><TD> <code>IN</code>
 </TD><TD> <code>INDEX</code>
</TD></TR>
<TR><TD><code>INFILE</code>
 </TD><TD> <code>INNER</code>
 </TD><TD> <code>INNODB</code>
</TD></TR>
<TR><TD><code>INOUT</code>
 </TD><TD> <code>INSENSITIVE</code>
 </TD><TD> <code>INSERT</code>
</TD></TR>
<TR><TD><code>INT</code>
 </TD><TD> <code>INTEGER</code>
 </TD><TD> <code>INTERVAL</code>
</TD></TR>
<TR><TD><code>INTO</code>
 </TD><TD> <code>IS</code>
 </TD><TD> <code>ITERATE</code>
</TD></TR>
<TR><TD><code>JOIN</code>
 </TD><TD> <code>KEY</code>
 </TD><TD> <code>KEYS</code>
</TD></TR>
<TR><TD><code>KILL</code>
 </TD><TD> <code>LEADING</code>
 </TD><TD> <code>LEAVE</code>
</TD></TR>
<TR><TD><code>LEFT</code>
 </TD><TD> <code>LIKE</code>
 </TD><TD> <code>LIMIT</code>
</TD></TR>
<TR><TD><code>LINES</code>
 </TD><TD> <code>LOAD</code>
 </TD><TD> <code>LOCALTIME</code>
</TD></TR>
<TR><TD><code>LOCALTIMESTAMP</code>
 </TD><TD> <code>LOCK</code>
 </TD><TD> <code>LONG</code>
</TD></TR>
<TR><TD><code>LONGBLOB</code>
 </TD><TD> <code>LONGTEXT</code>
 </TD><TD> <code>LOOP</code>
</TD></TR>
<TR><TD><code>LOW_PRIORITY</code>
 </TD><TD> <code>MASTER_SERVER_ID</code>
 </TD><TD> <code>MATCH</code>
</TD></TR>
<TR><TD><code>MEDIUMBLOB</code>
 </TD><TD> <code>MEDIUMINT</code>
 </TD><TD> <code>MEDIUMTEXT</code>
</TD></TR>
<TR><TD><code>MIDDLEINT</code>
 </TD><TD> <code>MINUTE_SECOND</code>
 </TD><TD> <code>MOD</code>
</TD></TR>
<TR><TD><code>MRG_MYISAM</code>
 </TD><TD> <code>NATURAL</code>
 </TD><TD> <code>NOT</code>
</TD></TR>
<TR><TD><code>NULL</code>
 </TD><TD> <code>NUMERIC</code>
 </TD><TD> <code>ON</code>
</TD></TR>
<TR><TD><code>OPTIMIZE</code>
 </TD><TD> <code>OPTION</code>
 </TD><TD> <code>OPTIONALLY</code>
</TD></TR>
<TR><TD><code>OR</code>
 </TD><TD> <code>ORDER</code>
 </TD><TD> <code>OUT</code>
</TD></TR>
<TR><TD><code>OUTER</code>
 </TD><TD> <code>OUTFILE</code>
 </TD><TD> <code>PRECISION</code>
</TD></TR>
<TR><TD><code>PRIMARY</code>
 </TD><TD> <code>PRIVILEGES</code>
 </TD><TD> <code>PROCEDURE</code>
</TD></TR>
<TR><TD><code>PURGE</code>
 </TD><TD> <code>READ</code>
 </TD><TD> <code>REAL</code>
</TD></TR>
<TR><TD><code>REFERENCES</code>
 </TD><TD> <code>REGEXP</code>
 </TD><TD> <code>RENAME</code>
</TD></TR>
<TR><TD><code>REPEAT</code>
 </TD><TD> <code>REPLACE</code>
 </TD><TD> <code>REQUIRE</code>
</TD></TR>
<TR><TD><code>RESTRICT</code>
 </TD><TD> <code>RETURN</code>
 </TD><TD> <code>RETURNS</code>
</TD></TR>
<TR><TD><code>REVOKE</code>
 </TD><TD> <code>RIGHT</code>
 </TD><TD> <code>RLIKE</code>
</TD></TR>
<TR><TD><code>RTREE</code>
 </TD><TD> <code>SELECT</code>
 </TD><TD> <code>SENSITIVE</code>
</TD></TR>
<TR><TD><code>SEPARATOR</code>
 </TD><TD> <code>SET</code>
 </TD><TD> <code>SHOW</code>
</TD></TR>
<TR><TD><code>SMALLINT</code>
 </TD><TD> <code>SOME</code>
 </TD><TD> <code>SONAME</code>
</TD></TR>
<TR><TD><code>SPATIAL</code>
 </TD><TD> <code>SPECIFIC</code>
 </TD><TD> <code>SQL_BIG_RESULT</code>
</TD></TR>
<TR><TD><code>SQL_CALC_FOUND_ROWS</code>
 </TD><TD> <code>SQL_SMALL_RESULT</code>
 </TD><TD> <code>SSL</code>
</TD></TR>
<TR><TD><code>STARTING</code>
 </TD><TD> <code>STRAIGHT_JOIN</code>
 </TD><TD> <code>STRIPED</code>
</TD></TR>
<TR><TD><code>TABLE</code>
 </TD><TD> <code>TABLES</code>
 </TD><TD> <code>TERMINATED</code>
</TD></TR>
<TR><TD><code>THEN</code>
 </TD><TD> <code>TINYBLOB</code>
 </TD><TD> <code>TINYINT</code>
</TD></TR>
<TR><TD><code>TINYTEXT</code>
 </TD><TD> <code>TO</code>
 </TD><TD> <code>TRAILING</code>
</TD></TR>
<TR><TD><code>TRUE</code>
 </TD><TD> <code>TYPES</code>
 </TD><TD> <code>UNION</code>
</TD></TR>
<TR><TD><code>UNIQUE</code>
 </TD><TD> <code>UNLOCK</code>
 </TD><TD> <code>UNSIGNED</code>
</TD></TR>
<TR><TD><code>UNTIL</code>
 </TD><TD> <code>UPDATE</code>
 </TD><TD> <code>USAGE</code>
</TD></TR>
<TR><TD><code>USE</code>
 </TD><TD> <code>USER_RESOURCES</code>
 </TD><TD> <code>USING</code>
</TD></TR>
<TR><TD><code>VALUES</code>
 </TD><TD> <code>VARBINARY</code>
 </TD><TD> <code>VARCHAR</code>
</TD></TR>
<TR><TD><code>VARCHARACTER</code>
 </TD><TD> <code>VARYING</code>
 </TD><TD> <code>WARNINGS</code>
</TD></TR>
<TR><TD><code>WHEN</code>
 </TD><TD> <code>WHERE</code>
 </TD><TD> <code>WHILE</code>
</TD></TR>
<TR><TD><code>WITH</code>
 </TD><TD> <code>WRITE</code>
 </TD><TD> <code>XOR</code>
</TD></TR>
<TR><TD><code>YEAR_MONTH</code>
 </TD><TD> <code>ZEROFILL</code>
 </TD><TD> </TD></TR>
</TABLE>

<P>
Следующие символы (из приведенной выше таблицы таблицы) не разрешены в
ANSI  SQL, но допускаются в MySQL как имена столбцов/таблиц. Это
объясняется тем, что некоторые из этих имен являются словами естественного
языка и уже использованы многими потребителями.

</P>


<ul>
<LI><code>ACTION</code>

<LI><code>BIT</code>

<LI><code>DATE</code>

<LI><code>ENUM</code>

<LI><code>NO</code>

<LI><code>TEXT</code>

<LI><code>TIME</code>

<LI><code>TIMESTAMP</code>

</ul>



<H2><A NAME="Column_types" HREF="manual.ru_toc.html#Column_types">6.2  Типы данных столбцов</A></H2>

<P>
<A NAME="IDX996"></A>
<A NAME="IDX997"></A>

</P>
<P>
MySQL поддерживает несколько типов столбцов, которые можно разделить на
три категории: числовые типы данных, типы данных для хранения даты и
времени и символьные (строковые) типы данных. В данном разделе вначале
дается обзор всех возможных типов и приводятся требования по хранению для
каждого типа столбца, затем свойства типов описываются более подробно по
каждой категории. Мы намеренно сделали обзор кратким, поскольку более
детальные описания требуют дополнительной информации о конкретных типах
столбцов, например, о допустимых форматах представления величин.

</P>
<P>
Ниже перечислены типы столбцов, поддерживаемые MySQL. В описаниях
используются следующие обозначения:

</P>
<P>
<A NAME="IDX998"></A>
<A NAME="IDX999"></A>
<A NAME="IDX1000"></A>
<A NAME="IDX1001"></A>
<A NAME="IDX1002"></A>
<A NAME="IDX1003"></A>

</P>
<DL COMPACT>

<DT><code>M</code>
<DD>
Указывает максимальный размер вывода. Максимально допустимый размер вывода
составляет 255 символов.

<DT><code>D</code>
<DD>
Употребляется для типов данных с плавающей точкой и указывает количество
разрядов, следующих за десятичной точкой. Максимально возможная величина
составляет 30 разрядов, но не может быть больше, чем <code>M</code>-2.
</DL>

<P>
Квадратные скобки (<samp>`['</samp> и <samp>`]'</samp>) указывают для типа данных группы
необязательных признаков.

</P>
<P>
<A NAME="IDX1004"></A>

</P>
<P>
Заметьте, что если для столбца указать параметр <code>ZEROFILL</code>, то MySQL будет
автоматически добавлять в этот столбец атрибут <code>UNSIGNED</code>.

</P>
<P>
<strong>Предупреждение:</strong> следует помнить, что при выполнении вычитания между
числовыми величинами, одна из которых относится к типу <code>UNSIGNED</code>, результат
будет беззнаковым! See section <A HREF="manual.ru_Reference.html#Cast_Functions">6.3.5  Функции приведения типов</A>.

</P>
<DL COMPACT>

<DT><code>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</code>
<DD>
<A NAME="IDX1005"></A>
 

Очень малое целое число. Диапазон со знаком от <code>-128</code> до <code>127</code>. Диапазон без
знака от <code>0</code> до <code>255</code>.

<A NAME="IDX1006"></A>
<A NAME="IDX1007"></A>
<DT><code>BIT</code>
<DD>
<DT><code>BOOL</code>
<DD>
Являются синонимами для <code>TINYINT(1)</code>.

<A NAME="IDX1008"></A>
<DT><code>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Малое целое число. Диапазон со знаком от <code>-32768</code> до <code>32767</code>. Диапазон без
знака от <code>0</code> до <code>65535</code>.

<A NAME="IDX1009"></A>
<DT><code>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Целое число среднего размера. Диапазон со знаком от <code>-8388608</code> до <code>8388607</code>.
Диапазон без знака от <code>0</code> до <code>16777215</code>.

<A NAME="IDX1010"></A>
<DT><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Целое число нормального размера. Диапазон со знаком от <code>-2147483648</code> до
<code>2147483647</code>. Диапазон без знака от <code>0</code> до <code>4294967295</code>.

<A NAME="IDX1011"></A>
<DT><code>INTEGER[(M)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Синоним для <code>INT</code>.

<A NAME="IDX1012"></A>
<DT><code>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Большое целое число. Диапазон со знаком от <code>-9223372036854775808</code> до
<code>9223372036854775807</code>. Диапазон без знака от 0 до <code>18446744073709551615</code>. Для
столбцов типа <code>BIGINT</code> необходимо учитывать некоторые особенности:


<ul>
<LI>

<A NAME="IDX1013"></A>
Все арифметические операции выполняются с использованием значений
<code>BIGINT</code> или <code>DOUBLE</code> со знаком, так что не следует использовать
беззнаковые целые числа больше чем <code>9223372036854775807</code> (63 бита),
кроме операций, выполняемых логическими функциями. В противном случае
несколько последних разрядов результата могут оказаться ошибочными
из-за ошибок округления при преобразовании <code>BIGINT</code> в <code>DOUBLE</code>. MySQL 4.0
может обрабатывать данные типа <code>BIGINT</code> в следующих случаях:


<ul>
<LI>

Использование целых чисел для хранения больших беззнаковых
величин в столбце с типом <code>BIGINT</code>.

<LI>

В случаях <code>MIN(big_int_column)</code> и <code>MAX(big_int_column)</code>.

<LI>

При использовании операторов (<samp>`+'</samp>, <samp>`-'</samp>, <samp>`*'</samp> и т.д.), когда оба операнда
являются целыми числами.
</ul>

<LI>

Точное значение целого числа всегда можно хранить в столбце с типом
<code>BIGINT</code> в виде строки. В этом случае MySQL выполнит преобразование
строки в число без промежуточного преобразования.

<LI>

Если оба аргумента являются целочисленными величинами, то при
выполнении над ними операций <samp>`-'</samp>, <samp>`+'</samp>, и <samp>`*'</samp> будут использоваться
правила <code>BIGINT</code>-арифметики. Это означает, что при умножении двух
больших целых чисел (или результатов вычислений функций, возвращающих
целые числа) результат операции может оказаться непредсказуемым, если
он превосходит значение <code>9223372036854775807</code>.
</ul>

<A NAME="IDX1014"></A>
<A NAME="IDX1015"></A>
<A NAME="IDX1016"></A>
<DT><code>FLOAT(точность) [UNSIGNED] [ZEROFILL]</code>
<DD>
Число с плавающей точкой. Атрибут точности может иметь значение <code>&#60;=24</code> для
числа с плавающей точкой обычной (одинарной) точности и между <code>25</code> и <code>53</code> -
для числа с плавающей точкой удвоенной точности. Эти типы данных сходны с
типами <code>FLOAT</code> и <code>DOUBLE</code>, описанными ниже. <code>FLOAT(X)</code> относится к тому же
интервалу, что и соответствующие типы <code>FLOAT</code> и <code>DOUBLE</code>, но диапазон значений
и количество десятичных знаков не определены.

В версии MySQL 3.23 это
истинная величина числа с плавающей точкой. В более ранних версиях MySQL
тип данных <code>FLOAT(точность)</code> всегда имеет два десятичных знака.

<A NAME="IDX1017"></A>
<A NAME="IDX1018"></A>
Следует
отметить, что использование типа данных <code>FLOAT</code> может привести к неожиданным
проблемам, так как все вычисления в MySQL выполняются с удвоенной
точностью. See section <A HREF="manual.ru_Problems.html#No_matching_rows">A.5.6  Решение проблем с отсутствием строк, удовлетворяющих условиям поиска</A>. Данный
синтаксис обеспечивает совместимость с ODBC.

<A NAME="IDX1019"></A>
<A NAME="IDX1020"></A>
<DT><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Малое число с плавающей точкой обычной точности. Допустимые значения: от
<code>-3,402823466E+38</code> до <code>-1,175494351E-38</code>, <code>0</code>, и от <code>1,175494351E-38</code> до
<code>3,402823466E+38</code>. Если указан атрибут <code>UNSIGNED</code>, отрицательные значения
недопустимы. Атрибут <code>M</code> указывает количество выводимых пользователю знаков,
а атрибут <code>D</code> - количество разрядов, следующих за десятичной точкой.
Обозначение <code>FLOAT</code> без указания аргументов или запись вида <code>FLOAT(X)</code>, где <code>X</code>
<code>&#60;=24</code> справедливы для числа с плавающей точкой обычной точности.

<A NAME="IDX1021"></A>
<A NAME="IDX1022"></A>
<DT><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Число с плавающей точкой удвоенной точности нормального размера.
Допустимые значения: от <code>-1,7976931348623157E+308</code> до
<code>-2,2250738585072014E-308</code>, <code>0</code>, и от <code>2,2250738585072014E-308</code> до
<code>1,7976931348623157E+308</code>. Если указан атрибут <code>UNSIGNED</code>, отрицательные
значения недопустимы. Атрибут <code>M</code> указывает количество выводимых
пользователю знаков, а атрибут <code>D</code> - количество разрядов, следующих за
десятичной точкой. Обозначение <code>DOUBLE</code> без указания аргументов или запись
вида <code>FLOAT(X)</code>, где <code>25 &#60;= X &#60;= 53</code> справедливы для числа с плавающей точкой
двойной точности.

<A NAME="IDX1023"></A>
<A NAME="IDX1024"></A>
<DT><code>DOUBLE PRECISION[(M,D)] [UNSIGNED] [ZEROFILL]</code>
<DD>
<DT><code>REAL[(M,D)] [UNSIGNED] [ZEROFILL]</code>
<DD>
Данные обозначения являются синонимами для <code>DOUBLE</code>.

<A NAME="IDX1025"></A>
<DT><code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code>
<DD>
``Неупакованное'' число с плавающей точкой. Ведет себя подобно столбцу
<code>CHAR</code>, содержащему цифровое значение. Термин ``неупакованное'' означает,
что число хранится в виде строки и при этом для каждого десятичного знака
используется один символ. Разделительный знак десятичных разрядов, а также
знак <samp>`-'</samp> для отрицательных чисел не учитываются в <code>M</code> (но место для них
зарезервировано). Если атрибут <code>D</code> равен <code>0</code>, величины будут представлены без
десятичного знака, т.е. без дробной части. Максимальный интервал значений
типа <code>DECIMAL</code> тот же, что и для типа <code>DOUBLE</code>, но действительный интервал для
конкретного столбца <code>DECIMAL</code> может быть ограничен выбором значений
атрибутов <code>M</code> и <code>D</code>. Если указан атрибут <code>UNSIGNED</code>, отрицательные значения
недопустимы. Если атрибут <code>D</code> не указан, его значение по умолчанию равно <code>0</code>.
Если не указан <code>M</code>, его значение по умолчанию равно <code>10</code>. В более ранних, чем
MySQL 3.23, версиях аргумент <code>M</code> должен содержать в себе место для знака
числа и десятичного знака.

<A NAME="IDX1026"></A>
<A NAME="IDX1027"></A>
<DT><code>DEC[(M[,D])] [UNSIGNED] [ZEROFILL]</code>
<DD>
<DT><code>NUMERIC[(M[,D])] [UNSIGNED] [ZEROFILL]</code>
<DD>
Данные обозначения являются синонимами для <code>DECIMAL</code>.

<A NAME="IDX1028"></A>
<DT><code>DATE</code>
<DD>
Дата. Поддерживается интервал от <code>'1000-01-01'</code> до <code>'9999-12-31'</code>. MySQL
выводит значения <code>DATE</code> в формате <code>'YYYY-MM-DD'</code>, но можно установить значения
в столбец <code>DATE</code>, используя как строки, так и числа. See section <A HREF="manual.ru_Reference.html#DATETIME">6.2.2.2  Типы данных <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code></A>.

<A NAME="IDX1029"></A>
<DT><code>DATETIME</code>
<DD>
Комбинация даты и времени. Поддерживается интервал от <code>'1000-01-01 00:00:00'</code> 
до <code>'9999-12-31 23:59:59'</code>. MySQL выводит значения <code>DATETIME</code>  в
формате <code>'YYYY-MM-DD HH:MM:SS'</code>, но можно устанавливать значения в столбце 
<code>DATETIME</code>, используя как строки, так и числа. See section <A HREF="manual.ru_Reference.html#DATETIME">6.2.2.2  Типы данных <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code></A>.

<A NAME="IDX1030"></A>
<DT><code>TIMESTAMP[(M)]</code>
<DD>
Временная метка. Интервал от <code>'1970-01-01 00:00:00'</code> до некоторого
значения времени в 2037 году. MySQL выводит значения <code>TIMESTAMP</code> в форматах
<code>YYYYMMDDHHMMSS</code>, <code>YYMMDDHHMMSS</code>, <code>YYYYMMDD</code> или <code>YYMMDD</code> в зависимости от
значений <code>M</code>: <code>14</code> (или отсутствующее), <code>12</code>, <code>8</code>, или <code>6</code>;  но можно также
устанавливать значения в столбце  <code>TIMESTAMP</code>, используя как строки, так и
числа. Столбец <code>TIMESTAMP</code> полезен для записи даты и времени при выполнении
операций <code>INSERT</code> или <code>UPDATE</code>, так как при этом автоматически вносятся
значения даты и времени самой последней операции, если эти величины не
введены программой. Можно также устанавливать текущее значение даты и
времени, задавая значение <code>NULL</code>. See section <A HREF="manual.ru_Reference.html#Date_and_time_types">6.2.2  Типы данных даты и времени</A>.
Аргумент <code>M</code> влияет только на способ вывода столбца <code>TIMESTAMP</code>; для хранения
его значений всегда используется 4 байта. Следует учитывать, что столбцы
<code>TIMESTAMP(M)</code>, где <code>M</code> равно <code>8</code> или <code>14</code>, представляют собой числа, в то время,
как столбцы <code>TIMESTAMP(M)</code> с иным значением аргумента <code>M</code> являются строками.
Это убеждает, что можно надежно сделать дамп и восстановить таблицу с
этими типами столбцов! See section <A HREF="manual.ru_Reference.html#DATETIME">6.2.2.2  Типы данных <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code></A>.

<A NAME="IDX1031"></A>
<DT><code>TIME</code>
<DD>
Время. Интервал от <code>'-838:59:59'</code> до <code>'838:59:59'</code>. MySQL выводит значения
<code>TIME</code> в формате <code>'HH:MM:SS'</code>, но можно устанавливать значения в столбце  <code>TIME</code>,
используя как строки, так и числа. See section <A HREF="manual.ru_Reference.html#TIME">6.2.2.3  Тип данных <code>TIME</code></A>.

<A NAME="IDX1032"></A>
<DT><code>YEAR[(2|4)]</code>
<DD>
Год в двухзначном или четырехзначном форматах (по умолчанию формат
четырехзначный). Допустимы следующие значения: с <code>1901</code> по <code>2155</code>, <code>0000</code> для
четырехзначного формата года и <code>1970-2069</code> при использовании двухзначного
формата (<code>70-69</code>). MySQL выводит значения <code>YEAR</code> в формате <code>YYYY</code>, но можно
задавать значения в столбце  <code>YEAR</code>,  используя как строки, так и числа (тип
данных <code>YEAR</code> недоступен в версиях, предшествующих MySQL 3.22). 
See section <A HREF="manual.ru_Reference.html#YEAR">6.2.2.4  Тип данных  <code>YEAR</code></A>.

<A NAME="IDX1033"></A>
<A NAME="IDX1034"></A>
<A NAME="IDX1035"></A>
<A NAME="IDX1036"></A>
<DT><code>[NATIONAL] CHAR(M) [BINARY]</code>
<DD>
Строка фиксированной длины, при хранении всегда дополняется пробелами в
конце строки до заданного размера. Диапазон аргумента <code>M</code> составляет от <code>0</code> до
<code>255</code> символов (от <code>1</code> до <code>255</code> в версиях, предшествующих MySQL 3.23). Концевые
пробелы удаляются при выводе значения. Если не задан атрибут
чувствительности к регистру <code>BINARY</code>, то величины <code>CHAR</code> сортируются и
сравниваются как независимые от регистра в соответствии с установленным по
умолчанию алфавитом. 

Атрибут <code>NATIONAL CHAR</code> (или его эквивалентная краткая
форма <code>NCHAR</code>) представляет собой принятый в ANSI  SQL способ указания, что
в столбце <code>CHAR</code> должен использоваться установленный по умолчанию набор
символов (<code>CHARACTER</code>). В MySQL это принято по умолчанию. <code>CHAR</code> является
сокращением от <code>CHARACTER</code>. MySQL позволяет создавать столбец типа <code>CHAR(0)</code>.

В основном это полезно, если необходимо обеспечить совместимость с
некоторыми старыми приложениями, которые зависят от наличия столбца, но
реально эту величину не используют. Кроме того, такая возможность может
очень пригодиться в случае, если необходим столбец, который может
содержать только 2 значения, а именно <code>CHAR(0)</code> (т.е. столбец, который не
определен как <code>NOT NULL</code>, занимает только один бит и принимает только 2
значения: <code>NULL</code> или <code>""</code>). See section <A HREF="manual.ru_Reference.html#CHAR">6.2.3.1  Типы данных CHAR и VARCHAR</A>.

<DT><code>CHAR</code>
<DD>
Это синоним для <code>CHAR(1)</code>.

<A NAME="IDX1037"></A>
<A NAME="IDX1038"></A>
<A NAME="IDX1039"></A>
<DT><code>[NATIONAL] VARCHAR(M) [BINARY]</code>
<DD>
Строка переменной длины. <strong>Примечание:</strong> концевые пробелы удаляются при
сохранении значения (в этом заключается отличие от спецификации ANSI 
SQL). Диапазон аргумента <code>M</code> составляет от <code>0</code> до <code>255</code> символов (от <code>1</code> до <code>255</code> в
версиях, предшествующих MySQL  Version 4.0.2). Если не задан атрибут
чувствительности к регистру <code>BINARY</code>, то величины <code>VARCHAR</code> сортируются и
сравниваются как независимые от регистра. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>. Термин <code>VARCHAR</code> является сокращением от <code>CHARACTER 
VARYING</code>. See section <A HREF="manual.ru_Reference.html#CHAR">6.2.3.1  Типы данных CHAR и VARCHAR</A>.

<A NAME="IDX1040"></A>
<A NAME="IDX1041"></A>
<DT><code>TINYBLOB</code>
<DD>
<DT><code>TINYTEXT</code>
<DD>
Столбец типа <code>BLOB</code> или <code>TEXT</code> с максимальной длиной <code>255</code> (<code>2^8 - 1</code>) символов.
See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>. See section <A HREF="manual.ru_Reference.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A>.

<A NAME="IDX1042"></A>
<A NAME="IDX1043"></A>
<DT><code>BLOB</code>
<DD>
<DT><code>TEXT</code>
<DD>
Столбец типа <code>BLOB</code> или <code>TEXT</code> с максимальной длиной <code>65535</code> (<code>2^16 - 1</code>)
символов. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>. See section <A HREF="manual.ru_Reference.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A>.

<A NAME="IDX1044"></A>
<A NAME="IDX1045"></A>
<DT><code>MEDIUMBLOB</code>
<DD>
<DT><code>MEDIUMTEXT</code>
<DD>
Столбец типа <code>BLOB</code> или <code>TEXT</code> с максимальной длиной <code>16777215</code> (<code>2^24 - 1</code>)
символов. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>. See section <A HREF="manual.ru_Reference.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A>.

<A NAME="IDX1046"></A>
<A NAME="IDX1047"></A>
<DT><code>LONGBLOB</code>
<DD>
<DT><code>LONGTEXT</code>
<DD>
Столбец типа <code>BLOB</code> или <code>TEXT</code> с максимальной длиной <code>4294967295</code> (<code>2^32 - 1</code>)
символов. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>. Следует
учитывать, что в настоящее время протокол передачи данных сервер/клиент и
таблицы <code>MyISAM</code> имеют ограничение 16 Мб на передаваемый пакет/строку таблицы,
поэтому пока нельзя использовать этот тип данных в его полном диапазоне.
See section <A HREF="manual.ru_Reference.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A>.

<DT><code>ENUM('значение1','значение2',...)</code>
<DD>
Перечисление. Перечисляемый тип данных. Объект строки может иметь только
одно значение, выбранное из заданного списка величин <code>'значение1'</code>, <code>'значение2'</code>,
<code>...</code>, <code>NULL</code> или специальная величина ошибки <code>""</code>. Список <code>ENUM</code> может содержать
максимум <code>65535</code> различных величин. See section <A HREF="manual.ru_Reference.html#ENUM">6.2.3.3  Тип перечисления <code>ENUM</code></A>.

<A NAME="IDX1048"></A>
<DT><code>SET('значение1','значение2',...)</code>
<DD>
Набор. Объект строки может иметь ноль или более значений, каждое из
которых должно быть выбрано из заданного списка величин <code>'значение1'</code>,
<code>'значение2'</code>, <code>...</code> Список <code>SET</code> может содержать максимум 64 элемента. 
See section <A HREF="manual.ru_Reference.html#SET">6.2.3.4  Тип множества <code>SET</code></A>.
</DL>



<H3><A NAME="Numeric_types" HREF="manual.ru_toc.html#Numeric_types">6.2.1  Числовые типы данных</A></H3>

<P>
MySQL поддерживает все числовые типы данных языка SQL92 по стандартам
ANSI/ISO. Они включают в себя типы точных числовых данных (<code>NUMERIC</code>,
<code>DECIMAL</code>, <code>INTEGER</code> и <code>SMALLINT</code>) и типы приближенных числовых данных (<code>FLOAT</code>,
<code>REAL</code> и <code>DOUBLE PRECISION</code>). Ключевое слово <code>INT</code> является синонимом для
<code>INTEGER</code>, а ключевое слово <code>DEC</code> - синонимом для <code>DECIMAL</code>.

</P>
<P>
Типы данных <code>NUMERIC</code> и <code>DECIMAL</code> реализованы в MySQL как один и тот же тип -
это разрешается стандартом SQL92. Они используются для величин, для
которых важно сохранить повышенную точность, например для денежных данных.
Требуемая точность данных и масштаб могут задаваться (и обычно задаются)
при объявлении столбца данных одного из этих типов, например:

</P>

<pre>
    salary DECIMAL(5,2)
</pre>

<P>
В этом примере - <code>5</code> (точность) представляет собой общее количество значащих
десятичных знаков, с которыми будет храниться данная величина, а цифра <code>2</code>
(масштаб) задает количество десятичных знаков после запятой.
Следовательно, в этом случае интервал величин, которые могут храниться в
столбце <code>salary</code>, составляет от  <code>-99,99</code> до <code>99,99</code> (в действительности для
данного столбца MySQL обеспечивает возможность хранения чисел вплоть до
<code>999,99</code>, поскольку можно не хранить знак для положительных чисел).

</P>
<P>
В SQL92 по стандарту ANSI/ISO выражение <code>DECIMAL(p)</code> эквивалентно
<code>DECIMAL(p,0)</code>. Аналогично, выражение <code>DECIMAL</code> также эквивалентно
<code>DECIMAL(p,0)</code>, при этом предполагается, что величина  <code>p</code> определяется
конкретной реализацией. В настоящее время MySQL не поддерживает ни одну из
рассматриваемых двух различных форм типов данных <code>DECIMAL/NUMERIC</code>. В общем
случае это не является серьезной проблемой, так как основные преимущества
данных типов состоят в возможности явно управлять как точностью, так и
масштабом представления данных.

</P>
<P>
Величины типов <code>DECIMAL</code> и <code>NUMERIC</code> хранятся как строки, а не как двоичные
числа с плавающей точкой, чтобы сохранить точность представления этих
величин в десятичном виде. При этом используется по одному символу строки
для каждого разряда хранимой величины, для десятичного знака (если <code>масштаб &#62; 0</code>) 
и для знака <samp>`-'</samp> (для отрицательных чисел). Если параметр <code>масштаба</code> равен <code>0</code>,
то величины <code>DECIMAL</code> и <code>NUMERIC</code> не содержат десятичного знака или дробной
части.

</P>
<P>
Максимальный интервал величин <code>DECIMAL</code> и  <code>NUMERIC</code> тот же, что и для типа
<code>DOUBLE</code>, но реальный интервал может быть ограничен выбором значений
параметров <code>точности</code> или <code>масштаба</code> для данного столбца с типом данных <code>DECIMAL</code>
или <code>NUMERIC</code>. Если конкретному столбцу присваивается значение, имеющее
большее количество разрядов после десятичного знака, чем разрешено
параметром <code>масштаба</code>, то данное значение округляется до количества разрядов,
разрешенного  <code>масштаба</code>. Если столбцу с типом <code>DECIMAL</code> или <code>NUMERIC</code>
присваивается значение, выходящее за границы интервала, заданного
значениями <code>точности</code> и <code>масштаба</code> (или принятого по умолчанию), то MySQL
сохранит данную величину со значением соответствующей граничной точки
данного интервала.

</P>
<P>
В качестве расширения стандарта ANSI/ISO  SQL92 MySQL также поддерживает
числовые типы представления данных <code>TINYINT</code>, <code>MEDIUMINT</code> и <code>BIGINT</code>, кратко
описанные в таблице выше. Еще одно расширение указанного стандарта,
поддерживаемое MySQL, позволяет при необходимости указывать количество
показываемых пользователю символов целого числа в круглых скобках,
следующих за базовым ключевым словом данного типа (например <code>INT(4)</code>). Это
необязательное указание количества выводимых символов используется для
дополнения слева выводимых значений, которые содержат символов меньше, чем
заданная ширина столбца, однако не накладывает ограничений ни на диапазон
величин, которые могут храниться в столбце, ни на количество разрядов,
которые могут выводиться для величин, у которых количество символов
превосходит ширину данного столбца. Если дополнительно указан
необязательный атрибут <code>ZEROFILL</code>, свободные позиции по умолчанию
заполняются нолями. Например, для столбца, объявленного как <code>INT(5)</code>
<code>ZEROFILL</code>, величина <code>4</code> извлекается как <code>00004</code>. Следует учитывать, что если в
столбце для целых чисел хранится величина с количеством символов,
превышающим заданную ширину столбца, могут возникнуть проблемы, когда
MySQL будет генерировать временные таблицы для некоторых сложных связей,
так как в подобных случаях MySQL полагает, что данные действительно
поместились в столбец имеющейся ширины.

</P>
<P>
Все типы целочисленных данных могут иметь необязательный и не оговоренный
в стандарте атрибут <code>UNSIGNED</code>. Беззнаковые величины можно использовать для
разрешения записи в столбец только положительных чисел, если необходимо
немного увеличить числовой интервал в столбце.

</P>
<P>
В версии MySQL 4.0.2 числовые типы данных с плавающей точкой также могут
иметь параметр <code>UNSIGNED</code>. Как и в целочисленных типах, этот атрибут
предотвращает хранение в отмеченном столбце отрицательных величин. Но, в
отличие от целочисленных типов, максимальный интервал для величин столбца
остается прежним.

</P>
<P>
Тип <code>FLOAT</code> обычно используется для представления приблизительных числовых
типов данных. Стандарт ANSI/ISO  SQL92 допускает факультативное указание
точности (но не интервала порядка числа) в битах в круглых скобках,
следующих за ключевым словом <code>FLOAT</code>. Реализация MySQL также поддерживает
это факультативное указание точности. При этом если ключевое слово <code>FLOAT</code> в
обозначении типа столбца используется без указания точности, MySQL
выделяет 4 байта для хранения величин в этом столбце. Возможно также иное
обозначение, с двумя числами в круглых скобках за ключевым словом <code>FLOAT</code>. В
этом варианте первое число по-прежнему определяет требования к хранению
величины в байтах, а второе число указывает количество разрядов после
десятичной запятой, которые будут храниться и показываться (как для типов
<code>DECIMAL</code> и <code>NUMERIC</code>). Если в столбец подобного типа попытаться записать
число, содержащее больше десятичных знаков после запятой, чем указано для
данного столбца, то значение величины при ее хранении в MySQL округляется
для устранения излишних разрядов.

</P>
<P>
Для типов <code>REAL</code> и <code>DOUBLE PRECISION</code> не предусмотрены установки точности.
MySQL воспринимает <code>DOUBLE</code> как синоним типа <code>DOUBLE PRECISION</code> - это еще
одно расширение стандарта ANSI/ISO  SQL92. Но, вопреки требованию
стандарта, указывающему, что точность для <code>REAL</code> меньше, чем для <code>DOUBLE 
PRECISION</code>, в  MySQL оба типа реализуются как 8-байтовые числа с плавающей
точкой удвоенной точности (если не установлен ``ANSI-режим''). Чтобы
обеспечить максимальную совместимость, в коде, требующем хранения
приблизительных числовых величин, должны использоваться типы <code>FLOAT</code> или
<code>DOUBLE PRECISION</code> без указаний точности или количества десятичных знаков.

</P>
<P>
Если в числовой столбец попытаться записать величину, выходящую за границы
допустимого интервала для столбца данного типа, то MySQL ограничит
величину до соответствующей граничной точки данного интервала и сохранит
результат вместо исходной величины.

</P>
<P>
Например, интервал столбца <code>INT</code> составляет от <code>-2147483648</code> до <code>2147483647</code>.
Если попытаться записать в столбец <code>INT</code> число <code>-9999999999</code>, то оно будет
усечено до нижней конечной точки интервала и вместо записываемого значения
в столбце будет храниться величина <code>-2147483648</code>. Аналогично, если
попытаться записать число <code>9999999999</code>, то взамен запишется число
<code>2147483647</code>.

</P>
<P>
Если для столбца <code>INT</code> указан параметр <code>UNSIGNED</code>, то величина допустимого
интервала для столбца останется той же, но его граничные точки сдвинутся к
<code>0</code> и <code>4294967295</code>. Если попытаться записать числа <code>-9999999999</code> и <code>9999999999</code>,
то в столбце окажутся величины <code>0</code> и <code>4294967296</code>.

</P>
<P>
Для команд <code>ALTER TABLE</code>, <code>LOAD DATA INFILE</code>, <code>UPDATE</code> и многострочной <code>INSERT</code>
выводится предупреждение, если могут возникнуть преобразования данных
вследствие вышеописанных усечений.

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип</strong> </TD><TD> <strong>Байт</strong> </TD><TD> <strong>От</strong> </TD><TD> <strong>До</strong>
</TD></TR>
<TR><TD><code>TINYINT</code> </TD><TD> 1 </TD><TD> -128 </TD><TD> 127
</TD></TR>
<TR><TD><code>SMALLINT</code> </TD><TD> 2 </TD><TD> -32768 </TD><TD> 32767
</TD></TR>
<TR><TD><code>MEDIUMINT</code> </TD><TD> 3 </TD><TD> -8388608 </TD><TD> 8388607
</TD></TR>
<TR><TD><code>INT</code> </TD><TD> 4 </TD><TD> -2147483648 </TD><TD> 2147483647
</TD></TR>
<TR><TD><code>BIGINT</code> </TD><TD> 8 </TD><TD> -9223372036854775808 </TD><TD> 9223372036854775807
</TD></TR>
</TABLE>



<H3><A NAME="Date_and_time_types" HREF="manual.ru_toc.html#Date_and_time_types">6.2.2  Типы данных даты и времени</A></H3>

<P>
<A NAME="IDX1049"></A>
<A NAME="IDX1050"></A>

</P>
<P>
Существуют следующие типы данных даты и времени: <code>DATETIME</code>, <code>DATE</code>,
<code>TIMESTAMP</code>, <code>TIME</code> и <code>YEAR</code>. Каждый из них имеет интервал допустимых значений,
а также значение ``ноль'', которое используется, когда пользователь вводит
действительно недопустимое значение. Отметим, что MySQL позволяет хранить
некоторые не вполне достоверные значения даты, например <code>1999-11-31</code>.
Причина в том, что, по нашему мнению, управление проверкой даты входит в
обязанности конкретного приложения, а не SQL-серверов. Для ускорения
проверки правильности даты MySQL только проверяет, находится ли месяц в
интервале <code>0-12</code> и день в интервале <code>0-31</code>. Данные интервалы начинаются с <code>0</code>,
это сделано для того, чтобы обеспечить для MySQL возможность хранить в
столбцах <code>DATE</code> или <code>DATETIME</code> даты, в которых день или месяц равен нулю. Эта
возможность особенно полезна для приложений, которые предполагают хранение
даты рождения - здесь не всегда известен день или месяц рождения. В таких
случаях дата хранится просто в виде <code>1999-00-00</code> или <code>1999-01-00</code> (при этом не
следует рассчитывать на то, что для подобных дат функции <code>DATE_SUB()</code> или
<code>DATE_ADD</code> дадут правильные значения).

</P>
<P>
Ниже приведены некоторые общие соображения, полезные при работе с типами
данных даты и времени:

</P>

<ul>
MySQL извлекает значения для данного типа даты или времени только в
стандартном формате, но в то же время пытается интерпретировать
разнообразные форматы, которые могут поступать от пользователей
(например, когда задается величина, которой следует присвоить тип даты
или времени или сравнить со значением, имеющим один из этих типов).
Тем не менее, поддерживаются только форматы, описанные в следующих
разделах. Предполагается, что пользователь будет вводить допустимые
значения величин, так как использование величин в других форматах
может дать непредсказуемые результаты.

<LI>

Хотя MySQL пытается интерпретировать значения в нескольких форматах,
во всех случаях ожидается, что крайним слева будет раздел значения
даты, содержащий год. Даты должны задаваться в порядке <code>год-месяц-день</code>
(например, <code>'98-09-04'</code>), а не в порядке <code>месяц-день-год</code> или
<code>день-месяц-год</code>, т.е. не так, как мы их обычно записываем (например
<code>'09-04-98'</code>, <code>'04-09-98'</code>).

<LI>

MySQL автоматически преобразует значение, имеющее тип даты или
времени, в число, если данная величина используется в числовом
контексте, и наоборот.

<LI>

Значение, имеющее тип даты или времени, которое выходит за границы
установленного интервала или является недопустимым для этого типа
данных (см. начало раздела), преобразуется в значение ``ноль'' для
данного типа. (Исключение составляют выходящие за границы
установленного интервала величины типа <code>TIME</code>, которые усекаются до
соответствующей граничной точки заданного интервала <code>TIME</code>). В следующей
таблице представлены форматы значения ``ноль'' для каждого из типов
столбцов:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип столбца</strong> </TD><TD> <strong>Значение ``Ноль''</strong>
</TD></TR>
<TR><TD><code>DATETIME</code> </TD><TD> <code>'0000-00-00 00:00:00'</code>
</TD></TR>
<TR><TD><code>DATE</code> </TD><TD> <code>'0000-00-00'</code>
</TD></TR>
<TR><TD><code>TIMESTAMP</code> </TD><TD> <code>00000000000000</code> (длина зависит от количества выводимых символов)
</TD></TR>
<TR><TD><code>TIME</code> </TD><TD> <code>'00:00:00'</code>
</TD></TR>
<TR><TD><code>YEAR</code> </TD><TD> <code>0000</code>
</TD></TR>
</TABLE>

<LI>

Значения ``ноль'' - особые. Для их хранения или ссылок на них можно
явно применять представленные в таблице значения, а можно использовать
<samp>`0'</samp> или <samp>`0'</samp>, что легче в написании.

<LI>

Значения ``ноль'' даты или времени при использовании MyODBC
автоматически конвертируются в <code>NULL</code> в версии MyODBC 2.50.12 и выше,
так как ODBC не оперирует с подобными величинами.
</ul>



<H4><A NAME="Y2K_issues" HREF="manual.ru_toc.html#Y2K_issues">6.2.2.1  Проблема 2000 года и типы данных</A></H4>

<P>
<A NAME="IDX1051"></A>
<A NAME="IDX1052"></A>

</P>
<P>
Ядро MySQL само по себе устойчиво к ``проблеме 2000 года'' (see section <A HREF="manual.ru_Introduction.html#Year_2000_compliance">1.4.5  Вопросы, связанные с Проблемой-2000</A>), 
но некоторые представленные в MySQL входные
величины могут являться источниками ошибок. Так, любое вводимое значение,
содержащее двухразрядное значение года, является неоднозначным, поскольку
неизвестно столетие. Подобные величины должны быть переведены в
четырехразрядную форму, так как для внутреннего представления года в MySQL
используется 4 разряда.

</P>
<P>
Для типов <code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code> и <code>YEAR</code> даты с неоднозначным годом
интерпретируются в MySQL по следующим правилам:

</P>

<ul>
<LI>

Величина года в интервале <code>00-69</code> конвертируется в <code>2000-2069</code>.
<LI>

Величина года в интервале <code>70-99</code> конвертируется в <code>1970-1999</code>.
</ul>

<P>
Следует помнить, что эти правила дают только правдоподобные предположения
о том, что ваши данные в действительности означают. Если применяемая MySQL
эвристика не дает правильных величин, необходимо обеспечить
недвусмысленные входные данные, содержащие четырехразрядные величины года.

</P>
<P>
<code>ORDER BY</code> отсортирует двухразрядные <code>YEAR/DATE/DATETIME</code> типы корректно.

</P>
<P>
Необходимо также отметить, что некоторые функции, такие как <code>MIN()</code> и <code>MAX()</code>
будут преобразовывать <code>TIMESTAMP/DATE</code> в число. Это означает, что столбец с
данными типа <code>TIMESTAMP</code>, содержащими год в виде двух разрядов, не будет
правильно работать с указанными функциями. Выход из этого положения
состоит в преобразовании <code>TIMESTAMP/DATE</code> к четырехразрядному формату или
использовании чего-нибудь вроде <code>MIN(DATE_ADD(timestamp,INTERVAL 0 DAYS))</code>.

</P>


<H4><A NAME="DATETIME" HREF="manual.ru_toc.html#DATETIME">6.2.2.2  Типы данных <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code></A></H4>

<P>
<A NAME="IDX1053"></A>
<A NAME="IDX1054"></A>
<A NAME="IDX1055"></A>

</P>
<P>
Типы <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code> являются родственными типами данных. В
данном разделе описаны их свойства, общие черты и различия.

</P>
<P>
Тип данных <code>DATETIME</code> используется для величин, содержащих информацию как о
дате, так и о времени. MySQL извлекает и выводит величины <code>DATETIME</code> в
формате <code>'YYYY-MM-DD HH:MM:SS'</code>. Поддерживается диапазон величин от
<code>'1000-01-01 00:00:00'</code> до <code>'9999-12-31 23:59:59'</code>. (''поддерживается''
означает, что хотя величины с более ранними временными значениями,
возможно, тоже будут работать, но нет гарантии того, что они будут
правильно храниться и отображаться).

</P>
<P>
Тип <code>DATE</code> используется для величин с информацией только о дате, без части,
содержащей время. MySQL извлекает и выводит величины <code>DATE</code> в формате
<code>'YYYY-MM-DD'</code>. Поддерживается диапазон величин от <code>'1000-01-01'</code> до
<code>'9999-12-31'</code>.

</P>
<P>
Тип столбца <code>TIMESTAMP</code> обеспечивает тип представления данных, который можно
использовать для автоматической записи текущих даты и времени при
выполнении операций <code>INSERT</code> или <code>UPDATE</code>. При наличии нескольких столбцов
типа <code>TIMESTAMP</code> только первый из них обновляется автоматически.

</P>
<P>
Автоматическое обновление первого столбца с типом <code>TIMESTAMP</code> происходит при
выполнении любого из следующих условий:

</P>

<ul>
<LI>

Столбец не указан явно в команде <code>INSERT</code> или <code>LOAD DATA INFILE</code>.

<LI>

Столбец не указан явно в команде <code>UPDATE</code>, и при этом изменяется
величина в некотором другом столбце (следует отметить, что команда
<code>UPDATE</code>, устанавливающая столбец в то же самое значение, которое было
до выполнения команды, не вызовет обновления столбца <code>TIMESTAMP</code>,
поскольку в целях повышения производительности  MySQL игнорирует
подобные обновления при установке столбца в его текущее значение).

<LI>

Величина в столбце <code>TIMESTAMP</code> явно установлена в <code>NULL</code>.
</ul>

<P>
Для остальных (кроме первого) столбцов типа <code>TIMESTAMP</code> также можно задать
установку в значение текущих даты и времени. Для этого необходимо просто
установить столбец в <code>NULL</code> или в <code>NOW()</code>.

</P>
<P>
Любой столбец типа <code>TIMESTAMP</code> (даже первый столбец данного типа) можно
установить в значение, отличное от текущих даты и времени. Это делается
путем явной установки его в желаемое значение. Данное свойство можно
использовать, например, если необходимо установить столбец <code>TIMESTAMP</code> в
значение текущих даты и времени при создании строки, а при последующем
обновлении этой строки значение столбца не должно изменяться:

</P>

<ul>
<LI>

Пусть MySQL автоматически установит значение столбца с типом <code>TIMESTAMP</code>
при создании данной строки. Столбец будет установлен в исходное
состояние со значением текущих даты и времени.

<LI>

При выполнении последующих обновлений других столбцов в данной строке
необходимо явно установить столбец <code>TIMESTAMP</code> в его текущее значение.
</ul>

<P>
Однако, с другой стороны, для этих целей, возможно, будет проще
использовать столбец <code>DATETIME</code>. При создании строки его следует
инициализировать функцией <code>NOW()</code> и оставить в покое при последующих
обновлениях.

</P>
<P>
Величины типа <code>TIMESTAMP</code> могут принимать значения от начала <code>1970</code> года до
некоторого значения в <code>2037</code> году с разрешением в одну секунду. Эти величины
выводятся в виде числовых значений.

</P>
<P>
Формат данных, в котором MySQL извлекает и показывает величины <code>TIMESTAMP</code>,
зависит от количества показываемых символов. Это проиллюстрировано в
приведенной ниже таблице. Полный формат <code>TIMESTAMP</code> составляет 14 десятичных
разрядов, но можно создавать столбцы типа <code>TIMESTAMP</code> и с более короткой
строкой вывода:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип столбца</strong> </TD><TD> <strong>Формат вывода</strong>
</TD></TR>
<TR><TD><code>TIMESTAMP(14)</code> </TD><TD> <code>YYYYMMDDHHMMSS</code>
</TD></TR>
<TR><TD><code>TIMESTAMP(12)</code> </TD><TD> <code>YYMMDDHHMMSS</code>
</TD></TR>
<TR><TD><code>TIMESTAMP(10)</code> </TD><TD> <code>YYMMDDHHMM</code>
</TD></TR>
<TR><TD><code>TIMESTAMP(8)</code> </TD><TD> <code>YYYYMMDD</code>
</TD></TR>
<TR><TD><code>TIMESTAMP(6)</code> </TD><TD> <code>YYMMDD</code>
</TD></TR>
<TR><TD><code>TIMESTAMP(4)</code> </TD><TD> <code>YYMM</code>
</TD></TR>
<TR><TD><code>TIMESTAMP(2)</code> </TD><TD> <code>YY</code>
</TD></TR>
</TABLE>

<P>
Независимо от размера выводимого значения размер данных, хранящихся в
столбцах типа <code>TIMESTAMP</code>, всегда один и тот же. Чаще всего используется
формат вывода с 6, 8, 12 или 14 десятичными знаками. При создании таблицы
можно указать произвольный размер выводимых значений, однако если этот
размер задать равным 0 или превышающим 14, то будет использоваться
значение 14. Нечетные значения размеров в интервале от 1 до 13 будут
приведены к ближайшему большему четному числу.

</P>
<P>
Величины <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code> могут быть заданы любым стандартным
набором форматов:

</P>

<ul>
<LI>

Как строка в формате <code>'YYYY-MM-DD HH:MM:SS'</code> или в формате <code>'YY-MM-DD HH:MM:SS'</code>. 
Допускается ``облегченный'' синтаксис - можно использовать
любой знак пунктуации в качестве разделительного между частями
разделов даты или времени. Например, величины <code>'98-12-31 11:30:45'</code>,
<code>'98.12.31 11+30+45'</code>, <code>'98/12/31 11*30*45'</code> и <code>'98@12@31 11^30^45'</code>
являются эквивалентными.

<LI>

Как строка в формате <code>'YYYY-MM-DD'</code> или в формате <code>'YY-MM-DD'</code>. Здесь
также допустим ``облегченный'' синтаксис. Например, величины
<code>'98-12-31'</code>, <code>'98.12.31'</code>, <code>'98/12/31'</code> и <code>'98@12@31'</code> являются
эквивалентными.

<LI>

Как строка без разделительных знаков в формате <code>'YYYYMMDDHHMMSS'</code> или в
формате <code>'YYMMDDHHMMSS'</code>, при условии, что строка понимается как дата.
Например, величины <code>'19970523091528'</code> и <code>'970523091528'</code> можно
интерпретировать как <code>'1997-05-23 09:15:28'</code>, но величина <code>'971122129015'</code>
является недопустимой (значение раздела минут является абсурдным) и
преобразуется в <code>'0000-00-00 00:00:00'</code>.

<LI>

Как строка без разделительных знаков в формате <code>'YYYYMMDD'</code> или в
формате <code>'YYMMDD'</code>, при условии, что строка интерпретируется как дата.
Например, величины <code>'19970523'</code> и <code>'970523'</code> можно интерпретировать как
<code>'1997-05-23'</code>, но величина <code>'971332'</code> является недопустимой (значения
разделов месяца и дня не имеют смысла) и преобразуется в <code>'0000-00-00'</code>.

<LI>

Как число в формате <code>YYYYMMDDHHMMSS</code> или в формате <code>YYMMDDHHMMSS</code>, при
условии, что число интерпретируется как дата. Например, величины
<code>19830905132800</code> и <code>830905132800</code> интерпретируются как <code>'1983-09-05 13:28:00'</code>.

<LI>

Как число в формате <code>YYYYMMDD</code> или в формате <code>YYMMDD</code>, при условии, что
число интерпретируется как дата. Например, величины <code>19830905</code> и <code>830905</code>
интерпретируются как <code>'1983-09-05'</code>.

<LI>

Как результат выполнения функции, возвращающей величину, приемлемую в
контекстах типов данных <code>DATETIME</code>, <code>DATE</code> или <code>TIMESTAMP</code> (например,
функции <code>NOW()</code> или <code>CURRENT_DATE()</code>.
</ul>

<P>
Недопустимые значения величин <code>DATETIME</code>, <code>DATE</code> или <code>TIMESTAMP</code> преобразуются в
значение ``ноль'' соответствующего типа величин (<code>'0000-00-00 00:00:00'</code>,
<code>'0000-00-00'</code>, или <code>00000000000000</code>).

</P>
<P>
Для величин, представленных как строки, содержащие разделительные знаки
между частями даты, нет необходимости указывать два разряда для значений
месяца или дня, меньших, чем <code>10</code>. Так, величина <code>'1979-6-9'</code> эквивалентна
величине <code>'1979-06-09'</code>. Аналогично, для величин, представленных как строки,
содержащие разделительные знаки внутри обозначения времени, нет
необходимости указывать два разряда для значений часов, минут или секунд,
меньших, чем <code>10</code>. Так,

</P>
<P>
Величины, определенные как числа, должны иметь <code>6</code>, <code>8</code>, <code>12</code>, или <code>14</code> десятичных
разрядов. Предполагается, что число, имеющее <code>8</code> или <code>14</code> разрядов,
представлено в форматах <code>YYYYMMDD</code> или <code>YYYYMMDDHHMMSS</code> соответственно, причем
год указан в первых четырех разрядах. Если же длина числа <code>6</code> или <code>12</code>
разрядов, то предполагаются соответственно форматы <code>YYMMDD</code> или
<code>YYMMDDHHMMSS</code>, где год указан в первых двух разрядах. Числа, длина которых
не соответствует ни одному из описанных вариантов, интерпретируются как
дополненные спереди нулями до ближайшей вышеуказанной длины.

</P>
<P>
Величины, представленные строками без разделительных знаков,
интерпретируются с учетом их длины согласно приведенным далее правилам.
Если длина строки равна <code>8</code> или <code>14</code> символам, то предполагается, что год
задан первыми четырьмя символами. В противном случае предполагается, что
год задан двумя первыми символами. Строка интерпретируется слева направо,
при этом определяются значения для года, месяца, дня, часов, минут и
секунд для всех представленных в строке разделов. Это означает, что строка
с длиной меньше, чем <code>6</code> символов, не может быть использована. Например,
если задать строку вида <code>'9903'</code>, полагая, что это будет означать март 1999
года, то MySQL внесет в таблицу ``нулевую'' дату. Год и месяц в данной
записи равны <code>99</code> и <code>03</code> соответственно, но раздел, представляющий день,
пропущен (значение равно нулю), поэтому в целом данная величина не
является достоверным значением даты.

</P>
<P>
При хранении допустимых величин в столбцах типа <code>TIMESTAMP</code> используется
полная точность, указанная при их задании, независимо от количества
выводимых символов. Это свойство имеет несколько следствий:

</P>

<ul>
<LI>

Необходимо всегда указывать год, месяц и день даже для типов
<code>TIMESTAMP(4)</code> или <code>TIMESTAMP(2)</code>. В противном случае задаваемая величина
не будет допустимым значением даты и будет храниться как <code>0</code>.

<LI>

При увеличении ширины узкого столбца <code>TIMESTAMP</code> путем использования
команды <code>ALTER TABLE</code> будет выводиться ранее ``скрытая'' информация.

<LI>

И аналогично, при сужении столбца <code>TIMESTAMP</code> хранимая информация не
будет потеряна, если не принимать во внимание, что при выводе
информации будет выдаваться меньше.

<LI>

Хотя величины <code>TIMESTAMP</code> хранятся с полной точностью, непосредственно
может работать с этим исходным хранимым значением величины только
функция <code>UNIX_TIMESTAMP()</code>. Остальные функции оперируют форматированными
значениями извлеченной величины. Это означает, что нельзя использовать
такие функции, как <code>HOUR()</code> или <code>SECOND()</code>, пока соответствующая часть
величины <code>TIMESTAMP</code> не будет включена в ее форматированное значение.
Например, раздел <code>HH</code> столбца <code>TIMESTAMP</code> не будет выводиться, пока
количество выводимых символов не станет по меньшей мере равным <code>10</code>, так
что попытки использовать <code>HOUR()</code> для более коротких величин <code>TIMESTAMP</code>
приведут к бессмысленным результатам.
</ul>

<P>
Величины одного типа даты можно в ряде случаев присвоить объекту другого
типа даты. Однако при этом возможны некоторое изменение величины или
потеря информации:

</P>

<ul>
<LI>

Если присвоить значение типа <code>DATE</code> объекту <code>DATETIME</code> или <code>TIMESTAMP</code>, то в
результирующей величине ``временная'' часть будет установлена в
<code>'00:00:00'</code>, так как величина <code>DATE</code> не содержит информации о времени.

<LI>

Если присвоить значение типа <code>DATE</code>,  <code>DATETIME</code> или <code>TIMESTAMP</code> объекту
<code>DATE</code>, то ``временная'' часть в результирующей величине будет удалена,
так как тип <code>DATE</code> не включает информацию о времени.

<LI>

Несмотря на то что все величины <code>DATETIME</code>, <code>DATE</code> и <code>TIMESTAMP</code> могут быть
указаны с использованием одного и того же набора форматов, следует
помнить, что указанные типы имеют разные интервалы допустимых
значений. Например, величины типа <code>TIMESTAMP</code> не могут иметь значения
даты более ранние, чем относящиеся к <code>1970</code> году или более поздние, чем
относящиеся к <code>2037</code> году. Это означает, что такая дата, как
<code>'1968-01-01'</code>, будучи разрешенной для величины типа <code>DATETIME</code> или <code>DATE</code>,
недопустима для величины типа <code>TIMESTAMP</code> и будет преобразована в <code>0</code> при
присвоении этому объекту.
</ul>

<P>
Задавая величины даты, следует иметь в виду некоторые ``подводные камни'':

</P>
<P>
<A NAME="IDX1056"></A>
<A NAME="IDX1057"></A>

</P>

<ul>
<LI>

Упрощенный формат, который допускается для величин, заданных строками,
может ввести в заблуждение. Например, такая величина, как <code>'10:11:12'</code>,
благодаря разделителю <samp>`:'</samp> могла бы оказаться величиной времени, но,
используемая в контексте даты, она будет интерпретирована как год
<code>'2010-11-12'</code>. В то же время величина <code>'10:45:15'</code> будет преобразована в
<code>'0000-00-00'</code>, так как для месяца значение <code>'45'</code> недопустимо.

<LI>

Сервер MySQL выполняет только первичную проверку истинности даты: дни
<code>00-31</code>, месяцы <code>00-12</code>, года <code>1000-9999</code>. Любая дата вне этого диапазона
преобразуется в <code>0000-00-00</code>. Следует отметить, что, тем не менее, при
этом не запрещается хранить неверные даты, такие как <code>2002-04-31</code>. Это
позволяет веб-приложениям сохранять данные форм без дополнительной
проверки. Чтобы убедиться в достоверности даты, выполняется проверка в
самом приложении.

<LI>

Величины года, представленные двумя разрядами, допускают неоднозначное
толкование, так как неизвестно столетие. MySQL интерпретирует
двухразрядные величины года по следующим правилам:


<ul>
<LI>

Величины года в интервале <code>00-69</code> преобразуются в <code>2000-2069</code>.
<LI>

Величины года в интервале <code>70-99</code> преобразуются в <code>1970-1999</code>.
</ul>

</ul>



<H4><A NAME="TIME" HREF="manual.ru_toc.html#TIME">6.2.2.3  Тип данных <code>TIME</code></A></H4>

<P>
<A NAME="IDX1058"></A>

</P>
<P>
MySQL извлекает и выводит величины типа <code>TIME</code> в формате <code>'HH:MM:SS'</code> (или в
формате <code>'HHH:MM:SS'</code> для больших значений часов). Величины <code>TIME</code> могут
изменяться в пределах от <code>'-838:59:59'</code> до <code>'838:59:59'</code>. Причина того, что
``часовая'' часть величины может быть настолько большой, заключается в
том, что тип <code>TIME</code> может использоваться не только для представления времени
дня (которое должно быть меньше 24 часов), но также для представления
общего истекшего времени или временного интервала между двумя событиями
(который может быть значительно больше 24 часов или даже отрицательным).

</P>
<P>
Величины <code>TIME</code> могут быть заданы в различных форматах:

</P>

<ul>
Как строка в формате <code>'D HH:MM:SS.дробная часть'</code> (следует учитывать,
что MySQL пока не обеспечивает хранения дробной части величины в
столбце рассматриваемого типа). Можно также использовать одно из
следующих ``облегченных'' представлений: <code>HH:MM:SS.дробная часть</code>,
<code>HH:MM:SS</code>, <code>HH:MM</code>, <code>D HH:MM:SS</code>, <code>D HH:MM</code>, <code>D HH</code> или <code>SS</code>. Здесь <code>D</code> - это
дни из интервала значений <code>0-33</code>.

<LI>

Как строка без разделителей в формате <code>'HHMMSS'</code>, при условии, что
строка интерпретируется как дата. Например, величина <code>'101112'</code>
понимается как <code>'10:11:12'</code>, но величина <code>'109712'</code> будет недопустимой
(значение раздела минут является абсурдным) и преобразуется в
<code>'00:00:00'</code>.

<LI>

Как число в формате <code>HHMMSS</code>, при условии, что строка интерпретируется
как дата. Например, величина <code>101112</code> понимается как <code>'10:11:12'</code>. MySQL
понимает и следующие альтернативные форматы: <code>SS</code>, <code>MMSS</code>, <code>HHMMSS</code>,
<code>HHMMSS.дробная часть</code>. При этом следует учитывать, что хранения дробной
части MySQL пока не обеспечивает.

<LI>

Как результат выполнения функции, возвращающей величину, приемлемую в
контексте типа данных типа <code>TIME</code> (например, такой функции, как
<code>CURRENT_TIME</code>).
</ul>

<P>
Для величин типа  <code>TIME</code>, представленных как строки, содержащие
разделительные знаки между частями значения времени, нет необходимости
указывать два разряда для значений часов, минут или секунд, меньших <code>10</code>.
Так, величина <code>'8:3:2'</code> эквивалентна величине <code>'08:03:02'</code>.

</P>
<P>
Будьте внимательны в отношении использования ``укороченных'' величин <code>TIME</code>
в столбце типа <code>TIME</code>.  MySQL интерпретирует выражения без разделительных
двоеточий исходя из предположения, что крайние справа разряды представляют
секунды (MySQL интерпретирует величины <code>TIME</code> как общее истекшее время, а не
как время дня). Например, можно подразумевать, что величины <code>'1112'</code> и <code>1112</code>
обозначают <code>'11:12:00'</code> (11 часов и 12 минут дня по показаниям часов), но
MySQL понимает их как <code>'00:11:12'</code> (11 минут, 12 секунд). Подобно этому,
<code>'12'</code> и <code>12</code> интерпретируются как <code>'00:00:12'</code>. Величины <code>TIME</code> с разделительными
двоеточиями, наоборот, всегда трактуются как время дня. Т.е. выражение
<code>'11:12'</code> будет пониматься как <code>'11:12:00'</code>, а не <code>'00:11:12'</code>.

</P>
<P>
Величины, лежащие вне разрешенного интервала <code>TIME</code>, но во всем остальном
представляющие собой допустимые значения, усекаются до соответствующей
граничной точки данного интервала. Например, величины <code>'-850:00:00'</code> и
<code>'850:00:00'</code> преобразуются соответственно в <code>'-838:59:59'</code> и <code>'838:59:59'</code>.

</P>
<P>
Недопустимые значения величин <code>TIME</code> преобразуются в значение <code>'00:00:00'</code>.
Отметим, что поскольку выражение <code>'00:00:00'</code> само по себе представляет
разрешенное значение величины <code>TIME</code>, то по хранящейся в таблице величине
<code>'00:00:00'</code> невозможно определить, была ли эта величина изначально задана
как <code>'00:00:00'</code> или является преобразованным значением недопустимой
величины.

</P>


<H4><A NAME="YEAR" HREF="manual.ru_toc.html#YEAR">6.2.2.4  Тип данных  <code>YEAR</code></A></H4>

<P>
<A NAME="IDX1059"></A>

</P>
<P>
Тип <code>YEAR</code> - это однобайтный тип данных для представления значений года.

</P>
<P>
MySQL извлекает и выводит величины <code>YEAR</code> в формате <code>YYYY</code>. Диапазон возможных
значений - от <code>1901</code> до <code>2155</code>.

</P>
<P>
Величины типа <code>YEAR</code> могут быть заданы в различных форматах:

</P>

<ul>
<LI>

Как четырехзначная строка в интервале значений от <code>'1901'</code> до <code>'2155'</code>.

<LI>

Как четырехзначное число в интервале значений от <code>1901</code> до <code>2155</code>.

<LI>

Как двухзначная строка в интервале значений от <code>'00'</code> до <code>'99'</code>. Величины
в интервалах от <code>'00'</code> до <code>'69'</code> и от <code>'70'</code> до <code>'99'</code> при этом преобразуются
в величины <code>YEAR</code> в интервалах от <code>2000</code> до <code>2069</code> и от <code>1970</code> до <code>1999</code>
соответственно.

<LI>

Как двухзначное число в интервале значений от <code>1</code> до <code>99</code>. Величины в
интервалах от <code>1</code> до <code>69</code> и от <code>70</code> до <code>99</code>  при этом преобразуются в величины
<code>YEAR</code> в интервалах от <code>2001</code> до <code>2069</code> и от <code>1970</code> до <code>1999</code> соответственно.
Необходимо принять во внимание, что интервалы для двухзначных чисел и
двухзначных строк несколько различаются, так как нельзя указать
``ноль'' непосредственно как число и интерпретировать его как <code>2000</code>.
Необходимо задать его как строку <code>'0'</code> или <code>'00'</code>, или же оно будет
интерпретировано как <code>0000</code>.

<LI>

Как результат выполнения функции, возвращающей величину, приемлемую в
контексте типа данных <code>YEAR</code> (такой как <code>NOW()</code>).
</ul>

<P>
Недопустимые величины <code>YEAR</code> преобразуются в <code>0000</code>.

</P>


<H3><A NAME="String_types" HREF="manual.ru_toc.html#String_types">6.2.3  Символьные типы данных</A></H3>

<P>
Существуют следующие символьные типы данных: <code>CHAR</code>, <code>VARCHAR</code>, <code>BLOB</code>, <code>TEXT</code>,
<code>ENUM</code> и <code>SET</code>. В данном разделе дается описание их работы, требований к их
хранению и использования их в запросах.

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип</strong> </TD><TD> <strong>Макс.размер</strong> </TD><TD> <strong>Байт</strong>
</TD></TR>
<TR><TD><code>TINYTEXT</code>   или <code>TINYBLOB</code> </TD><TD> 2^8-1 </TD><TD> 255
</TD></TR>
<TR><TD><code>TEXT</code>       или <code>BLOB</code> </TD><TD> 2^16-1 (64K-1) </TD><TD> 65535
</TD></TR>
<TR><TD><code>MEDIUMTEXT</code> или <code>MEDIUMBLOB</code> </TD><TD> 2^24-1 (16M-1) </TD><TD> 16777215
</TD></TR>
<TR><TD><code>LONGBLOB</code> </TD><TD> 2^32-1 (4G-1) </TD><TD> 4294967295
</TD></TR>
</TABLE>



<H4><A NAME="CHAR" HREF="manual.ru_toc.html#CHAR">6.2.3.1  Типы данных CHAR и VARCHAR</A></H4>

<P>
<A NAME="IDX1060"></A>
<A NAME="IDX1061"></A>

</P>
<P>
<A NAME="IDX1062"></A>
<A NAME="IDX1063"></A>

</P>
<P>
Типы данных <code>CHAR</code> и <code>VARCHAR</code> очень схожи между собой, но различаются по
способам их хранения и извлечения.

</P>
<P>
В столбце типа <code>CHAR</code> длина поля постоянна и задается при создании таблицы.
Эта длина может принимать любое значение между <code>1</code> и <code>255</code> (что же касается
версии MySQL 3.23, то в ней длина столбца <code>CHAR</code> может быть от <code>0</code> до <code>255</code>).
Величины типа <code>CHAR</code> при хранении дополняются справа пробелами до заданной
длины. Эти концевые пробелы удаляются при извлечении хранимых величин.

</P>
<P>
Величины в столбцах <code>VARCHAR</code> представляют собой строки переменной длины.
Так же как и для столбцов <code>CHAR</code>, можно задать столбец <code>VARCHAR</code> любой длины
между <code>1</code> и <code>255</code>. Однако, в противоположность <code>CHAR</code>, при хранении величин типа
<code>VARCHAR</code> используется только то количество символов, которое необходимо,
плюс один байт для записи длины. Хранимые величины пробелами не
дополняются, наоборот, концевые пробелы при хранении удаляются (описанный
процесс удаления пробелов отличается от предусмотренного спецификацией
ANSI  SQL).

</P>
<P>
Если задаваемая в столбце <code>CHAR</code> или <code>VARCHAR</code> величина превосходит
максимально допустимую длину столбца, то эта величина соответствующим
образом усекается.

</P>
<P>
Различие между этими двумя типами столбцов в представлении результата
хранения величин с разной длиной строки в столбцах <code>CHAR(4)</code> и
<code>VARCHAR(4)</code> проиллюстрировано следующей таблицей:

</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Величина</strong> </TD><TD> <code>CHAR(4)</code> </TD><TD> <strong>Требуемая память</strong> </TD><TD> <code>VARCHAR(4)</code> </TD><TD> <strong>Требуемая память</strong>
</TD></TR>
<TR><TD><code>''</code> </TD><TD> <code>'    '</code> </TD><TD> 4 байта </TD><TD> <code>''</code> </TD><TD> 1 байт
</TD></TR>
<TR><TD><code>'ab'</code> </TD><TD> <code>'ab  '</code> </TD><TD> 4 байта </TD><TD> <code>'ab'</code> </TD><TD> 3 байта
</TD></TR>
<TR><TD><code>'abcd'</code> </TD><TD> <code>'abcd'</code> </TD><TD> 4 байта </TD><TD> <code>'abcd'</code> </TD><TD> 5 байтов
</TD></TR>
<TR><TD><code>'abcdefgh'</code> </TD><TD> <code>'abcd'</code> </TD><TD> 4 байта </TD><TD> <code>'abcd'</code> </TD><TD> 5 байтов
</TD></TR>
</TABLE>

<P>
Извлеченные из столбцов <code>CHAR(4)</code> и <code>VARCHAR(4)</code> величины в каждом случае
будут одними и теми же, поскольку при извлечении концевые пробелы из
столбца CHAR удаляются.

</P>
<P>
Если при создании таблицы не был задан атрибут <code>BINARY</code> для столбцов, то
величины в столбцах типа <code>CHAR</code> и <code>VARCHAR</code> сортируются и сравниваются без
учета регистра. При задании атрибута <code>BINARY</code> величины в столбце сортируются
и сравниваются с учетом регистра в соответствии с порядком таблицы ASCII
на том компьютере, где работает сервер MySQL. Атрибут <code>BINARY</code> не влияет на
процессы хранения или извлечения данных из столбца.

</P>
<P>
Атрибут <code>BINARY</code> является ``прилипчивым''. Это значит, что, если в
каком-либо выражении использовать столбец, помеченный как <code>BINARY</code>, то
сравнение всего выражения будет выполняться как сравнение величины типа
<code>BINARY</code>.

</P>
<P>
MySQL может без предупреждения изменить тип столбца <code>CHAR</code> или <code>VARCHAR</code> во
время создания таблицы. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>.

</P>


<H4><A NAME="BLOB" HREF="manual.ru_toc.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A></H4>

<P>
<A NAME="IDX1064"></A>
<A NAME="IDX1065"></A>

</P>
<P>
Тип данных <code>BLOB</code> представляет собой двоичный объект большого размера,
который может содержать переменное количество данных. Существуют 4
модификации этого типа - <code>TINYBLOB</code>, <code>BLOB</code>, <code>MEDIUMBLOB</code> и <code>LONGBLOB</code>,
отличающиеся только максимальной длиной хранимых величин.
See section <A HREF="manual.ru_Reference.html#Storage_requirements">6.2.6  Требования к памяти для различных типов столбцов</A>.

</P>
<P>
Тип данных <code>TEXT</code> также имеет 4 модификации - <code>TINYTEXT</code>, <code>TEXT</code>, <code>MEDIUMTEXT</code> и
<code>LONGTEXT</code>, соответствующие упомянутым четырем типам <code>BLOB</code> и имеющие те же
максимальную длину и требования к объему памяти. Единственное различие
между типами <code>BLOB</code> и <code>TEXT</code> состоит в том, что сортировка и сравнение данных
выполняются с учетом регистра для величин <code>BLOB</code> и без учета регистра для
величин <code>TEXT</code>. Другими словами, <code>TEXT</code> - это независимый от регистра <code>BLOB</code>.

</P>
<P>
Если размер задаваемого в столбце <code>BLOB</code> или <code>TEXT</code> значения превосходит
максимально допустимую длину столбца, то это значение соответствующим
образом усекается.

</P>
<P>
В большинстве случаев столбец <code>TEXT</code> может рассматриваться как столбец
<code>VARCHAR</code> неограниченного размера. И, аналогично, <code>BLOB</code> - как столбец типа
<code>VARCHAR BINARY</code>. Различия при этом следующие:

</P>

<ul>
<LI>

Столбцы типов <code>BLOB</code> и <code>TEXT</code> могут индексироваться в версии MySQL 3.23.2
и более новых. Более старые версии MySQL не поддерживают индексацию
этих столбцов.

<LI>

В столбцах типов  <code>BLOB</code> и <code>TEXT</code> не производится удаление концевых
символов, как это делается для столбцов типа <code>VARCHAR</code>.

<A NAME="IDX1066"></A>
<A NAME="IDX1067"></A>
<A NAME="IDX1068"></A>
<LI>

Для столбцов <code>BLOB</code> и <code>TEXT</code> не может быть задан атрибут <code>DEFAULT</code> -
значения величин по умолчанию.
</ul>

<P>
В MyODBC величины типа <code>BLOB</code> определяются как <code>LONGVARBINARY</code> и величины типа
TEXT - как <code>LONGVARCHAR</code>.

</P>
<P>
Так как величины типов <code>BLOB</code> и <code>TEXT</code> могут быть чрезмерно большими, при их
использовании целесообразно предусмотреть некоторые ограничения:

</P>

<ul>
Чтобы обеспечить возможность использования команд <code>GROUP BY</code> или <code>ORDER 
BY</code> в столбце типа <code>BLOB</code> или <code>TEXT</code>, необходимо преобразовать значение
столбца в объект с фиксированной длиной. Обычно это делается с помощью
функции <code>SUBSTRING</code>. Например:


<pre>
mysql&#62; SELECT comment FROM tbl_name,SUBSTRING(comment,20) AS substr
    -&#62; ORDER BY substr;
</pre>

Если этого не сделать, то операция сортировки в столбце будет выполнена
только для первых байтов, количество которых задается параметром
<code>max_sort_length</code>. Значение по умолчанию величины <code>max_sort_length</code> равно
<code>1024</code>; это значение можно изменить, используя параметр <code>-O</code> сервера <code>mysqld</code>
при его запуске. Группировка выражения, включающего в себя величины <code>BLOB</code>
или <code>TEXT</code>, возможна при указании позиции столбца или использовании
псевдонима:


<pre>
mysql&#62; SELECT id,SUBSTRING(blob_col,1,100) FROM tbl_name GROUP BY 2;
mysql&#62; SELECT id,SUBSTRING(blob_col,1,100) AS b FROM tbl_name GROUP BY b;
</pre>

<LI>

Максимальный размер объекта типа <code>BLOB</code> или <code>TEXT</code> определяется его типом,
но наибольшее значение, которое фактически может быть передано между
клиентом и сервером, ограничено величиной доступной памяти и размером
буферов связи. Можно изменить размер буфера блока передачи, но сделать
это необходимо как на стороне сервера, так и на стороне клиента. 
See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.
</ul>

<P>
Следует учитывать, что внутренним представлением любой величины типа <code>BLOB</code>
или <code>TEXT</code> является отдельно размещенный объект - в противоположность всем
остальным типам столбцов, для которых память выделяется единовременно для
столбца при открытии таблицы.

</P>


<H4><A NAME="ENUM" HREF="manual.ru_toc.html#ENUM">6.2.3.3  Тип перечисления <code>ENUM</code></A></H4>

<P>
<A NAME="IDX1069"></A>

</P>
<P>
ENUM (перечисление) - это столбец, который может принимать значение из списка допустимых значений, явно перечисленных в спецификации столбца в момент создания таблицы. 

</P>
<P>
Этим значением также может быть пустая строка ("") или NULL при определенных условиях:

</P>

<ul>
<LI>

Если делается всавка некорректного значения в столбец ENUM (т.е. вставка строки, не перечисленной в списке допустимых), то вставляется пустая строка, что является указанием на ошибочное значение. Эта строка отличается от "обычной" пустой строки по тому признаку, что она имеет цифровое значение, равное 0. Об этом чуть ниже. 

<LI>

Если ENUM определяется как NULL, то тогда NULL тоже является допустимым значением столбца и значение по умолчанию - NULL. Если ENUM определяется как NOT NULL, то значением по умолчанию является первый элемент из списка допустимых значений.
</ul>

<P>
Каждая величина из допустимы имеет индекс: 

</P>

<ul>
<LI>

Значение из списка допустимых величин, определенных при создании таблицы нумеруются, начиная с 1.

<LI>

Индекс пустой ошибочной строки - 0. Это означает что вы можете использовать следующий SELECT для того, чтобы найти записи, в которые были вставлены некорректные значения ENUM: 


<pre>
mysql&#62; SELECT * FROM tbl_name WHERE enum_col=0;
</pre>

<LI>

Индекс значения NULL - NULL. 
</ul>

<P>
Например, столбец, определенный как ENUM("один", "два", "три") может иметь любую из перечисленных величин. Индекс каждой величины также известен: 

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Величина</strong> </TD><TD> <strong>Индекс</strong>
</TD></TR>
<TR><TD><code>NULL</code> </TD><TD> <code>NULL</code>
</TD></TR>
<TR><TD><code>""</code> </TD><TD> 0
</TD></TR>
<TR><TD><code>"один"</code> </TD><TD> 1
</TD></TR>
<TR><TD><code>"два"</code> </TD><TD> 2
</TD></TR>
<TR><TD><code>"три"</code> </TD><TD> 3
</TD></TR>
</TABLE>

<P>
Перечисление может иметь максимум 65535 элементов. 

</P>
<P>
Начиная с 3.23.51, оконечные пробелы автоматически удаляются из величин этого столбца  в момент создания таблицы. 

</P>
<P>
Регистр не играет роли, когда вы делаете вставку в столбец ENUM. Однако регистр значений, получаемых из этого столбца, совпадает с регистром в написании соответствующего значения, заданного во время создания таблицы. 

</P>
<P>
Если вы делаете выборку столбца ENUM в числовом контексте, возвращается индекс значения. Например, вы можете получить численное значение ENUM таким образом: 

</P>

<pre>
mysql&#62; SELECT enum_col+0 FROM tbl_name;
</pre>

<P>
Если вы вставляете число в столбец ENUM, это число воспринимается как индекс, и
в таблицу записывается соответствующее этому индексу значение перечисления.
(Однако, это не будет работать с LOAD DATA, который воспринимает все входящие
данные как строки.) Не рекомендуется сохранять числа в перечислении, т.к. это
может привести к излишней путаннице. 

</P>
<P>
Значения перечисления сортируются в соответствии с порядком, в котором
допустимые значения были заданы при создании таблицы. (Другими словами,
значения ENUM сортируются в соответствии с ихними индексами.) Например,
<code>"a"</code> в отсортированном выводе будет присутствовать раньше чем <code>"b"</code>
для <code>ENUM("a", "b")</code>, но <code>"b"</code> появится раньше <code>"a"</code> для
<code>ENUM("b","a")</code>. Пустые строки возвращаются перед непустыми строками, и
NULL-значения будут выведены в самую первую очередь. 

</P>
<P>
Для предотвращения неожиданностей, указывайте список <code>ENUM</code>  в алфавитном
порядке.  Вы также можете использовать <code>GROUP BY CONCAT(col)</code> чтобы
удостовериться, что столбец отсортирован в алфавитном порядке, а не по индексу.

</P>

<P>
Если вам нужно получить список возможных значения для столбца ENUM, вы должны вызвать 
<code>SHOW COLUMNS FROM имя_таблицы LIKE имя_столбца_enum</code> 
и проанализировать определение ENUM во втором столбце. 

</P>



<H4><A NAME="SET" HREF="manual.ru_toc.html#SET">6.2.3.4  Тип множества <code>SET</code></A></H4>

<P>
<A NAME="IDX1070"></A>

</P>
<P>
SET - это строковый тип, который может принимать ноль или более значений, каждое из которых
должно быть выбрано из списка допустимых значений, определенных при создании таблицы. Элементы 
множества SET разделяются запятыми. Как следствие, сами элементы множества не могут содержать 
запятых. 

</P>
<P>
Например, столбец, определенный как <code>SET("один", "два") NOT NULL</code>  может принимать
такие значения: 

</P>

<pre>
""
"один"
"два"
"один,два"
</pre>

<P>
Множество SET может иметь максимум 64 различных элемента. 

</P>
<P>
Начиная с 3.23.51, оконечные пробелы удаляются из значений множества SET 
в момент создания таблицы. 

</P>
<P>
MySQL сохраняет значения SET в численном виде, где младший бит сохраненной 
величины соответствует первому элементу множества. Если вы делаете выборку 
столбца SET в числовом контексте, полученное значение содержит соответствующим 
образом установленные биты, создающие значение столбца. Например, вы можете сделать
выборку численного значения SET-столбца таким образом: 

</P>

<pre>
mysql&#62; SELECT set_col+0 FROM tbl_name;
</pre>

<P>
Если делается вставка в столбец SET, биты, установленные в двоичном
представлении числа определяют элементы множества. Допустим, столбец определен как
<code>SET("a","b","c","d")</code>.  Тогда элементы имеют такие биты установленными: 

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><code>SET</code> <strong>элемент</strong> </TD><TD> <strong>числовое значение</strong> </TD><TD> <strong>двоичное значение</strong>
</TD></TR>
<TR><TD><code>a</code> </TD><TD> <code>1</code> </TD><TD> <code>0001</code>
</TD></TR>
<TR><TD><code>b</code> </TD><TD> <code>2</code> </TD><TD> <code>0010</code>
</TD></TR>
<TR><TD><code>c</code> </TD><TD> <code>4</code> </TD><TD> <code>0100</code>
</TD></TR>
<TR><TD><code>d</code> </TD><TD> <code>8</code> </TD><TD> <code>1000</code>
</TD></TR>
</TABLE>

<P>
Если вы вставляет значение <code>9</code> в этот столбец, это соответствует <code>1001</code> в двоичном представлении,
так что первый (<code>"a"</code>) и четвертый (<code>"d"</code>) элементы множества выбираются, что в результате дает <code>"a,d"</code>.

</P>
<P>
Для значения, содержащего более чем один элемент множестве, не играет никакой роли, в каком
порядке эти элементы перечисляются в момент вставки значения. Также не играет роли,
как много раз то или иное значение перечислено. Когда позже это значение выбирается, каждый
элемент будет присутствовать только единожды, и элементы будут перечислены в том порядке,
в котором они перечисляются в определении таблицы. Например, если столбец определен как
<code>SET("a","b","c","d")</code>, тогда <code>"a,d"</code>, <code>"d,a"</code>, и
<code>"d,a,a,d,d"</code> будут представлены как <code>"a,d"</code>.

</P>

<P>
Если вы вставляете в столбец SET некорректую величины, это значение будет проигнорировано. 

</P>
<P>
SET-значения сортируются в соответствии с числовым представлением. NULL-значения идут в первую очередь.

</P>
<P>
Обычно, следует выполнять <code>SELECT</code> для  SET-столбца, используя оператор <code>LIKE</code> или функцию <code>FIND_IN_SET()</code>:

</P>

<pre>
mysql&#62; SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
mysql&#62; SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)&#62;0;
</pre>

<P>
Но и такая форма также работает: 

</P>

<pre>
mysql&#62; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';
mysql&#62; SELECT * FROM tbl_name WHERE set_col &#38; 1;
</pre>

<P>
Первый оператор в каждом примере делает выборку точного значения. Второй оператор делает 
выборку значений, содержащих первого элемента множества. 

</P>
<P>
Если вам нужно получить все возможные значения для столбца SET, вам следует вызвать
<code>SHOW COLUMNS FROM table_name LIKE set_column_name</code> 
и проанализировать SET-определение во втором столбце.

</P>


<H3><A NAME="Choosing_types" HREF="manual.ru_toc.html#Choosing_types">6.2.4  Выбор правильного типа данных в столбце</A></H3>

<P>
<A NAME="IDX1071"></A>
<A NAME="IDX1072"></A>

</P>
<P>
Для того чтобы память использовалась наиболее эффективно, всегда следует
стараться применять тип данных, обеспечивающий максимальную точность.
Например, для величин в диапазоне между <code>1</code> и <code>99999</code> в целочисленном столбце
наилучшим типом будет <code>MEDIUMINT UNSIGNED</code>.

</P>
<P>
Часто приходится сталкиваться с такой проблемой, как точное представление
денежных величин. В MySQL для представления таких величин необходимо
использовать тип данных <code>DECIMAL</code>. Поскольку данные этого типа хранятся в
виде строки, потерь в точности не происходит. А в случаях, когда точность
не имеет слишком большого значения, вполне подойдет и тип данных <code>DOUBLE</code>.

</P>
<P>
Если же требуется высокая точность, всегда можно выполнить конвертирование
в тип данных с фиксированной точкой. Такие данные хранятся в виде <code>BIGINT</code>.
Это позволяет выполнять все вычисления с ними как с целыми числами, а
впоследствии при необходимости результаты можно преобразовать обратно в
величины с плавающей точкой.

</P>


<H3><A NAME="Other-vendor_column_types" HREF="manual.ru_toc.html#Other-vendor_column_types">6.2.5  Использование типов столбцов из других баз данных</A></H3>

<P>
<A NAME="IDX1073"></A>
<A NAME="IDX1074"></A>
<A NAME="IDX1075"></A>

</P>
<P>
Чтобы облегчить использование SQL-кода, написанного для баз данных других
поставщиков, в MySQL установлено соответствие типов столбцов, как показано
в следующей таблице. Это соответствие упрощает применение описаний таблиц
баз данных других поставщиков в MySQL:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип иного поставщика</strong> </TD><TD> <strong>Тип MySQL</strong>
</TD></TR>
<TR><TD><code>BINARY(NUM)</code> </TD><TD> <code>CHAR(NUM) BINARY</code>
</TD></TR>
<TR><TD><code>CHAR VARYING(NUM)</code> </TD><TD> <code>VARCHAR(NUM)</code>
</TD></TR>
<TR><TD><code>FLOAT4</code> </TD><TD> <code>FLOAT</code>
</TD></TR>
<TR><TD><code>FLOAT8</code> </TD><TD> <code>DOUBLE</code>
</TD></TR>
<TR><TD><code>INT1</code> </TD><TD> <code>TINYINT</code>
</TD></TR>
<TR><TD><code>INT2</code> </TD><TD> <code>SMALLINT</code>
</TD></TR>
<TR><TD><code>INT3</code> </TD><TD> <code>MEDIUMINT</code>
</TD></TR>
<TR><TD><code>INT4</code> </TD><TD> <code>INT</code>
</TD></TR>
<TR><TD><code>INT8</code> </TD><TD> <code>BIGINT</code>
</TD></TR>
<TR><TD><code>LONG VARBINARY</code> </TD><TD> <code>MEDIUMBLOB</code>
</TD></TR>
<TR><TD><code>LONG VARCHAR</code> </TD><TD> <code>MEDIUMTEXT</code>
</TD></TR>
<TR><TD><code>MIDDLEINT</code> </TD><TD> <code>MEDIUMINT</code>
</TD></TR>
<TR><TD><code>VARBINARY(NUM)</code> </TD><TD> <code>VARCHAR(NUM) BINARY</code>
</TD></TR>
</TABLE>

<P>
Соотнесение типов столбцов происходит во время создания таблицы. При
создании таблицы с типами столбцов, которые используются другими
поставщиками, после запуска команды <code>DESCRIBE имя_таблицы</code> выдается структура
данной таблицы с применением принятых в MySQL эквивалентных типов.

</P>


<H3><A NAME="Storage_requirements" HREF="manual.ru_toc.html#Storage_requirements">6.2.6  Требования к памяти для различных типов столбцов</A></H3>

<P>
<A NAME="IDX1076"></A>
<A NAME="IDX1077"></A>

</P>
<P>
Требования к объему памяти для столбцов каждого типа, поддерживаемого
MySQL, перечислены ниже по категориям.

</P>
<P>
<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>

</P>
<P>
Требования к памяти для числовых типов

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип столбца</strong> </TD><TD> <strong>Требуемая память</strong>
</TD></TR>
<TR><TD><code>TINYINT</code> </TD><TD> 1 byte
</TD></TR>
<TR><TD><code>SMALLINT</code> </TD><TD> 2 байта
</TD></TR>
<TR><TD><code>MEDIUMINT</code> </TD><TD> 3 байта
</TD></TR>
<TR><TD><code>INT</code> </TD><TD> 4 байта
</TD></TR>
<TR><TD><code>INTEGER</code> </TD><TD> 4 байта
</TD></TR>
<TR><TD><code>BIGINT</code> </TD><TD> 8 байтов
</TD></TR>
<TR><TD><code>FLOAT(X)</code> </TD><TD> 4, если X &#60;= 24 или 8, если 25 &#60;= X &#60;= 53
</TD></TR>
<TR><TD><code>FLOAT</code> </TD><TD> 4 байта
</TD></TR>
<TR><TD><code>DOUBLE</code> </TD><TD> 8 байтов
</TD></TR>
<TR><TD><code>DOUBLE PRECISION</code> </TD><TD> 8 байтов
</TD></TR>
<TR><TD><code>REAL</code> </TD><TD> 8 байтов
</TD></TR>
<TR><TD><code>DECIMAL(M,D)</code> </TD><TD> <code>M+2</code> байт, если D &#62; 0, <code>M+1</code> байт, если D = 0 (<code>D</code>+2, если <code>M &#60; D</code>)
</TD></TR>
<TR><TD><code>NUMERIC(M,D)</code> </TD><TD> <code>M+2</code> байт, если D &#62; 0, <code>M+1</code> байт, если D = 0 (<code>D</code>+2, если <code>M &#60; D</code>)
</TD></TR>
</TABLE>

<P>
<A NAME="IDX1080"></A>
<A NAME="IDX1081"></A>
<A NAME="IDX1082"></A>
<A NAME="IDX1083"></A>

</P>
<P>
Требования к памяти для типов даты и времени

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип столбца</strong> </TD><TD> <strong>Требуемая память</strong>
</TD></TR>
<TR><TD><code>DATE</code> </TD><TD> 3 байта
</TD></TR>
<TR><TD><code>DATETIME</code> </TD><TD> 8 байтов
</TD></TR>
<TR><TD><code>TIMESTAMP</code> </TD><TD> 4 байта
</TD></TR>
<TR><TD><code>TIME</code> </TD><TD> 3 байта
</TD></TR>
<TR><TD><code>YEAR</code> </TD><TD> 1 байт
</TD></TR>
</TABLE>

<P>
Требования к памяти для символьных типов

</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип столбца</strong> </TD><TD> <strong>Требуемая память</strong>
</TD></TR>
<TR><TD><code>CHAR(M)</code> </TD><TD> <code>M</code> байт, <code>1 &#60;= M &#60;= 255</code>
</TD></TR>
<TR><TD><code>VARCHAR(M)</code> </TD><TD> <code>L</code>+1 байт, где <code>L &#60;= M</code> и <code>1 &#60;= M &#60;= 255</code>
</TD></TR>
<TR><TD><code>TINYBLOB</code>, <code>TINYTEXT</code> </TD><TD> <code>L</code>+1 байт, где <code>L</code> &#60; 2^8
</TD></TR>
<TR><TD><code>BLOB</code>, <code>TEXT</code> </TD><TD> <code>L</code>+2 байт, где <code>L</code> &#60; 2^16
</TD></TR>
<TR><TD><code>MEDIUMBLOB</code>, <code>MEDIUMTEXT</code> </TD><TD> <code>L</code>+3 байт, где <code>L</code> &#60; 2^24
</TD></TR>
<TR><TD><code>LONGBLOB</code>, <code>LONGTEXT</code> </TD><TD> <code>L</code>+4 байт, где <code>L</code> &#60; 2^32
</TD></TR>
<TR><TD><code>ENUM('value1','value2',...)</code> </TD><TD> 1 или 2 байт, в зависимости от количества перечисляемых величин (максимум 65535)
</TD></TR>
<TR><TD><code>SET('value1','value2',...)</code> </TD><TD> 1, 2, 3, 4 или 8 байт, в зависимости от количества элементов множества (максимум 64)
</TD></TR>
</TABLE>

<P>
<A NAME="IDX1084"></A>
<A NAME="IDX1085"></A>
<A NAME="IDX1086"></A>
<code>VARCHAR</code>, <code>BLOB</code> и <code>TEXT</code> являются типами данных с переменной длиной строки,
для таких типов требования к памяти в общем случае определяются реальным
размером величин в столбце (представлен символом <code>L</code> в приведенной выше
таблице), а не максимально возможным для данного типа размером. Например,
столбец <code>VARCHAR(10)</code> может содержать строку с максимальной длиной <code>10</code>
символов. Реально требуемый объем памяти равен длине строки (<code>L</code>) плюс 1
байт для записи длины строки. Для строки <code>'abcd'</code>  <code>L</code> равно 4 и требуемый
объем памяти равен 5 байтов.

</P>
<P>
В случае типов данных <code>BLOB</code> и <code>TEXT</code> требуется 1, 2, 3 или 4 байта для записи
длины значения данного столбца в зависимости от максимально возможной
длины для данного типа. See section <A HREF="manual.ru_Reference.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A>.

</P>
<P>
Если таблица включает в себя столбец какого-либо типа с переменной длиной
строки, то формат записи также будет переменной длины. Следует учитывать,
что при создании таблицы MySQL может при определенных условиях
преобразовать тип столбца с переменной длиной в тип с постоянной длиной
строки или наоборот. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>.

</P>
<P>
<A NAME="IDX1087"></A>
Размер объекта <code>ENUM</code> определяется количеством различных перечисляемых 
величин. Один байт используется для перечисления до <code>255</code> возможных величин.
Используя два байта, можно перечислить до <code>65535</code> величин. See section <A HREF="manual.ru_Reference.html#ENUM">6.2.3.3  Тип перечисления <code>ENUM</code></A>.

</P>
<P>
<A NAME="IDX1088"></A>
Размер объекта <code>SET</code> определяется количеством различных элементов
множества.  Если это количество равно <code>N</code>, то размер объекта вычисляется
по формуле <code>(N+7)/8</code> и полученное число округляется до <code>1</code>, <code>2</code>,
<code>3</code>, <code>4</code> или <code>8</code> байтов.  Множество <code>SET</code> может иметь
максимум <code>64</code> элемента. See section <A HREF="manual.ru_Reference.html#SET">6.2.3.4  Тип множества <code>SET</code></A>.

</P>
<P>
<A NAME="IDX1089"></A>
Максимальный размер записи в MyISAM составляет 65534 байтов. Каждый <code>BLOB</code> или
<code>TEXT</code>-столбец засчитывается здесь как 5-9 байтов. 

</P>


<H2><A NAME="Functions" HREF="manual.ru_toc.html#Functions">6.3  Функции, используемые в операторах <code>SELECT</code> и <code>WHERE</code></A></H2>

<P>
<A NAME="IDX1090"></A>

</P>
<P>
В команде SQL выражение <code>SELECT</code>  или определение  <code>WHERE</code> могут включать в
себя любое выражение, в котором используются описанные ниже функции.

</P>
<P>
Выражение, содержащее <code>NULL</code>, всегда будет давать в результате величину
<code>NULL</code>, если иное не оговорено в документации для операторов и функций,
задействованных в данном выражении.

</P>
<P>
<strong>Примечание:</strong> между именем функции и следующими за ним скобками не должно
быть пробелов. Это поможет синтаксическому анализатору MySQL отличать
вызовы функций от ссылок на таблицы или столбцы, имена которых случайно
окажутся теми же, что и у функций. Однако допускаются пробелы до или после
аргументов.

</P>
<P>
Если нужно, чтобы в MySQL допускались пробелы после имени функции, следует
запустить <code>mysqld</code> с параметром <code>--ansi</code> или использовать <code>CLIENT_IGNORE_SPACE</code>
в <code>mysql_connect()</code>, но в этом случае все имена функций станут
зарезервированными словами. See section <A HREF="manual.ru_Introduction.html#ANSI_mode">1.9.2  Запуск MySQL в режиме ANSI</A>.

</P>
<P>
В целях упрощения в данной документации результат выполнения программы
<code>mysql</code> в примерах представлен в сокращенной форме. Таким образом вывод:

</P>

<pre>
mysql&#62; SELECT MOD(29,9);
1 rows in set (0.00 sec)

+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
</pre>

<P>
будет представлен следующим образом:

</P>

<pre>
mysql&#62; SELECT MOD(29,9);
        -&#62; 2
</pre>



<H3><A NAME="Non-typed_Operators" HREF="manual.ru_toc.html#Non-typed_Operators">6.3.1  Операторы и функции общего назначения</A></H3>



<H4><A NAME="Parentheses" HREF="manual.ru_toc.html#Parentheses">6.3.1.1  Круглые скобки</A></H4>

<P>
<A NAME="IDX1091"></A>
<A NAME="IDX1092"></A>

</P>
<P>
<A NAME="IDX1093"></A>
<A NAME="IDX1094"></A>

</P>


<pre>
( ... )
</pre>

<P>
Круглые скобки используются для задания порядка вычислений в выражении.
Например:

</P>


<pre>
mysql&#62; SELECT 1+2*3;
        -&#62; 7
mysql&#62; SELECT (1+2)*3;
        -&#62; 9
</pre>



<H4><A NAME="Comparison_Operators" HREF="manual.ru_toc.html#Comparison_Operators">6.3.1.2  Операторы сравнения</A></H4>

<P>
<A NAME="IDX1095"></A>

</P>
<P>
<A NAME="IDX1096"></A>

</P>
<P>
Операторы сравнения дают в результате величину <code>1</code> (истина, TRUE), <code>0</code> (ложь, FALSE) или
<code>NULL</code>. Эти функции работают как с числами, так и со строками. Строки при
необходимости автоматически преобразуются в числа, а числа - в строки (как
в Perl).

</P>
<P>
Операции сравнения в MySQL выполняются по следующим правилам:

</P>

<ul>
<LI>

Если один или оба аргумента - <code>NULL</code>, то и результат сравнения будет
<code>NULL</code>. Справедливо для всех операторов кроме <code>&#60;=&#62;</code>.

<LI>

Если оба аргумента в операторе сравнения являются строками, то они
сравниваются как строки.

<LI>

Если оба аргумента - целые числа, то они сравниваются как целые числа.

<LI>

Шестнадцатеричные величины, если они не сравниваются с числом,
трактуются как строки с двоичными данными.

<LI>

<A NAME="IDX1097"></A>
<A NAME="IDX1098"></A>
Если один из аргументов представляет собой столбец типа <code>TIMESTAMP</code> или
<code>DATETIME</code>, а второй аргумент - константа, то константа перед
выполнением сравнения преобразуется к типу <code>TIMESTAMP</code>. Это сделано для
лучшей совместимости с ODBC.

<LI>

Во всех других случаях аргументы сравниваются как действительные числа
с плавающей точкой.
</ul>

<P>
По умолчанию сравнение строк производится без учета регистра символов с
использованием текущего набора символов (по умолчанию ISO-8859-1 Latin1,
который, к тому же, прекрасно подходит для английского языка).

</P>
<P>
Ниже приведены примеры, иллюстрирующие преобразование строк в числа для
операторов сравнения:

</P>

<pre>
mysql&#62; SELECT 1 &#62; '6x';
         -&#62; 0
mysql&#62; SELECT 7 &#62; '6x';
         -&#62; 1
mysql&#62; SELECT 0 &#62; 'x6';
         -&#62; 0
mysql&#62; SELECT 0 = 'x6';
         -&#62; 1
</pre>

<DL COMPACT>

<DT><code>=</code>
<DD>
<A NAME="IDX1099"></A>
 <A NAME="IDX1100"></A>
 
Равно:


<pre>
mysql&#62; SELECT 1 = 0;
        -&#62; 0
mysql&#62; SELECT '0' = 0;
        -&#62; 1
mysql&#62; SELECT '0.0' = 0;
        -&#62; 1
mysql&#62; SELECT '0.01' = 0;
        -&#62; 0
mysql&#62; SELECT '.01' = 0.01;
        -&#62; 1
</pre>

<A NAME="IDX1101"></A>
<A NAME="IDX1102"></A>
<A NAME="IDX1103"></A>
<A NAME="IDX1104"></A>
<DT><code>&#60;&#62;</code>
<DD>
<DT><code>!=</code>
<DD>
Не равно:


<pre>
mysql&#62; SELECT '.01' &#60;&#62; '0.01';
        -&#62; 1
mysql&#62; SELECT .01 &#60;&#62; '0.01';
        -&#62; 0
mysql&#62; SELECT 'zapp' &#60;&#62; 'zappp';
        -&#62; 1
</pre>

<A NAME="IDX1105"></A>
<A NAME="IDX1106"></A>
<DT><code>&#60;=</code>
<DD>
Меньше или равно:

<pre>
mysql&#62; SELECT 0.1 &#60;= 2;
        -&#62; 1
</pre>

<A NAME="IDX1107"></A>
<A NAME="IDX1108"></A>
<DT><code>&#60;</code>
<DD>
Меньше чем:

<pre>
mysql&#62; SELECT 2 &#60; 2;
        -&#62; 0
</pre>

<A NAME="IDX1109"></A>
<A NAME="IDX1110"></A>
<DT><code>&#62;=</code>
<DD>
Больше или равно:

<pre>
mysql&#62; SELECT 2 &#62;= 2;
        -&#62; 1
</pre>

<A NAME="IDX1111"></A>
<A NAME="IDX1112"></A>
<DT><code>&#62;</code>
<DD>
Больше чем:

<pre>
mysql&#62; SELECT 2 &#62; 2;
        -&#62; 0
</pre>

<A NAME="IDX1113"></A>
<A NAME="IDX1114"></A>
<DT><code>&#60;=&#62;</code>
<DD>
NULL-безопасное сравнение (равно):

<pre>
mysql&#62; SELECT 1 &#60;=&#62; 1, NULL &#60;=&#62; NULL, 1 &#60;=&#62; NULL;
        -&#62; 1 1 0
</pre>

<A NAME="IDX1115"></A>
<A NAME="IDX1116"></A>
<A NAME="IDX1117"></A>
<DT><code>IS NULL</code>
<DD>
<DT><code>IS NOT NULL</code>
<DD>
Тест для определения, является величина равной <code>NULL</code> или нет:

<pre>
mysql&#62; SELECT 1 IS NULL, 0 IS NULL, NULL IS NULL;
        -&#62; 0 0 1
mysql&#62; SELECT 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;
        -&#62; 1 1 0
</pre>

<A NAME="IDX1118"></A>
<A NAME="IDX1119"></A>
Для того, чтобы MySQL хорошо работал с другими программами, обеспечивается
поддержка следующих дополнительных возможностей для функции <code>IS NULL</code>:


<ul>
<LI>

Можно найти последнюю вставленную строку, используя выражение:


<pre>
SELECT * FROM tbl_name WHERE auto_col IS NULL
</pre>

Это свойство можно блокировать установкой <code>SQL_AUTO_IS_NULL=0</code>. 
See section <A HREF="manual.ru_MySQL_Optimisation.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A>.

<LI>

Для данных типа <code>NOT NULL DATE</code> и столбцов <code>DATETIME</code> можно найти особую
дату <code>0000-00-00</code>, используя выражение:


<pre>
SELECT * FROM tbl_name WHERE date_column IS NULL
</pre>

Это необходимо для работы некоторых приложений  ODBC (так как ODBC не
поддерживает значение даты <code>0000-00-00</code>).
</ul>

<A NAME="IDX1120"></A>
<DT><code>expr BETWEEN min AND max</code>
<DD>
Если величина выражения expr больше или равна заданному значению <code>min</code> и
меньше или равна заданному значению <code>max</code>, то функция <code>BETWEEN</code> возвращает <code>1</code>,
в противном случае - <code>0</code>. Это эквивалентно выражению (<code>min &#60;= expr AND expr
&#60;= max</code>), в котором все аргументы представлены одним и тем же типом данных.
В противном случае имеет место быть преобразование типов так, как сказано выше,
но применительно ко всем трем аргументами. <strong>Внимание:</strong> до 4.0.5 аргументы
приводились к типу <code>expr</code>. 


<pre>
mysql&#62; SELECT 1 BETWEEN 2 AND 3;
        -&#62; 0
mysql&#62; SELECT 'b' BETWEEN 'a' AND 'c';
        -&#62; 1
mysql&#62; SELECT 2 BETWEEN 2 AND '3';
        -&#62; 1
mysql&#62; SELECT 2 BETWEEN 2 AND 'x-3';
        -&#62; 0
</pre>

<A NAME="IDX1121"></A>
<DT><code>expr NOT BETWEEN min AND max</code>
<DD>
То же справедливо и для функции <code>NOT (expr BETWEEN min AND max)</code>.

<A NAME="IDX1122"></A>
<DT><code>expr IN (value,...)</code>
<DD>
Возвращает <code>1</code>, если выражение expr равно любой величине из списка <code>IN</code>,
иначе - <code>0</code>. Если все величины - константы, то они оцениваются в
соответствии с типом выражения expr и сортируются. Поиск элемента в
этом случае производится методом логического поиска. Это означает, что
функция <code>IN</code> является очень быстрой, если список значений <code>IN</code> состоит
полностью из констант. Если expr является зависимым от регистра
строковым выражением, то сравнение строк производится с учетом
регистра:


<pre>
mysql&#62; SELECT 2 IN (0,3,5,'wefwf');
        -&#62; 0
mysql&#62; SELECT 'wefwf' IN (0,3,5,'wefwf');
        -&#62; 1
</pre>

Начиная с 4.1 (в соответствии со стандартом SQL-99), <code>IN</code> возвращает
<code>NULL</code> не только если выражение в левой части является <code>NULL</code>, но
также если не найдено соответствия в списке и одно из выражений в списке
является величиной <code>NULL</code>.

<A NAME="IDX1123"></A>
<DT><code>expr NOT IN (value,...)</code>
<DD>
То же справедливо и для функции <code>NOT (expr IN (value,...))</code>.

<A NAME="IDX1124"></A>
<DT><code>ISNULL(expr)</code>
<DD>
Если <code>expr</code> равно <code>NULL</code>, то <code>ISNULL()</code> возвращает <code>1</code>, в противном случае - <code>0</code>:


<pre>
mysql&#62; SELECT ISNULL(1+1);
        -&#62; 0
mysql&#62; SELECT ISNULL(1/0);
        -&#62; 1
</pre>

Обратите внимание: при сравнении величин <code>NULL</code> с использованием оператора <code>=</code>
всегда будет возвращаться значение <code>FALSE</code>!

<A NAME="IDX1125"></A>
<A NAME="IDX1126"></A>
<DT><code>COALESCE(list)</code>
<DD>
Возвращает первый в списке элемент со значением, не равным <code>NULL</code>:


<pre>
mysql&#62; SELECT COALESCE(NULL,1);
        -&#62; 1
mysql&#62; SELECT COALESCE(NULL,NULL,NULL);
        -&#62; NULL
</pre>

<A NAME="IDX1127"></A>
<DT><code>INTERVAL(N,N1,N2,N3,...)</code>
<DD>
Возвращает <code>0</code>, если <code>N &#60; N1</code>, и <code>1</code>, если <code>N &#60; N2</code>, и так далее. Все аргументы
трактуются как целые числа. Для корректной работы этой функции необходимо
условие <code>N1 &#60; N2 &#60; N3 &#60; ... &#60; Nn</code>. Это обусловлено тем, что используется
логический поиск (очень быстрый):


<pre>
mysql&#62; SELECT INTERVAL(23, 1, 15, 17, 30, 44, 200);
        -&#62; 3
mysql&#62; SELECT INTERVAL(10, 1, 10, 100, 1000);
        -&#62; 2
mysql&#62; SELECT INTERVAL(22, 23, 30, 44, 200);
        -&#62; 0
</pre>

</DL>

<P>
Если регистронезависимая строка сравнивается с помощью любого
стандартного оператора (<code>=,</code> <code>&#60;&#62;</code>, ..., но не <code>LIKE</code>), то конечные пустые символы (т.е. пробелы, табуляторы и переводы строк) игнорируются: 
игнорируется.

</P>

<pre>
mysql&#62; SELECT "a" ="A \n";
        -&#62; 1
</pre>



<H4><A NAME="Logical_Operators" HREF="manual.ru_toc.html#Logical_Operators">6.3.1.3  Логические операторы</A></H4>

<P>
<A NAME="IDX1128"></A>
<A NAME="IDX1129"></A>

</P>
<P>
В SQL, все логические операторы возвращают 
TRUE (ИСТИНА), FALSE (ЛОЖЬ) или NULL (UNKNOWN, неизвестно).
В MySQL это реализовано как <code>1</code> (TRUE, ИСТИНА), <code>0</code> (FALSE, ЛОЖЬ)
или <code>NULL</code>. Это справедливо для большинства SQL СУБД, однако некоторые
возвращают любое положительное значение как значение TRUE. 

</P>
<DL COMPACT>

<DT><code>NOT</code>
<DD>
<A NAME="IDX1130"></A>
 <A NAME="IDX1131"></A>
 
<DT><code>!</code>
<DD>
Логическое НЕ. 
Возвращает <code>1</code>, если операнд равен <code>0</code>, <code>0</code> если операнд -
ненулевая величина, и <code>NOT NULL</code> возвращает <code>NULL</code>.


<pre>
mysql&#62; SELECT NOT 10;
        -&#62; 0
mysql&#62; SELECT NOT 0;
        -&#62; 1
mysql&#62; SELECT NOT NULL;
        -&#62; NULL
mysql&#62; SELECT ! (1+1);
        -&#62; 0
mysql&#62; SELECT ! 1+1;
        -&#62; 1
</pre>

Последний пример дает <code>1</code>, поскольку данное выражение вычисляется тем же
способом, что и <code>(!1)+1</code>.

<A NAME="IDX1132"></A>
<A NAME="IDX1133"></A>
<DT><code>AND</code>
<DD>
<DT><code>&#38;&</code>
<DD>
Логическое И. 
Дает <code>1</code> если все операнды ненулевые и не <code>NULL</code>, <code>0</code> если один
или более операндов равны <code>0</code>, или <code>NULL</code> в остальных случаях.


<pre>
mysql&#62; SELECT 1 &#38;& 1;
        -&#62; 1
mysql&#62; SELECT 1 &#38;& 0;
        -&#62; 0
mysql&#62; SELECT 1 &#38;& NULL;
        -&#62; NULL
mysql&#62; SELECT 0 &#38;& NULL;
        -&#62; 0
mysql&#62; SELECT NULL &#38;& 0;
        -&#62; 0
</pre>

Обратите внимание, что версии MySQL до 4.0.5 прекращали вычисление, встретив
первый <code>NULL</code>, вместо  того, чтобы продолжать вычисление выражений с целью
нахождения возможных значений <code>0</code>. Это означает, что в этих версиях
выражение <code>SELECT (NULL AND 0)</code> возвращает <code>NULL</code> вместо <code>0</code>.  В
4.0.5 код был переписан так, чтобы оптимизация сохранилась, но результат всегда
был таков, как требует того ANSI.

<A NAME="IDX1134"></A>
<A NAME="IDX1135"></A>
<DT><code>OR</code>
<DD>
<DT><code>||</code>
<DD>
Логическое ИЛИ. 
Возвращает <code>1</code>, если любой из операндов не <code>0</code>, <code>NULL</code> если один
из операндов <code>NULL</code>, в остальных случаях возвращает <code>0</code>. 


<pre>
mysql&#62; SELECT 1 || 1;
        -&#62; 1
mysql&#62; SELECT 1 || 0;
        -&#62; 1
mysql&#62; SELECT 0 || 0;
        -&#62; 0
mysql&#62; SELECT 0 || NULL;
        -&#62; NULL
mysql&#62; SELECT 1 || NULL;
        -&#62; 1
</pre>

<A NAME="IDX1136"></A>
<DT><code>XOR</code>
<DD>
Логический XOR (побитовое сложение по модулю 2) Возвращает <code>NULL</code> если
любой из операндов - <code>NULL</code>. Для не-<code>NULL</code> операндов, возвращает
<code>1</code> если нечетное количество операндов - не <code>0</code>.


<pre>
mysql&#62; SELECT 1 XOR 1;
        -&#62; 0
mysql&#62; SELECT 1 XOR 0;
        -&#62; 1
mysql&#62; SELECT 1 XOR NULL;
        -&#62; NULL
mysql&#62; SELECT 1 XOR 1 XOR 1;
        -&#62; 1
</pre>

<code>a XOR b</code> математически эквалиентно
<code>(a AND (NOT b)) OR ((NOT a) and b)</code>.

<code>XOR</code> был реализован в 4.0.2.

</DL>



<H4><A NAME="Control_flow_functions" HREF="manual.ru_toc.html#Control_flow_functions">6.3.1.4  Функции потока управления программой</A></H4>

<P>
<A NAME="IDX1137"></A>
<A NAME="IDX1138"></A>

</P>
<DL COMPACT>

<DT><code>IFNULL(expr1,expr2)</code>
<DD>
<A NAME="IDX1139"></A>
 <A NAME="IDX1140"></A>
 

Если <code>expr1</code> не равно <code>NULL</code>, то функция <code>IFNULL()</code> возвращает значение <code>expr1</code>, в
противном случае - <code>expr2</code>. В зависимости от контекста функция <code>IFNULL()</code> может
возвращать либо числовое, либо строковое значение:


<pre>
mysql&#62; SELECT IFNULL(1,0);
        -&#62; 1
mysql&#62; SELECT IFNULL(NULL,10);
        -&#62; 10
mysql&#62; SELECT IFNULL(1/0,10);
        -&#62; 10
mysql&#62; SELECT IFNULL(1/0,'yes');
        -&#62; 'yes'
</pre>

В 4.0.6 и раньше по умолчанию возвращал для <code>IFNULL(expr1,expr2)</code>
более "общее" из двух выражений в порядке <code>STRING</code>, <code>REAL</code> или
<code>INTEGER</code>.  Разница с более ранними версиями MySQL больше всего заметна
тогда, когда вы создаете таблицу, основанную на выражении или MySQL внутренне
сохраняет величину, основанную на выражении <code>IFNULL()</code> во временной
таблице. 


<pre>
CREATE TABLE foo SELECT IFNULL(1,"test") as test;
</pre>

В 4.0.6 тип для столбца "test" - <code>CHAR(4)</code> в то время как на более ранних типом был бы
<code>BIGINT</code>. 

<A NAME="IDX1141"></A>
<DT><code>NULLIF(expr1,expr2)</code>
<DD>
Если выражение <code>expr1 = expr2</code> истинно, то возвращает <code>NULL</code>, в противном
случае - <code>expr1</code>. Эквивалентна оператору <code>CASE WHEN x = y THEN NULL ELSE x
END</code>:


<pre>
mysql&#62; SELECT NULLIF(1,1);
        -&#62; NULL
mysql&#62; SELECT NULLIF(1,2);
        -&#62; 1
</pre>

Отметим, что если аргументы не равны, то величина <code>expr1</code> вычисляется в MySQL
дважды.

<A NAME="IDX1142"></A>
<DT><code>IF(expr1,expr2,expr3)</code>
<DD>
Если <code>expr1</code> равно значению ИСТИНА (<code>expr1 &#60;&#62; 0</code> и <code>expr1 &#60;&#62; NULL</code>), то функция
<code>IF()</code> возвращает <code>expr2</code>, в противном случае - <code>expr3</code>. В зависимости от
контекста функция <code>IF()</code> может возвращать либо числовое, либо строковое
значение:


<pre>
mysql&#62; SELECT IF(1&#62;2,2,3);
        -&#62; 3
mysql&#62; SELECT IF(1&#60;2,'yes','no');
        -&#62; 'yes'
mysql&#62; SELECT IF(STRCMP('test','test1'),'no','yes');
        -&#62; 'no'
</pre>

Если <code>expr2</code> или <code>expr3</code> являются <code>NULL</code> тогда результирующим
типом <code>IF()</code> будет тип, который не есть <code>NULL</code>. Это нововведение в
MySQL 4.0.3.

<code>expr1</code> вычисляется как целое число; это означает, что при исследовании
чисел с плавающей точкой или строковых величин в этой функции необходимо
использовать операцию сравнения:


<pre>
mysql&#62; SELECT IF(0.1,1,0);
        -&#62; 0
mysql&#62; SELECT IF(0.1&#60;&#62;0,1,0);
        -&#62; 1
</pre>

В первом случае из приведенных выше функция <code>IF(0.1)</code> возвращает <code>0</code>, так как
<code>0.1</code> преобразуется в целое число и в результате выполняется функция <code>IF(0)</code>.
Но это вовсе не то, что должно было бы получиться. Во втором случае
исходная величина с плавающей точкой исследуется при помощи оператора
сравнения, чтобы определить, является ли она ненулевой, и в качестве
аргумента функции используется результат сравнения - целое число. В версии
MySQL 3.23 возвращаемый по умолчанию тип функции <code>IF()</code> (это может иметь
значение при сохранении его во временной таблице) вычисляется, как
показано ниже:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Выражение</strong> </TD><TD> <strong>Возвращаемая величина</strong>
</TD></TR>
<TR><TD>expr2 или expr3 возвращает строку </TD><TD> строка
</TD></TR>
<TR><TD>expr2 or  expr3 возвращает величину с плавающей точкой </TD><TD> с плавающей точкой
</TD></TR>
<TR><TD>expr2 or  expr3 возвращает целое число </TD><TD> целое число
</TD></TR>
</TABLE>

Если <code>expr2</code> и <code>expr3</code> являются строками, и обе регистро-независимы,
то и результат является регистро-независимым (начиная с 3.23.51).

<A NAME="IDX1143"></A>
<DT><code>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END</code>
<DD>
<DT><code>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END</code>
<DD>
В первом варианте возвращается значение <code>result</code>, если <code>value=compare-value</code>.
Во втором - результат для первого указанного условия <code>condition</code>, если оно
истинно. Если соответствующая величина результата не определена, то
возвращается значение <code>result</code>, указанное после оператора <code>ELSE</code>. Если часть
<code>ELSE</code> в выражении отсутствует, возвращается <code>NULL</code>:


<pre>
mysql&#62; SELECT CASE 1 WHEN 1 THEN "one"
           WHEN 2 THEN "two" ELSE "more" END;
       -&#62; "one"
mysql&#62; SELECT CASE WHEN 1&#62;0 THEN "true" ELSE "false" END;
       -&#62; "true"
mysql&#62; SELECT CASE BINARY "B" WHEN "a" THEN 1 WHEN "b" THEN 2 END;
       -&#62; NULL
</pre>

</DL>

<P>
Тип возвращаемой величины будет такой же (<code>INTEGER</code>, <code>DOUBLE</code> или <code>STRING</code>),
как и у первой возвращаемой величины (выражение после первого оператора
<code>THEN</code>).

</P>


<H3><A NAME="String_functions" HREF="manual.ru_toc.html#String_functions">6.3.2  Строковые функции</A></H3>

<P>
<A NAME="IDX1144"></A>
<A NAME="IDX1145"></A>

</P>
<P>
Строковые функции возвращают <code>NULL</code>, если длина результата оказывается
больше, чем указано в значении серверного параметра <code>max_allowed_packet</code>.
See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

</P>
<P>
Для функций, работающих с позициями в строке, нумерация позиций начинается
с 1.

</P>
<DL COMPACT>

Возвращает значение ASCII-кода крайнего слева символа строки <code>str</code>; <code>0</code> если
<code>str</code> является пустой строкой;  <code>NULL</code>, если <code>str</code> равна <code>NULL</code>:


<pre>
mysql&#62; SELECT ASCII('2');
        -&#62; 50
mysql&#62; SELECT ASCII(2);
        -&#62; 50
mysql&#62; SELECT ASCII('dx');
        -&#62; 100
</pre>

См. также функцию <code>ORD()</code>.

<DT><code>ORD(str)</code>
<DD>
<A NAME="IDX1146"></A>
 <A NAME="IDX1147"></A>
 

Если крайний слева символ строки <code>str</code> представляет собой многобайтный
символ, то данная функция возвращает его код, который вычисляется на
основе ASCII-кодов составляющих его символов по формуле: ((первый байт
ASCII-кода)*256+(второй байт ASCII-кода))[*256+третий байт ASCII-кода...].
Если крайний слева символ не является многобайтным, то данная функция
возвращает то же значение, что и ASCII():


<pre>
mysql&#62; SELECT ORD('2');
        -&#62; 50
</pre>

<A NAME="IDX1148"></A>
<DT><code>CONV(N,from_base,to_base)</code>
<DD>
Преобразует числа из одной системы счисления в другую. Возвращает
строковое представление числа <code>N</code>, преобразованного из системы счисления с
основой <code>from_base</code> в систему счисления с основой <code>to_base</code>. Если хотя бы один
из аргументов равен <code>NULL</code>, то возвращается <code>NULL</code>. Аргумент <code>N</code>
интерпретируется как целое число, но может быть задан как целое число или
строка. Минимальное значение основы системы счисления равно <code>2</code>, а
максимальное - <code>36</code>. Если аргумент <code>to_base</code> представлен отрицательным числом,
то принимается, что <code>N</code> - число со знаком. В противном случае <code>N</code> трактуется
как беззнаковое число. Функция <code>CONV</code> работает с 64-битовой точностью:


<pre>
mysql&#62; SELECT CONV("a",16,2);
        -&#62; '1010'
mysql&#62; SELECT CONV("6E",18,8);
        -&#62; '172'
mysql&#62; SELECT CONV(-17,10,-18);
        -&#62; '-H'
mysql&#62; SELECT CONV(10+"10"+'10'+0xa,10,10);
        -&#62; '40'
</pre>

<A NAME="IDX1149"></A>
<DT><code>BIN(N)</code>
<DD>
Возвращает строку, представляющую двоичную величину <code>N</code>, где <code>N</code> - целое число
большого размера (<code>BIGINT</code>). Эквивалентна функции <code>CONV(N,10,2)</code>. Если <code>N</code> равно
<code>NULL</code>, возвращается <code>NULL</code>:


<pre>
mysql&#62; SELECT BIN(12);
        -&#62; '1100'
</pre>

<A NAME="IDX1150"></A>
<DT><code>OCT(N)</code>
<DD>
Возвращает строковое представление восьмеричного значения числа <code>N</code>, где <code>N</code> -
целое число большого размера. Эквивалентно функции <code>CONV(N,10,8)</code>. Если <code>N</code>
равно <code>NULL</code>, возвращается <code>NULL</code>:


<pre>
mysql&#62; SELECT OCT(12);
        -&#62; '14'
</pre>

<A NAME="IDX1151"></A>
<DT><code>HEX(N_or_S)</code>
<DD>
Если <code>N_OR_S</code> - число, то возвращается строковое представление
шестнадцатеричного числа <code>N</code>, где <code>N</code> - целое число большого размера (<code>BIGINT</code>).
Эквивалентна функции <code>CONV(N,10,16)</code>. Если <code>N_OR_S</code> - строка, то функция
возвращает шестнадцатеричную строку <code>N_OR_S</code>, где каждый символ в <code>N_OR_S</code>
конвертируется в 2 шестнадцатеричных числа. Является обратной по отношению
к строкам <code>0xff</code>.


<pre>
mysql&#62; SELECT HEX(255);
        -&#62; 'FF'
mysql&#62; SELECT HEX("abc");
        -&#62; 616263
mysql&#62; SELECT 0x616263;
        -&#62; "abc"
</pre>

<A NAME="IDX1152"></A>
<DT><code>CHAR(N,...)</code>
<DD>
<code>CHAR()</code> интерпретирует аргументы как целые числа и возвращает строку,
состоящую из символов, соответствующих ASCII-коду этих чисел. Величины
<code>NULL</code> пропускаются:


<pre>
mysql&#62; SELECT CHAR(77,121,83,81,'76');
        -&#62; 'MySQL'
mysql&#62; SELECT CHAR(77,77.3,'77.3');
        -&#62; 'MMM'
</pre>

<A NAME="IDX1153"></A>
<DT><code>CONCAT(str1,str2,...)</code>
<DD>
Возвращает строку, являющуюся результатом конкатенации аргументов. Если
хотя бы один из аргументов равен <code>NULL</code>, возвращается  <code>NULL</code>. Может принимать
более 2 аргументов. Числовой аргумент преобразуется в эквивалентную
строковую форму:


<pre>
mysql&#62; SELECT CONCAT('My', 'S', 'QL');
        -&#62; 'MySQL'
mysql&#62; SELECT CONCAT('My', NULL, 'QL');
        -&#62; NULL
mysql&#62; SELECT CONCAT(14.3);
        -&#62; '14.3'
</pre>

<A NAME="IDX1154"></A>
<DT><code>CONCAT_WS(separator, str1, str2,...)</code>
<DD>
Функция <code>CONCAT_WS</code>() обозначает <code>CONCAT With Separator</code> (конкатенация с
разделителем) и представляет собой специальную форму функции <code>CONCAT()</code>.
Первый аргумент является разделителем для остальных аргументов.
Разделитель, так же как и остальные аргументы, может быть строкой. Если
разделитель равен <code>NULL</code>, то результат будет <code>NULL</code>. Данная функция будет
пропускать все величины <code>NULL</code> и пустые строки, расположенные после
аргумента-разделителя. Разделитель будет добавляться между строками,
подлежащими конкатенации:


<pre>
mysql&#62; SELECT CONCAT_WS(",","First name","Second name","Last Name");
        -&#62; 'First name,Second name,Last Name'

mysql&#62; SELECT CONCAT_WS(",","First name",NULL,"Last Name");
        -&#62; 'First name,Last Name'
</pre>

<A NAME="IDX1155"></A>
<A NAME="IDX1156"></A>
<A NAME="IDX1157"></A>
<A NAME="IDX1158"></A>
<DT><code>LENGTH(str)</code>
<DD>
<DT><code>OCTET_LENGTH(str)</code>
<DD>
<DT><code>CHAR_LENGTH(str)</code>
<DD>
<DT><code>CHARACTER_LENGTH(str)</code>
<DD>
Возвращает длину строки str:


<pre>
mysql&#62; SELECT LENGTH('text');
        -&#62; 4

mysql&#62; SELECT OCTET_LENGTH('text');
        -&#62; 4
</pre>

Обратите внимание: для <code>CHAR_LENGTH()</code> и <code>CHARACTER_LENGTH()</code> многобайтные
символы учитываются только однажды.

<A NAME="IDX1159"></A>
<DT><code>BIT_LENGTH(str)</code>
<DD>
Возвращает длину строки <code>str</code> в битах:


<pre>
mysql&#62; SELECT BIT_LENGTH('text');
        -&#62; 32
</pre>

<A NAME="IDX1160"></A>
<A NAME="IDX1161"></A>
<DT><code>LOCATE(substr,str)</code>
<DD>
<DT><code>POSITION(substr IN str)</code>
<DD>
Возвращает позицию первого вхождения подстроки <code>substr</code> в строку <code>str</code>. Если
подстрока substr в строке <code>str</code>  отсутствует, возвращается <code>0</code>:


<pre>
mysql&#62; SELECT LOCATE('bar', 'foobarbar');
        -&#62; 4
mysql&#62; SELECT LOCATE('xbar', 'foobar');
        -&#62; 0
</pre>

Данная функция поддерживает многобайтные величины. В MySQL 3.23 эта
функция чувствительна к регистру, а в 4.0 она чувствительна к регистру
только в случае, если хотя бы один из аргументов является строкой с
двоичными данными.

<A NAME="IDX1162"></A>
<DT><code>LOCATE(substr,str,pos)</code>
<DD>
Возвращает позицию первого вхождения подстроки <code>substr</code> в строку <code>str</code>,
начиная с позиции <code>pos</code>. Если подстрока <code>substr</code> в строке <code>str</code>  отсутствует,
возвращается <code>0</code>:


<pre>
mysql&#62; SELECT LOCATE('bar', 'foobarbar',5);
        -&#62; 7
</pre>

Данная функция поддерживает многобайтные величины. В MySQL 3.23 эта
функция чувствительна к регистру, а в 4.0 она чувствительна к регистру,
только в случае, если хотя бы один из аргументов является строкой с
двоичными данными.

<A NAME="IDX1163"></A>
<DT><code>INSTR(str,substr)</code>
<DD>
Возвращает позицию первого вхождения подстроки <code>substr</code> в строку <code>str</code>. То же,
что и двухаргументная форма функции <code>LOCATE()</code>, за исключением перемены мест
аргументов:


<pre>
mysql&#62; SELECT INSTR('foobarbar', 'bar');
        -&#62; 4

mysql&#62; SELECT INSTR('xbar', 'foobar');
        -&#62; 0
</pre>

Данная функция поддерживает многобайтные величины. В MySQL 3.23 эта
функция чувствительна к регистру, а в 4.0 она чувствительна к регистру
только в случае, если хотя бы один из аргументов является строкой с
двоичными данными.

<A NAME="IDX1164"></A>
<DT><code>LPAD(str,len,padstr)</code>
<DD>
Возвращает строку <code>str</code>, которая дополняется слева строкой <code>padstr</code>, пока
строка <code>str</code> не достигнет длины <code>len</code> символов. Если строка <code>str</code> длиннее, чем
<code>len</code>, то она будет укорочена до <code>len</code> символов.


<pre>
mysql&#62; SELECT LPAD('hi',4,'??');
        -&#62; '??hi'
</pre>

<A NAME="IDX1165"></A>
<DT><code>RPAD(str,len,padstr)</code>
<DD>
Возвращает строку <code>str</code>, которая дополняется справа строкой <code>padstr</code>, пока
строка <code>str</code> не достигнет длины <code>len</code> символов. Если строка <code>str</code> длиннее, чем
<code>len</code>, то она будет укорочена до <code>len</code> символов.


<pre>
mysql&#62; SELECT RPAD('hi',5,'?');
        -&#62; 'hi???'
</pre>

<A NAME="IDX1166"></A>
<DT><code>LEFT(str,len)</code>
<DD>
Возвращает крайние слева <code>len</code> символов из строки <code>str</code>:


<pre>
mysql&#62; SELECT LEFT('foobarbar', 5);
        -&#62; 'fooba'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1167"></A>
<DT><code>RIGHT(str,len)</code>
<DD>
Возвращает крайние справа <code>len</code> символов из строки <code>str</code>:


<pre>
mysql&#62; SELECT RIGHT('foobarbar', 4);
        -&#62; 'rbar'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1168"></A>
<A NAME="IDX1169"></A>
<DT><code>SUBSTRING(str,pos,len)</code>
<DD>
<DT><code>SUBSTRING(str FROM pos FOR len)</code>
<DD>
<DT><code>MID(str,pos,len)</code>
<DD>
Возвращает подстроку длиной <code>len</code> символов из строки <code>str</code>, начиная от позиции
<code>pos</code>. Существует форма с оператором <code>FROM</code>, для которой используется
синтаксис ANSI  SQL92:


<pre>
mysql&#62; SELECT SUBSTRING('Quadratically',5,6);
        -&#62; 'ratica'
</pre>

Данная функция поддерживает многобайтные величины.

<DT><code>SUBSTRING(str,pos)</code>
<DD>
<DT><code>SUBSTRING(str FROM pos)</code>
<DD>
Возвращает подстроку из строки <code>str</code>, начиная с позиции <code>pos</code>:


<pre>
mysql&#62; SELECT SUBSTRING('Quadratically',5);
        -&#62; 'ratically'

mysql&#62; SELECT SUBSTRING('foobarbar' FROM 4);
        -&#62; 'barbar'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1170"></A>
<DT><code>SUBSTRING_INDEX(str,delim,count)</code>
<DD>
Возвращает подстроку из строки <code>str</code> перед появлениям <code>count</code> вхождений
разделителя <code>delim</code>. Если <code>count</code> положителен, то возвращается все, что
находится слева от последнего разделителя (считая слева). Если <code>count</code>
отрицателен, то возвращается все, что находится справа от последнего
разделителя (считая справа):


<pre>
mysql&#62; SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -&#62; 'www.mysql'

mysql&#62; SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -&#62; 'mysql.com'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1171"></A>
<DT><code>LTRIM(str)</code>
<DD>
Возвращает строку <code>str</code> с удаленными начальными пробелами:


<pre>
mysql&#62; SELECT LTRIM(' barbar');
        -&#62; 'barbar'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1172"></A>
<DT><code>RTRIM(str)</code>
<DD>
Возвращает строку <code>str</code> с удаленными конечными пробелами:


<pre>
mysql&#62; SELECT RTRIM('barbar ');
        -&#62; 'barbar'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1173"></A>
<DT><code>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</code>
<DD>
Возвращает строку <code>str</code> с удаленными всеми префиксами и/или суффиксами,
указанными в <code>remstr</code>. Если не указан ни один из спецификаторов <code>BOTH</code>,
<code>LEADING</code> или <code>TRAILING</code>, то подразумевается <code>BOTH</code>. Если аргумент <code>remstr</code> не
задан, то удаляются пробелы:


<pre>
mysql&#62; SELECT TRIM(' bar ');
        -&#62; 'bar'

mysql&#62; SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -&#62; 'barxxx'

mysql&#62; SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -&#62; 'bar'

mysql&#62; SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -&#62; 'barx'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1174"></A>
<DT><code>SOUNDEX(str)</code>
<DD>
Возвращает саундекс от str. 

<em>Soundex - ``идентификатор звучания строки''. Словосочетания 
``К скалам бурым'' и ``С каламбуроми'' должны давать одинаковый 
саундекс, т.к. на слух они звучат одинаково. Заметим, однако,
что этой функции для русского языка не существует. MySQL нуждается 
в ней, и если кто-то может предоставить алгоритм саундекса на русском 
языке - свяжитесь с нами. - Прим. переводчика.</em>

Две созвучные строки, создающие впечатление почти одинаковых, могут иметь
идентичные саундексы. Обычно стандартная саундекс-строка имеет длину 4
символа, но функция <code>SOUNDEX()</code> возвращает строку произвольной длины. Можно
использовать функцию <code>SUBSTRING()</code> для извлечения стандартного саундекса
строки из результата функции <code>SOUNDEX()</code>. В строке <code>str</code> игнорируются все
символы, не являющиеся буквами или цифрами. Все международные буквенные
символы, не входящие в диапазон <code>A-Z</code>, трактуются как гласные:


<pre>
mysql&#62; SELECT SOUNDEX('Hello');
        -&#62; 'H400'

mysql&#62; SELECT SOUNDEX('Quadratically');
        -&#62; 'Q36324'
</pre>

<A NAME="IDX1175"></A>
<DT><code>SPACE(N)</code>
<DD>
Возвращает строку, состоящую из <code>N</code> пробелов:


<pre>
mysql&#62; SELECT SPACE(6);
        -&#62; ' '
</pre>

<A NAME="IDX1176"></A>
<DT><code>REPLACE(str,from_str,to_str)</code>
<DD>
Возвращает строку  <code>str</code>, в которой все вхождения строки <code>from_str</code> заменены
на <code>to_str</code>:


<pre>
mysql&#62; SELECT REPLACE('www.mysql.com', 'w', 'Ww');
        -&#62; 'WwWwWw.mysql.com'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1177"></A>
<DT><code>REPEAT(str,count)</code>
<DD>
Возвращает строку, состоящую из строки <code>str</code>, повторенной <code>count</code> раз. Если
значение <code>count &#60;= 0</code>, возвращает пустую строку. Возвращает <code>NULL</code>, если <code>str</code>
или <code>count</code> равны <code>NULL</code>:


<pre>
mysql&#62; SELECT REPEAT('MySQL', 3);
        -&#62; 'MySQLMySQLMySQL'
</pre>

<A NAME="IDX1178"></A>
<DT><code>REVERSE(str)</code>
<DD>
Возвращает строку  <code>str</code> с обратным порядком символов:


<pre>
mysql&#62; SELECT REVERSE('abc');
        -&#62; 'cba'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1179"></A>
<DT><code>INSERT(str,pos,len,newstr)</code>
<DD>
Возвращает строку  <code>str</code>, в которой подстрока начиная с позиции <code>pos</code>, имеющая
длину <code>len</code> замещена на <code>newstr</code>:


<pre>
mysql&#62; SELECT INSERT('Quadratic', 3, 4, 'What');
        -&#62; 'QuWhattic'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1180"></A>
<DT><code>ELT(N,str1,str2,str3,...)</code>
<DD>
Возвращает <code>str1</code>, если <code>N = 1</code>, <code>str2</code>, если <code>N = 2</code>, и так далее. Если <code>N</code> меньше,
чем <code>1</code> или больше, чем число аргументов, возвращается <code>NULL</code>. Функция <code>ELT()</code>
является дополненительной по отношению к функции <code>FIELD()</code>:


<pre>
mysql&#62; SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'ej'

mysql&#62; SELECT ELT(4, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'foo'
</pre>

<A NAME="IDX1181"></A>
<DT><code>FIELD(str,str1,str2,str3,...)</code>
<DD>
Возвращает индекс строки <code>str</code> в списке <code>str1, str2, str3, ...</code>. Если строка
<code>str</code> не найдена, возвращается <code>0</code>. Функция <code>FIELD()</code> является дополнительной по
отношению к функции <code>ELT()</code>:


<pre>
mysql&#62; SELECT FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 2

mysql&#62; SELECT FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 0
</pre>

<A NAME="IDX1182"></A>
<DT><code>FIND_IN_SET(str,strlist)</code>
<DD>
Возвращает значение от <code>1</code> до <code>N</code>, если строка <code>str</code> присутствует в списке
<code>strlist</code>, состоящем из <code>N</code> подстрок. Список строк представляет собой строку,
состоящую из подстрок, разделенных символами <samp>`,'</samp>. Если первый аргумент
представляет собой строку констант, а второй является столбцом типа <code>SET</code>,
функция <code>FIND_IN_SET()</code> оптимизируется для использования двоичной
арифметики! Возвращает <code>0</code>, если <code>str</code> отсутствует в списке <code>strlist</code> или если
<code>strlist</code> является пустой строкой. Если один из аргументов равен <code>NULL</code>,
возвращается <code>0</code>. Данная функция не будет корректно работать, если первый
аргумент содержит символ <samp>`,'</samp>:


<pre>
mysql&#62; SELECT FIND_IN_SET('b','a,b,c,d');
        -&#62; 2
</pre>

<A NAME="IDX1183"></A>
<DT><code>MAKE_SET(bits,str1,str2,...)</code>
<DD>
Возвращает множество (строку, содержащую подстроки, разделенные символами
<samp>`,'</samp>), состоящее из строк, имеющих соответствующий бит в наборе <code>bits</code>.
Аргумент <code>str1</code> соответствует биту <code>0</code>, <code>str2</code> - биту <code>1</code>, и так далее. Нулевые
строки в наборах <code>str1</code>, <code>str2</code>, <code>...</code> не прибавляются к результату:


<pre>
mysql&#62; SELECT MAKE_SET(1,'a','b','c');
        -&#62; 'a'

mysql&#62; SELECT MAKE_SET(1 | 4,'hello','nice','world');
        -&#62; 'hello,world'

mysql&#62; SELECT MAKE_SET(0,'a','b','c');
        -&#62; ''
</pre>

<A NAME="IDX1184"></A>
<DT><code>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</code>
<DD>
Возвращает строку, где для каждому установленному биту в аргументе <code>bits</code>
соответствует строка  <code>on</code>, а каждому сброшенному биту - <code>off</code>.
Каждая строка отделена разделителем, указанным в параметре <code>separator</code> (по
умолчанию - <samp>`,'</samp>), причем используется только количество битов, заданное
аргументом <code>number_of_bits</code>  (по умолчанию 64), из всего количества,
указанного в <code>bits</code>:


<pre>
mysql&#62; SELECT EXPORT_SET(5,'Y','N',',',4)
        -&#62; Y,N,Y,N
</pre>

<A NAME="IDX1185"></A>
<A NAME="IDX1186"></A>
<DT><code>LCASE(str)</code>
<DD>
<DT><code>LOWER(str)</code>
<DD>
Возвращает строку <code>str</code>, в которой все символы переведены в нижний регистр
в соответствии с текущей установкой набора символов (по умолчанию -
ISO-8859-1 Latin1):


<pre>
mysql&#62; SELECT LCASE('QUADRATICALLY');
        -&#62; 'quadratically'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1187"></A>
<A NAME="IDX1188"></A>
<DT><code>UCASE(str)</code>
<DD>
<DT><code>UPPER(str)</code>
<DD>
Возвращает строку <code>str</code>, в которой все символы переведены в верхний регистр
в соответствии с текущей установкой набора символов (по умолчанию -
ISO-8859-1 Latin1):


<pre>
mysql&#62; SELECT UCASE('Hej');
        -&#62; 'HEJ'
</pre>

Данная функция поддерживает многобайтные величины.

<A NAME="IDX1189"></A>
<DT><code>LOAD_FILE(file_name)</code>
<DD>
Читает заданный файл и возвращает его содержимое в виде строки. Данный
файл должен находится на сервере, должен быть указан полный путь к этому
файлу и пользователь должен обладать привилегией <code>FILE</code>. Размер данного
файла должен быть меньше указанного в <code>max_allowed_packet</code> и файл должен
быть открыт для чтения для всех. Если файл не существует или не может быть
прочитан по одной из вышеупомянутых причин, то функция возвращает <code>NULL</code>:


<pre>
mysql&#62; UPDATE tbl_name 
       SET blob_column=LOAD_FILE("/tmp/picture")
       WHERE id=1;
</pre>

При использовании версии MySQL, отличной от 3.23, чтение файла
необходимо выполнять внутри вашего приложения и использовать команду
<code>INSERT</code> для внесения в базу данных информации, содержащейся в файле. Один
из путей реализации этого с использованием библиотеки <code>MySQL++</code> можно найти
на <a HREF="http://www.mysql.com/documentation/mysql++/mysql++-examples.html">http://www.mysql.com/documentation/mysql++/mysql++-examples.html</a>.

<A NAME="IDX1190"></A>
<DT><code>QUOTE(str)</code>
<DD>
Экранирует строку с тем, чтобы получить корректное значение для SQL-выражения. 
Строка заключается в одинарные кавычки, и каждое вхождение одинарной кавычки (<samp>`''</samp>),
обратного слеша (<samp>`\'</samp>), значения ASCII NUL и Control-Z экранируются обратным слешом. 
Если аргумент - <code>NULL</code>, то тогда результатом будет слово "NULL" без окружающих кавычек. 


<pre>
mysql&#62; SELECT QUOTE("Don't");
        -&#62; 'Don\'t!'
mysql&#62; SELECT QUOTE(NULL);
        -&#62; NULL
</pre>

</DL>

<P>
MySQL при необходимости автоматически конвертирует числа в строки и
наоборот:

</P>

<pre>
mysql&#62; SELECT 1+"1";
        -&#62; 2

mysql&#62; SELECT CONCAT(2,' test');
        -&#62; '2 test'
</pre>

<P>
Для преобразования числа в строку явным образом, необходимо передать его в
качестве аргумента функции <code>CONCAT()</code>.

</P>
<P>
Если строковая функция содержит в качестве аргумента строку с двоичными
данными, то и результирующая строка также будет строкой с двоичными
данными. При этом число, конвертированное в строку, воспринимается как
строка с двоичными данными. Это имеет значение только при выполнении
операций сравнения.

</P>



<H4><A NAME="String_comparison_functions" HREF="manual.ru_toc.html#String_comparison_functions">6.3.2.1  Функции сравнения строк</A></H4>

<P>
<A NAME="IDX1191"></A>
<A NAME="IDX1192"></A>

</P>
<P>
<A NAME="IDX1193"></A>
<A NAME="IDX1194"></A>

</P>
<P>
Обычно если при выполнении сравнения строк одно из выражений является
зависимым от регистра, то сравнение выполняется также с учетом регистра.

</P>
<DL COMPACT>

<DT><code>expr LIKE pat [ESCAPE 'escape-char']</code>
<DD>
<A NAME="IDX1195"></A>
 

Функция производит сравнение с шаблоном, используя операции сравнения
простых регулярных выражений в SQL. Возвращает <code>1</code> (ИСТИНА) или <code>0</code> (ЛОЖЬ).
Выражение <code>LIKE</code> предусматривает использование следующих двух шаблонных
символов в <code>pat</code>:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Символ</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>%</code> </TD><TD> Соответствует любому количеству символов, даже нулевых
</TD></TR>
<TR><TD><code>_</code> </TD><TD> Соответствует ровно одному символу
</TD></TR>
</TABLE>


<pre>
mysql&#62; SELECT 'David!' LIKE 'David_';
        -&#62; 1
mysql&#62; SELECT 'David!' LIKE '%D%v%';
        -&#62; 1
mysql&#62; select TRUNCATE(-1.999,1);
        -&#62; -1.9
</pre>

Начиная с MySQL 3.23.51 все числа округляются к нулю. 

Если <code>D</code> является негативным, то тогда вся часть числа округляется к нулю. 


<pre>
mysql&#62; select truncate(122,-2);
       -&#62; 100
</pre>

Если требуется исследовать литералы при помощи шаблонного символа, следует
предварить шаблонный символ экранирующим символом. Если экранирующий
символ конкретно не указывается, то подразумевается применение символа
<samp>`\'</samp>:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Строка</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>\%</code> </TD><TD> Соответствует одному символу <samp>`%'</samp>
</TD></TR>
<TR><TD><code>\_</code> </TD><TD> Соответствует одному символу <samp>`_'</samp>
</TD></TR>
</TABLE>


<pre>
mysql&#62; SELECT 'David!' LIKE 'David\_';
        -&#62; 0

mysql&#62; SELECT 'David_' LIKE 'David\_';
        -&#62; 1
</pre>

Для указания конкретного экранирующего символа используется выражение
<code>ESCAPE</code>:


<pre>
mysql&#62; SELECT 'David_' LIKE 'David|_' ESCAPE '|';
        -&#62; 1
</pre>

В следующих двух примерах показано, что сравнение строк производится с
учетом регистра, если ни один из операндов не является строкой с двоичными
данными:


<pre>
mysql&#62; SELECT 'abc' LIKE 'ABC';
        -&#62; 1
mysql&#62; SELECT 'abc' LIKE BINARY 'ABC';
        -&#62; 0
</pre>

В функции <code>LIKE</code> допускаются даже числовые выражения! (Это расширение MySQL
по сравнению с ANSI  SQL  LIKE.)


<pre>
mysql&#62; SELECT 10 LIKE '1%';
        -&#62; 1
</pre>

Примечание: поскольку в MySQL применяются правила экранирования в строках,
применяемые в языке C (например, <samp>`\n'</samp>), необходимо дублировать все символы
<samp>`\'</samp>, используемые в строках функции <code>LIKE</code>. Например, для поиска сочетания
символов <samp>`\n'</samp> его необходимо указать как  <samp>`\\n'</samp>. Чтобы выполнить поиск
символа <samp>`\'</samp>, он должен быть указан как <samp>`\\\\'</samp> (обратные слеши удаляются
дважды: сначала синтаксическим анализатором, а потом - при выполнении
сравнения с шаблоном, таким образом остается только один обратный слеш,
который и будет обрабатываться).

<A NAME="IDX1196"></A>
<DT><code>expr NOT LIKE pat [ESCAPE 'escape-char']</code>
<DD>
То же, что и <code>NOT (expr LIKE pat [ESCAPE 'escape-char'])</code>.

<A NAME="IDX1197"></A>
<DT><code>expr SOUNDS LIKE expr</code>
<DD>
Тоже самое что и <code>SOUNDEX(expr)=SOUNDEX(expr)</code> (доступно в версии 4.1 или новее). 

<A NAME="IDX1198"></A>
<A NAME="IDX1199"></A>
<A NAME="IDX1200"></A>
<A NAME="IDX1201"></A>
<DT><code>expr REGEXP pat</code>
<DD>
<DT><code>expr RLIKE pat</code>
<DD>
Выполняет сравнение строкового выражения <code>expr</code> с шаблоном <code>pat</code>. Шаблон может
представлять собой расширенное регулярное выражение. See section <A HREF="manual.ru_Regexp.html#Regexp">G  Регулярные выражения в MySQL</A>. Возвращает <code>1</code>, если <code>expr</code> соответствует <code>pat</code>, в
противном случае - <code>0</code>. Функция <code>RLIKE</code> является синонимом для <code>REGEXP</code>, она
предусмотрена для совместимости с mSQL. Примечание: поскольку в MySQL
используются правила экранирования в строках, применяемые в языке C
(например, <samp>`\n'</samp>), необходимо дублировать все символы <samp>`\'</samp>, используемые в
строках функции <code>REGEXP</code>. Что касается версии MySQL 3.23.4, функция <code>REGEXP</code>
является независимой от регистра для нормальных строк (т.е. строк не с
двоичными данными):


<pre>
mysql&#62; SELECT 'Monty!' REGEXP 'm%y%%';
        -&#62; 0

mysql&#62; SELECT 'Monty!' REGEXP '.*';
        -&#62; 1

mysql&#62; SELECT 'new*\n*line' REGEXP 'new\\*.\\*line';
        -&#62; 1

mysql&#62; SELECT "a" REGEXP "A", "a" REGEXP BINARY "A";
        -&#62; 1 0

mysql&#62; SELECT "a" REGEXP "^[a-d]";
        -&#62; 1
</pre>

В <code>REGEXP</code> и <code>RLIKE</code> используется текущий набор символов (ISO-8859-1 Latin1 по
умолчанию),

<A NAME="IDX1202"></A>
<DT><code>expr NOT REGEXP pat</code>
<DD>
<DT><code>expr NOT RLIKE pat</code>
<DD>
То же, что и <code>NOT (expr REGEXP pat)</code>.

<A NAME="IDX1203"></A>
<DT><code>STRCMP(expr1,expr2)</code>
<DD>
Функция <code>STRCMP()</code> возвращает: <code>0</code>, если строки идентичны, <code>-1</code> - если первый
аргумент меньше второго (в соответствии с имеющимся порядком сортировки),
и <code>1</code> - в остальных случаях:


<pre>
mysql&#62; SELECT STRCMP('text', 'text2');
        -&#62; -1

mysql&#62; SELECT STRCMP('text2', 'text');
        -&#62; 1

mysql&#62; SELECT STRCMP('text', 'text');
        -&#62; 0
</pre>

<A NAME="IDX1204"></A>
<DT><code>MATCH (col1,col2,...) AGAINST (expr)</code>
<DD>
<DT><code>MATCH (col1,col2,...) AGAINST (expr IN BOOLEAN MODE)</code>
<DD>
Функция <code>MATCH ... AGAINST()</code> используется для полнотекстового поиска и
возвращает величину релевантности - степень сходства между текстом в
столбцах <code>(col1,col2,...)</code> и запросом <code>expr</code>. Величина релевантности
представляет собой положительное число с плавающей точкой. Нулевая
релевантность означает отсутствие сходства. Функция <code>MATCH ... AGAINST()</code>
работает в версиях MySQL 3.23.23 или более поздних. Расширение <code>IN BOOLEAN
MODE</code> было добавлено в версии 4.0.1. Более подробное описание и примеры
использования приведены в разделе section <A HREF="manual.ru_Reference.html#Fulltext_Search">6.8  Полнотекстовый поиск в MySQL</A>.
</DL>



<H4><A NAME="Case_Sensitivity_Operators" HREF="manual.ru_toc.html#Case_Sensitivity_Operators">6.3.2.2  Чувствительность к регистру</A></H4>

<P>
<A NAME="IDX1205"></A>

</P>
<P>
<A NAME="IDX1206"></A>

</P>
<DL COMPACT>

<DT><code>BINARY</code>
<DD>
<A NAME="IDX1207"></A>
 

Оператор <code>BINARY</code> преобразует следующую за ним строку в строку с двоичными
данными. Это простой способ обеспечить сравнение в столбце с учетом
регистра, даже если данный столбец не определен как <code>BINARY</code> или <code>BLOB</code>:


<pre>
mysql&#62; SELECT "a" = "A";
        -&#62; 1

mysql&#62; SELECT BINARY "a" = "A";
        -&#62; 0
</pre>

<code>BINARY string</code> является сокращением для <code>CAST(string AS BINARY)</code>.
See section <A HREF="manual.ru_Reference.html#Cast_Functions">6.3.5  Функции приведения типов</A>. Оператор <code>BINARY</code> был введен в версии MySQL 3.23.0. Следует
учитывать, что при приведении индексированного столбца к типу <code>BINARY</code> 
MySQL в некоторых случаях не сможет эффективно использовать индексы.

Для сравнения двоичных данных типа <code>BLOB</code> без учета регистра данные с типом
<code>BLOB</code>  перед выполнением сравнения всегда можно конвертировать в верхний
регистр:


<pre>
SELECT 'A' LIKE UPPER(blob_col) FROM table_name;
</pre>

В скором времени мы планируем ввести преобразование между различными
кодировками, чтобы сделать сравнение строк еще более гибким.
</DL>



<H3><A NAME="Numeric_Functions" HREF="manual.ru_toc.html#Numeric_Functions">6.3.3  Числовые функции</A></H3>



<H4><A NAME="Arithmetic_functions" HREF="manual.ru_toc.html#Arithmetic_functions">6.3.3.1  Арифметические операции</A></H4>

<P>
В MySQL можно применять обычные арифметические операторы. Следует иметь в
виду, что если оба аргумента являются целыми числами, то при использовании
операторов <samp>`-'</samp>, <samp>`+'</samp> и <samp>`*'</samp> результат вычисляется с точностью <code>BIGINT</code> (64
бита). Если один из аргументов - беззнаковое целое число, а второй
аргумент - также целое число, то результат будет беззнаковым целым числом.
See section <A HREF="manual.ru_Reference.html#Cast_Functions">6.3.5  Функции приведения типов</A>.

</P>
<P>
<A NAME="IDX1208"></A>
<A NAME="IDX1209"></A>
<DL COMPACT>

<DT><code>+</code>
<DD>
<A NAME="IDX1210"></A>
 <A NAME="IDX1211"></A>
 

Сложение:

<pre>
mysql&#62; SELECT 3+5;
        -&#62; 8
</pre>

<A NAME="IDX1212"></A>
<A NAME="IDX1213"></A>
<DT><code>-</code>
<DD>
Вычитание:

<pre>
mysql&#62; SELECT 3-5;
        -&#62; -2
</pre>

<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>
<DT><code>*</code>
<DD>
Умножение:


<pre>
mysql&#62; SELECT 3*5;
        -&#62; 15

mysql&#62; SELECT 18014398509481984*18014398509481984.0;
        -&#62; 324518553658426726783156020576256.0

mysql&#62; SELECT 18014398509481984*18014398509481984;
        -&#62; 0
</pre>

В последнем выражении мы получим неверный результат, так как произведение
умножения целых чисел выходит за границы 64-битового диапазона для
вычислений с точностью <code>BIGINT</code>.

<A NAME="IDX1216"></A>
<A NAME="IDX1217"></A>
<DT><code>/</code>
<DD>
Деление:


<pre>
mysql&#62; SELECT 3/5;
        -&#62; 0.60
</pre>

Деление на ноль приводит к результату <code>NULL</code>:


<pre>
mysql&#62; SELECT 102/(1-1);
        -&#62; NULL
</pre>

Деление будет выполняться по правилам <code>BIGINT</code>-арифметики только в случае,
если эта операция представлена в контексте, где ее результат преобразуется
в <code>INTEGER</code>!

</DL>



<H4><A NAME="Mathematical_functions" HREF="manual.ru_toc.html#Mathematical_functions">6.3.3.2  Математические функции</A></H4>

<P>
<A NAME="IDX1218"></A>

</P>
<P>
Все математические функции в случае ошибки возвращают <code>NULL</code>.

</P>
<DL COMPACT>

<DT><code>-</code>
<DD>
<A NAME="IDX1219"></A>
 <A NAME="IDX1220"></A>
 <A NAME="IDX1221"></A>
 

Унарный минус. Изменяет знак аргумента:


<pre>
mysql&#62; SELECT - 2;
        -&#62; -2
</pre>

Необходимо учитывать, что если этот оператор используется с данными типа
<code>BIGINT</code>, возвращаемое значение также будет иметь тип <code>BIGINT</code>! Это означает,
что следует избегать использования оператора для целых чисел, которые
могут иметь величину <code>-2^63</code>!

<A NAME="IDX1222"></A>
<DT><code>ABS(X)</code>
<DD>
Возвращает абсолютное значение величины <code>X</code>:

<pre>
mysql&#62; SELECT ABS(2);
        -&#62; 2
mysql&#62; SELECT ABS(-32);
        -&#62; 32
</pre>

Эту функцию можно уверенно применять для величин типа <code>BIGINT</code>.

<A NAME="IDX1223"></A>
<DT><code>SIGN(X)</code>
<DD>
Возвращает знак аргумента в виде <code>-1</code>, <code>0</code> или <code>1</code>, в зависимости от того,
является ли <code>X</code> отрицательным, нулем или положительным:


<pre>
mysql&#62; SELECT SIGN(-32);
        -&#62; -1

mysql&#62; SELECT SIGN(0);
        -&#62; 0

mysql&#62; SELECT SIGN(234);
        -&#62; 1
</pre>

<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>
<DT><code>MOD(N,M)</code>
<DD>
<DT><code>%</code>
<DD>
Значение по модулю (подобно оператору <code>%</code> в C). Возвращает остаток от
деления <code>N</code> на <code>M</code>:


<pre>
mysql&#62; SELECT MOD(234, 10);
        -&#62; 4

mysql&#62; SELECT 253 % 7;
        -&#62; 1

mysql&#62; SELECT MOD(29,9);
        -&#62; 2
</pre>

Эту функцию можно уверенно применять для величин типа <code>BIGINT</code>.

<A NAME="IDX1226"></A>
<DT><code>FLOOR(X)</code>
<DD>
Возвращает наибольшее целое число, не превышающее <code>X</code>:


<pre>
mysql&#62; SELECT FLOOR(1.23);
        -&#62; 1

mysql&#62; SELECT FLOOR(-1.23);
        -&#62; -2
</pre>

Следует учитывать, что возвращаемая величина преобразуется в <code>BIGINT</code>!

<A NAME="IDX1227"></A>
<DT><code>CEILING(X)</code>
<DD>
Возвращает наименьшее целое число, не меньшее, чем <code>X</code>:


<pre>
mysql&#62; SELECT CEILING(1.23);
        -&#62; 2

mysql&#62; SELECT CEILING(-1.23);
        -&#62; -1
</pre>

Следует учитывать, что возвращаемая величина преобразуется в <code>BIGINT</code>!

<A NAME="IDX1228"></A>
<DT><code>ROUND(X)</code>
<DD>
Возвращает аргумент <code>X</code>, округленный до ближайшего целого числа:


<pre>
mysql&#62; SELECT ROUND(-1.23);
        -&#62; -1

mysql&#62; SELECT ROUND(-1.58);
        -&#62; -2

mysql&#62; SELECT ROUND(1.58);
        -&#62; 2
</pre>

Следует учитывать, что поведение функции <code>ROUND()</code> при значении аргумента,
равном середине между двумя целыми числами, зависит от конкретной
реализации библиотеки C. Округление может выполняться: к ближайшему
четному числу, всегда к ближайшему большему, всегда к ближайшему меньшему,
всегда быть направленным к нулю. Чтобы округление всегда происходило
только в одном направлении, необходимо использовать вместо данной хорошо
определенные функции, такие как <code>TRUNCATE()</code> или <code>FLOOR()</code>.

<A NAME="IDX1229"></A>
<DT><code>ROUND(X,D)</code>
<DD>
Возвращает аргумент <code>X</code>, округленный до числа с <code>D</code> десятичными знаками. Если
<code>D</code> равно <code>0</code>, результат будет представлен без десятичного знака или дробной
части:


<pre>
mysql&#62; SELECT ROUND(1.298, 1);
        -&#62; 1.3

mysql&#62; SELECT ROUND(1.298, 0);
        -&#62; 1
</pre>

<A NAME="IDX1230"></A>
<DT><code>EXP(X)</code>
<DD>
Возвращает значение <code>e</code> (основа натуральных логарифмов), возведенное в
степень <code>X</code>:


<pre>
mysql&#62; SELECT EXP(2);
        -&#62; 7.389056

mysql&#62; SELECT EXP(-2);
        -&#62; 0.135335
</pre>

<A NAME="IDX1231"></A>
<DT><code>LN(X)</code>
<DD>
Возвращает натуральный логарифм числа <code>X</code>: 

<pre>
mysql&#62; SELECT LN(2);
        -&#62; 0.693147
mysql&#62; SELECT LN(-2);
        -&#62; NULL
</pre>

Эта функция появилась в MySQL 4.0.3. Это синоним 
<code>LOG(X)</code>. 

<A NAME="IDX1232"></A>
<DT><code>LOG(B, X)</code>
<DD>
Если вызывается с одним параметром, возвращает натуральный логарифм числа <code>X</code>:


<pre>
mysql&#62; SELECT LOG(2);
        -&#62; 0.693147

mysql&#62; SELECT LOG(-2);
        -&#62; NULL
</pre>

Если вызывается с двумя параметрами, функция возвращает логарифм числа <code>X</code> по базе <code>B</code>:

<pre>
mysql&#62; SELECT LOG(2,65536);
        -&#62; 16.000000
mysql&#62; SELECT LOG(1,100);
        -&#62; NULL
</pre>

Опция указания базы логарифма появилась в MySQL 4.0.3. 
<code>LOG(B,X)</code> эквалиентно <code>LOG(X)/LOG(B)</code>.

<A NAME="IDX1233"></A>
<DT><code>LOG2(X)</code>
<DD>
Возвращает логарифм числа <code>X</code> по базе 2: 

<pre>
mysql&#62; SELECT LOG2(65536);
        -&#62; 16.000000
mysql&#62; SELECT LOG2(-100);
        -&#62; NULL
</pre>

Функция <code>LOG2()</code> полезна с тем, чтобы узнать, сколько бит число потребует для хранения. 
Эта функция добавлена в MySQL 4.0.3. 
В более старых версиях вызывайте вместо нее: <code>LOG(X)/LOG(2)</code> 

<A NAME="IDX1234"></A>
<DT><code>LOG10(X)</code>
<DD>
Возвращает десятичный логарифм числа <code>X</code>:


<pre>
mysql&#62; SELECT LOG10(2);
        -&#62; 0.301030

mysql&#62; SELECT LOG10(100);
        -&#62; 2.000000

mysql&#62; SELECT LOG10(-100);
        -&#62; NULL
</pre>

<A NAME="IDX1235"></A>
<A NAME="IDX1236"></A>
<DT><code>POW(X,Y)</code>
<DD>
<DT><code>POWER(X,Y)</code>
<DD>
Возвращает значение аргумента <code>X</code>, возведенное в степень <code>Y</code>:


<pre>
mysql&#62; SELECT POW(2,2);
        -&#62; 4.000000

mysql&#62; SELECT POW(2,-2);
        -&#62; 0.250000
</pre>

<DT><code>SQRT(X)</code>
<DD>
Возвращает неотрицательный квадратный корень числа <code>X</code>:


<pre>
mysql&#62; SELECT SQRT(4);
        -&#62; 2.000000

mysql&#62; SELECT SQRT(20);
        -&#62; 4.472136
</pre>

<A NAME="IDX1237"></A>
<DT><code>PI()</code>
<DD>
Возвращает значение числа "пи". По умолчанию представлено 5 десятичных
знаков, но в MySQL для представления числа "пи" при внутренних вычислениях
используется полная двойная точность.


<pre>
mysql&#62; SELECT PI();
        -&#62; 3.141593

mysql&#62; SELECT PI()+0.000000000000000000;
        -&#62; 3.141592653589793116
</pre>

<A NAME="IDX1238"></A>
<DT><code>COS(X)</code>
<DD>
Возвращает косинус числа <code>X</code>, где <code>X</code> задается в радианах:


<pre>
mysql&#62; SELECT COS(PI());
        -&#62; -1.000000
</pre>

<A NAME="IDX1239"></A>
<DT><code>SIN(X)</code>
<DD>
Возвращает синус числа <code>X</code>, где <code>X</code> задается в радианах:


<pre>
mysql&#62; SELECT SIN(PI());
        -&#62; 0.000000
</pre>

<A NAME="IDX1240"></A>
<DT><code>TAN(X)</code>
<DD>
Возвращает тангенс числа <code>X</code>, где <code>X</code> задается в радианах:


<pre>
mysql&#62; SELECT TAN(PI()+1);
        -&#62; 1.557408
</pre>

<DT><code>ACOS(X)</code>
<DD>
Возвращает арккосинус числа <code>X</code>, т.е. величину, косинус которой равен <code>X</code>.
Если <code>X</code> не находится в диапазоне от <code>-1</code> до <code>1</code>, возвращает <code>NULL</code>:


<pre>
mysql&#62; SELECT ACOS(1);
        -&#62; 0.000000

mysql&#62; SELECT ACOS(1.0001);
        -&#62; NULL

mysql&#62; SELECT ACOS(0);
        -&#62; 1.570796
</pre>

<A NAME="IDX1241"></A>
<DT><code>ASIN(X)</code>
<DD>
Возвращает арксинус числа <code>X</code>, т.е. величину, синус которой равен <code>X</code>. Если <code>X</code>
не находится в диапазоне от <code>-1</code> до <code>1</code>, возвращает <code>NULL</code>:


<pre>
mysql&#62; SELECT ASIN(0.2);
        -&#62; 0.201358

mysql&#62; SELECT ASIN('foo');
        -&#62; 0.000000
</pre>

<A NAME="IDX1242"></A>
<DT><code>ATAN(X)</code>
<DD>
Возвращает арктангенс числа <code>X</code>, т.е. величину, тангенс которой равен <code>X</code>:


<pre>
mysql&#62; SELECT ATAN(2);
        -&#62; 1.107149

mysql&#62; SELECT ATAN(-2);
        -&#62; -1.107149
</pre>

<A NAME="IDX1243"></A>
<A NAME="IDX1244"></A>
<DT><code>ATAN(Y,X)</code>
<DD>
<DT><code>ATAN2(Y,X)</code>
<DD>
Возвращает арктангенс двух переменных <code>X</code> и <code>Y</code>. Вычисление производится так
же, как и вычисление арктангенса <code>Y / X</code>, за исключением того, что знаки
обоих аргументов используются для определения квадранта результата:


<pre>
mysql&#62; SELECT ATAN(-2,2);
        -&#62; -0.785398

mysql&#62; SELECT ATAN2(PI(),0);
        -&#62; 1.570796
</pre>

<A NAME="IDX1245"></A>
<DT><code>COT(X)</code>
<DD>
Возвращает котангенс числа <code>X</code>:


<pre>
mysql&#62; SELECT COT(12);
        -&#62; -1.57267341

mysql&#62; SELECT COT(0);
        -&#62; NULL
</pre>

<A NAME="IDX1246"></A>
<DT><code>RAND()</code>
<DD>
<DT><code>RAND(N)</code>
<DD>
Возвращает случайную величину с плавающей точкой в диапазоне от <code>0</code> до <code>1,0</code>.
Если целочисленный аргумент <code>N</code> указан, то он используется как начальное
значение этой величины:


<pre>
mysql&#62; SELECT RAND();
        -&#62; 0.9233482386203

mysql&#62; SELECT RAND(20);
        -&#62; 0.15888261251047

mysql&#62; SELECT RAND(20);
        -&#62; 0.15888261251047

mysql&#62; SELECT RAND();
        -&#62; 0.63553050033332

mysql&#62; SELECT RAND();
        -&#62; 0.70100469486881
</pre>

В выражениях вида <code>ORDER BY</code>  не следует использовать столбец с величинами
<code>RAND()</code>, поскольку применение оператора <code>ORDER BY</code> приведет к многократным
вычислениям в этом столбце. В версии MySQL 3.23 можно, однако, выполнить
следующий оператор: <code>SELECT * FROM table_name ORDER BY RAND()</code>: он
полезен для получения случайного экземпляра из множества <code>SELECT * FROM 
table1,table2 WHERE a=b AND c&#60;d ORDER BY RAND() LIMIT 1000</code>. Следует
учитывать, что оператор <code>RAND()</code> в выражении <code>WHERE</code> при выполнении выражения
<code>WHERE</code> будет вычисляться каждый раз заново. Оператор <code>RAND()</code> не следует
воспринимать как полноценный генератор случайных чисел: это просто быстрый
способ динамической генерации случайных чисел, переносимых между
платформами для одной и той же версии MySQL.

<A NAME="IDX1247"></A>
<DT><code>LEAST(X,Y,...)</code>
<DD>
Если задано два или более аргументов, возвращает наименьший (с минимальным
значением) аргумент. Сравнение аргументов происходит по следующим
правилам:


<ul>
<LI>

Если возвращаемая величина используется в целочисленном контексте
(<code>INTEGER</code>), или все аргументы являются целочисленными, то они
сравниваются как целые числа.

<LI>

Если возвращаемая величина используется в контексте действительных
чисел (<code>REAL</code>) или все аргументы являются действительными числами, то
они сравниваются как числа типа <code>REAL</code>.

<LI>

Если один из аргументов является зависимой от регистра строкой, то
данные аргументы сравниваются с учетом регистра.

<LI>

В остальных случаях аргументы сравниваются как строки, независимые от
регистра.
</ul>


<pre>
mysql&#62; SELECT LEAST(2,0);
        -&#62; 0

mysql&#62; SELECT LEAST(34.0,3.0,5.0,767.0);
        -&#62; 3.0

mysql&#62; SELECT LEAST("B","A","C");
        -&#62; "A"
</pre>

В версиях MySQL до 3.22.5 можно использовать MIN() вместо  LEAST.

<A NAME="IDX1248"></A>
<DT><code>GREATEST(X,Y,...)</code>
<DD>
Возвращает наибольший (с максимальным значением) аргумент. Сравнение
аргументов происходит по тем же правилам, что и для <code>LEAST</code>:


<pre>
mysql&#62; SELECT GREATEST(2,0);
        -&#62; 2

mysql&#62; SELECT GREATEST(34.0,3.0,5.0,767.0);
        -&#62; 767.0

mysql&#62; SELECT GREATEST("B","A","C");
        -&#62; "C"
</pre>

В версиях MySQL до 3.22.5 можно использовать <code>MAX()</code> вместо <code>GREATEST</code>.

<A NAME="IDX1249"></A>
<DT><code>DEGREES(X)</code>
<DD>
Возвращает аргумент <code>X</code>, преобразованный из радианов в градусы:


<pre>
mysql&#62; SELECT DEGREES(PI());
        -&#62; 180.000000
</pre>

<A NAME="IDX1250"></A>
<DT><code>RADIANS(X)</code>
<DD>
Возвращает аргумент <code>X</code>, преобразованный из градусов в радианы:


<pre>
mysql&#62; SELECT RADIANS(90);
        -&#62; 1.570796
</pre>

<A NAME="IDX1251"></A>
<DT><code>TRUNCATE(X,D)</code>
<DD>
Возвращает число <code>X</code>, усеченное до <code>D</code> десятичных знаков. Если <code>D</code> равно <code>0</code>,
результат будет представлен без десятичного знака или дробной части:


<pre>
mysql&#62; SELECT TRUNCATE(1.223,1);
        -&#62; 1.2
mysql&#62; SELECT TRUNCATE(1.999,1);
        -&#62; 1.9
mysql&#62; SELECT TRUNCATE(1.999,0);
        -&#62; 1
mysql&#62; SELECT TRUNCATE(-1.999,1);
        -&#62; -1.9
</pre>

Начиная с MySQL 3.23.51 все числа округляются к нулю. 

Если <code>D</code> - негативное, то тогда вся часть числа обнуляется: 


<pre>
mysql&#62; SELECT TRUNCATE(122,-2);
       -&#62; 100
</pre>

Следует учитывать, что обычно в компьютерах десятичные числа хранятся не
так, как целые, а как числа двойной точности с плавающим десятичным знаком
(<code>DOUBLE</code>). Поэтому иногда результат может вводить в заблуждение, как в
следующем примере:


<pre>
mysql&#62; SELECT TRUNCATE(10.28*100,0);
        -&#62; 1027
</pre>

Это происходит потому, что в действительности <code>10,28</code> хранится как нечто
вроде <code>10,2799999999999999</code>.
</DL>



<H3><A NAME="Date_and_time_functions" HREF="manual.ru_toc.html#Date_and_time_functions">6.3.4  Функции даты и времени</A></H3>

<P>
<A NAME="IDX1252"></A>

</P>

<P>
Описание диапазона величин для каждого типа и возможные форматы
представления даты и времени приведены в разделе section <A HREF="manual.ru_Reference.html#Date_and_time_types">6.2.2  Типы данных даты и времени</A>.

</P>
<P>
Ниже представлен пример, в котором используются функции даты. Приведенный
запрос выбирает все записи с величиной <code>date_col</code> в течение последних 30
дней:

</P>

<pre>
mysql&#62; SELECT something FROM tbl_name
        WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &#60;= 30;
</pre>

<DL COMPACT>

<DT><code>DAYOFWEEK(date)</code>
<DD>
<A NAME="IDX1253"></A>
 

Возвращает индекс дня недели для аргумента <code>date</code> (1 = воскресенье, 2 =
понедельник, ... 7 = суббота). Эти индексные величины соответствуют
стандарту ODBC.


<pre>
mysql&#62; SELECT DAYOFWEEK('1998-02-03');
        -&#62; 3
</pre>

<A NAME="IDX1254"></A>
<DT><code>WEEKDAY(date)</code>
<DD>
Возвращает индекс дня недели для аргумента date (0 =понедельник, 1 =
вторник, ... 6 = воскресенье):


<pre>
mysql&#62; SELECT WEEKDAY('1998-02-03 22:23:00');
        -&#62; 1
mysql&#62; SELECT WEEKDAY('1997-11-05');
        -&#62; 2
</pre>

<A NAME="IDX1255"></A>
<DT><code>DAYOFMONTH(date)</code>
<DD>
Возвращает порядковый номер дня месяца для аргумента <code>date</code> в диапазоне от 1
до 31:


<pre>
mysql&#62; SELECT DAYOFMONTH('1998-02-03');
        -&#62; 3
</pre>

<A NAME="IDX1256"></A>
<DT><code>DAYOFYEAR(date)</code>
<DD>
Возвращает порядковый номер дня года для аргумента <code>date</code> в диапазоне от 1
до 366:


<pre>
mysql&#62; SELECT DAYOFYEAR('1998-02-03');
        -&#62; 34
</pre>

<A NAME="IDX1257"></A>
<DT><code>MONTH(date)</code>
<DD>
Возвращает порядковый номер месяца в году для аргумента <code>date</code> в диапазоне
от 1 до 12:


<pre>
mysql&#62; SELECT MONTH('1998-02-03');
        -&#62; 2
</pre>

<A NAME="IDX1258"></A>
<DT><code>DAYNAME(date)</code>
<DD>
Возвращает название дня недели для аргумента <code>date</code>:


<pre>
mysql&#62; SELECT DAYNAME("1998-02-05");
        -&#62; 'Thursday'
</pre>

<A NAME="IDX1259"></A>
<DT><code>MONTHNAME(date)</code>
<DD>
Возвращает название месяца для аргумента <code>date</code>:


<pre>
mysql&#62; SELECT MONTHNAME("1998-02-05");
        -&#62; 'February'
</pre>

<A NAME="IDX1260"></A>
<DT><code>QUARTER(date)</code>
<DD>
Возвращает номер квартала года для аргумента <code>date</code> в диапазоне от 1 до 4:


<pre>
mysql&#62; SELECT QUARTER('98-04-01');
        -&#62; 2
</pre>

<A NAME="IDX1261"></A>
<DT><code>WEEK(date)</code>
<DD>
<DT><code>WEEK(date,first)</code>
<DD>
При наличии одного аргумента возвращает порядковый номер недели в году для
<code>date</code> в диапазоне от 0 до 53 (да, возможно начало 53-й недели) для
регионов, где воскресенье считается первым днем недели. Форма <code>WEEK()</code> с
двумя аргументами позволяет уточнить, с какого дня начинается неделя - с
воскресенья или с понедельника. Результат будет в пределах <code>0-53</code> или <code>1-52</code>.

Вот как работает второй аргумент:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Величина</strong> </TD><TD> <code>Означает</code>
</TD></TR>
<TR><TD>0 </TD><TD> Неделя начинается с воскресенья; возвращаемое значение - в промежутке 0-53
</TD></TR>
<TR><TD>1 </TD><TD> Неделя начинается с понедельника; возвращаемое значение - в промежутке 0-53
</TD></TR>
<TR><TD>2 </TD><TD> Неделя начинается с воскресенья; возвращаемое значение - в промежутке 1-53
</TD></TR>
<TR><TD>3 </TD><TD> Неделя начинается с понедельника; возвращаемое значение - в промежутке 1-53 (ISO 8601)
</TD></TR>
</TABLE>


<pre>
mysql&#62; SELECT WEEK('1998-02-20');
        -&#62; 7

mysql&#62; SELECT WEEK('1998-02-20',0);
        -&#62; 7

mysql&#62; SELECT WEEK('1998-02-20',1);
        -&#62; 8

mysql&#62; SELECT WEEK('1998-12-31',1);
        -&#62; 53
</pre>

Примечание: в версии 4.0 функция <code>WEEK(#,0)</code> была изменена с целью
соответствия календарю США.

Заметьте, если неделя является последней неделей прошлого года, MySQL вернет <code>0</code>
если вы не указали <code>2</code> или <code>3</code> как опциональный аргумент:


<pre>
mysql&#62; SELECT YEAR('2000-01-01'), WEEK('2000-01-01',0);
        -&#62; 2000, 0
mysql&#62; SELECT WEEK('2000-01-01',2);
        -&#62; 52
</pre>

Можно считать, что MySQL должен вернуть <code>52</code>, так как данная дата
и является 52-ой неделей года 1999. Мы решили возвращать <code>0</code>, так как мы
хотим, чтобы функция давала "номер недели в указанном году". Это делает функцию
<code>WEEK()</code> более надежной при использовании совместно с другими функциями,
которые вычисляют части дат. 

Если вам все же важно уточнить корректную неделю в году, тогда вы можете использовать <code>2</code> или <code>3</code>
как опциональный аргумент или использовать <code>YEARWEEK()</code>


<pre>
mysql&#62; SELECT YEARWEEK('2000-01-01');
        -&#62; 199952
mysql&#62; SELECT MID(YEARWEEK('2000-01-01'),5,2);
        -&#62; 52
</pre>

<A NAME="IDX1262"></A>
<DT><code>YEAR(date)</code>
<DD>
Возвращает год для аргумента <code>date</code> в диапазоне от 1000 до 9999:


<pre>
mysql&#62; SELECT YEAR('98-02-03');
        -&#62; 1998
</pre>

<A NAME="IDX1263"></A>
<DT><code>YEARWEEK(date)</code>
<DD>
<DT><code>YEARWEEK(date,first)</code>
<DD>
Возвращает год и неделю для аргумента <code>date</code>. Второй аргумент в данной
функции работает подобно второму аргументу в функции <code>WEEK()</code>. Следует
учитывать, что год может отличаться от указанного в аргументе <code>date</code> для
первой и последней недель года:


<pre>
mysql&#62; SELECT YEARWEEK('1987-01-01');
        -&#62; 198653
</pre>

Обратите внимание, что номер недели отличается от того, который возвращает
функция <code>WEEK()</code> (<code>0</code>), будучи вызванной с опциональным аргументом <code>0</code> или <code>1</code>. Это
потому, что <code>WEEK()</code> возвращает номер недели именно в указанном году. 

<A NAME="IDX1264"></A>
<DT><code>HOUR(time)</code>
<DD>
Возвращает час для аргумента <code>time</code> в диапазоне от 0 до 23:


<pre>
mysql&#62; SELECT HOUR('10:05:03');
        -&#62; 10
</pre>

<A NAME="IDX1265"></A>
<DT><code>MINUTE(time)</code>
<DD>
Возвращает количество минут для аргумента <code>time</code> в диапазоне от 0 до 59:


<pre>
mysql&#62; SELECT MINUTE('98-02-03 10:05:03');
        -&#62; 5
</pre>

<A NAME="IDX1266"></A>
<DT><code>SECOND(time)</code>
<DD>
Возвращает количество секунд для аргумента <code>time</code> в диапазоне от 0 до 59:


<pre>
mysql&#62; SELECT SECOND('10:05:03');
        -&#62; 3
</pre>

<A NAME="IDX1267"></A>
<DT><code>PERIOD_ADD(P,N)</code>
<DD>
Добавляет <code>N</code> месяцев к периоду <code>P</code> (в формате <code>YYMM</code> или <code>YYYYMM</code>). Возвращает
величину в формате <code>YYYYMM</code>. Следует учитывать, что аргумент периода <code>P</code>  не
является значением даты:


<pre>
mysql&#62; SELECT PERIOD_ADD(9801,2);
        -&#62; 199803
</pre>

<A NAME="IDX1268"></A>
<DT><code>PERIOD_DIFF(P1,P2)</code>
<DD>
Возвращает количество месяцев между периодами <code>P1</code> и <code>P2</code>. <code>P1</code> и <code>P2</code> должны быть
в формате <code>YYMM</code> или <code>YYYYMM</code>. Следует учитывать, что аргументы периода <code>P1</code> и
<code>P2</code>  не являются значениями даты:


<pre>
mysql&#62; SELECT PERIOD_DIFF(9802,199703);
        -&#62; 11
</pre>

<A NAME="IDX1269"></A>
<A NAME="IDX1270"></A>
<A NAME="IDX1271"></A>
<A NAME="IDX1272"></A>
<DT><code>DATE_ADD(date,INTERVAL expr type)</code>
<DD>
<DT><code>DATE_SUB(date,INTERVAL expr type)</code>
<DD>
<DT><code>ADDDATE(date,INTERVAL expr type)</code>
<DD>
<DT><code>SUBDATE(date,INTERVAL expr type)</code>
<DD>
Данные функции производят арифметические действия над датами. Обе являются
нововведением версии MySQL 3.22. Функции <code>ADDDATE()</code> и <code>SUBDATE()</code> - синонимы
для <code>DATE_ADD()</code> и <code>DATE_SUB()</code>. В версии MySQL 3.23 вместо функций <code>DATE_ADD()</code>
и <code>DATE_SUB()</code> можно использовать операторы <code>+</code> и <code>-</code>, если выражение с правой
стороны представляет собой столбец типа <code>DATE</code> или <code>DATETIME</code> (см. пример
ниже). Аргумент <code>date</code> является величиной типа <code>DATETIME</code> или <code>DATE</code>, задающей
начальную дату. 

Выражение <code>expr</code> задает величину интервала, который следует
добавить к начальной дате или вычесть из начальной даты. Выражение <code>expr</code>
представляет собой строку, которая может начинаться с <code>-</code> для
отрицательных значений интервалов. Ключевое слово <code>type</code> показывает, каким
образом необходимо интерпретировать данное выражение. Вспомогательная
функция <code>EXTRACT(type FROM date)</code> возвращает интервал указанного типа
(<code>type</code>) из значения даты. В следующей таблице показана взаимосвязь
аргументов <code>type</code> и <code>expr</code>:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Значение</strong> <code>Type</code> </TD><TD> <strong>Ожидаемый формат</strong> <code>expr</code>
</TD></TR>
<TR><TD><code>SECOND</code> </TD><TD> <code>SECONDS</code>
</TD></TR>
<TR><TD><code>MINUTE</code> </TD><TD> <code>MINUTES</code>
</TD></TR>
<TR><TD><code>HOUR</code> </TD><TD> <code>HOURS</code>
</TD></TR>
<TR><TD><code>DAY</code> </TD><TD> <code>DAYS</code>
</TD></TR>
<TR><TD><code>MONTH</code> </TD><TD> <code>MONTHS</code>
</TD></TR>
<TR><TD><code>YEAR</code> </TD><TD> <code>YEARS</code>
</TD></TR>
<TR><TD><code>MINUTE_SECOND</code> </TD><TD> <code>"MINUTES:SECONDS"</code>
</TD></TR>
<TR><TD><code>HOUR_MINUTE</code> </TD><TD> <code>"HOURS:MINUTES"</code>
</TD></TR>
<TR><TD><code>DAY_HOUR</code> </TD><TD> <code>"DAYS HOURS"</code>
</TD></TR>
<TR><TD><code>YEAR_MONTH</code> </TD><TD> <code>"YEARS-MONTHS"</code>
</TD></TR>
<TR><TD><code>HOUR_SECOND</code> </TD><TD> <code>"HOURS:MINUTES:SECONDS"</code>
</TD></TR>
<TR><TD><code>DAY_MINUTE</code> </TD><TD> <code>"DAYS HOURS:MINUTES"</code>
</TD></TR>
<TR><TD><code>DAY_SECOND</code> </TD><TD> <code>"DAYS HOURS:MINUTES:SECONDS"</code>
</TD></TR>
</TABLE>

В MySQL формат выражения <code>expr</code>  допускает любые разделительные знаки.
Разделители, представленные в данной таблице, приведены в качестве
примеров. Если аргумент <code>date</code> является величиной типа <code>DATE</code> и предполагаемые
вычисления включают в себя только части <code>YEAR</code>, <code>MONTH</code>, и <code>DAY</code> (т.е. не
содержат временной части <code>TIME</code>), то результат представляется величиной типа
<code>DATE</code>. В других случаях результат представляет собой величину <code>DATETIME</code>:


<pre>
mysql&#62; SELECT "1997-12-31 23:59:59" + INTERVAL 1 SECOND;
        -&#62; 1998-01-01 00:00:00
mysql&#62; SELECT INTERVAL 1 DAY + "1997-12-31";
        -&#62; 1998-01-01
mysql&#62; SELECT "1998-01-01" - INTERVAL 1 SECOND;
        -&#62; 1997-12-31 23:59:59
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59", INTERVAL 1 SECOND);
        -&#62; 1998-01-01 00:00:00
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59", INTERVAL 1 DAY);
        -&#62; 1998-01-01 23:59:59
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59", INTERVAL "1:1" MINUTE_SECOND);
        -&#62; 1998-01-01 00:01:00
mysql&#62; SELECT DATE_SUB("1998-01-01 00:00:00", INTERVAL "1 1:1:1" DAY_SECOND);
        -&#62; 1997-12-30 22:58:59
mysql&#62; SELECT DATE_ADD("1998-01-01 00:00:00", INTERVAL "-1 10" DAY_HOUR);
        -&#62; 1997-12-30 14:00:00
mysql&#62; SELECT DATE_SUB("1998-01-02", INTERVAL 31 DAY);
        -&#62; 1997-12-02
</pre>

Если указанный интервал слишком короткий (т.е. не включает все части
интервала, ожидаемые при заданном ключевом слове <code>type</code>), то MySQL
предполагает, что опущены крайние слева части интервала. Например, если
указан аргумент <code>type</code> в виде <code>DAY_SECOND</code>, то ожидаемое выражение <code>expr</code> должно
иметь следующие части: дни, часы, минуты и секунды. Если в этом случае
указать значение интервала в виде <code>"1:10"</code>, то MySQL предполагает, что
опущены дни и часы, а данная величина включает только минуты и секунды.
Другими словами, сочетание <code>"1:10"</code> <code>DAY_SECOND</code> интерпретируется как
эквивалент <code>"1:10"</code> <code>MINUTE_SECOND</code>. Аналогичным образом в MySQL
интерпретируются и значения <code>TIME</code> - скорее как представляющие прошедшее
время, чем как время дня. Следует учитывать, что при операциях сложения
или вычитания с участием величины <code>DATE</code> и выражения, содержащего временную
часть, данная величина <code>DATE</code> будет автоматически конвертироваться в
величину типа <code>DATETIME</code>:


<pre>
mysql&#62; SELECT DATE_ADD("1999-01-01", INTERVAL 1 DAY);
        -&#62; 1999-01-02

mysql&#62; SELECT DATE_ADD("1999-01-01", INTERVAL 1 HOUR);
        -&#62; 1999-01-01 01:00:00
</pre>

При использовании некорректных значений дат результат будет равен <code>NULL</code>.
Если при суммировании <code>MONTH</code>, <code>YEAR_MONTH</code> или <code>YEAR</code> номер дня в
результирующей дате превышает максимальное количество дней в новом месяце,
то номер дня результирующей даты принимается равным последнему дню нового
месяца:


<pre>
mysql&#62; SELECT DATE_ADD('1998-01-30', INTERVAL 1 MONTH);
        -&#62; 1998-02-28
</pre>

Из предыдущего примера видно, что слово <code>INTERVAL</code> и ключевое слово <code>type</code> не
являются регистро-зависимыми.

<A NAME="IDX1273"></A>
<DT><code>EXTRACT(type FROM date)</code>
<DD>
Типы интервалов для функции <code>EXTRACT()</code> используются те же, что и для
функций <code>DATE_ADD()</code> или <code>DATE_SUB()</code>, но <code>EXTRACT()</code> производит скорее
извлечение части из значения даты, чем выполнение арифметических действий.


<pre>
mysql&#62; SELECT EXTRACT(YEAR FROM "1999-07-02");
        -&#62; 1999

mysql&#62; SELECT EXTRACT(YEAR_MONTH FROM "1999-07-02 01:02:03");
        -&#62; 199907

mysql&#62; SELECT EXTRACT(DAY_MINUTE FROM "1999-07-02 01:02:03");
        -&#62; 20102
</pre>

<A NAME="IDX1274"></A>
<DT><code>TO_DAYS(date)</code>
<DD>
функция возвращает номер дня для даты, указанной в аргументе <code>date</code>,
(количество дней, прошедших с года 0):


<pre>
mysql&#62; SELECT TO_DAYS(950501);
        -&#62; 728779

mysql&#62; SELECT TO_DAYS('1997-10-07');
        -&#62; 729669
</pre>

Функция <code>TO_DAYS()</code> не предназначена для использования с величинами,
предшествующими введению григорианского календаря (1582), поскольку не
учитывает дни, утерянные при изменении календаря.

<A NAME="IDX1275"></A>
<DT><code>FROM_DAYS(N)</code>
<DD>
Возвращает величину <code>DATE</code> для заданного номера дня <code>N</code>:


<pre>
mysql&#62; SELECT FROM_DAYS(729669);
        -&#62; '1997-10-07'
</pre>

Функция <code>FROM_DAYS()</code> не предназначена для использования с величинами,
предшествующими введению григорианского календаря (1582), поскольку она не
учитывает дни, утерянные при изменении календаря.

<A NAME="IDX1276"></A>
<DT><code>DATE_FORMAT(date,format)</code>
<DD>
Форматирует величину <code>date</code> в соответствии со строкой <code>format</code>. В строке
<code>format</code> могут использоваться следующие определители:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Определитель</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>%M</code> </TD><TD> Название месяца (январь...декабрь)
</TD></TR>
<TR><TD><code>%W</code> </TD><TD> Название дня недели (воскресенье...суббота)
</TD></TR>
<TR><TD><code>%D</code> </TD><TD> День месяца с английским суффиксом (0st, 1st, 2nd, 3rd и т.д.)
</TD></TR>
<TR><TD><code>%Y</code> </TD><TD> Год, число, 4 разряда
</TD></TR>
<TR><TD><code>%y</code> </TD><TD> Год, число, 2 разряда
</TD></TR>
<TR><TD><code>%X</code> </TD><TD> Год для недели, где воскресенье считается первым днем недели, число, 4 разряда, используется с '%V'
</TD></TR>
<TR><TD><code>%x</code> </TD><TD> Год для недели, где воскресенье считается первым днем недели, число, 4 разряда, используется с '%v'
</TD></TR>
<TR><TD><code>%a</code> </TD><TD> Сокращенное наименование дня недели (Вс...Сб)
</TD></TR>
<TR><TD><code>%d</code> </TD><TD> День месяца, число (00..31)
</TD></TR>
<TR><TD><code>%e</code> </TD><TD> День месяца, число (0..31)
</TD></TR>
<TR><TD><code>%m</code> </TD><TD> Месяц, число (00..12)
</TD></TR>
<TR><TD><code>%c</code> </TD><TD> Месяц, число (0..12)
</TD></TR>
<TR><TD><code>%b</code> </TD><TD> Сокращенное наименование месяца (Янв...Дек)
</TD></TR>
<TR><TD><code>%j</code> </TD><TD> День года (001..366)
</TD></TR>
<TR><TD><code>%H</code> </TD><TD> Час (00..23)
</TD></TR>
<TR><TD><code>%k</code> </TD><TD> Час (0..23)
</TD></TR>
<TR><TD><code>%h</code> </TD><TD> Час (01..12)
</TD></TR>
<TR><TD><code>%I</code> </TD><TD> Час (01..12)
</TD></TR>
<TR><TD><code>%l</code> </TD><TD> Час (1..12)
</TD></TR>
<TR><TD><code>%i</code> </TD><TD> Минуты, число (00..59)
</TD></TR>
<TR><TD><code>%r</code> </TD><TD> Время, 12-часовой формат (hh:mm:ss [AP]M)
</TD></TR>
<TR><TD><code>%T</code> </TD><TD> Время, 24-часовой формат (hh:mm:ss)
</TD></TR>
<TR><TD><code>%S</code> </TD><TD> Секунды (00..59)
</TD></TR>
<TR><TD><code>%s</code> </TD><TD> Секунды (00..59)
</TD></TR>
<TR><TD><code>%p</code> </TD><TD> AM или PM
</TD></TR>
<TR><TD><code>%w</code> </TD><TD> День недели (0=воскресенье..6=суббота)
</TD></TR>
<TR><TD><code>%U</code> </TD><TD> Неделя (00..53), где воскресенье считается первым  днем недели
</TD></TR>
<TR><TD><code>%u</code> </TD><TD> Неделя (00..53), где понедельник считается первым  днем недели
</TD></TR>
<TR><TD><code>%V</code> </TD><TD> Неделя (01..53), где воскресенье считается первым  днем недели. Используется с <samp>`%X'</samp>
</TD></TR>
<TR><TD><code>%v</code> </TD><TD> Неделя (01..53), где понедельник считается первым  днем недели. Используется с <samp>`%x'</samp>
</TD></TR>
<TR><TD><code>%%</code> </TD><TD> Литерал <samp>`%'</samp>.
</TD></TR>
</TABLE>

Все другие символы просто копируются в результирующее выражение без
интерпретации:


<pre>
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
        -&#62; 'Saturday October 1997'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
        -&#62; '22:23:00'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%D %y %a %d %m %b %j');
        -&#62; '4th 97 Sat 04 10 Oct 277'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%H %k %I %r %T %S %w');
        -&#62; '22 22 10 10:23:00 PM 22:23:00 00 6'
mysql&#62; SELECT DATE_FORMAT('1999-01-01', '%X %V');
        -&#62; '1998 52'
</pre>

В MySQL 3.23 символ <samp>`%'</samp> должен предшествовать символам определителя
формата. В более ранних версиях MySQL символ <samp>`%'</samp> необязателен.

Причина того, что промежутки для месяца и дня начинаются с нуля заключается в том, что MySQL позволяет
использовать неполные даты, такие как <code>'2004-00-00'</code>, начиная с MySQL 3.23.

<A NAME="IDX1277"></A>
<DT><code>TIME_FORMAT(time,format)</code>
<DD>
Данная функция используется аналогично описанной выше функции
<code>DATE_FORMAT()</code>, но строка <code>format</code> может содержать только те определители
формата, которые относятся к часам, минутам и секундам. При указании
других определителей будет выдана величина <code>NULL</code> или <code>0</code>.

<A NAME="IDX1278"></A>
<A NAME="IDX1279"></A>
<DT><code>CURDATE()</code>
<DD>
<DT><code>CURRENT_DATE</code>
<DD>
Возвращает сегодняшнюю дату как величину в формате <code>YYYY-MM-DD</code> или
<code>YYYYMMDD</code>, в зависимости от того, в каком контексте используется функция -
в строковом или числовом:


<pre>
mysql&#62; SELECT CURDATE();
        -&#62; '1997-12-15'
mysql&#62; SELECT CURDATE() + 0;
        -&#62; 19971215
</pre>

<A NAME="IDX1280"></A>
<A NAME="IDX1281"></A>
<DT><code>CURTIME()</code>
<DD>
<DT><code>CURRENT_TIME</code>
<DD>
Возвращает текущее время как величину в формате <code>HH:MM:SS</code> или <code>HHMMS</code>, в
зависимости от того, в каком контексте используется функция - в строковом
или числовом:


<pre>
mysql&#62; SELECT CURTIME();
        -&#62; '23:50:26'
mysql&#62; SELECT CURTIME() + 0;
        -&#62; 235026
</pre>

<A NAME="IDX1282"></A>
<A NAME="IDX1283"></A>
<A NAME="IDX1284"></A>
<DT><code>NOW()</code>
<DD>
<DT><code>SYSDATE()</code>
<DD>
<DT><code>CURRENT_TIMESTAMP</code>
<DD>
Возвращает текущую дату и время как величину в формате <code>YYYY-MM-DD HH:MM:SS</code> 
или <code>YYYYMMDDHHMMSS</code>, в зависимости от того, в каком контексте
используется функция - в строковом или числовом:


<pre>
mysql&#62; SELECT NOW();
        -&#62; '1997-12-15 23:50:26'
mysql&#62; SELECT NOW() + 0;
        -&#62; 19971215235026
</pre>

Заметьте, что <code>NOW()</code> вычисляется только единожды для каждого запроса, а
именно - в начале его выполнения.  Это позволяет быть уверенным в том, что
множественные ссылки на <code>NOW()</code> в рамках одного запроса дадут одно и то же
значение. 

<A NAME="IDX1285"></A>
<DT><code>UNIX_TIMESTAMP()</code>
<DD>
<DT><code>UNIX_TIMESTAMP(date)</code>
<DD>
При вызове данной функции без аргумента она возвращает временную метку
<code>UNIX_TIMESTAMP</code> (секунды с 1970-01-01 00:00:00 GMT) как беззнаковое
целое число. Если функция <code>UNIX_TIMESTAMP()</code> вызывается с аргументом  <code>date</code>,
она возвращает величину аргумента как количество секунд с 1970-01-01
00:00:00 GMT. Аргумент date может представлять собой строку типа <code>DATE</code>,
строку <code>DATETIME</code>, величину типа <code>TIMESTAMP</code> или число в формате <code>YYMMDD</code> или
<code>YYYYMMDD</code> местного времени:


<pre>
mysql&#62; SELECT UNIX_TIMESTAMP();
        -&#62; 882226357

mysql&#62; SELECT UNIX_TIMESTAMP('1997-10-04 22:23:00');
        -&#62; 875996580
</pre>

При использовании функции <code>UNIX_TIMESTAMP</code> в столбце <code>TIMESTAMP</code> эта функция
будет возвращать величину внутренней временной метки непосредственно, без
подразумеваемого преобразования строки во временную метку
(``string-to-unix-timestamp'' ). Если заданная дата выходит за пределы
допустимого диапазона, то функция <code>UNIX_TIMESTAMP()</code> возвратит <code>0</code>, но следует
учитывать, что выполняется только базовая проверка (год 1970-2037, месяц
01-12, день 01-31). Если необходимо выполнить вычитание столбцов
<code>UNIX_TIMESTAMP()</code>, результат можно преобразовать к целым числам со знаком.
See section <A HREF="manual.ru_Reference.html#Cast_Functions">6.3.5  Функции приведения типов</A>.

<A NAME="IDX1286"></A>
<DT><code>FROM_UNIXTIME(unix_timestamp)</code>
<DD>
Возвращает представление аргумента <code>unix_timestamp</code> как величину в формате
<code>YYYY-MM-DD HH:MM:SS</code> или <code>YYYYMMDDHHMMSS</code>, в зависимости от того, в каком
контексте используется функция - в строковом или числовом:


<pre>
mysql&#62; SELECT FROM_UNIXTIME(875996580);
        -&#62; '1997-10-04 22:23:00'

mysql&#62; SELECT FROM_UNIXTIME(875996580) + 0;
        -&#62; 19971004222300
</pre>

<A NAME="IDX1287"></A>
<DT><code>FROM_UNIXTIME(unix_timestamp,format)</code>
<DD>
Возвращает строковое представление аргумента <code>unix_timestamp</code>,
отформатированное в соответствии со строкой <code>format</code>. Строка <code>format</code> может
содержать те же определители, которые перечислены в описании для функции
<code>DATE_FORMAT()</code>:


<pre>
mysql&#62; SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y %D %M %h:%i:%s %x');
        -&#62; '1997 23rd December 03:43:30 1997'
</pre>

<A NAME="IDX1288"></A>
<DT><code>SEC_TO_TIME(seconds)</code>
<DD>
Возвращает аргумент seconds, преобразованный в часы, минуты и секунды, как
величину в формате <code>HH:MM:SS</code> или <code>HHMMSS</code>, в зависимости от того, в каком
контексте используется функция - в строковом или числовом:


<pre>
mysql&#62; SELECT SEC_TO_TIME(2378);
        -&#62; '00:39:38'

mysql&#62; SELECT SEC_TO_TIME(2378) + 0;
        -&#62; 3938
</pre>

<A NAME="IDX1289"></A>
<DT><code>TIME_TO_SEC(time)</code>
<DD>
Возвращает аргумент <code>time</code>, преобразованный в секунды:


<pre>
mysql&#62; SELECT TIME_TO_SEC('22:23:00');
        -&#62; 80580

mysql&#62; SELECT TIME_TO_SEC('00:39:38');
        -&#62; 2378
</pre>

</DL>



<H3><A NAME="Cast_Functions" HREF="manual.ru_toc.html#Cast_Functions">6.3.5  Функции приведения типов</A></H3>

<P>
Функция <code>CAST</code> имеет следующий синтаксис:

</P>
<P>
<A NAME="IDX1290"></A>
<A NAME="IDX1291"></A>

</P>

<pre>
CAST(expression AS type)
</pre>

<P>
или

</P>

<pre>
CONVERT(expression,type)
</pre>

<P>
где аргумент <code>type</code> представляет один из типов:

</P>

<ul>
<LI>

<code>BINARY</code>
<LI>

<code>CHAR</code> (Новшество в 4.0.6)
<LI>

<code>DATE</code>
<LI>

<code>DATETIME</code>
<LI>

<code>SIGNED {INTEGER}</code>
<LI>

<code>TIME</code>
<LI>

<code>UNSIGNED {INTEGER}</code>
</ul>

<P>
Функция <code>CAST()</code> соответствует синтаксису ANSI  SQL99, а функция <code>CONVERT()</code> -
синтаксису ODBC.

</P>
<P>
Данная функция приведения типов используется главным образом для создания
столбца конкретного типа с помощью команды <code>CREATE ... SELECT</code>:

</P>

<pre>
CREATE TABLE new_table SELECT CAST('2000-01-01' AS DATE);
</pre>

<P>
Выражение <code>CAST string AS BINARY</code> эквивалентно <code>BINARY string</code>.
<code>CAST(expr AS CHAR</code> считает что данное выражение есть строка в
кодировке по умолчанию. 

</P>
<P>
Для преобразования строки в числовую величину обычно не нужно ничего
делать: просто используйте строку так, как будто это число:

</P>

<pre>
mysql&#62; SELECT 1+'1';
       -&#62; 2
</pre>

<P>
Если вы указываете номер в строковом контексте, номер будет автоматически преобразован
к строке типа <code>BINARY</code>. 

</P>

<pre>
mysql&#62; SELECT concat("hello you ",2);
       -&#62;  "hello you 2"
</pre>

<P>
MySQL поддерживает арифметические операции с 64-битовыми величинами - как
со знаковыми, так и с беззнаковыми. Если используются числовые операции
(такие как +) и один из операндов представлен в виде <code>unsigned integer</code>, то
результат будет беззнаковым. Его можно переопределить, используя операторы
приведения <code>SIGNED</code> и <code>UNSIGNED</code>, чтобы получить 64-битовое целое число со
знаком или без знака соответственно.

</P>

<pre>
mysql&#62; SELECT CAST(1-2 AS UNSIGNED)
        -&#62; 18446744073709551615

mysql&#62; SELECT CAST(CAST(1-2 AS UNSIGNED) AS SIGNED);
        -&#62; -1
</pre>

<P>
Следует учитывать, что если один из операндов представлен величиной с
плавающей точкой (в данном контексте <code>DECIMAL()</code> рассматривается как
величина с плавающей точкой), результат также является величиной с
плавающей точкой и не подчиняется вышеприведенному правилу приведения.

</P>

<pre>
mysql&#62; SELECT CAST(1 AS UNSIGNED) -2.0
        -&#62; -1.0
</pre>

<P>
Если в арифметической операции используется строка, то результат
преобразуется в число с плавающей точкой.

</P>
<P>
Функции <code>CAST()</code> и <code>CONVERT()</code> были добавлены в MySQL 4.0.2.

</P>
<P>
В MySQL 4.0 была изменены правила обработки беззнаковых величин, чтобы
обеспечить более полную поддержку величин типа <code>BIGINT</code>. Если код необходимо
использовать и для MySQL 4.0, и для версии 3.23 (в которой функция <code>CAST</code>,
скорее всего, не будет работать), то можно, применив следующий трюк,
получить при вычитании двух беззнаковых целочисленных столбцов результат
со знаком:

</P>

<pre>
SELECT (unsigned_column_1+0.0)-(unsigned_column_2+0.0);
</pre>

<P>
Идея состоит в том, что перед выполнением вычитания данные столбцы
приводятся к типу с плавающей точкой.

</P>
<P>
Если возникнут проблемы со столбцами типа <code>UNSIGNED</code> в старых приложениях
MySQL при переносе их на MySQL 4.0, можно использовать параметр
<code>--sql-mode=NO_UNSIGNED_SUBTRACTION</code> при запуске <code>mysqld</code>. Однако следует
учитывать, что при этом теряется возможность эффективного использования
столбцов типа <code>UNSIGNED BIGINT</code>.

</P>


<H3><A NAME="Other_Functions" HREF="manual.ru_toc.html#Other_Functions">6.3.6  Другие функции</A></H3>



<H4><A NAME="Bit_functions" HREF="manual.ru_toc.html#Bit_functions">6.3.6.1  Битовые функции</A></H4>

<P>
<A NAME="IDX1292"></A>
<A NAME="IDX1293"></A>

</P>
<P>
MySQL использует для двоичных операций 64-битовые величины <code>BIGINT</code>,
следовательно, для двоичных операторов максимальный диапазон составляет 64
бита.

</P>
<DL COMPACT>

<DT><code>|</code>
<DD>
<A NAME="IDX1294"></A>
 <A NAME="IDX1295"></A>
 

Побитовое ИЛИ


<pre>
mysql&#62; SELECT 29 | 15;
        -&#62; 31
</pre>

Результат является беззнаковым 64-битовым целым числом.

<A NAME="IDX1296"></A>
<A NAME="IDX1297"></A>
<DT><code>&#38;</code>
<DD>
Побитовое И


<pre>
mysql&#62; SELECT 29 &#38; 15;
        -&#62; 13
</pre>

Результат является беззнаковым 64-битовым целым числом.

<A NAME="IDX1298"></A>
<A NAME="IDX1299"></A>
<DT><code>^</code>
<DD>
Побитовый XOR (побитовое сложение по модулю 2)

<pre>
mysql&#62; SELECT 1 ^ 1;
        -&#62; 0
mysql&#62; SELECT 1 ^ 0;
        -&#62; 1
mysql&#62; SELECT 11 ^ 3;
        -&#62; 8
</pre>

Результат - беззнаковое 64-битное целое число.

<code>XOR</code> был реализован в MySQL 4.0.2.

<A NAME="IDX1300"></A>
<DT><code>&#60;&#60;</code>
<DD>
Сдвиг числа двойной длины (<code>BIGINT</code>) влево:


<pre>
mysql&#62; SELECT 1 &#60;&#60; 2;
        -&#62; 4
</pre>

Результат является беззнаковым 64-битовым целым числом.

<A NAME="IDX1301"></A>
<DT><code>&#62;&#62;</code>
<DD>
Сдвиг числа двойной длины (<code>BIGINT</code>) вправо:


<pre>
mysql&#62; SELECT 4 &#62;&#62; 2;
        -&#62; 1
</pre>

Результат является беззнаковым 64-битовым целым числом.

<A NAME="IDX1302"></A>
<DT><code>~</code>
<DD>
Инвертировать все биты:


<pre>
mysql&#62; SELECT 5 &#38; ~1;
        -&#62; 4
</pre>

Результат является беззнаковым 64-битовым целым числом.

<A NAME="IDX1303"></A>
<DT><code>BIT_COUNT(N)</code>
<DD>
Возвращает число битов, указанное в аргументе <code>N</code>:


<pre>
mysql&#62; SELECT BIT_COUNT(29);
        -&#62; 4
</pre>

</DL>



<H4><A NAME="Miscellaneous_functions" HREF="manual.ru_toc.html#Miscellaneous_functions">6.3.6.2  Разные функции</A></H4>

<P>
<A NAME="IDX1304"></A>

</P>
<DL COMPACT>

<DT><code>DATABASE()</code>
<DD>
<A NAME="IDX1305"></A>
 

Возвращает имя текущей базы данных:


<pre>
mysql&#62; SELECT DATABASE();
        -&#62; 'test'
</pre>

Если в данное время нет активной базы данных, то функция <code>DATABASE()</code>
возвращает пустую строку.

<A NAME="IDX1306"></A>
<A NAME="IDX1307"></A>
<A NAME="IDX1308"></A>
<DT><code>USER()</code>
<DD>
<DT><code>SYSTEM_USER()</code>
<DD>
<DT><code>SESSION_USER()</code>
<DD>
Возвращает имя текущего активного пользователя MySQL:


<pre>
mysql&#62; SELECT USER();
        -&#62; 'davida@localhost'
</pre>

В версии MySQL 3.22.11 или более поздней данная функция включает в себя
имя хоста клиента, а также имя пользователя. Можно извлечь часть,
касающуюся только имени пользователя, приведенным ниже способом
(проверяется, включает ли данная величина имя хоста):


<pre>
mysql&#62; SELECT SUBSTRING_INDEX(USER(),"@",1);
        -&#62; 'davida'
</pre>

<A NAME="IDX1309"></A>
<DT><code>CURRENT_USER()</code>
<DD>
Возвращает текущее имя пользователя, под которым пользователь аутентифицировался в текущей сессии: 


<pre>
mysql&#62; SELECT USER();
        -&#62; 'davida@localhost'
mysql&#62; SELECT * FROM mysql.user;
        -&#62; ERROR 1044: Access denied for user: '@localhost' to database 'mysql'
mysql&#62; SELECT CURRENT_USER();
        -&#62; '@localhost'
</pre>

<A NAME="IDX1310"></A>
<A NAME="IDX1311"></A>
<DT><code>PASSWORD(str)</code>
<DD>
<DT><code>OLD_PASSWORD(str)</code>
<DD>
Создает строку "пароля" из простого текста в аргументе <code>str</code>. Именно эта
функция используется в целях шифрования паролей MySQL для хранения в
столбце <code>Password</code> в таблице привилегий <code>user</code>:


<pre>
mysql&#62; SELECT PASSWORD('badpwd');
        -&#62; '7f84554057dd964b'
</pre>

Шифрование, которое выполняет функция <code>PASSWORD()</code>, необратимо. Способ
шифрования пароля, который используется функцией <code>PASSWORD()</code>, отличается от
применяемого для шифрования паролей в Unix. 

Функция <code>PASSWORD()</code> используется в системе аутентификации в сервер MySQL, вам не следует использовать
ее для ваших собственных приложений. С этой целью, лучше используйте функции <code>MD5()</code> и <code>SHA1()</code>.

<A NAME="IDX1312"></A>
<DT><code>ENCRYPT(str[,salt])</code>
<DD>
Шифрует аргумент <code>str</code>, используя вызов системной функции кодирования
<code>crypt()</code> из Unix. Аргумент <code>salt</code> должен быть строкой из двух символов (в
версии MySQL 3.22.16 аргумент <code>salt</code> может содержать более двух символов):


<pre>
mysql&#62; SELECT ENCRYPT("hello");
        -&#62; 'VxuFAJXVARROc'
</pre>

Если функция <code>crypt()</code> в данной операционной системе недоступна, функция
<code>ENCRYPT()</code> всегда возвращает <code>NULL</code>. Функция  <code>ENCRYPT()</code> игнорирует все
символы в аргументе <code>str</code>, за исключением первых восьми, по крайней мере в
некоторых операционных системах - это определяется тем, как реализован
системный вызов базовой функции <code>crypt()</code>.

<A NAME="IDX1313"></A>
<DT><code>ENCODE(str,pass_str)</code>
<DD>
Шифрует  <code>str</code>, используя аргумент  <code>pass_str</code> как пароль. Для расшифровки
результата следует использовать функцию <code>DECODE()</code>. Результат представляет
собой двоичную строку той же длины, что и <code>string</code>. Для хранения результата
в столбце следует использовать столбец типа <code>BLOB</code>.

<A NAME="IDX1314"></A>
<DT><code>DECODE(crypt_str,pass_str)</code>
<DD>
Расшифровывает зашифрованную строку <code>crypt_str</code>, используя аргумент
<code>pass_str</code> как пароль. Аргумент <code>crypt_str</code> должен быть строкой, возвращаемой
функцией <code>ENCODE()</code>.

<A NAME="IDX1315"></A>
<DT><code>MD5(string)</code>
<DD>
Вычисляет 128-битовую контрольную сумму <code>MD5</code> для аргумента <code>string</code>.
Возвращаемая величина представляет собой 32-разрядное шестнадцатеричное
число, которое может быть использовано, например, в качестве хеш-ключа:


<pre>
mysql&#62; SELECT MD5("testing");
        -&#62; 'ae2b1fca515949e5d54fb22b8ed95575'
</pre>

Это "<code>RSA Data Security, Inc. MD5 Message-Digest Algorithm</code>".

<A NAME="IDX1316"></A>
<A NAME="IDX1317"></A>
<DT><code>SHA1(string)</code>
<DD>
<DT><code>SHA(string)</code>
<DD>
Вычисляет 160-битовую контрольную сумму <code>SHA1</code> для аргумента <code>string</code>, как
описано в RFC 3174 (Secure  Hash  Algorithm). Возвращаемая величина
представляет собой 40-разрядное шестнадцатеричное число или <code>NULL</code> (в том
случае, если входной аргумент был равен <code>NULL</code>). Одно из возможных
применений для этой функции - в качестве хеш-ключа. Можно ее использовать
и как криптографически безопасную функцию для сохранения паролей.


<pre>
mysql&#62; SELECT SHA1("abc");
        -&#62; 'a9993e364706816aba3e25717850c26c9cd0d89d'
</pre>

Функция  <code>SHA1()</code> была добавлена в версии 4.0.2, и может рассматриваться как
более защищенный криптографически эквивалент функции <code>MD5()</code>. <code>SHA()</code> является
синонимом для функции <code>SHA1()</code>.

<A NAME="IDX1318"></A>
<A NAME="IDX1319"></A>
<DT><code>AES_ENCRYPT(string,key_string)</code>
<DD>
<DT><code>AES_DECRYPT(string,key_string)</code>
<DD>
Эти функции позволяют шифровать/дешифровать данные, используя официальный
алгоритм AES (Advanced  Encryption  Standard) (предыдущее название -
Rijndael). В нем применяется кодирование с 128-битовым ключом, однако при
помощи патча к исходному коду длину ключа можно увеличить до 256 битов. В
MySQL выбран 128-битовый ключ, поскольку он работает намного быстрее и
обычно обеспечивает вполне достаточную защищенность. Входные аргументы
могут быть любой длины. Если один из аргументов равен <code>NULL</code>, то результат
этой функции также будет иметь значение <code>NULL</code>. 

Так как AES является
алгоритмом блочного уровня, то для декодирования используется дополнение
строк нечетной длины, так, чтобы длина результирующей строки могла
вычисляться как выражение <code>16*(trunc(длина_строки/16)+1)</code>. 

Если <code>AES_DECRYPT()</code> обнаруживает некорректные данные или некорректное 
заполнение строки (<em>имеет в виду padding - прим. пер.</em>), функция вернет
<code>NULL</code>. Однако <code>AES_DECRYPT()</code> вполне может вернуть не-<code>NULL</code> величину, или, возможно,
просто мусор, если входные данных или ключ - некорректны.

<code>AES_DECRYPT()</code> имеет также модификацию, возвращающую величину со
значением, не равным <code>NULL</code>, даже при неправильном ключе. Функции AES можно
использовать для хранения данных в зашифрованном виде путем модификации
запросов:


<pre>
INSERT INTO t VALUES (1,AES_ENCRYPT("text","password"));
</pre>

Можно добиться еще более высокого уровня защищенности за счет исключения
передачи ключа через соединение для каждого запроса - для этого ключ на
время соединения должен сохраняться в переменной на сервере:


<pre>
SELECT @password:="my password";
INSERT INTO t VALUES (1,AES_ENCRYPT("text",@password));
</pre>

Функции  <code>AES_ENCRYPT()</code> и <code>AES_DECRYPT()</code> были добавлены в версию 4.0.2 и
могут рассматриваться как наиболее криптографически защищенные шифрующие
функции, в настоящее время доступные в MySQL.

<A NAME="IDX1320"></A>
<DT><code>DES_ENCRYPT(string_to_encrypt [, (key_number | key_string) ] )</code>
<DD>
Шифрует строку с заданным ключом, используя алгоритм тройного DES. Следует
учитывать, что эта функция работает только тогда, когда конфигурация MySQL
поддерживает SSL. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Secure_connections">4.3.9  Использование безопасных соединений</A>. Ключ для
использования при шифровании выбирается следующим образом:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Аргумент</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>Только один аргумент </TD><TD> Используется первый ключ из <code>des-key-file</code>
</TD></TR>
<TR><TD>Номер ключа </TD><TD> Используется заданный ключ (0-9) из <code>des-key-file</code>
</TD></TR>
<TR><TD>Строка </TD><TD> Для шифрования <code>string_to_encrypt</code> может использоваться ключ, заданный в <code>key_string</code>
</TD></TR>
</TABLE>

Функция возвращает двоичную строку, в которой первый символ будет 
<code>CHAR(128 | key_number)</code>. Число <code>128</code> добавлено для упрощения распознавания
зашифрованного ключа. При использовании строкового ключа <code>key_number</code> будет
равен <code>127</code>. При ошибке эта функция возвращает <code>NULL</code>. Длина строки в
результате будет равна <code>new_length=org_length + (8-(org_length % 8))+1</code>.
Выражение <code>des-key-file</code> имеет следующий форматt:


<pre>
key_number des_key_string
key_number des_key_string
</pre>

Каждый элемент <code>key_number</code> должен быть числом от 0 до 9. Строки в данном
файле могут располагаться в произвольном порядке. Выражение <code>des_key_string</code>
представляет собой строку, которая будет использована при шифровании
сообщения. Между числом и ключом должен быть по крайней мере один пробел.
Первый ключ используется по умолчанию, если не задан какой-либо аргумент
ключа в функции <code>DES_ENCRYPT()</code>. Существует возможность послать MySQL запрос
на чтение новых значений ключей из файла ключей при помощи команды <code>FLUSH 
DES_KEY_FILE</code>. Эта операция требует наличия привилегии <code>Reload_priv</code>. Одно из
преимуществ наличия набора ключей по умолчанию состоит в том, что
приложения могут проверять существование зашифрованных величин в столбцах
без предоставления конечному пользователю права расшифровки этих величин.


<pre>
mysql&#62; SELECT customer_address FROM customer_table WHERE
        crypted_credit_card = DES_ENCRYPT("credit_card_number");
</pre>

<A NAME="IDX1321"></A>
<DT><code>DES_DECRYPT(string_to_decrypt [, key_string])</code>
<DD>
Дешифрует строку, зашифрованную с помощью функции <code>DES_ENCRYPT()</code>. Следует
учитывать, что эта функция работает только тогда, когда конфигурация MySQL
поддерживает SSL. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Secure_connections">4.3.9  Использование безопасных соединений</A>. Если аргумент
<code>key_string</code> не задан, то функция <code>DES_DECRYPT()</code> проверяет первый байт
зашифрованной строки для определения номера ключа алгоритма DES,
использованного для шифрования исходной строки, Затем читает ключ из
<code>des-key-file</code> для расшифровки сообщения. Чтобы выполнить это, пользователь
должен обладать привилегией <code>SUPER</code>. При указании значения аргумента в
<code>key_string</code> эта строка используется как ключ для дешифровки сообщения. Если
строка <code>string_to_decrypt</code> не выглядит как зашифрованная, то MySQL вернет
заданную строку <code>string_to_decrypt</code>. При ошибке эта функция возвращает <code>NULL</code>.

<A NAME="IDX1322"></A>
<DT><code>LAST_INSERT_ID([expr])</code>
<DD>
Возвращает последнюю автоматически сгенерированную величину, которая была
внесена в столбец <code>AUTO_INCREMENT</code>. See section <A HREF="manual.ru_Clients.html#mysql_insert_id">8.4.3.130  <code>mysql_insert_id()</code></A>.


<pre>
mysql&#62; SELECT LAST_INSERT_ID();
        -&#62; 195
</pre>

Значение последнего сгенерированного <code>ID</code> сохраняется на сервере для данного
конкретного соединения и не будет изменено другим клиентом. Оно не будет
изменено даже при обновлении другого столбца <code>AUTO_INCREMENT</code> конкретной
величиной (то есть, которая не равна <code>NULL</code> и не равна <code>0</code>). При внесении
большого количества строк с помощью одной команды <code>INSERT</code> функция
<code>LAST_INSERT_ID()</code> возвращает значение для первой внесенной строки. Причина
этого заключается в том, что можно легко воспроизвести точно такую же
команду <code>INSERT</code> на другом сервере.

Если задано значение аргумента <code>expr</code> в функции <code>LAST_INSERT_ID()</code>, то
величина аргумента возвращается функцией и устанавливается в качестве
следующего значения, которое будет возвращено функцией <code>LAST_INSERT_ID()</code>.
Это можно использовать для моделирования последовательностей: 

Вначале создается таблица:


<pre>
mysql&#62; CREATE TABLE sequence (id INT NOT NULL);
mysql&#62; INSERT INTO sequence VALUES (0);
</pre>

Затем данную таблицу можно использовать для генерации чисел
последовательности как показано ниже:


<pre>
mysql&#62; UPDATE sequence SET id=LAST_INSERT_ID(id+1);
</pre>

Можно генерировать последовательности без вызова <code>LAST_INSERT_ID()</code>:
полезность применения данной функции состоит в том, что данное значение <code>ID</code>
поддерживается на сервере как последняя автоматически сгенерированная
величина (защищенная от других пользователей), и вы можете извлекать новый
<code>ID</code> так же, как и любое другое нормальное значение <code>AUTO_INCREMENT</code> в MySQL.
Например, функция <code>LAST_INSERT_ID()</code> (без аргумента) возвратит новое
значение <code>ID</code>. Функцию C  API  <code>mysql_insert_id()</code> также можно использовать
для получения этой величины. Следует учитывать, что, поскольку функция
<code>mysql_insert_id()</code> обновляется только после команд <code>INSERT</code> и <code>UPDATE</code>, то
нельзя использовать эту функцию C  API для извлечения значения <code>ID</code> для
<code>LAST_INSERT_ID(expr)</code> после выполнения других команд SQL, таких как <code>SELECT</code>
или <code>SET</code>.

<A NAME="IDX1323"></A>
<DT><code>FORMAT(X,D)</code>
<DD>
Форматирует число <code>X</code> в формат вида <code>'#,###,###.##'</code> с округлением до <code>D</code>
десятичных знаков. Если <code>D</code> равно <code>0</code>, результат будет представлен без
десятичной точки или дробной части:


<pre>
mysql&#62; SELECT FORMAT(12332.123456, 4);
        -&#62; '12,332.1235'

mysql&#62; SELECT FORMAT(12332.1,4);
        -&#62; '12,332.1000'

mysql&#62; SELECT FORMAT(12332.2,0);
        -&#62; '12,332'
</pre>

<A NAME="IDX1324"></A>
<DT><code>VERSION()</code>
<DD>
Возвращает строку с номером версии сервера MySQL:


<pre>
mysql&#62; SELECT VERSION();
        -&#62; '3.23.13-log'
</pre>

Следует учитывать, что если данная версия заканчивается с <code>-log</code>, то это
означает, что включено ведение журналов.

<A NAME="IDX1325"></A>
<DT><code>CONNECTION_ID()</code>
<DD>
Возвращает идентификатор (<code>thread_id</code>) для данного соединения. Каждое
соединение имеет свой собственный уникальный идентификатор:


<pre>
mysql&#62; SELECT CONNECTION_ID();
        -&#62; 1
</pre>

<A NAME="IDX1326"></A>
<DT><code>GET_LOCK(str,timeout)</code>
<DD>
Пытается осуществить блокировку по имени, которое заданно в строке <code>str</code>, с
временем ожидания в секундах, указанном в аргументе <code>timeout</code>. Возвращает <code>1</code>,
если блокировка осуществлена успешно, <code>0</code> - если закончилось время
ожидания для данной попытки, или <code>NULL</code>, если возникла ошибка (такая как
отсутствие свободной памяти или уничтожение потока командой <code>mysqladmin kill</code>).

Блокировка снимается при выполнении команды <code>RELEASE_LOCK()</code>, запуске новой
команды <code>GET_LOCK()</code> или при завершении данного потока. Эту функцию можно
использовать для осуществления блокировок уровня приложения или для
моделирования блокировки записи. Функция блокирует запросы других клиентов
на блокировку с тем же именем; клиенты, которые используют согласованные
имена блокировок, могут применять эту функцию для выполнения совместного
упредительного блокирования:


<pre>
mysql&#62; SELECT GET_LOCK("lock1",10);
        -&#62; 1
mysql&#62; SELECT IS_FREE_LOCK("lock2");
        -&#62; 1
mysql&#62; SELECT GET_LOCK("lock2",10);
        -&#62; 1
mysql&#62; SELECT RELEASE_LOCK("lock2");
        -&#62; 1
mysql&#62; SELECT RELEASE_LOCK("lock1");
        -&#62; NULL
</pre>

Обратите внимание: повторный вызов функции <code>RELEASE_LOCK()</code> возвращает <code>NULL</code>,
поскольку блокировка <code>lock1</code> была автоматически выполнена вторым вызовом
функции <code>GET_LOCK()</code>.

<A NAME="IDX1327"></A>
<DT><code>RELEASE_LOCK(str)</code>
<DD>
Снимает блокировку, указанную в строке <code>str</code>, полученной от функции
<code>GET_LOCK()</code>. Возвращает <code>1</code> если блокировка была снята, <code>0</code> - если такая
блокировка уже поставлена в другом соединении (в этом случае блокировка не
снимается) и <code>NULL</code>, если блокировки с указанным именем не существует.
Последнее может произойти в случае, когда вызов функции <code>GET_LOCK()</code> не
привел к успешному результату или данная блокировка уже снята. Функцию
<code>RELEASE_LOCK()</code> удобно использовать совместно с командой <code>DO</code>. 
See section <A HREF="manual.ru_Reference.html#DO">6.4.10  Синтаксис оператора <code>DO</code></A>.

<A NAME="IDX1328"></A>
<DT><code>IS_FREE_LOCK(str)</code>
<DD>
Проверяет, свободна ли блокировка по имени <code>str</code> (т.е. не установлена).
Возвращает <code>1</code> если блокировка свободна (никто не поставил таковую).
Возвращает <code>0</code> если блокировка установлена и <code>NULL</code> в случае ошибки
(например, при неправильных аргументах).

<A NAME="IDX1329"></A>
<DT><code>BENCHMARK(count,expr)</code>
<DD>
Функция <code>BENCHMARK()</code> повторяет выполнение выражения <code>expr</code> заданное
количество раз, указанное в аргументе <code>count</code>. Она может использоваться для
определения того, насколько быстро MySQL обрабатывает данное выражение.
Значение результата всегда равно <code>0</code>. Функция предназначена для
использования в клиенте <code>mysql</code>, который сообщает о времени выполнения
запроса:


<pre>
mysql&#62; SELECT BENCHMARK(1000000,ENCODE("hello","goodbye"));
+----------------------------------------------+
| BENCHMARK(1000000,ENCODE("hello","goodbye")) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (4.74 sec)
</pre>

Указанное в отчете время представляет собой время, подсчитанное на стороне
клиента, а не время, затраченное центральным процессором (CPU time) на
сервере. Может оказаться целесообразным выполнить <code>BENCHMARK()</code> несколько
раз, чтобы выяснить, насколько интенсивно загружен серверный компьютер.

<A NAME="IDX1330"></A>
<DT><code>INET_NTOA(expr)</code>
<DD>
По заданному числовому адресу сети (4 или 8 байтов) возвращает
представление указанного адреса в виде разделенных точками четырех октетов
в виде строки:


<pre>
mysql&#62; SELECT INET_NTOA(3520061480);
        -&#62; "209.207.224.40"
</pre>

<A NAME="IDX1331"></A>
<DT><code>INET_ATON(expr)</code>
<DD>
По заданному представлению сетевого адреса в виде строки, содержащей
разделенные точками четыре октета, функция возвращает целое число,
представляющее собой числовое значение данного адреса. Адреса могут быть
длиной 4 или 8 байтов:


<pre>
mysql&#62; SELECT INET_ATON("209.207.224.40");
        -&#62; 3520061480
</pre>

Результирующее число всегда генерируется в соответствии с порядком
расположения октетов в сетевом адресе, например вышеприведенное число
вычисляется как <code>209*256^3 + 207*256^2 + 224*256 +40</code>.

<A NAME="IDX1332"></A>
<DT><code>MASTER_POS_WAIT(log_name, log_pos)</code>
<DD>
Блокируется, пока подчиненный сервер не достигнет определенной точки положения
в журнале репликации головного сервера (т.е. не прочитает и не выполнит все
операции до указанной позиции).

Если информация головного сервера не инициализирована, или аргументы
неправильны, то функция возвращает <code>NULL</code>. Если подчиненный сервер не
работает, то функция блокируется и ожидает, пока сервер запустится и дойдет до
указанной позиции или пройдет через нее.  Если подчиненный сервер уже прошел
указанную точку, то функция немедленно возвращает результат. 

Если timeout (новшество в 4.0.10) указан, то ожидание прекратится по 
прошествии timeout секунд. Таймаут должен быть больше 0. 0 или негативный таймаут
означает тоже самое что и отсутствие таймаута. 

Возвращаемая величина представляет собой число событий в журнале, которые
функция должна была ``переждать'', пока сервер дойдет до указанной точки,
<code>NULL</code> в случае ошибки или <code>-1</code> в случае, если истек таймаут. 

<A NAME="IDX1333"></A>
<A NAME="IDX1334"></A>
<DT><code>FOUND_ROWS()</code>
<DD>
Возвращает количество строк, которые возвратила бы последняя команда
<code>SELECT SQL_CALC_FOUND_ROWS ...</code> при отсутствии ограничения оператором
<code>LIMIT</code>.


<pre>
mysql&#62; SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name WHERE id &#62; 100 LIMIT 10;
mysql&#62; SELECT FOUND_ROWS();
</pre>

Второй вызов команды <code>SELECT</code> возвратит количество строк, которые возвратила
бы первая команда SELECT, если бы она была написана без выражения <code>LIMIT</code>.
Отметим, что, хотя при использовании команды <code>SELECT SQL_CALC_FOUND_ROWS
...</code>, MySQL должен пересчитать все строки в наборе результатов, этот способ
все равно быстрее, чем без <code>LIMIT</code>, так как не требуется посылать результат
клиенту.

Функция <code>SQL_CALC_FOUND_ROWS</code> появилась в MySQL 4.0.0.
</DL>



<H3><A NAME="Group_by_functions" HREF="manual.ru_toc.html#Group_by_functions">6.3.7  Функции, используемые в операторах <code>GROUP BY</code></A></H3>

<P>
<A NAME="IDX1335"></A>

</P>
<P>
Вызов групповых функций для SQL-команд, не содержащих <code>GROUP BY</code>,
эквивалентен выполнению этих функций над всем набором возвращаемых данных.

</P>
<DL COMPACT>

<DT><code>COUNT(expr)</code>
<DD>
<A NAME="IDX1336"></A>
 

Возвращает количество величин со значением, не равным <code>NULL</code>, в строках,
полученных при помощи команды <code>SELECT</code>:


<pre>
mysql&#62; SELECT student.student_name,COUNT(*) FROM student,course
        WHERE student.student_id=course.student_id
        GROUP BY student_name;
</pre>

Функция <code>COUNT(*)</code> несколько отличается от описанной выше: она возвращает
количество извлеченных строк, содержащих величины со значением <code>NULL</code>.
<code>COUNT(*)</code> оптимизирована для очень быстрого возврата результата при
условии, что команда <code>SELECT</code> извлекает данные из одной таблицы, никакие
другие столбцы не обрабатываются и функция не содержит выражения <code>WHERE</code>.
Например:


<pre>
mysql&#62; SELECT COUNT(*) FROM student;
</pre>

<A NAME="IDX1337"></A>
<A NAME="IDX1338"></A>
<DT><code>COUNT(DISTINCT expr,[expr...])</code>
<DD>
Возвращает количество различающихся величин со значением, не равным <code>NULL</code>:


<pre>
mysql&#62; SELECT COUNT(DISTINCT results) FROM student;
</pre>

В MySQL для того, чтобы получить количество различающихся комбинаций
выражений, не содержащих <code>NULL</code>, нужно просто задать список этих выражений.
В ANSI  SQL необходимо провести конкатенацию всех выражений внутри
<code>COUNT(DISTINCT ...)</code>.

<A NAME="IDX1339"></A>
<DT><code>AVG(expr)</code>
<DD>
Возвращает среднее значение аргумента expr:


<pre>
mysql&#62; SELECT student_name, AVG(test_score)
        FROM student
        GROUP BY student_name;
</pre>

<A NAME="IDX1340"></A>
<A NAME="IDX1341"></A>
<DT><code>MIN(expr)</code>
<DD>
<DT><code>MAX(expr)</code>
<DD>
Возвращает минимальную или максимальную величину аргумента <code>expr</code>. Функции 
<code>MIN()</code> и <code>MAX()</code> могут принимать строковый аргумент; в таких случаях они
возвращают минимальную или максимальную строковую величину. 
See section <A HREF="manual.ru_MySQL_Optimisation.html#MySQL_indexes">5.4.3  Использование индексов в MySQL</A>.


<pre>
mysql&#62; SELECT student_name, MIN(test_score), MAX(test_score)
        FROM student
        GROUP BY student_name;
</pre>

В <code>MIN()</code>, <code>MAX()</code> и других групповых фунциях MySQL сейчас сравнивает <code>ENUM</code> и <code>SET</code>-столбцы по ихнему строковому представлению а не по относительной позиции строки в множестве. Это будет исправлено. 

<A NAME="IDX1342"></A>
<DT><code>SUM(expr)</code>
<DD>
Возвращает сумму величин в аргументе <code>expr</code>. Обратите внимание: если
возвращаемый набор данных не содержит ни одной строки, то функция
возвращает <code>NULL</code>!

<A NAME="IDX1343"></A>
<DT><code>VARIANCE(expr)</code>
<DD>
Возвращает вариант стандарта, которому соответствует <code>expr</code>. Это - расширение по сравнению с ANSI SQL, доступное только в 4.1 или более поздних версиях. 

<A NAME="IDX1344"></A>
<A NAME="IDX1345"></A>
<DT><code>STD(expr)</code>
<DD>
<DT><code>STDDEV(expr)</code>
<DD>
Возвращает среднеквадратичное отклонение значения в аргументе <code>expr</code>. Эта
функция является расширением ANSI  SQL. Форма <code>STDDEV()</code> обеспечивает
совместимость с Oracle.

<A NAME="IDX1346"></A>
<DT><code>BIT_OR(expr)</code>
<DD>
Возвращает побитовое ИЛИ для всех битов в <code>expr</code>. Вычисление производится с
64-битовой (<code>BIGINT</code>) точностью.

<A NAME="IDX1347"></A>
<DT><code>BIT_AND(expr)</code>
<DD>
Возвращает побитовое И для всех битов в <code>expr</code>. Вычисление производится с
64-битовой (<code>BIGINT</code>) точностью.
</DL>

<P>
В MySQL расширены возможности использования оператора <code>GROUP BY</code>. Теперь в
выражениях <code>SELECT</code> можно использовать столбцы или вычисления, которые не
присутствуют в части <code>GROUP BY</code>. Это справедливо для любой возможной
величины для этой группы. Данная возможность позволяет повысить
производительность за счет исключения сортировки и группирования ненужных
величин. Например, в следующем запросе нет необходимости в группировке
<code>customer.name</code>:

</P>

<pre>
mysql&#62; SELECT order.custid,customer.name,MAX(payments)
        FROM order,customer
        WHERE order.custid = customer.custid
        GROUP BY order.custid;
</pre>

<P>
В ANSI  SQL к предложению <code>GROUP BY</code>  необходимо добавлять <code>customer.name</code>. В
MySQL, если работа происходит не в режиме ANSI, это имя избыточно.

</P>
<P>
Не используйте данное свойство, если столбцы, пропущенные в части <code>GROUP 
BY</code>, не являются уникальными в данной группе! Возможны непредсказуемые
результаты.

</P>
<P>
В некоторых случаях можно применять функции <code>MIN()</code> и <code>MAX()</code> для получения
указанной величины столбца, даже если он не является уникальным. В
следующем примере выдается значение столбца <code>column</code> из строки, содержащей
наименьшую величину в столбце <code>sort</code>:

</P>

<pre>
SUBSTR(MIN(CONCAT(RPAD(sort,6,' '),column)),7)
</pre>

<P>
See section <A HREF="manual.ru_Tutorial.html#example-Maximum-column-group-row">3.5.4  Строка, содержащая максимальное значение некоторого столбца</A>.

</P>
<P>
<A NAME="IDX1348"></A>
<A NAME="IDX1349"></A>
<A NAME="IDX1350"></A>
<A NAME="IDX1351"></A>
<A NAME="IDX1352"></A>

</P>

<P>
Следует отметить, что в версии MySQL 3.22 (или более ранней) либо при
попытке работы в рамках ANSI  SQL применение выражений в предложениях
<code>GROUP BY</code> или <code>ORDER BY</code> невозможно. Это ограничение можно обойти,
используя для выражения псевдоним:

</P>

<pre>
mysql&#62; SELECT id,FLOOR(value/100) AS val FROM tbl_name
        GROUP BY id,val ORDER BY val;
</pre>

<P>
В версии MySQL 3.23 можно также выполнить следующее:

</P>

<pre>
mysql&#62; SELECT id,FLOOR(value/100) FROM tbl_name ORDER BY RAND();
</pre>



<H2><A NAME="Data_Manipulation" HREF="manual.ru_toc.html#Data_Manipulation">6.4  Обработка данных: SELECT, INSERT, UPDATE, DELETE</A></H2>



<H3><A NAME="SELECT" HREF="manual.ru_toc.html#SELECT">6.4.1  Синтаксис оператора <code>SELECT</code></A></H3>

<P>
<A NAME="IDX1353"></A>

</P>
<P>
Оператор SELECT имеет следующую структуру:

</P>

<pre>
SELECT [STRAIGHT_JOIN]
       [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
       [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] [HIGH_PRIORITY]
       [DISTINCT | DISTINCTROW | ALL]
    select_expression,...
    [INTO {OUTFILE | DUMPFILE} 'file_name' export_options]
    [FROM table_references
      [WHERE where_definition]
      [GROUP BY {unsigned_integer | col_name | formula} [ASC | DESC], ...]
      [HAVING where_definition]
      [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC], ...]
      [LIMIT [offset,] rows | rows OFFSET offset]
      [PROCEDURE procedure_name(argument_list)]
      [FOR UPDATE | LOCK IN SHARE MODE]]
</pre>

<P>
<code>SELECT</code> применяется для извлечения строк, выбранных из одной или нескольких
таблиц. Выражение <code>select_expression</code> задает столбцы, в которых необходимо
проводить выборку. Кроме того, оператор  <code>SELECT</code> можно использовать для
извлечения строк, вычисленных без ссылки на какую-либо таблицу. Например:

</P>

<pre>
mysql&#62; SELECT 1 + 1;
        -&#62; 2
</pre>

<P>
При указании ключевых слов следует точно соблюдать порядок, указанный
выше. Например, выражение <code>HAVING</code> должно располагаться после всех выражений
<code>GROUP BY</code> и перед всеми выражениями <code>ORDER BY</code>.

</P>

<ul>
<LI>

Используя ключевое слово <code>AS</code>, выражению в <code>SELECT</code> можно присвоить
псевдоним. Псевдоним используется в качестве имени столбца в данном
выражении и может применяться в <code>ORDER BY</code> или <code>HAVING</code>. Например:


<pre>
mysql&#62; SELECT CONCAT(last_name,', ',first_name) AS full_name
        FROM mytable ORDER BY full_name;
</pre>

<LI>

Псевдонимы столбцов нельзя использовать в выражении  <code>WHERE</code>, поскольку
находящиеся в столбцах величины на момент выполнения <code>WHERE</code>  могут быть
еще не определены. See section <A HREF="manual.ru_Problems.html#Problems_with_alias">A.5.4  Проблемы  с <code>alias</code></A>.

<LI>

<A NAME="IDX1355"></A>
<A NAME="IDX1356"></A>
<A NAME="IDX1357"></A>
<A NAME="IDX1358"></A>
<A NAME="IDX1359"></A>
<A NAME="IDX1360"></A>
Выражение <code>FROM table_references</code> задает таблицы, из которых надлежит
извлекать строки. Если указано имя более чем одной таблицы, следует
выполнить объединение. Информацию о синтаксисе объединения можно найти
в разделе section <A HREF="manual.ru_Reference.html#JOIN">6.4.1.1  Синтаксис оператора <code>JOIN</code></A>. Для каждой заданной таблицы по желанию можно
указать псевдоним.


<pre>
table_name [[AS] alias] [[USE INDEX (key_list)] | [IGNORE INDEX (key_list)] | FORCE INDEX (key_list)]]
</pre>

В версии MySQL 3.23.12 можно указывать, какие именно индексы (ключи) MySQL
должен применять для извлечения информации из таблицы. Это полезно, если
оператор <code>EXPLAIN</code> (выводящий информацию о структуре и порядке выполнения
запроса <code>SELECT</code>), показывает, что MySQL из списка возможных индексов выбрал неправильный. Если
нужно. чтобы для поиска записи в таблице применялся только один из
возможных индексов, следует задать значение этого индекса в <code>USE INDEX</code>
(<code>key_list</code>). Альтернативное выражение <code>IGNORE INDEX (key_list)</code> запрещает
использование в MySQL данного конкретного индекса. 

В MySQL 4.0.9 можно также указывать <code>FORCE INDEX</code>. Это работает также, как
и <code>USE INDEX (key_list)</code> но в дополнение дает понять серверу что полное
сканирование таблицы будет ОЧЕНЬ дорогостоящей операцией. Другими словами, в
этом случае сканирование таблицы будет использовано только тогда, когда не
будет найдено другого способа использовать один из данных индексов для поиска
записей в таблице. 

Выражения <code>USE/IGNORE
KEY</code> являются синонимами для <code>USE/IGNORE INDEX</code>.

<LI>

Ссылки на таблицы могут даваться как <code>tbl_name</code> (в рамках текущей базы данных),
или как <code>dbname.tbl_name</code> с тем, чтобы четко указать базу данных.

Ссылки на столбцы могут задаваться в виде <code>col_name</code>, <code>tbl_name.col_name</code>
или <code>db_name.tbl_name.col_name</code>. В выражениях <code>tbl_name</code> или
<code>db_name.tbl_name</code> нет необходимости указывать префикс  для ссылок на
столбцы в команде <code>SELECT</code>, если эти ссылки нельзя истолковать
неоднозначно. See section <A HREF="manual.ru_Reference.html#Legal_names">6.1.2  Имена баз данных, таблиц, столбцов, индексы псевдонимы</A>, где приведены примеры неоднозначных случаев, для которых
требуются более четкие определения ссылок на столбцы.

<LI>

<A NAME="IDX1361"></A>
Ссылку на таблицу можно заменить псевдонимом, используя <code>tbl_name [AS]
alias_name</code>:


<pre>
mysql&#62; SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
        WHERE t1.name = t2.name;

mysql&#62; SELECT t1.name, t2.salary FROM employee t1, info t2
        WHERE t1.name = t2.name;
</pre>

<LI>

В выражениях <code>ORDER BY</code> и <code>GROUP BY</code> для ссылок на столбцы, выбранные
для вывода информации, можно использовать либо имена столбцов, либо их
псевдонимы, либо их позиции (местоположения). Нумерация позиций
столбцов начинается с <code>1</code>:


<pre>
mysql&#62; SELECT college, region, seed FROM tournament
        ORDER BY region, seed;

mysql&#62; SELECT college, region AS r, seed AS s FROM tournament
        ORDER BY r, s;

mysql&#62; SELECT college, region, seed FROM tournament
        ORDER  BY 2, 3;
</pre>

Для того чтобы сортировка производилась в обратном порядке, в утверждении
<code>ORDER BY</code>  к имени заданного столбца, в котором производится сортировка,
следует добавить ключевое слово <code>DESC</code> (убывающий). По умолчанию принята
сортировка в возрастающем порядке, который можно задать явно при помощи
ключевого слова <code>ASC</code>.

<LI>

В выражении <code>WHERE</code> можно использовать любую из функций, которая
поддерживается в MySQL. See section <A HREF="manual.ru_Reference.html#Functions">6.3  Функции, используемые в операторах <code>SELECT</code> и <code>WHERE</code></A>.

Выражение <code>HAVING</code> может ссылаться на любой столбец или псевдоним,
упомянутый в выражении <code>select_expression</code>. <code>HAVING</code> отрабатывается
последним, непосредственно перед отсылкой данных клиенту, и без какой бы
то ни было оптимизации. Не используйте это выражение для определения того, что должно
быть определено в <code>WHERE</code>. Например, нельзя задать следующий оператор:


<pre>
mysql&#62; SELECT col_name FROM tbl_name HAVING col_name &#62; 0;
</pre>

Вместо этого следует задавать:


<pre>
mysql&#62; SELECT col_name FROM tbl_name WHERE col_name &#62; 0;
</pre>

В версии MySQL 3.22.5 или более поздней можно также писать запросы, как
показано ниже:


<pre>
mysql&#62; SELECT user,MAX(salary) FROM users
        GROUP BY user HAVING MAX(salary)&#62;10;
</pre>

В более старых версиях MySQL вместо этого можно указывать:


<pre>
mysql&#62; SELECT user,MAX(salary) AS sum FROM users
        GROUP BY user HAVING sum&#62;10;
</pre>

<LI>

Параметры (опции) <code>DISTINCT</code>, <code>DISTINCTROW</code> и <code>ALL</code> указывают, должны ли
возвращаться дублирующиеся записи. По умолчанию установлен параметр
(<code>ALL</code>), т.е. возвращаются все встречающиеся строки. <code>DISTINCT</code> и
<code>DISTINCTROW</code> являются синонимами и указывают, что дублирующиеся строки
в результирующем наборе данных должны быть удалены.

<LI>

Все параметры, начинающиеся с <code>SQL_</code>, <code>STRAIGHT_JOIN</code> и <code>HIGH_PRIORITY</code>,
представляют собой расширение MySQL для ANSI  SQL.

<LI>

При указании параметра  <code>HIGH_PRIORITY</code> содержащий его оператор <code>SELECT</code>
будет иметь более высокий приоритет, чем команда обновления таблицы.
Нужно только использовать этот параметр с запросами, которые должны
выполняться очень быстро и сразу. Если таблица заблокирована для
чтения, то запрос <code>SELECT HIGH_PRIORITY</code> будет выполняться даже при
наличии команды обновления, ожидающей, пока таблица освободится.

<LI>

Параметр  <code>SQL_BIG_RESULT</code> можно использовать с <code>GROUP BY</code> или <code>DISTINCT</code>,
чтобы сообщить оптимизатору, что результат будет содержать большое
количество строк. Если указан этот параметр, MySQL при необходимости
будет непосредственно использовать временные таблицы на диске, однако
предпочтение будет отдаваться не созданию временной таблицы с ключом
по элементам <code>GROUP BY</code>, а сортировке данных.

<LI>

При указании параметра  <code>SQL_BUFFER_RESULT</code>  MySQL будет заносить
результат во временную таблицу. Таким образом MySQL получает
возможность раньше снять блокировку таблицы; это полезно также для
случаев, когда для посылки результата клиенту требуется значительное
время.

<LI>

Параметр  <code>SQL_SMALL_RESULT</code> является опцией, специфической для MySQL.
Данный параметр можно использовать с <code>GROUP BY</code> или <code>DISTINCT</code>, чтобы
сообщить оптимизатору, что результирующий набор данных будет
небольшим. В этом случае MySQL для хранения результирующей таблицы
вместо сортировки будет использовать быстрые временные таблицы. В
версии MySQL 3.23 указывать данный параметр обычно нет необходимости.

<LI>

Параметр <code>SQL_CALC_FOUND_ROWS</code> (MySQL 4.0.0 и более новый) возвращает
количество строк, которые вернул бы оператор <code>SELECT</code>, если бы не был
указан <code>LIMIT</code>. Искомое количество строк можно получить при помощи
<code>SELECT FOUND_ROWS()</code>. See section <A HREF="manual.ru_Reference.html#Miscellaneous_functions">6.3.6.2  Разные функции</A>.

Заметьте, что в версиях MySQL до 4.1.0 это не работает с <code>LIMIT 0</code>,
который оптимизирован для того, чтобы немедленно вернуть нулевой результат.
See section <A HREF="manual.ru_MySQL_Optimisation.html#LIMIT_optimisation">5.2.8  Как MySQL оптимизирует <code>LIMIT</code></A>.

<LI>

Параметр  <code>SQL_CACHE</code> предписывает MySQL сохранять результат запроса в
кэше запросов при использовании <code>QUERY_CACHE_TYPE=2</code> (<code>DEMAND</code>).
See section <A HREF="manual.ru_Reference.html#Query_Cache">6.9  Кэш запросов в MySQL</A>.

<LI>

Параметр  <code>SQL_NO_CACHE</code> запрещает MySQL хранить результат запроса в
кэше запросов. See section <A HREF="manual.ru_Reference.html#Query_Cache">6.9  Кэш запросов в MySQL</A>.

<LI>

<A NAME="IDX1362"></A>
При использовании выражения <code>GROUP BY</code> строки вывода будут
сортироваться в соответствии с порядком, заданным в <code>GROUP BY</code>, - так,
как если бы применялось выражение <code>ORDER BY</code> для всех полей, указанных
в <code>GROUP BY</code>. В MySQL выражение <code>GROUP BY</code> расширено таким образом, что
для него можно также указывать параметры <code>ASC</code> и <code>DESC</code>:


<pre>
SELECT a,COUNT(b) FROM test_table GROUP BY a DESC
</pre>

<LI>

Расширенный оператор <code>GROUP BY</code> в MySQL обеспечивает, в частности,
возможность выбора полей, не упомянутых в выражении <code>GROUP BY</code>. Если
ваш запрос не приносит ожидаемых результатов, прочтите, пожалуйста,
описание <code>GROUP BY</code>. See section <A HREF="manual.ru_Reference.html#Group_by_functions">6.3.7  Функции, используемые в операторах <code>GROUP BY</code></A>.

<LI>

При указании параметра  <code>STRAIGHT_JOIN</code> оптимизатор будет объединять
таблицы в том порядке, в котором они перечислены в выражении <code>FROM</code>.
Применение данного параметра позволяет увеличить скорость выполнения
запроса, если оптимизатор производит объединение таблиц неоптимальным
образом. See section <A HREF="manual.ru_MySQL_Optimisation.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A>.

<LI>

Выражение <code>LIMIT</code> может использоваться для ограничения количества строк,
возвращенных командой <code>SELECT</code>. <code>LIMIT</code> принимает один или два числовых
аргумента. Эти аргументы должны быть целочисленными константами. Если
заданы два аргумента, то первый указывает на начало первой
возвращаемой строки, а второй задает максимальное количество
возвращаемых строк. При этом смещение начальной строки равно <code>0</code> (не <code>1</code>):

Для совместимости с PostgreSQL MySQL также поддерживает синтаксис
<code>LIMIT # OFFSET #</code>.


<pre>
mysql&#62; SELECT * FROM table LIMIT 5,10; # возвращает строки 6-15
</pre>

Для того, чтобы выбрать все строки с определенного смещения и до конца
результата, вы можете использовать значение <code>-1</code> в качестве второго параметра: 


<pre>
mysql&#62; SELECT * FROM table LIMIT 95,-1; # Retrieve rows 96-last.
</pre>

Если задан один аргумент, то он показывает максимальное количество
возвращаемых строк:


<pre>
mysql&#62; SELECT * FROM table LIMIT 5; # возвращает первых 5 строк
</pre>

Другими словами, <code>LIMIT n</code> эквивалентно <code>LIMIT 0,n</code>.

<LI>

<A NAME="IDX1363"></A>
Оператор <code>SELECT</code> может быть представлен в форме <code>SELECT ... INTO 
OUTFILE 'file_name'</code>. Эта разновидность команды осуществляет запись
выбранных строк в файл, указанный в <code>file_name</code>. Данный файл создается
на сервере и до этого не должен существовать (таким образом, помимо
прочего, предотвращается разрушение таблиц и файлов, таких как
<tt>`/etc/passwd'</tt>). Для использования этой формы команды <code>SELECT</code> необходимы
привилегии <code>FILE</code>. Форма <code>SELECT ... INTO OUTFILE</code> главным образом
предназначена для выполнения очень быстрого дампа таблицы на серверном
компьютере. Команду <code>SELECT ... INTO OUTFILE</code> нельзя применять, если
необходимо создать результирующий файл на ином хосте, отличном от
серверного. В таком случае для генерации нужного файла вместо этой
команды следует использовать некоторую клиентскую программу наподобие
<code>mysqldump --tab</code> или <code>mysql -e "SELECT ..." &#62; outfile</code>. Команда  <code>SELECT
... INTO OUTFILE</code> является дополнительной по отношению к <code>LOAD DATA 
INFILE</code>; синтаксис части export_options этой команды содержит те же
выражения <code>FIELDS</code> и <code>LINES</code>, которые используются в команде <code>LOAD DATA 
INFILE</code>. See section <A HREF="manual.ru_Reference.html#LOAD_DATA">6.4.9  Синтаксис оператора  <code>LOAD DATA INFILE</code></A>. Следует учитывать, что в
результирующем текстовом файле оператор <code>ESCAPED BY</code> экранирует только
следующие символы:


<ul>
<LI>Символ оператора <code>ESCAPED BY</code>

<LI>Первый символ оператора <code>FIELDS TERMINATED BY</code>

<LI>Первый символ оператора <code>LINES TERMINATED BY</code>

</ul>

Помимо этого ASCII-символ <code>0</code> конвертируется в <code>ESCAPED BY</code>, за которым
следует символ <samp>`0'</samp> (ASCII 48). Это делается потому, что необходимо
экранировать любые символы операторов <code>FIELDS TERMINATED BY</code>, <code>ESCAPED BY</code>
или <code>LINES TERMINATED BY</code>, чтобы иметь надежную возможность повторить
чтение этого файла. ASCII <code>0</code> экранируется, чтобы облегчить просмотр файла с
помощью программ вывода типа pager. Поскольку результирующий файл не
должен удовлетворять синтаксису SQL, нет необходимости экранировать
что-либо еще. Ниже приведен пример того, как получить файл в формате,
который используется многими старыми программами.


<pre>
SELECT a,b,a+b INTO OUTFILE "/tmp/result.text"
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY "\n"
FROM test_table;
</pre>

<LI>

<A NAME="IDX1364"></A>
Если вместо <code>INTO OUTFILE</code>  использовать <code>INTO DUMPFILE</code>, то MySQL
запишет в файл только одну строку без символов завершения столбцов или
строк и без какого бы то ни было экранирования. Это полезно для
хранения данных типа <code>BLOB</code> в файле.

<LI>

Следует учитывать, что любой файл, созданный с помощью <code>INTO OUTFILE</code> и
<code>INTO DUMPFILE</code>, будет доступен для записи всем пользователям! Причина
этого заключается в следующем: сервер MySQL не может создавать файл,
принадлежащий только какому-либо текущему пользователю (вы никогда не
можете запустить <code>mysqld</code> от пользователя <code>root</code>), соответственно, файл
должен быть доступен для записи всем пользователям.

При использовании <code>FOR UPDATE</code> с обработчиком таблиц, поддерживающим
блокировку страниц/строк, выбранные строки будут заблокированы для записи.
</ul>



<H4><A NAME="JOIN" HREF="manual.ru_toc.html#JOIN">6.4.1.1  Синтаксис оператора <code>JOIN</code></A></H4>

<P>
<A NAME="IDX1365"></A>
<A NAME="IDX1366"></A>
<A NAME="IDX1367"></A>
<A NAME="IDX1368"></A>
<A NAME="IDX1369"></A>
<A NAME="IDX1370"></A>
<A NAME="IDX1371"></A>
<A NAME="IDX1372"></A>
<A NAME="IDX1373"></A>
<A NAME="IDX1374"></A>
<A NAME="IDX1375"></A>
<A NAME="IDX1376"></A>

</P>
<P>
MySQL поддерживает следующий синтаксис оператора <code>JOIN</code> при использовании в
командах <code>SELECT</code>:

</P>

<pre>
table_reference, table_reference
table_reference [CROSS] JOIN table_reference
table_reference INNER JOIN table_reference join_condition
table_reference STRAIGHT_JOIN table_reference
table_reference LEFT [OUTER] JOIN table_reference join_condition
table_reference LEFT [OUTER] JOIN table_reference
table_reference NATURAL [LEFT [OUTER]] JOIN table_reference
{ OJ table_reference LEFT OUTER JOIN table_reference ON conditional_expr }
table_reference RIGHT [OUTER] JOIN table_reference join_condition
table_reference RIGHT [OUTER] JOIN table_reference
table_reference NATURAL [RIGHT [OUTER]] JOIN table_reference
</pre>

<P>
где <code>table_reference</code> определено, как:
<A NAME="IDX1377"></A>

<pre>
table_name [[AS] alias] [[USE INDEX (key_list)] | [IGNORE INDEX (key_list)] | [FORCE INDEX (key_list)]]
</pre>

<P>
и <code>join_condition</code> определено, как:

</P>

<pre>
ON conditional_expr |
USING (column_list)
</pre>

<P>
В большинстве случаев не следует указывать в части <code>ON</code>  какие бы то ни
было условия, накладывающие ограничения на строки в наборе результатов (из
этого правила есть исключения). Если необходимо указать, какие строки должны
присутствовать в результате, следует сделать это в выражении <code>WHERE</code>.

</P>
<P>
Необходимо учитывать, что в версиях до 3.23.17 оператор <code>INNER JOIN</code> не
принимает параметр <code>join_condition</code>!

</P>
<P>
<A NAME="IDX1378"></A>
<A NAME="IDX1379"></A>
Наличие последней из приведенных выше конструкций выражения <code>LEFT OUTER 
JOIN</code> обусловлено только требованиями совместимости с ODBC:

</P>

<ul>
<LI>

Вместо ссылки на таблицу может использоваться псевдоним, который
присваивается при помощи выражений <code>tbl_name AS alias_name</code> или
<code>tbl_name alias_name</code>:


<pre>
mysql&#62; SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
        WHERE t1.name = t2.name;
</pre>

<LI>

Условный оператор <code>ON</code> представляет собой условие в любой форме из числа
тех, которые можно использовать в выражении <code>WHERE</code>.

<LI>

Если запись для правой таблицы в частях <code>ON</code> или <code>USING</code> в <code>LEFT JOIN</code> не
найдена, то для данной таблицы используется строка, в которой все
столбцы установлены в <code>NULL</code>. Эту возможность можно применять для
нахождения результатов в таблице, не имеющей эквивалента в другой
таблице:


<pre>
mysql&#62; SELECT table1.* FROM table1
        LEFT JOIN table2 ON table1.id=table2.id
        WHERE table2.id IS NULL;
</pre>

Этот пример находит все строки в таблице <code>table1</code> с величиной <code>id</code>, которая
не присутствует в таблице <code>table2</code> (т.е. все строки в <code>table1</code>, для которых
нет соответствующих строк в <code>table2</code>). Конечно, это предполагает, что
<code>table2.id</code> объявлен как <code>NOT NULL</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#LEFT_JOIN_optimisation">5.2.6  Как MySQL оптимизирует <code>LEFT JOIN</code> и <code>RIGHT JOIN</code></A>.

<LI>

<code>USING (column_list)</code> служит для указания списка столбцов, которые
должны существовать в обеих таблицах. Такое выражение <code>USING</code>, как:


<pre>
A LEFT JOIN B USING (C1,C2,C3,...)
</pre>

семантически идентично выражению <code>ON</code>, например:


<pre>
A.C1=B.C1 AND A.C2=B.C2 AND A.C3=B.C3,...
</pre>

<LI>

Выражение <code>NATURAL [LEFT] JOIN</code> для двух таблиц определяется так, чтобы
оно являлось семантическим эквивалентом <code>INNER JOIN</code> или <code>LEFT JOIN</code> с
выражением <code>USING</code>, в котором указаны все столбцы, имеющиеся в обеих
таблицах.

<LI>

<code>INNER JOIN</code> и <code>,</code> (запятая) являются семантическими эквивалентами. Оба
осуществляют полное объединение используемых таблиц. Способ связывания
таблиц обычно задается в условии <code>WHERE</code>.

<LI>

<code>RIGHT JOIN</code> работает аналогично <code>LEFT JOIN</code>. Для сохранения
переносимости кода между различными базами данных рекомендуется вместо
<code>RIGHT JOIN</code>  использовать <code>LEFT JOIN</code>.

<LI>

<code>STRAIGHT_JOIN</code> идентично <code>JOIN</code>, за исключением того, что левая таблица
всегда читается раньше правой. Это выражение может использоваться для
тех (немногих) случаев, когда оптимизатор объединения располагает
таблицы в неправильном порядке.

<LI>

<A NAME="IDX1380"></A>
<A NAME="IDX1381"></A>
Начиная с версии  MySQL 3.23.12, можно давать MySQL указания о том,
какой индекс должен использоваться при извлечении информации из
таблицы. Эта возможность полезна, если оператор <code>EXPLAIN</code> 
показывает, что MySQL из всех возможных индексов использует ошибочный. Задавая значение
индекса в  <code>USE INDEX (key_list)</code>, можно заставить MySQL применять для
поиска записи только один из возможных индексов. Альтернативное
выражение  <code>IGNORE INDEX (key_list)</code> запрещает использование в MySQL
данного конкретного индекса. Выражения <code>USE/IGNORE KEY</code> являются
синонимами для <code>USE/IGNORE INDEX</code>.

<A NAME="IDX1382"></A>
В MySQL 4.0.9 можно также указывать <code>FORCE INDEX</code>. Это работает также, как
и <code>USE INDEX (key_list)</code> но в дополнение дает понять серверу что полное
сканирование таблицы будет ОЧЕНЬ дорогостоящей операцией. Другими словами, в
этом случае сканирование таблицы будет использовано только тогда, когда не
будет найдено другого способа использовать один из данных индексов для поиска
записей в таблице. 
</ul>

<P>
<A NAME="IDX1383"></A>
<A NAME="IDX1384"></A>

</P>
<P>
Несколько примеров:

</P>

<pre>
mysql&#62; SELECT * FROM table1,table2 WHERE table1.id=table2.id;
mysql&#62; SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;
mysql&#62; SELECT * FROM table1 LEFT JOIN table2 USING (id);
mysql&#62; SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id
       LEFT JOIN table3 ON table2.id=table3.id;
mysql&#62; SELECT * FROM table1 USE INDEX (key1,key2)
       WHERE key1=1 AND key2=2 AND key3=3;
mysql&#62; SELECT * FROM table1 IGNORE INDEX (key3)
       WHERE key1=1 AND key2=2 AND key3=3;
</pre>

<P>
See section <A HREF="manual.ru_MySQL_Optimisation.html#LEFT_JOIN_optimisation">5.2.6  Как MySQL оптимизирует <code>LEFT JOIN</code> и <code>RIGHT JOIN</code></A>.

</P>


<H4><A NAME="UNION" HREF="manual.ru_toc.html#UNION">6.4.1.2  Синтаксис оператора  <code>UNION</code></A></H4>

<P>
<A NAME="IDX1385"></A>

</P>

<pre>
SELECT ...
UNION [ALL]
SELECT ...
  [UNION 
   SELECT ...]
</pre>

<P>
Оператор <code>UNION</code> реализован в MySQL 4.0.0.

</P>
<P>
<code>UNION</code> используется для объединения результатов работы нескольких команд
<code>SELECT</code> в один набор результатов.

</P>
<P>
Столбцы, перечисленные в части <code>select_expression</code> должны быть одинакового типа.
Имена столбцов, указанные в первом <code>SELECT</code> будут использованы как имена столбцов для 
всего результата. 

</P>
<P>
Эти команды <code>SELECT</code> являются обычными командами выборки данных, но со
следующим ограничением:

</P>

<ul>
<LI>

Только последняя команда <code>SELECT</code> может включать оператор <code>INTO OUTFILE</code>.
</ul>

<P>
Если не используется ключевое слово <code>ALL</code> для <code>UNION</code>, все возвращенные строки
будут уникальными, так как по умолчанию подразумевается <code>DISTINCT</code> для всего
результирующего набора данных. Если указать ключевое слово <code>ALL</code>, то
результат будет содержать все найденные строки из всех примененных команд
<code>SELECT</code>.

</P>
<P>
Если для всего результата <code>UNION</code>  необходимо применить оператор <code>ORDER BY</code>,
следует использовать круглые скобки:

</P>

<pre>
(SELECT a FROM table_name WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
UNION
(SELECT a FROM table_name WHERE a=11 AND B=2 ORDER BY a LIMIT 10)
ORDER BY a;
</pre>



<H3><A NAME="HANDLER" HREF="manual.ru_toc.html#HANDLER">6.4.2  Синтаксис оператора  <code>HANDLER</code></A></H3>

<P>
<A NAME="IDX1386"></A>

</P>

<pre>
HANDLER tbl_name OPEN [ AS alias ]
HANDLER tbl_name READ index_name { = | &#62;= | &#60;= | &#60; } (value1,value2,...)
    [ WHERE ... ] [LIMIT ... ]
HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }
    [ WHERE ... ] [LIMIT ... ]
HANDLER tbl_name READ { FIRST | NEXT }
    [ WHERE ... ] [LIMIT ... ]
HANDLER tbl_name CLOSE
</pre>

<P>
Оператор <code>HANDLER</code> обеспечивает прямой доступ к интерфейсу обработчика
таблиц <code>MyISAM</code>.

</P>
<P>
Первая форма оператора  <code>HANDLER</code> открывает таблицу, делая ее доступной для
последовательности команд <code>HANDLER ... READ</code>. Этот объект недоступен другим
потокам и не будет закрыт, пока данный поток не вызовет <code>HANDLER tbl_name 
CLOSE</code> или сам поток не будет уничтожен.

</P>
<P>
Вторая форма выбирает одну строку (или больше - в соответствии с
установкой в выражении <code>LIMIT</code>), для которой(ых) указанный индекс
соответствует заданному условию и условие в выражении <code>WHERE</code> также
выполняется. Если индекс состоит из нескольких частей (охватывает
несколько столбцов), то составляющие его величины указываются в виде
разделенного запятыми списка. Обеспечиваются величины только для
нескольких первых столбцов.

</P>
<P>
Третья форма выбирает одну строку (или больше - в соответствии с
установкой в выражении <code>LIMIT</code>), из таблицы; в порядке указания индексов в
соответствии с условием <code>WHERE</code>.

</P>
<P>
Четвертая форма (без указания индексов) выбирает одну строку (или больше -
в соответствии с установкой в выражении <code>LIMIT</code>), из таблицы, используя
естественный порядок строк (как они хранятся в файле данных), в
соответствии с условием <code>WHERE</code>. Эта форма работает быстрее, чем <code>HANDLER 
tbl_name READ index_name</code>, в тех случаях, когда желателен просмотр всей
таблицы.

</P>
<P>
Оператор  <code>HANDLER ... CLOSE</code> закрывает таблицу, открытую оператором 
<code>HANDLER ... OPEN</code>.

</P>
<P>
Оператор  <code>HANDLER</code> представляет собой что-то наподобие низкоуровневой
команды. Например, он не обеспечивает целостности таблицы. Т.е. <code>HANDLER
... OPEN</code> НЕ делает моментального снимка таблицы и НЕ блокирует ее. Отсюда
следует, что после вызова команды <code>HANDLER ... OPEN</code> данные таблицы могут
быть модифицированы (этим или любым другим потоком), а сами модификации в
просмотрах таблицы при помощи <code>HANDLER ... NEXT</code> или <code>HANDLER ... PREV</code>  могут
появляться только частично.

</P>
<P>
Вот причины, по которым вы можете предпочесть HANDLER вместо обычного SQL:

</P>

<ul>
<LI>

Он быстрее чем <code>SELECT</code>, потому что: 

<ul>
<LI>

Выделенный код обработчика таблиц создается в потоке по вызову <code>HANDLER open</code>. 
<LI>

Меньше синтаксического анализа. 
<LI>

Нет нагрузки на оптимизацию и проверку. 
<LI>

Таблицу не нужно блокировать между запросами.
<LI>

Этот интерфейс не обязан предоставлять целостный вид данных (скажем, грязное
чтение допускается), что позволяет обработчику таблиц делать оптимизации
которые SQL обычно не допускает. 
</ul>

<LI>

Гораздо легче переносить на MySQL приложения, которые используют интерфейс, подобный ISAM.
<LI>

Такой интерфейс позволяет просматривать базу данных способом, который не 
так легко (или в некоторых случаях и вовсе невозможно) реализовать с помощью SQL.
Интерфейс HANDLER является более естественным способом получить данные, когда приходится
иметь дело с интерактивными пользовательскими приложениями.
</ul>



<H3><A NAME="INSERT" HREF="manual.ru_toc.html#INSERT">6.4.3  Синтаксис оператора <code>INSERT</code></A></H3>

<P>
<A NAME="IDX1387"></A>

</P>

<pre>
    INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
        [ ON DUPLICATE KEY UPDATE col_name=expression, ... ]
или INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
или INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name
        SET col_name=(expression | DEFAULT), ...
        [ ON DUPLICATE KEY UPDATE col_name=expression, ... ]

</pre>

<P>
<A NAME="IDX1388"></A>
<A NAME="IDX1389"></A>

</P>
<P>
Оператор <code>INSERT</code> вставляет новые строки в существующую таблицу. Форма
данной команды  <code>INSERT ... VALUES</code> вставляет строки в соответствии с точно
указанными в команде значениями. Форма <code>INSERT ... SELECT</code> вставляет строки,
выбранные из другой таблицы или таблиц. Форма <code>INSERT ... VALUES</code> со списком
из нескольких значений поддерживается в версии MySQL 3.22.5 и более
поздних. Синтаксис выражения <code>col_name=expression</code> поддерживается в версии
MySQL 3.22.10 и более поздних.

</P>
<P>
<code>tbl_name</code> задает таблицу, в которую должны быть внесены строки. Столбцы,
для которых заданы величины в команде, указываются в списке имен столбцов
или в части <code>SET</code>:

</P>

<ul>
<LI>

Если не указан список столбцов для <code>INSERT ... VALUES</code> или <code>INSERT ...
SELECT</code>, то величины для всех столбцов должны быть определены в списке
<code>VALUES()</code> или в результате работы <code>SELECT</code>. Если порядок столбцов в
таблице неизвестен, для его получения можно использовать <code>DESCRIBE tbl_name</code>.

<LI>

<A NAME="IDX1390"></A>
Любой столбец, для которого явно не указано значение, будет установлен
в свое значение по умолчанию. Например, если в заданном списке
столбцов не указаны все столбцы в данной таблице, то не упомянутые
столбцы устанавливаются в свои значения по умолчанию. Установка
значений по умолчанию описывается в разделе section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>. 

Вы также можете использовать ключевое слово <code>DEFAULT</code> для того, чтобы
установить столбец в его значение по умолчанию (новшество в MySQL 4.0.3). Это
облегчает написание <code>INSERT</code>, присвающим значения всем, за исключением
одного-двух, столбцам, т.к. такой ситнаксис позволяет вам обойтись без указания
списка столбцов, которые оператор <code>INSERT</code> должен обновить. 

В MySQL всегда предусмотрено значение по умолчанию для каждого поля. Это
требование ``навязано'' MySQL, чтобы обеспечить возможность работы как с
таблицами, поддерживающими транзакции, так и с таблицами, не поддерживающими
их. 

Наша точка зрения (разработчиков) состоит в том, что проверка содержимого полей
должна производиться приложением, а не сервером баз данных.

<LI>

Выражение <code>expression</code> может относится к любому столбцу, который ранее
был внесен в список значений. Например, можно указать следующее:


<pre>
mysql&#62; INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);
</pre>

Но нельзя указать:


<pre>
mysql&#62; INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);
</pre>

<LI>

Если указывается ключевое слово <code>LOW_PRIORITY</code>, то выполнение данной
команды <code>INSERT</code> будет задержано до тех пор, пока другие клиенты не
завершат чтение этой таблицы. В этом случае данный клиент должен
ожидать, пока данная команда вставки не будет завершена, что в случае
интенсивного использования таблицы может потребовать значительного
времени. В противоположность этому команда <code>INSERT DELAYED</code> позволяет
данному клиенту продолжать операцию сразу же. See section <A HREF="manual.ru_Reference.html#INSERT_DELAYED">6.4.4  Синтаксис оператора <code>INSERT DELAYED</code></A>. 
Следует отметить, что указатель <code>LOW_PRIORITY</code> обычно не
используется с таблицами <code>MyISAM</code>, поскольку при его указании становятся
невозможными параллельные вставки. See section <A HREF="manual.ru_Table_types.html#MyISAM">7.1  Таблицы <code>MyISAM</code></A>.

<LI>

Если в команде <code>INSERT</code> со строками, имеющими много значений,
указывается ключевое слово <code>IGNORE</code>, то все строки, имеющие
дублирующиеся ключи <code>PRIMARY</code> или <code>UNIQUE</code>  в этой таблице, будут
проигнорированы и не будут внесены. Если не указывать <code>IGNORE</code>, то
данная операция вставки прекращается при обнаружении строки, имеющей
дублирующееся значение существующего ключа. Количество строк,
внесенных в данную таблицу, можно определить при помощи функции C  API
<code>mysql_info()</code>.

<LI>

Если вы указываете <code>ON DUPLICATE KEY UPDATE</code> (новшество в MySQL 4.1.0), 
и производится вставка строки, которая вызывает ошибку дублирующегося первичного (<code>PRIMARY</code>) или 
уникального (<code>UNIQUE</code>) ключа, то вполняется <code>UPDATE</code> старой строки. 

Например: 


<pre>
mysql&#62; INSERT INTO table (a,b,c) VALUES (1,2,3)
   --&#62; ON DUPLICATE KEY UPDATE c=c+1;
</pre>

Если <code>a</code> определяется как <code>UNIQUE</code> и уже содержит <code>1</code>, то тогда
вышеуказанная команда будет аналогична следующей: 


<pre>
mysql&#62; UPDATE table SET c=c+1 WHERE a=1;
</pre>

<strong>Внимание:</strong> если столбец  <code>b</code> также является уникальным ключем, то 
<code>UPDATE</code> переписывается как: 


<pre>
mysql&#62; UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;
</pre>

и если несколько записей соответствуют <code>a=1 OR b=2</code> только <strong>одна</strong> запись
будет обновлена! В общем случае, следует избегать использования <code>ON DUPLICATE KEY</code> на таблицах со множеством уникальных (<code>UNIQUE</code>) ключей. 

Когда используется <code>ON DUPLICATE KEY UPDATE</code>,
опция <code>DELAYED</code> будет проигнорирована.

<LI>

Если MySQL был сконфигурирован с использованием опции
<code>DONT_USE_DEFAULT_FIELDS</code>, то команда <code>INSERT</code> будет генерировать ошибку,
если явно не указать величины для всех столбцов, которые требуют
значений не-<code>NULL</code>. See section <A HREF="manual.ru_Installing.html#configure_options">2.3.3  Типичные опции <code>configure</code></A>.

<LI>

С помощью функции <code>mysql_insert_id</code> можно найти величину, использованную
для столбца <code>AUTO_INCREMENT</code>. See section <A HREF="manual.ru_Clients.html#mysql_insert_id">8.4.3.130  <code>mysql_insert_id()</code></A>.

</ul>

<P>
Если задается команда <code>INSERT ... SELECT</code> или <code>INSERT ... VALUES</code> со списками
из нескольких значений, то для получения информации о данном запросе можно
использовать функцию C API <code>mysql_info()</code>. Формат этой информационной строки
приведен ниже:

</P>

<pre>
Records: 100 Duplicates: 0 Warnings: 0
</pre>

<P>
<code>Duplicates</code> показывает число строк, которые не могли быть внесены,
поскольку они дублировали бы значения некоторых существующих уникальных
индексов. Указатель <code>Warnings</code> показывает число попыток внести величину в
столбец, который по какой-либо причине оказался проблематичным.
Предупреждения возникают при выполнении любого из следующих условий:

</P>

<ul>
<LI>

Внесение <code>NULL</code> в столбец, который был объявлен, как <code>NOT NULL</code>. Данный
столбец устанавливается в значение, заданное по умолчанию.

<LI>

Установка числового столбца в значение, лежащее за пределами его
допустимого диапазона. Данная величина усекается до соответствующей
конечной точки этого диапазона.

<LI>

Занесение в числовой столбец такой величины, как <code>'10.34 a'</code>. Конечные
данные удаляются и вносится только оставшаяся числовая часть. Если
величина вовсе не имеет смысла как число, то столбец устанавливается в
<code>0</code>.

<LI>

Внесение в столбцы типа <code>CHAR</code>, <code>VARCHAR</code>, <code>TEXT</code> или <code>BLOB</code> строки,
превосходящей максимальную длину столбца. Данная величина усекается до
максимальной длины столбца.

<LI>

Внесение в столбец даты или времени строки, недопустимой для данного
типа столбца. Этот столбец устанавливается в нулевую величину,
соответствующую данному типу.
</ul>

<P>
<A NAME="IDX1391"></A>
<A NAME="IDX1392"></A>

</P>


<H4><A NAME="INSERT_SELECT" HREF="manual.ru_toc.html#INSERT_SELECT">6.4.3.1  Синтаксис оператора <code>INSERT ... SELECT</code></A></H4>


<pre>
INSERT [LOW_PRIORITY] [IGNORE] [INTO] tbl_name [(column list)] SELECT ...
</pre>

<P>
Команда <code>INSERT ... SELECT</code> обеспечивает возможность быстрого внесения
большого количества строк в таблицу из одной или более таблиц.

</P>

<pre>
INSERT INTO tblTemp2 (fldID) SELECT tblTemp1.fldOrder_ID 
        FROM tblTemp1
        WHERE tblTemp1.fldOrder_ID &#62; 100;
</pre>

<P>
Для команды <code>INSERT ... SELECT</code> необходимо соблюдение следующих условий:

</P>

<ul>
<LI>

Целевая таблица команды <code>INSERT</code> не должна появляться в утверждении <code>FROM</code>
части <code>SELECT</code> данного запроса, поскольку в ANSI  SQL запрещено
производить выборку из той же таблицы, в которую производится вставка.
(Проблема заключается в том, что операция <code>SELECT</code>, возможно, найдет
записи, которые были внесены ранее в течение того же самого прогона
команды. При использовании команд, внутри которых содержатся
многоступенчатые выборки, можно легко попасть в очень запутанную
ситуацию!)

<LI>

Столбцы <code>AUTO_INCREMENT</code> работают, как обычно.

<LI>

Для получения информации о данном запросе можно использовать функцию C
API <code>mysql_info()</code>. See section <A HREF="manual.ru_Reference.html#INSERT">6.4.3  Синтаксис оператора <code>INSERT</code></A>.

<LI>

Чтобы гарантировать возможность использования журнала
обновлений/двоичного журнала для восстановления исходного состояния
таблиц, в MySQL во время выполнения команды <code>INSERT ... SELECT</code> 
параллельные вставки не разрешаются.
</ul>

<P>
Разумеется, для перезаписи старых строк можно вместо <code>INSERT</code>  использовать
<code>REPLACE</code>.

</P>


<H3><A NAME="INSERT_DELAYED" HREF="manual.ru_toc.html#INSERT_DELAYED">6.4.4  Синтаксис оператора <code>INSERT DELAYED</code></A></H3>

<P>
<A NAME="IDX1393"></A>
<A NAME="IDX1394"></A>

</P>
<P>
<A NAME="IDX1395"></A>

</P>


<pre>
INSERT  DELAYED ...
</pre>

<P>
Опция <code>DELAYED</code> для команды <code>INSERT</code> является специфической для MySQL
возможностью, которая очень полезна, если клиент не может ждать завершения
команды <code>INSERT</code>. Такая проблема встречается часто - она возникает, когда
MySQL используется для ведения журналов (проще говоря, для логгинга) и при
этом периодически запускаются команды <code>SELECT</code> и <code>UPDATE</code>, для выполнения
которых требуется много времени. Оператор <code>DELAYED</code> был введен в версию
MySQL 3.22.15. Он является расширением MySQL к ANSI  SQL92.

</P>
<P>
<code>INSERT DELAYED</code> работает только с таблицами типа <code>ISAM</code> и <code>MyISAM</code>. Следует
учитывать, что таблицы <code>MyISAM</code> поддерживают одновременное выполнение <code>SELECT</code>
и <code>INSERT</code>, поэтому если нет свободных блоков в середине файла данных, то
необходимость в применении <code>INSERT DELAYED</code> возникает очень редко. 
See section <A HREF="manual.ru_Table_types.html#MyISAM">7.1  Таблицы <code>MyISAM</code></A>.

</P>
<P>
При использовании оператора <code>INSERT DELAYED</code> клиент сразу же получает
успешный ответ от сервера, а запись будет добавлена в таблицу сразу же
после того, как эту таблицу перестанет использовать другой поток.

</P>
<P>
Еще одно существенное преимущество применения оператора <code>INSERT DELAYED</code>
заключается в том, что данные от многих клиентов собираются вместе и
записываются одним блоком. Это намного быстрее, чем несколько отдельных
операций вставки.

</P>
<P>
Обратите внимание: в настоящее время все записи, поставленные в очередь на
добавление, хранятся только в памяти до тех пор, пока они не будут
записаны на диск. Отсюда следует, что если выполнение <code>mysqld</code> будет
завершено принудительно (<code>kill -9</code>) или программа умрет, то все находящиеся
в очереди данные, которые не записаны на диск, будут потеряны!.

</P>
<P>
Ниже детально описано, что происходит при использовании опции <code>DELAYED</code> в
командах <code>INSERT</code> или <code>REPLACE</code>. В этом описании ``поток'' понимается как
поток, принимающий команду <code>INSERT DELAYED</code>, а ``обработчик'' - это поток,
который обрабатывает все команды <code>INSERT DELAYED</code> в конкретной таблице.

</P>

<ul>
<LI>

При выполнении потоком команды <code>DELAYED</code> для таблицы создается
поток-обработчик для обработки всех команд <code>DELAYED</code> в данной таблице,
если подобный обработчик уже не существует.

<LI>

Данный поток проверяет, выполнил ли уже обработчик блокировку <code>DELAYED</code>;
если нет, то он предписывает обработчику сделать это. Блокировка
<code>DELAYED</code> может быть осуществлена даже в случае, если блокировки <code>READ</code>
или <code>WRITE</code> на данной таблице уже выполнены другими потоками. Однако
обработчик будет ожидать всех блокировок <code>ALTER TABLE</code> и завершения
всех команд <code>FLUSH TABLES</code>, чтобы убедиться в том, что структура
таблицы соответствует последнему обновлению.

<LI>

Поток выполняет команду <code>INSERT</code>, но вместо записи строки в таблицу он
ставит финальную копию этой строки в очередь, управляемую
потоком-обработчиком. Поток отмечает все синтаксические ошибки и
сообщает о них клиентской программе.

<LI>

Клиент не может уведомить о количестве дубликатов или значении
<code>AUTO_INCREMENT</code> для данной результирующей строки; он также не может
получить эти данные с сервера, поскольку команда <code>INSERT</code> возвращает
результат до полного завершения операции вставки. По той же причине
ничего существенного не даст и использование функции C  API 
<code>mysql_info()</code>.

<LI>

Обновление журнала обновлений производится потоком-обработчиком после
вставки строки в таблицу. В случае многострочной вставки обновление
журнала обновлений производится при записи первой строки.

<A NAME="IDX1396"></A>
<A NAME="IDX1397"></A>
<LI>

После записи каждых <code>delayed_insert_limit</code> строк, обработчик проверяет,
не находятся ли в ожидании выполнения какие-либо команды <code>SELECT</code>. Если
да, то обработчик перед продолжением своей работы ``пропускает их
вперед'' на выполнение.

<LI>

Если очередь обработчика больше не содержит строк, то с данной таблицы
будет снята блокировка. Если в течение <code>delayed_insert_timeout</code> секунд
не поступят никакие новые команды <code>INSERT DELAYED</code>, то обработчик
завершит свою работу.

<LI>

Если более, чем <code>delayed_queue_size</code> строк уже ожидают в очереди
обработчика, то поток, запрашивающий <code>INSERT DELAYED</code>, будет ждать,
пока не освободится место в очереди. Таким образом можно иметь
уверенность в том, что <code>mysqld</code> не займет всю память сервера для
хранения запросов данной очереди.

<LI>

Поток-обработчик будет наблюдаться в списке процессов MySQL  со
значением <code>delayed_insert</code> в столбце <code>Command</code>. Поток-обработчик можно
уничтожить запуском команды <code>FLUSH TABLES</code> или командой <code>KILL 
номер_потока</code>. Однако перед своим завершением он вначале сохранит в
таблице все поставленные в очередь строки. В процессе сохранения он не
будет принимать никаких новых команд <code>INSERT</code> от иного потока. При
выполнении после этого команды <code>INSERT DELAYED</code> будет создан новый
поток-обработчик. Обратите внимание: отсюда следует, что команды
<code>INSERT DELAYED</code> имеют более высокий приоритет, чем обычные команды
<code>INSERT</code>, если уже существует запущенный обработчик <code>INSERT DELAYED</code>!
Другие команды обновления должны ожидать, пока не опустеет очередь
<code>INSERT DELAYED</code> или же пока кто-либо не прекратит выполнение
потока-обработчика (с помощью <code>KILL номер_потока</code>) или не выполнит <code>FLUSH
TABLES</code>.

<LI>

Представленные в таблице переменные обеспечивают информацию об <code>INSERT 
DELAYED</code>:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Переменная</strong> </TD><TD> <strong>Значение</strong>
</TD></TR>
<TR><TD><code>Delayed_insert_threads</code> </TD><TD> Количество потоков-обработчиков
</TD></TR>
<TR><TD><code>Delayed_writes</code> </TD><TD> Количество строк, записанных <code>INSERT DELAYED</code>
</TD></TR>
<TR><TD><code>Not_flushed_delayed_rows</code> </TD><TD> Количество строк, ожидающих записи
</TD></TR>
</TABLE>

<LI>

Чтобы увидеть эти переменные, следует вызвать команду <code>SHOW STATUS</code> или
выполнить команду <code>mysqladmin extended-status</code>.
</ul>

<P>
Обратите внимание: если данная таблица не используется, то команда  <code>INSERT
DELAYED</code> работает медленнее, чем обычная команда <code>INSERT</code>. Кроме того,
возникает дополнительная нагрузка на сервер, поскольку требуется управлять
отдельным потоком для каждой таблицы, для которой используется <code>INSERT 
DELAYED</code>. Это означает, что команду <code>INSERT DELAYED</code> следует применять
только тогда, когда в ней есть реальная необходимость!

</P>


<H3><A NAME="UPDATE" HREF="manual.ru_toc.html#UPDATE">6.4.5  Синтаксис оператора  <code>UPDATE</code></A></H3>

<P>
<A NAME="IDX1398"></A>

</P>

<pre>
UPDATE [LOW_PRIORITY] [IGNORE] tbl_name
    SET col_name1=expr1 [, col_name2=expr2 ...]
    [WHERE where_definition]
    [ORDER BY ...]
    [LIMIT rows]

или

UPDATE [LOW_PRIORITY] [IGNORE] tbl_name [, tbl_name ...]
    SET col_name1=expr1 [, col_name2=expr2 ...]
    [WHERE where_definition]
</pre>

<P>
Оператор <code>UPDATE</code> обновляет столбцы в соответствии с их новыми значениями в
строках существующей таблицы. В выражении <code>SET</code> указывается, какие именно
столбцы следует модифицировать и какие величины должны быть в них
установлены. В выражении <code>WHERE</code>, если оно присутствует, задается, какие
строки подлежат обновлению. В остальных случаях обновляются все строки.
Если задано выражение <code>ORDER BY</code>, то строки будут обновляться в указанном в
нем порядке.

</P>
<P>
Если указывается ключевое слово <code>LOW_PRIORITY</code>, то выполнение данной команды
<code>UPDATE</code> задерживается до тех пор, пока другие клиенты не завершат чтение
этой таблицы.

</P>
<P>
Если указывается ключевое слово <code>IGNORE</code>, то команда обновления не будет
прервана, даже если при обновлении возникнет ошибка дублирования ключей.
Строки, из-за которых возникают конфликтные ситуации, обновлены не будут.

</P>
<P>
Если доступ к столбцу из указанного выражения осуществляется по аргументу
<code>tbl_name</code>, то команда <code>UPDATE</code> использует для этого столбца его текущее
значение. Например, следующая команда устанавливает столбец <code>age</code> в
значение, на единицу большее его текущей величины:

</P>

<pre>
mysql&#62; UPDATE persondata SET age=age+1;
</pre>

<P>
Значения команда <code>UPDATE</code> присваивает слева направо. Например, следующая
команда дублирует столбец <code>age</code>, затем инкрементирует его:

</P>

<pre>
mysql&#62; UPDATE persondata SET age=age*2, age=age+1;
</pre>

<P>
Если столбец устанавливается в его текущее значение, то MySQL замечает это
и не обновляет его.

</P>
<P>
Команда  <code>UPDATE</code> возвращает количество фактически измененных строк. В
версии MySQL 3.22 и более поздних функция C  API  <code>mysql_info()</code> возвращает
количество строк, которые были найдены и обновлены, и количество
предупреждений, имевших место при выполнении <code>UPDATE</code>.

</P>
<P>
В версии MySQL 3.23 можно использовать <code>LIMIT #</code>, чтобы убедиться, что было
изменено только заданное количество строк.

</P>
<P>
Начиная с версии MySQL 4.0.4 вы также можете выполнять <code>UPDATE</code>, охватывающий множество таблиц: 

</P>

<pre>
UPDATE items,month SET items.price=month.price
WHERE items.id=month.id;
</pre>

<P>
Обратите внимание:  вы не можете использовать <code>ORDER BY</code> или <code>LIMIT</code> для многотабличных обновлений.

</P>


<H3><A NAME="DELETE" HREF="manual.ru_toc.html#DELETE">6.4.6  Синтаксис оператора <code>DELETE</code></A></H3>

<P>
<A NAME="IDX1399"></A>

</P>

<pre>
DELETE [LOW_PRIORITY] [QUICK] FROM table_name
       [WHERE where_definition]
       [ORDER BY ...]
       [LIMIT rows]
</pre>

<P>
или

</P>

<pre>
DELETE [LOW_PRIORITY] [QUICK] table_name[.*] [, table_name[.*] ...]
       FROM table-references
       [WHERE where_definition]
</pre>

<P>
или

</P>

<pre>
DELETE [LOW_PRIORITY] [QUICK]
       FROM table_name[.*] [, table_name[.*] ...]
       USING table-references
       [WHERE where_definition]
</pre>

<P>
Оператор <code>DELETE</code> удаляет из таблицы <code>table_name</code> строки, удовлетворяющие
заданным в <code>where_definition</code> условиям, и возвращает число удаленных
записей.

</P>
<P>
Если оператор <code>DELETE</code> запускается без определения <code>WHERE</code>, то удаляются все
строки. При работе в режиме <code>AUTOCOMMIT</code> это будет аналогично использованию
оператора <code>TRUNCATE</code>. See section <A HREF="manual.ru_Reference.html#TRUNCATE">6.4.7  Синтаксис оператора <code>TRUNCATE</code></A>. В MySQL 3.23 оператор 
<code>DELETE</code> без определения <code>WHERE</code> возвратит ноль как число удаленных записей.

</P>
<P>
Если действительно необходимо знать число удаленных записей при удалении
всех строк, и если допустимы потери в скорости, то можно использовать
команду <code>DELETE</code> в следующей форме:

</P>

<pre>
mysql&#62; DELETE FROM table_name WHERE 1&#62;0;
</pre>

<P>
Следует учитывать, что эта форма работает намного медленнее, чем <code>DELETE 
FROM table_name</code> без выражения <code>WHERE</code>, поскольку строки удаляются
поочередно по одной.

</P>
<P>
Если указано ключевое слово <code>LOW_PRIORITY</code>, выполнение данной команды <code>DELETE</code>
будет задержано до тех пор, пока другие клиенты не завершат чтение этой
таблицы.

</P>
<P>
Если задан параметр <code>QUICK</code>, то обработчик таблицы при выполнении удаления
не будет объединять индексы - в некоторых случаях это может ускорить
данную операцию.

</P>
<P>
В таблицах <code>MyISAM</code> удаленные записи сохраняются в связанном списке, а
последующие операции <code>INSERT</code> повторно используют места, где располагались
удаленные записи. Чтобы возвратить неиспользуемое пространство и уменьшить
размер файлов, можно применить команду <code>OPTIMIZE TABLE</code> или утилиту
<code>myisamchk</code> для реорганизации таблиц. Команда <code>OPTIMIZE TABLE</code> проще, но
утилита <code>myisamchk</code> работает быстрее. See section <A HREF="manual.ru_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  Синтаксис  команды <code>OPTIMIZE TABLE</code></A>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Optimisation">4.4.6.10  Оптимизация  таблиц</A>.

</P>
<P>
Первый из числа приведенных в начале данного раздела многотабличный формат
команды <code>DELETE</code> поддерживается, начиная с MySQL 4.0.0. Второй
многотабличный формат поддерживается, начиная с MySQL 4.0.2.

</P>
<P>
Идея заключается в том, что удаляются только совпадающие строки из таблиц,
перечисленных перед выражениями <code>FROM</code> или <code>USING</code>. Это позволяет удалять
единовременно строки из нескольких таблиц, а также использовать для поиска
дополнительные таблицы.

</P>
<P>
Символы <code>.*</code> после имен таблиц требуются только для совместимости с Access:

</P>

<pre>
DELETE t1,t2 FROM t1,t2,t3 WHERE t1.id=t2.id AND t2.id=t3.id
</pre>

<P>
или

</P>

<pre>
DELETE FROM t1,t2 USING t1,t2,t3 WHERE t1.id=t2.id AND t2.id=t3.id
</pre>

<P>
В предыдущем случае просто удалены совпадающие строки из таблиц <code>t1</code> и <code>t2</code>.

</P>
<P>
Если применяется выражение <code>ORDER BY</code> (доступно с версии MySQL 4.0), то
строки будут удалены в указанном порядке. В действительности это выражение
полезно только в сочетании с <code>LIMIT</code>. Например:

</P>

<pre>
DELETE FROM somelog
        WHERE user = 'jcole'
        ORDER BY timestamp
        LIMIT 1
</pre>

<P>
Данный оператор удалит самую старую запись (по <code>timestamp</code>), в которой
строка соответствует указанной в выражении <code>WHERE</code>.

</P>
<P>
Специфическая для MySQL опция <code>LIMIT</code> для команды <code>DELETE</code> указывает
серверу максимальное количество строк, которые следует удалить до возврата
управления клиенту. Эта опция может использоваться для гарантии того, что
данная команда <code>DELETE</code> не потребует слишком много времени для выполнения.
Можно просто повторять команду <code>DELETE</code> до тех пор, пока количество
удаленных строк меньше, чем величина <code>LIMIT</code>.

</P>
<P>
С MySQL 4.0 вы можете указать множество таблиц в <code>DELETE</code> чтобы удалить записи из одной таблицы, основываясь на 
условии по множеству таблиц. Однако, с такой формой оператора <code>DELETE</code> нельзя использовать <code>ORDER BY</code> или <code>LIMIT</code>.

</P>


<H3><A NAME="TRUNCATE" HREF="manual.ru_toc.html#TRUNCATE">6.4.7  Синтаксис оператора <code>TRUNCATE</code></A></H3>

<P>
<A NAME="IDX1400"></A>

</P>

<pre>
TRUNCATE TABLE table_name
</pre>

<P>
В версии 3.23 <code>TRUNCATE TABLE</code> выполняет последовательность <code>"COMMIT ; DELETE
FROM table_name"</code>. See section <A HREF="manual.ru_Reference.html#DELETE">6.4.6  Синтаксис оператора <code>DELETE</code></A>.

</P>
<P>
<code>TRUNCATE TABLE</code> имеет следующие отличия от <code>DELETE FROM ...</code>:

</P>

<ul>
<LI>

Эта операция удаляет и воссоздает таблицу, что намного быстрее, чем
поочередное удаление строк.

<LI>

Операция является нетранзакционной; если одновременно выполняется
транзакция или активная блокировка таблицы, то можно получить ошибку.

<LI>

Не возвращает количество удаленных строк.

<LI>

Пока существует корректный файл <tt>`table_name.frm'</tt>, таблицу можно
воссоздать с его с помощью, даже если файлы данных или индексов
повреждены.
</ul>

<P>
<code>TRUNCATE</code> является расширением Oracle  SQL.

</P>


<H3><A NAME="REPLACE" HREF="manual.ru_toc.html#REPLACE">6.4.8  Синтаксис оператора <code>REPLACE</code></A></H3>

<P>
<A NAME="IDX1401"></A>

</P>

<pre>
    REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
или REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
или REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression,...
</pre>

<P>
Оператор  <code>REPLACE</code> работает точно так же, как <code>INSERT</code>, за исключением того,
что если старая запись в данной таблице имеет то же значение индекса 
<code>UNIQUE</code> или <code>PRIMARY KEY</code>, что и новая, то старая запись перед занесением
новой будет удалена. See section <A HREF="manual.ru_Reference.html#INSERT">6.4.3  Синтаксис оператора <code>INSERT</code></A>.

</P>
<P>
Другими словами, команда <code>REPLACE</code> не предоставляет доступа к замещаемой
записи. В некоторых старых версиях MySQL такой доступ иногда оказывался
возможным, но это был дефект, который уже исправлен.

</P>
<P>
Для использования <code>REPLACE</code> у вас должны быть привилегии <code>INSERT</code> и <code>DELETE</code> для таблицы.

</P>
<P>
При использовании команды <code>REPLACE</code> функция <code>mysql_affected_rows()</code> вернет
значение, равное <code>2</code>, если старая строка была заменена новой. Объясняется
это тем, что в таблицу вставляется строка после того, как удаляется дубликат. 

</P>
<P>
Это позволяет легко определять, какое действие произвела команда <code>REPLACE</code> -
добавление или замещение строки. Достаточно просто проверить, какое число
вернула функция <code>mysql_affected_rows()</code> - <code>1</code> (строка добавлена) или <code>2</code>
(замещена).

</P>
<P>
Следует учитывать, что, если не используются индексы <code>UNIQUE</code> или <code>PRIMARY 
KEY</code>, то применение команды <code>REPLACE</code> не имеет смысла, так как она работает
просто как <code>INSERT</code>.

</P>


<H3><A NAME="LOAD_DATA" HREF="manual.ru_toc.html#LOAD_DATA">6.4.9  Синтаксис оператора  <code>LOAD DATA INFILE</code></A></H3>

<P>
<A NAME="IDX1402"></A>

</P>

<pre>
LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name.txt'
    [REPLACE | IGNORE]
    INTO TABLE tbl_name
    [FIELDS
        [TERMINATED BY '\t']
        [[OPTIONALLY] ENCLOSED BY '']
        [ESCAPED BY '\\' ]
    ]
    [LINES TERMINATED BY '\n']
    [IGNORE number LINES]
    [(col_name,...)]
</pre>

<P>
Команда <code>LOAD DATA INFILE</code> читает строки из текстового файла и вставляет
их в таблицу с очень высокой скоростью. Если задано ключевое слово <code>LOCAL</code>,
то файл читается с клиентского хоста. Если же <code>LOCAL</code> не указывается, то
файл должен находиться на сервере. (Опция <code>LOCAL</code> доступна в версии MySQL
3.22.6 и более поздних.)

</P>
<P>
Если текстовые файлы, которые нужно прочитать, находятся на сервере, то из
соображений безопасности эти файлы должны либо размещаться в директории
базы данных, либо быть доступными для чтения всем пользователям. Кроме
того, для применения команды <code>LOAD DATA INFILE</code> к серверным файлам
необходимо обладать привилегиями <code>FILE</code> для серверного хоста. 
See section <A HREF="manual.ru_MySQL_Database_Administration.html#Privileges_provided">4.2.7  Привилегии, предоставляемые MySQL</A>.

</P>
<P>
В версиях MySQL 3.23.49 и MySQL 4.0.2 команда  <code>LOCAL</code> не будет работать в
случаях, если демон <code>mysqld</code> запущен с параметром <code>--local-infile=0</code> или если
для клиента не включена возможность поддержки <code>LOCAL</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#LOAD_DATA_LOCAL">4.2.4  Вопросы безопасности, относящиеся к команде LOAD DATA LOCAL</A>.

</P>
<P>
Если указывается ключевое слово <code>LOW_PRIORITY</code>, то выполнение данной команды
<code>LOAD DATA</code> будет задержано до тех пор, пока другие клиенты не завершат
чтение этой таблицы.

</P>
<P>
Если указывается ключевое слово <code>CONCURRENT</code> при работе с таблицами <code>MyISAM</code>,
то другие потоки могут извлекать данные из таблицы во время выполнения
команды <code>LOAD DATA</code>. Использование этой возможности, конечно, будет немного
влиять на производительность выполнения <code>LOAD DATA</code>, даже если никакой
другой поток не использует данную таблицу в это же время.

</P>
<P>
При применении опции <code>LOCAL</code> выполнение может происходить несколько
медленнее в сравнении с предоставлением серверу доступа к файлам напрямую,
поскольку содержимое файла должно переместиться с клиентского хоста на
сервер. С другой стороны, в этом случае нет необходимости в привилегиях
<code>FILE</code> для загрузки локальных файлов.

</P>
<P>
При использовании версий MySQL до 3.23.24 при помощи команды <code>LOAD DATA 
INFILE</code> нельзя выполнять чтение из <code>FIFO</code>. Если необходимо читать из <code>FIFO</code>
(например, стандартный вывод <code>gunzip</code>), следует использовать <code>LOAD DATA 
LOCAL INFILE</code>.

</P>
<P>
Можно также загружать файлы данных, используя утилиту <code>mysqlimport</code>. Эта
утилита выполняет загрузку файлов путем посылки на сервер команд <code>LOAD 
DATA INFILE</code>. Опция <code>--local</code> заставляет <code>mysqlimport</code> читать файлы данных с
клиентского хоста. Можно указать параметр <code>--compress</code>, чтобы получить
лучшую производительность при работе через медленные сети, если и клиент,
и сервер поддерживают протокол сжатия данных.

</P>
<P>
В случаях, когда файлы находятся на сервере, последний действует по
следующим правилам:

</P>

<ul>
<LI>

Если задан абсолютный (полный) путь к файлу, то сервер использует этот
путь без изменений.

<LI>

Если задан относительный путь к файлу с указанием одного или более
начальных каталогов, то поиск файла будет осуществляться относительно
указанных каталогов в каталоге данных сервера (<code>datadir</code>).

<LI>

Если дается путь к файлу без указания начальных каталогов, то сервер
ищет этот файл в директории используемой базы данных.
</ul>

<P>
Отсюда следует, что файл, заданный как <tt>`./myfile.txt'</tt>, читается из
серверного каталога данных, в то время как файл, заданный как <tt>`myfile.txt'</tt>,
читается из каталога используемой базы данных. Например, следующая команда
<code>LOAD DATA</code> читает файл <code>data.txt</code> в каталоге базы данных для <code>db1</code>, поскольку
<code>db1</code> является текущей базой данных, даже если эта команда явно содержит
указание загрузить файл в таблицу базы данных <code>db2</code>:

</P>

<pre>
mysql&#62; USE db1;
mysql&#62; LOAD DATA INFILE "data.txt" INTO TABLE db2.my_table;
</pre>

<P>
Ключевые слова <code>REPLACE</code> и <code>IGNORE</code> управляют обработкой входных записей,
которые дублируют существующие записи с теми же величинами уникальных
ключей. Если указать <code>REPLACE</code>, то новые строки заменят существующие с таким
же уникальным ключом. Если указать <code>IGNORE</code>, то входные строки, имеющие тот
же уникальный ключ, что и существующие, будут пропускаться. Если не указан
ни один из параметров, то при обнаружении дублирующегося значения ключа
возникает ошибка и оставшаяся часть текстового файла игнорируется.

</P>
<P>
Если данные загружаются из локального файла с использованием ключевого
слова <code>LOCAL</code>, то сервер не сможет прервать передачу данных посреди этой
операции, поэтому по умолчанию выполнение команды происходит так же, как и
в случае, когда указывается <code>IGNORE</code>.

</P>
<P>
При использовании <code>LOAD DATA INFILE</code> на пустых таблицах <code>MyISAM</code> все
неуникальные индексы создаются в отдельном пакете (как в <code>REPAIR</code>). Обычно
это значительно ускоряет работу <code>LOAD DATA INFILE</code> в случае большого
количества индексов.

</P>
<P>
Команда <code>LOAD DATA INFILE</code> является дополнительной к <code>SELECT ... INTO
OUTFILE</code>. See section <A HREF="manual.ru_Reference.html#SELECT">6.4.1  Синтаксис оператора <code>SELECT</code></A>. Чтобы записать данные из базы данных в
файл, используется <code>SELECT ... INTO OUTFILE</code>. Чтобы прочитать данные
обратно в базу данных, используется <code>LOAD DATA INFILE</code>. Синтаксис <code>FIELDS</code> и
<code>LINES</code> одинаков в обеих командах. Обе части являются необязательными, но
если указаны оба, то <code>FIELDS</code> должно предшествовать <code>LINES</code>.

</P>
<P>
Если указывается <code>FIELDS</code>, то каждое из его подвыражений (<code>TERMINATED BY</code>,
<code>[OPTIONALLY] ENCLOSED BY</code>, и  <code>ESCAPED BY</code>) также является
необязательным, однако необходимо указать по меньшей мере одно из них.

</P>
<P>
Если утверждение <code>FIELDS</code> не определено, то по умолчанию его параметры будут
принимать следующие значения:

</P>

<pre>
FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
</pre>

<P>
Если утверждение <code>LINES</code> не определено, то по умолчанию оно имеет следующую
структуру:

</P>

<pre>
LINES TERMINATED BY '\n'
</pre>

<P>
Иными словами, при установках по умолчанию команда <code>LOAD DATA INFILE</code> при
чтении входных данных будет работать следующим образом:

</P>

<ul>
<LI>

Искать концы строк в виде символов <samp>`\n'</samp>

<LI>

Разбивать строки на поля по символам табуляции.

<LI>

Не ожидать, что поля могут быть заключены в символы цитирования.

<LI>

Интерпретировать встречающиеся символы табуляции, новой строки или <samp>`\'</samp>,
предваренные <samp>`\'</samp>, как литералы, являющиеся частью значения поля.
</ul>

<P>
И, наоборот, если действуют установки по умолчанию при записи выходных
данных, команда <code>SELECT ... INTO OUTFILE</code> будет работать следующим образом:

</P>

<ul>
<LI>

Вставлять символы табуляции между полями.

<LI>

Не заключать поля в символы цитирования.

Использовать символы <samp>`\'</samp> для экранирования экземпляров символов
табуляции, новой строки или <samp>`\'</samp>, которые появляются среди величин
поля.

<LI>

Вставлять символы новой строки в конце каждой записи.
</ul>

<P>
Следует учитывать, что в записи <code>FIELDS ESCAPED BY <samp>`\'</samp></code> необходимо
указывать два обратных слеша для величины, которая должна читаться как
один обратный слеш.

</P>
<P>
Опцию <code>IGNORE number LINES</code> можно применять для игнорирования заголовка
имен столбцов в начале файла:

</P>

<pre>
mysql&#62; LOAD DATA INFILE "/tmp/file_name" INTO TABLE test IGNORE 1 LINES;
</pre>

<P>
При использовании <code>SELECT ... INTO OUTFILE</code> совместно с <code>LOAD DATA INFILE</code>
для того, чтобы данные из базы данных прочитать в файл, а затем - обратно
из файла в базу данных, опции, обрабатывающие поля и строки, для обеих
команд должны совпадать. В противном случае <code>LOAD DATA INFILE</code> не сможет
интерпретировать содержимое данного файла правильно. Предположим, что
команда <code>SELECT ... INTO OUTFILE</code> используется для записи в файл с полями,
разделенными запятыми:

</P>

<pre>
mysql&#62; SELECT * INTO OUTFILE 'data.txt'
        FIELDS TERMINATED BY ','
        FROM ...;
</pre>

<P>
Чтобы прочитать этот разделенный запятыми файл обратно в базу данных,
корректная команда должна иметь вид:

</P>

<pre>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE table2
        FIELDS TERMINATED BY ',';
</pre>

<P>
Если вместо этого попытаться прочитать этот файл с помощью команды,
представленной ниже, то она не будет работать, поскольку предписывает
команде <code>LOAD DATA INFILE</code> искать символы табуляции между полями:

</P>

<pre>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE table2
        FIELDS TERMINATED BY '\t';
</pre>

<P>
Похожий результат получился бы, если бы каждая входная строка
интерпретировалась как отдельное поле.

</P>
<P>
Команду  <code>LOAD DATA INFILE</code> можно также использовать для чтения файлов,
полученных из внешних источников. Например, поля в файле формата базе
данных dBASE будут разделены запятыми и заключены в двойные кавычки. Если
строки в данном файле заканчиваются символами новой строки, то для записи
файла можно использовать приведенную ниже команду, в которой
проиллюстрировано задание опций, обрабатывающих поля и строки:

</P>

<pre>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name
        FIELDS TERMINATED BY ',' ENCLOSED BY '"'
        LINES TERMINATED BY '\n';
</pre>

<P>
Любая из опций, обрабатывающих поля и строки, может задавать пустую строку
(''). Если строка не пустая, то величины опций <code>FIELDS [OPTIONALLY]
ENCLOSED BY</code> и <code>FIELDS ESCAPED BY</code> должны содержать один символ. Величины
опций <code>FIELDS TERMINATED BY</code> и <code>LINES TERMINATED BY</code> могут содержать более
чем один символ. Например, чтобы записать строки, заканчивающиеся парами
``возврат каретки - перевод строки'' (как в текстовых файлах MS  DOS или
Windows), необходимо задать следующее выражение: 
<code>LINES TERMINATED BY '\r\n'</code>.

</P>
<P>
Например, чтобы прочитать файл <tt>`jokes'</tt>, в котором строки разделены
символами <code>%%</code>, в таблицу SQL, необходимо сделать следующее:

</P>

<pre>
CREATE TABLE jokes (
        a INT NOT NULL AUTO_INCREMENT PRIMARY KEY, 
        joke TEXT NOT NULL);

LOAD DATA INFILE "/tmp/jokes.txt" INTO TABLE jokes FIELDS TERMINATED BY "";

LINES TERMINATED BY "\n%%\n" (joke);
</pre>

<P>
Опция  <code>FIELDS [OPTIONALLY] ENCLOSED BY</code> служит для управления полями,
заключенными в заданные символы. Если параметр <code>OPTIONALLY</code> опущен, то в
выводе <code>(SELECT ... INTO OUTFILE)</code> все поля будут заключены в символы,
заданные в <code>ENCLOSED BY</code>. Пример такого вывода (в котором в качестве
разделителя полей используется запятая) показан ниже:

</P>

<pre>
"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</pre>

<P>
Если указан параметр <code>OPTIONALLY</code>, то заданным в <code>ENCLOSED BY</code> символом
выделяются только поля типа <code>CHAR</code> и <code>VARCHAR</code>:

</P>

<pre>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</pre>

<P>
Следует учитывать, что появление символов <code>ENCLOSED BY</code> внутри величины
поля экранируется применением перед ними префикса из <code>ESCAPED BY</code>. Также
следует учитывать, что если в <code>ESCAPED BY</code> указана пустая величина, то
существует возможность создать вывод, который оператор <code>LOAD DATA INFILE</code>
не сможет правильно прочитать. Например, если символ экранирования
является пустой строкой, то вывод, представленный выше, окажется таким,
как показано ниже. Обратите внимание: второе поле в четвертой строке
содержит запятую, следующую за кавычкой, которая (ошибочно) появляется,
чтобы ограничить данное поле:

</P>

<pre>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</pre>

<P>
Для ввода символ <code>ENCLOSED BY</code>, если он есть, удаляется из обоих концов
величин полей. (Это справедливо независимо от того, указан или нет
параметр <code>OPTIONALLY</code>: при работе с входными данными параметр <code>OPTIONALLY</code> не
учитывается.) Если встречается символ <code>ENCLOSED BY</code>, которому предшествует
символ <code>ESCAPED BY</code>, то он интерпретируется как часть текущей величины
поля. Кроме того, двойные символы <code>ENCLOSED BY</code>, встречающиеся внутри поля,
интерпретируются как одиночные символы <code>ENCLOSED BY</code>, если данное поле само
начинается с этого символа. Например, если указывается <code>ENCLOSED BY '"'</code>,
то кавычки обрабатываются, как показано ниже:

</P>

<pre>
"The ""BIG"" boss"  -&#62; The "BIG" boss
The "BIG" boss      -&#62; The "BIG" boss
The ""BIG"" boss    -&#62; The ""BIG"" boss
</pre>

<P>
Опция  <code>FIELDS ESCAPED BY</code> служит для управления записью или чтением
специальных символов. Если символ <code>FIELDS ESCAPED BY</code> не пустой, он
используется в качестве префикса для следующих символов в выводе:

</P>

<ul>
<LI>

Символ <code>FIELDS ESCAPED BY</code>

<LI>

Символ <code>FIELDS [OPTIONALLY] ENCLOSED BY</code>

<LI>

Первый символ величин <code>FIELDS TERMINATED BY и LINES TERMINATED BY</code>

<LI>

Символ ASCII  <code>0</code> (в действительности после экранирующего символа
пишется ASCII <samp>`0'</samp>, а не байт с нулевой величиной)
</ul>

<P>
Если символ <code>FIELDS ESCAPED BY</code> пустой, то никакие символы не
экранируются. На самом деле указывать пустой экранирующий символ нет
смысла, особенно если величины полей в обрабатываемых данных содержат
какие-либо из символов, указанных в приведенном выше списке.

</P>
<P>
Если символ <code>FIELDS ESCAPED BY</code> не пуст, то в случае входных данных
вхождения такого символа удаляются и следующий за таким вхождением символ
принимается буквально как часть величины поля. Исключениями являются
экранированные <samp>`0'</samp> или <samp>`N'</samp> (например, <code>\0</code> или <code>\N</code>, если экранирующим
символом является <samp>`\'</samp>). Эти последовательности интерпретируются как ASCII 
<code>0</code> (байт с нулевой величиной) и <code>NULL</code>. См. ниже правила обработки величины
<code>NULL</code>.

</P>
<P>
Чтобы получить более полную информацию о синтаксисе экранирующего символа
<samp>`\'</samp> см. раздел section <A HREF="manual.ru_Reference.html#Literals">6.1.1  Литералы: представление строк и чисел</A>.

</P>
<P>
В ряде случаев опции обработки полей и строк взаимодействуют:

</P>

<ul>
<LI>

Если <code>LINES TERMINATED BY</code> является пустой строкой и <code>FIELDS 
TERMINATED BY</code> является не пустой строкой, то строки также
заканчиваются символами <code>FIELDS TERMINATED BY</code>.

<LI>

Если обе величины <code>FIELDS TERMINATED BY</code> и <code>FIELDS ENCLOSED BY</code>
являются пустыми (''), то применяется формат с фиксированной строкой
(без разделителей). В формате с фиксированной строкой не предусмотрены
никакие разделители между полями. Вместо этого при чтении и записи
величин столбцов используется ширина ``вывода'' столбцов. Например,
если столбец объявлен как <code>INT(7)</code>, значения для этого столбца
записываются с использованием полей шириной <code>7</code> символов. Входные
значения для этого столбца получаются чтением <code>7</code> символов. Формат с
фиксированной строкой влияет также на обработку величин <code>NULL</code> (см.
ниже). Отметим, что формат с фиксированными размерами не будет
работать при использовании мультибайтного набора символов.
</ul>

<P>
Значения <code>NULL</code> в зависимости от используемых опций <code>FIELDS</code> и <code>LINES</code> будут
обрабатываться по-разному:

</P>

<ul>
<LI>

Для установленных по умолчанию величин <code>FIELDS</code> и <code>LINES</code>  <code>NULL</code>
записывается как <code>\N</code> для вывода и <code>\N</code> читается как <code>NULL</code> для ввода
(исходя из предположения, что символ <code>ESCAPED BY</code> равен <samp>`\'</samp>).

<LI>

Если <code>FIELDS ENCLOSED BY</code> не является пустым, то поле, значение
которого представляет собой слово из букв <code>NULL</code>, читается как величина
<code>NULL</code> (в отличие от слова <code>NULL</code>, заключенного между символами <code>FIELDS 
ENCLOSED BY</code>, которое читается как строка '<code>NULL</code>').

<LI>

Если <code>FIELDS ESCAPED BY</code> является пустым, <code>NULL</code> записывается как слово
<code>NULL</code>.

<LI>

В формате с фиксированной строкой (который имеет место, если оба
спецификатора - <code>FIELDS TERMINATED BY</code> и <code>FIELDS ENCLOSED BY</code> -
являются пустыми), <code>NULL</code> записывается как пустая строка. Отметим, что
вследствие этого величина <code>NULL</code> и пустая строка в данной таблице будут
неразличимы при записи в файл, поскольку они обе записываются как
пустые строки. Если необходимо, чтобы эти величины были различными при
обратном чтении файла, то не следует использовать формат с
фиксированной строкой.
</ul>

<P>
Некоторые случаи, не поддерживаемые оператором <code>LOAD DATA INFILE</code>:

</P>

<ul>
<LI>

Строки с фиксированным размером (обе опции <code>FIELDS TERMINATED BY</code> и
<code>FIELDS ENCLOSED BY</code> пустые) и столбцы типа <code>BLOB</code> или <code>TEXT</code>.

<LI>

Если указывается разделитель, совпадающий с другим или являющийся
префиксом другого, то <code>LOAD DATA INFILE</code> не сможет интерпретировать
ввод правильно. Например, следующее утверждение <code>FIELDS</code> вызовет
проблемы:


<pre>
FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</pre>

<LI>

Если опция <code>FIELDS ESCAPED BY</code> пустая, то содержащееся в значении поля
вхождение символа <code>FIELDS ENCLOSED BY</code> или <code>LINES TERMINATED BY</code>, за
которым следует символ <code>FIELDS TERMINATED BY</code>, приведет к
преждевременному завершению чтения поля или строки командой <code>LOAD DATA
INFILE</code>. Это происходит вследствие того, что <code>LOAD DATA INFILE</code> не
может правильно определить, где заканчивается поле или строка.
</ul>

<P>
Следующий пример загружает все столбцы таблицы <code>persondata</code>:

</P>

<pre>
mysql&#62; LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</pre>

<P>
Список полей не указывается, следовательно, команда <code>LOAD DATA INFILE</code>
ожидает входные строки для заполнения каждого столбца таблицы. При этом
используются значения <code>FIELDS</code> и <code>LINES</code> по умолчанию.

</P>
<P>
Если требуется загрузить только некоторые из столбцов таблицы, необходимо
задать список столбцов:

</P>

<pre>
mysql&#62; LOAD DATA INFILE 'persondata.txt'
        INTO TABLE persondata (col1,col2,...);
</pre>

<P>
Список полей необходимо задавать и в случаях, если порядок следования
полей во входном файле отличается от порядка столбцов в данной таблице. В
противном случае MySQL не сможет установить соответствие вводимых полей и
столбцов таблицы.

</P>
<P>
Если строка имеет слишком мало полей, то столбцы, для которых отсутствуют
поля во входном файле, устанавливаются в свои значения по умолчанию.
Назначение величин по умолчанию описывается в разделе section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>.

</P>
<P>
Значение пустого поля интерпретируется иначе, чем отсутствие значения:

</P>

<ul>
<LI>

Для строковых типов столбец устанавливается в пустую строку.

<LI>

Для числовых типов столбец устанавливается в <code>0</code>.

<LI>

Для типов даты и времени столбец устанавливается в соответствующее
этому типу значение ``ноль''. See section <A HREF="manual.ru_Reference.html#Date_and_time_types">6.2.2  Типы данных даты и времени</A>.
</ul>

<P>
Отметим, что это те же самые величины, которые окажутся в столбце в
результате явного назначения пустой строки столбцам строкового, числового
типов, либо типов даты или времени в команде <code>INSERT</code> или <code>UPDATE</code>.

</P>
<P>
Столбцы типа <code>TIMESTAMP</code> устанавливаются только в текущую дату или время в
случаях, если для столбца назначено значение <code>NULL</code> или (только для первого
столбца <code>TIMESTAMP</code>) если столбец <code>TIMESTAMP</code> находится вне списка полей, если
такой список задан.

</P>
<P>
Если входная строка имеет слишком много полей, то лишние поля игнорируются
и количество предупреждений увеличится.

</P>
<P>
Команда  <code>LOAD DATA INFILE</code> интерпретирует все входные данные как строки,
поэтому нельзя указывать числовые величины для столбцов <code>ENUM</code> или <code>SET</code> так
же, как для команд <code>INSERT</code>. Все величины <code>ENUM</code> и <code>SET</code> должны быть заданы как
строки!

</P>
<P>
При использовании C  API можно получить информацию о запросе, вызвав
функцию API  <code>mysql_info()</code> по окончании запроса <code>LOAD DATA INFILE</code>. Ниже
показан формат строки информации для этого случая:

</P>

<pre>
Records: 1 Deleted: 0 Skipped: 0 Warnings: 0
</pre>

<P>
Предостережения выдаются при тех же обстоятельствах, что и при записи
величин командой <code>INSERT</code> (see section <A HREF="manual.ru_Reference.html#INSERT">6.4.3  Синтаксис оператора <code>INSERT</code></A>), за исключением того,
что команда <code>LOAD DATA INFILE</code> дополнительно генерирует предупреждения,
когда во входной строке слишком мало или слишком много полей.
Предостережения нигде не хранятся; количество предупреждений может
использоваться только для того, чтобы проверить, нормально ли выполнились
указанные действия. Если необходимо точно знать причины предупреждений, то
следует выполнить команду <code>SELECT ... INTO OUTFILE</code> в другой файл и
сравнить результат с первоначальным входным файлом - это единственный
способ получить такую информацию.

</P>
<P>
Если необходимо выполнить <code>LOAD DATA</code> для чтения из канала, можно применить
следующий трюк:

</P>


<pre>
mkfifo /mysql/db/x/x
chmod 666 /mysql/db/x/x
cat &#60; /dev/tcp/10.1.1.12/4711 &#62; /nt/mysql/db/x/x
mysql -e "LOAD DATA INFILE 'x' INTO TABLE x" x
</pre>

<P>
При использовании версии MySQL старше, чем 3.23.25, вышеприведенное можно
сделать только с <code>LOAD DATA LOCAL INFILE</code>.

</P>
<P>
Чтобы получить более подробную информацию об эффективности <code>INSERT</code> в
сравнении с <code>LOAD DATA INFILE</code> и увеличении скорости <code>LOAD DATA INFILE</code>,
см. раздел section <A HREF="manual.ru_MySQL_Optimisation.html#Insert_speed">5.2.9  Скорость выполнения запросов <code>INSERT</code></A>.

</P>


<H3><A NAME="DO" HREF="manual.ru_toc.html#DO">6.4.10  Синтаксис оператора <code>DO</code></A></H3>

<P>
<A NAME="IDX1403"></A>

</P>

<pre>
DO expression, [expression, ...]
</pre>

<P>
Выполняет данное выражение, но не возвращает какой-либо результат.
Является сокращенной формой оператора <code>SELECT expression, expression</code>, но
преимущество его заключается в том, что он работает немного быстрее, если
нет необходимости в возвращении результата.

</P>
<P>
Оператор главным образом полезен при использовании с функциями, имеющими
побочные эффекты, такими как <code>RELEASE_LOCK</code>.

</P>


<H2><A NAME="Data_Definition" HREF="manual.ru_toc.html#Data_Definition">6.5  Определение данных: <code>CREATE</code>, <code>DROP</code>, <code>ALTER</code></A></H2>



<H3><A NAME="CREATE_DATABASE" HREF="manual.ru_toc.html#CREATE_DATABASE">6.5.1  Синтаксис оператора <code>CREATE DATABASE</code></A></H3>

<P>
<A NAME="IDX1404"></A>

</P>

<pre>
CREATE DATABASE [IF NOT EXISTS] db_name
</pre>

<P>
Оператор <code>CREATE DATABASE</code> создает базу данных с указанным именем. Правила
для допустимых имен базы данных приведены в разделе section <A HREF="manual.ru_Reference.html#Legal_names">6.1.2  Имена баз данных, таблиц, столбцов, индексы псевдонимы</A>. Если база данных уже существует и не
указан ключевой параметр <code>IF NOT EXISTS</code>, то возникает ошибка выполнения
команды.

</P>
<P>
Базы данных в MySQL реализуются как директории, содержащие файлы, которые
соответствуют таблицам в базе данных. Поскольку при первоначальном
создании база данных не содержит таблиц, то команда <code>CREATE DATABASE</code>
создает только соответствующую поддиректорию в директории данных MySQL.

</P>
<P>
Базы данных можно также создавать с помощью утилиты <code>mysqladmin</code>. 
See section <A HREF="manual.ru_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  Клиентские сценарии и утилиты MySQL</A>.

</P>


<H3><A NAME="DROP_DATABASE" HREF="manual.ru_toc.html#DROP_DATABASE">6.5.2  Синтаксис оператора  <code>DROP DATABASE</code></A></H3>

<P>
<A NAME="IDX1405"></A>
<A NAME="IDX1406"></A>

</P>

<pre>
DROP DATABASE [IF EXISTS] db_name
</pre>

<P>
Оператор <code>DROP DATABASE</code> удаляет все таблицы в указанной базе данных и саму
базу. Если вы выполняете <code>DROP DATABASE</code> на базе данных, символически
связанной с другой, то удаляется как ссылка, так и оригинальная база
данных. Будьте <strong>ОЧЕНЬ</strong> внимательны при работе с этой командой!

</P>
<P>
Оператор <code>DROP DATABASE</code> возвращает количество файлов, которые были удалены
из директории базы данных. Как правило, это число равно количеству таблиц,
умноженному на три, поскольку обычно каждая таблица представлена тремя
файлами - <tt>`.MYD'</tt>-файлом, <tt>`MYI'</tt>-файлом и <tt>`.frm'</tt>-файлом.

</P>
<P>
Команда <code>DROP DATABASE</code> удаляет из директории указанной базы данных все
файлы со следующими расширениями:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Расширение</strong> </TD><TD> <strong>Расширение</strong> </TD><TD> <strong>Расширение</strong> </TD><TD> <strong>Расширение</strong>
</TD></TR>
<TR><TD>.BAK </TD><TD> .DAT </TD><TD> .HSH </TD><TD> .ISD
</TD></TR>
<TR><TD>.ISM </TD><TD> .ISM </TD><TD> .MRG </TD><TD> .MYD
</TD></TR>
<TR><TD>.MYI </TD><TD> .db </TD><TD> .frm </TD><TD>
</TD></TR>
</TABLE>

<P>
Все поддиректории, имена которых состоят из двух цифр (<code>RAID</code>-директории),
также удаляются.

</P>
<P>
В версии MySQL 3.22 и более поздних можно использовать ключевые слова <code>IF 
EXISTS</code> для предупреждения ошибки, если указанная база данных не
существует.

</P>
<P>
<A NAME="IDX1407"></A>
Можно также удалять базы данных с помощью утилиты <code>mysqladmin</code>. 
See section <A HREF="manual.ru_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  Клиентские сценарии и утилиты MySQL</A>.

</P>


<H3><A NAME="CREATE_TABLE" HREF="manual.ru_toc.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A></H3>

<P>
<A NAME="IDX1408"></A>

</P>

<pre>
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)]
[table_options] [select_statement]

или

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name LIKE old_table_name;

create_definition:
  col_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]
            [PRIMARY KEY] [reference_definition]
  или   PRIMARY KEY (index_col_name,...)
  или   KEY [index_name] (index_col_name,...)
  или   INDEX [index_name] (index_col_name,...)
  или   UNIQUE [INDEX] [index_name] (index_col_name,...)
  или   FULLTEXT [INDEX] [index_name] (index_col_name,...)
  или   [CONSTRAINT symbol] FOREIGN KEY [index_name] (index_col_name,...)
            [reference_definition]
  или   CHECK (expr)

type:
        TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  или   SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  или   MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  или   INT[(length)] [UNSIGNED] [ZEROFILL]
  или   INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  или   BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  или   REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  или   DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  или   FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  или   DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]
  или   NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]
  или   CHAR(length) [BINARY]
  или   VARCHAR(length) [BINARY]
  или   DATE
  или   TIME
  или   TIMESTAMP
  или   DATETIME
  или   TINYBLOB
  или   BLOB
  или   MEDIUMBLOB
  или   LONGBLOB
  или   TINYTEXT
  или   TEXT
  или   MEDIUMTEXT
  или   LONGTEXT
  или   ENUM(value1,value2,value3,...)
  или   SET(value1,value2,value3,...)

index_col_name:
        col_name [(length)]

reference_definition:
        REFERENCES tbl_name [(index_col_name,...)]
                   [MATCH FULL | MATCH PARTIAL]
                   [ON DELETE reference_option]
                   [ON UPDATE reference_option]

reference_option:
        RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
        TYPE = {BDB | HEAP | ISAM | InnoDB | MERGE | MRG_MYISAM | MYISAM }
или     AUTO_INCREMENT = #
или     AVG_ROW_LENGTH = #
или     CHECKSUM = {0 | 1}
или     COMMENT = "string"
или     MAX_ROWS = #
или     MIN_ROWS = #
или     PACK_KEYS = {0 | 1 | DEFAULT}
или     PASSWORD = "string"
или     DELAY_KEY_WRITE = {0 | 1}
или     ROW_FORMAT= { default | dynamic | fixed | compressed }
или     RAID_TYPE= {1 | STRIPED | RAID0 } RAID_CHUNKS=#  RAID_CHUNKSIZE=#
или     UNION = (table_name,[table_name...])
или     INSERT_METHOD= {NO | FIRST | LAST }
или     DATA DIRECTORY="абсолютный путь к каталогу"
или     INDEX DIRECTORY="абсолютный путь к каталогу"

select_statement:
        [IGNORE | REPLACE] SELECT ...  (любое корректное выражение SELECT)
</pre>

<P>
Оператор <code>CREATE TABLE</code> создает таблицу с заданным именем в текущей базе
данных. Правила для допустимых имен таблицы приведены в разделе section <A HREF="manual.ru_Reference.html#Legal_names">6.1.2  Имена баз данных, таблиц, столбцов, индексы псевдонимы</A>. Если нет активной текущей базы
данных или указанная таблица уже существует, то возникает ошибка
выполнения команды.

</P>
<P>
В версии MySQL 3.22 и более поздних имя таблицы может быть указано как
<code>db_name.tbl_name</code>. Эта форма записи работает независимо от того, является
ли указанная база данных текущей.

</P>
<P>
Начиная с MySQL 3.23 при создании таблицы можно использовать ключевое слово
<code>TEMPORARY</code>. Временная таблица автоматически удаляется по завершении
соединения, а ее имя действительно только в течение данного соединения.
Это означает, что в двух разных соединениях могут использоваться временные
таблицы с одинаковыми именами без конфликта друг с другом или с
существующей таблицей с тем же именем (существующая таблица скрыта, пока
не удалена временная таблица). С версии MySQL 4.0.2 для создания временных
таблиц необходимо иметь привилегии <code>CREATE TEMPORARY TABLES</code>.

</P>
<P>
В версии MySQL 3.23 и более поздних можно использовать ключевые слова <code>IF 
NOT EXISTS</code> для того, чтобы не возникала ошибка, если указанная таблица
уже существует. Следует учитывать, что при этом не проверяется
идентичность структур этих таблиц.

</P>
<P>
В MySQL 4.1 вы можете указать <code>LIKE</code> чтобы создавать таблицу, основываясь на
определении другой, уже существующей, таблицы.  В MySQL 4.1 также можете
определять тип автоматически создаваемого столбца: 

</P>

<pre>
CREATE TABLE foo (a tinyint not null) SELECT b+1 AS 'a' FROM bar;
</pre>

<P>
Каждая таблица <code>tbl_name</code> представлена определенными файлами в директории
базы данных. В случае таблиц типа <code>MyISAM</code> это следующие файлы:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Файл</strong> </TD><TD> <strong>Назначение</strong>
</TD></TR>
<TR><TD><code>tbl_name.frm</code> </TD><TD> Файл определения таблицы
</TD></TR>
<TR><TD><code>tbl_name.MYD</code> </TD><TD> Файл данных
</TD></TR>
<TR><TD><code>tbl_name.MYI</code> </TD><TD> Файл индексов
</TD></TR>
</TABLE>

<P>
Чтобы получить более полную информацию о свойствах различных типов
столбцов, section <A HREF="manual.ru_Reference.html#Column_types">6.2  Типы данных столбцов</A>:

</P>

<ul>
<LI>

Если не указывается ни <code>NULL</code>, ни <code>NOT NULL</code>, то столбец интерпретируется
так, как будто указано <code>NULL</code>.

<LI>

Целочисленный столбец может иметь дополнительный атрибут
<code>AUTO_INCREMENT</code>. При записи величины <code>NULL</code> (рекомендуется) или <code>0</code> в
столбец <code>AUTO_INCREMENT</code> данный столбец устанавливается в значение
<code>value+1</code>, где <code>value</code> представляет собой наибольшее для этого столбца
значение в таблице на момент записи. Последовательность <code>AUTO_INCREMENT</code>
начинается с <code>1</code>. See section <A HREF="manual.ru_Clients.html#mysql_insert_id">8.4.3.130  <code>mysql_insert_id()</code></A>. Если удалить строку,
содержащую максимальную величину для столбца <code>AUTO_INCREMENT</code>, то в
таблицах типа <code>ISAM</code> или <code>BDB</code> эта величина будет восстановлена, а в
таблицах типа <code>MyISAM</code> или <code>InnoDB</code> - нет. Если удалить все строки в
таблице командой <code>DELETE FROM table_name</code> (без выражения <code>WHERE</code>) в
режиме <code>AUTOCOMMIT</code>, то для таблиц всех типов последовательность
начнется заново. 

Примечание: в таблице может быть только один столбец
<code>AUTO_INCREMENT</code>, и он должен быть индексирован. Кроме того, версия
MySQL 3.23 будет правильно работать только с положительными величинами
столбца <code>AUTO_INCREMENT</code>. В случае внесения отрицательного числа оно
интерпретируется как очень большое положительное число. Это делается,
чтобы избежать проблем с точностью, когда числа ``заворачиваются'' от
положительного к отрицательному и, кроме того, для гарантии, что по
ошибке не будет получен столбец <code>AUTO_INCREMENT</code> со значением <code>0</code>. В
таблицах <code>MyISAM</code> и <code>BDB</code> можно указать вторичный столбец <code>AUTO_INCREMENT</code> с
многостолбцовым ключом. See section <A HREF="manual.ru_Tutorial.html#example-AUTO_INCREMENT">3.5.9  Использование атрибута AUTO_INCREMENT</A>. 

<A NAME="IDX1409"></A>
Последнюю
внесенную строку можно найти с помощью следующего запроса (чтобы
сделать MySQL совместимым с некоторыми ODBC-приложениями):


<pre>
SELECT * FROM tbl_name WHERE auto_col IS NULL
</pre>

<LI>

<code>CREATE TABLE</code> автоматически принимает текущую открытую транзакцию в InnoDB если 
в MySQL включен двоичный журнал. 

<LI>

Величины <code>NULL</code> для столбца типа <code>TIMESTAMP</code> обрабатываются иначе, чем для
столбцов других типов. В столбце <code>TIMESTAMP</code> нельзя хранить литерал
<code>NULL</code>; при установке данного столбца в <code>NULL</code> он будет установлен в
текущее значение даты и времени. Поскольку столбцы <code>TIMESTAMP</code> ведут
себя подобным образом, то атрибуты <code>NULL</code> и <code>NOT NULL</code> неприменимы в
обычном режиме и игнорируются при их задании. 

С другой стороны, чтобы
облегчить клиентам MySQL использование столбцов <code>TIMESTAMP</code>, сервер
сообщает, что таким столбцам могут быть назначены величины <code>NULL</code> (что
соответствует действительности), хотя реально <code>TIMESTAMP</code> никогда не
будет содержать величины <code>NULL</code>. Это можно увидеть, применив <code>DESCRIBE 
tbl_name</code> для получения описания данной таблицы. Следует учитывать, что
установка столбца <code>TIMESTAMP</code> в <code>0</code> не равнозначна установке его в <code>NULL</code>,
поскольку <code>0</code> для <code>TIMESTAMP</code>  является допустимой величиной.

<LI>

<A NAME="IDX1410"></A>
Величина <code>DEFAULT</code> должна быть константой, она не может быть функцией
или выражением. Если для данного столбца не задается никакой величины
<code>DEFAULT</code>, то MySQL автоматически назначает ее. Если столбец может
принимать <code>NULL</code> как допустимую величину, то по умолчанию присваивается
значение  <code>NULL</code>. Если столбец объявлен как <code>NOT NULL</code>, то значение по
умолчанию зависит от типа столбца:


<ul>
<LI>

Для числовых типов, за исключением объявленных с атрибутом
<code>AUTO_INCREMENT</code>, значение по умолчанию равно <code>0</code>. Для столбца
<code>AUTO_INCREMENT</code> значением по умолчанию является следующее значение
в последовательности для этого столбца.

<LI>

Для типов даты и времени, отличных от <code>TIMESTAMP</code>, значение по
умолчанию равно соответствующей нулевой величине для данного
типа. Для первого столбца <code>TIMESTAMP</code> в таблице значение по
умолчанию представляет собой текущее значение даты и времени. 
See section <A HREF="manual.ru_Reference.html#Date_and_time_types">6.2.2  Типы данных даты и времени</A>.

Для типов даты и времени, отличных от <code>TIMESTAMP</code>, значение по
умолчанию равно соответствующей нулевой величине для данного
типа. Для первого столбца <code>TIMESTAMP</code> в таблице значение по
умолчанию представляет собой текущее значение даты и времени. 
See section <A HREF="manual.ru_Reference.html#Date_and_time_types">6.2.2  Типы данных даты и времени</A>.

<LI>

Для строковых типов, кроме <code>ENUM</code>, значением по умолчанию является
пустая строка. Для <code>ENUM</code> значение по умолчанию равно первой
перечисляемой величине.
</ul>

Значения по умолчанию должны быть константами. Это означает, например, что
нельзя установить для столбца даты в качестве значения по умолчанию
величину функции, такой как <code>NOW()</code> или <code>CURRENT_DATE</code>.

<LI>

<code>KEY</code> является синонимом для <code>INDEX</code>.

<LI>

В MySQL ключ <code>UNIQUE</code> может иметь только различающиеся значения. При
попытке добавить новую строку с ключом, совпадающим с существующей
строкой, возникает ошибка выполнения команды.

<LI>

<A NAME="IDX1411"></A>
<code>PRIMARY KEY</code> представляет собой уникальный ключ <code>KEY</code> с дополнительным
ограничением, что все столбцы с данным ключом должны быть определены
как <code>NOT NULL</code>. В MySQL этот ключ называется <code>PRIMARY</code> (первичный).
Таблица может иметь только один первичный ключ <code>PRIMARY KEY</code>. Если
<code>PRIMARY KEY</code> отсутствует в таблицах, а некоторое приложение
запрашивает его, то MySQL может превратить в <code>PRIMARY KEY</code> первый ключ
<code>UNIQUE</code>, не имеющий ни одного столбца <code>NULL</code>.

<LI>

<code>PRIMARY KEY</code> может быть многостолбцовым индексом. Однако нельзя
создать многостолбцовый индекс, используя в определении столбца
атрибут ключа <code>PRIMARY KEY</code>. Именно таким образом только один столбец
будет отмечен как первичный. Необходимо использовать синтаксис <code>PRIMARY
KEY(index_col_name, ...</code>).

<LI>

Если ключ <code>PRIMARY</code> или <code>UNIQUE</code> состоит только из одного столбца и он
принадлежит к числовому типу, то на него можно сослаться также как на
<code>_rowid</code> (новшество версии 3.23.11).

<LI>

Если индексу не назначено имя, то ему будет присвоено первое имя в
<code>index_col_name</code>, возможно, с суффиксами (<code>_2</code>, <code>_3</code>, <code>...</code>), делающими это
имя уникальным. Имена индексов для таблицы можно увидеть, используя
<code>SHOW INDEX FROM tbl_name</code>. <code>SHOW Syntax</code>.

<LI>

<A NAME="IDX1412"></A>
Только таблицы типов <code>MyISAM</code>, <code>InnoDB</code> и <code>BDB</code> поддерживают индексы
столбцов, которые могут иметь величины <code>NULL</code>. В других случаях, во
избежание ошибки, необходимо объявлять такие столбцы как <code>NOT NULL</code>.

<LI>

С помощью выражения <code>col_name(length)</code> можно указать индекс, для
которого используется только часть столбца <code>CHAR</code> или <code>VARCHAR</code>. Это
поможет сделать файл индексов намного меньше. See section <A HREF="manual.ru_MySQL_Optimisation.html#Indexes">5.4.4  Индексы столбцов</A>.

<LI>

<A NAME="IDX1413"></A>
<A NAME="IDX1414"></A>
<A NAME="IDX1415"></A>
<A NAME="IDX1416"></A>
Индексацию столбцов <code>BLOB</code> и <code>TEXT</code>  поддерживают только таблицы с типом
<code>MyISAM</code>. Назначая индекс столбцу с типом <code>BLOB</code> или <code>TEXT</code>, всегда
НЕОБХОДИМО указывать длину этого индекса:


<pre>
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre>

<LI>

При использовании выражений <code>ORDER BY</code> или <code>GROUP BY</code> со столбцом типа
<code>TEXT</code> или <code>BLOB</code> используются только первые <code>max_sort_length</code> байтов. 
See section <A HREF="manual.ru_Reference.html#BLOB">6.2.3.2  Типы данных <code>BLOB</code> и <code>TEXT</code></A>.

<LI>

В версии MySQL 3.23.23 и более поздних можно создавать также
специальные индексы <code>FULLTEXT</code>. Они применяются для полнотекстового
поиска. Эти индексы поддерживаются только таблицами типа <code>MyISAM</code> и они
могут быть созданы только из столбцов <code>CHAR</code>, <code>VARCHAR</code> и <code>TEXT</code>. Индексирование
всегда выполняется для всего столбца целиком, частичная индексация не
поддерживается. Более подробно эта операция описана в разделе MySQL 
section <A HREF="manual.ru_Reference.html#Fulltext_Search">6.8  Полнотекстовый поиск в MySQL</A>.

<LI>

Выражения <code>FOREIGN KEY</code>, <code>CHECK</code> и <code>REFERENCES</code> фактически ничего не
делают. Они введены только из соображений совместимости, чтобы
облегчить перенос кода с других SQL-серверов и запускать приложения,
создающие таблицы со ссылками. See section <A HREF="manual.ru_Introduction.html#Extensions_to_ANSI">1.9.3  Расширения MySQL к ANSI SQL92</A>.

<LI>

В MySQL версии 3.23.44 или более поздней, таблицы InnoDB выполняют проверку
ограничений внешнего ключа.  See section <A HREF="manual.ru_Table_types.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A>. Однако обратите внимание, что
синтаксис <code>FOREIGN KEY</code> в InnoDB более строгий чем приведенный выше.
InnoDB не допускает указания <code>index_name</code>. Также столбцы таблицы, на
которую ссылаются, должны быть явно указаны.  Начиная с 4.0.8 InnoDB
поддерживает действия <code>ON DELETE</code> и <code>ON UPDATE</code>.

Для уточнения синтаксиса см. документацию по InnoDB. See section <A HREF="manual.ru_Table_types.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A>.  Для
остальных типов таблиц, MySQL делает синтаксической разбор указаний
<code>FOREIGN KEY</code>, <code>CHECK</code> и <code>REFERENCES</code> в <code>CREATE TABLE</code>, но
при этом успешно их игнорирует.  See section <A HREF="manual.ru_Introduction.html#ANSI_diff_Foreign_Keys">1.9.4.5  Внешние ключи</A>.

<LI>

Для каждого столбца <code>NULL</code> требуется один дополнительный бит, при этом
величина столбца округляется в большую сторону до ближайшего байта.

<LI>

Максимальную длину записи в байтах можно вычислить следующим образом:


<pre>
длина записи = 1
        + (сумма длин столбцов)
        + (количество столбцов с допустимым NULL + 7)/8
        + (количество столбцов с динамической длинной)
</pre>

<LI>

Опции <code>table_options</code> и <code>SELECT</code> реализованы только в версиях MySQL 3.23 и
выше. Ниже представлены различные типы таблиц:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Тип таблицы</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>BDB или BerkeleyDB </TD><TD> Таблицы с поддержкой транзакций и блокировкой страниц. See section <A HREF="manual.ru_Table_types.html#BDB">7.6  Таблицы <code>BDB</code> или BerkeleyDB</A>.
</TD></TR>
<TR><TD>HEAP </TD><TD> Данные для этой таблицы хранятся только в памяти.  See section <A HREF="manual.ru_Table_types.html#HEAP">7.4  Таблицы <code>HEAP</code></A>.
</TD></TR>
<TR><TD>ISAM </TD><TD> Оригинальный обработчик таблиц. See section <A HREF="manual.ru_Table_types.html#ISAM">7.3  Таблицы <code>ISAM</code></A>.
</TD></TR>
<TR><TD>InnoDB </TD><TD> Таблицы с поддержкой транзакций и блокировкой строк. See section <A HREF="manual.ru_Table_types.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A>.
</TD></TR>
<TR><TD>MERGE </TD><TD> Набор таблиц MyISAM, используемый как одна таблица. See section <A HREF="manual.ru_Table_types.html#MERGE">7.2  Таблицы <code>MERGE</code></A>.
</TD></TR>
<TR><TD>MRG_MyISAM </TD><TD> Псевдоним для таблиц MERGE
</TD></TR>
<TR><TD>MyISAM </TD><TD> Новый обработчик, обеспечивающий переносимость таблиц в бинарном виде, который заменяет ISAM.  See section <A HREF="manual.ru_Table_types.html#MyISAM">7.1  Таблицы <code>MyISAM</code></A>.
</TD></TR>
</TABLE>
See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>. 

Если задается тип таблицы, который не
поддерживается данной версией, то MySQL выберет из возможных типов
ближайший к указанному. Например, если задается <code>TYPE=BDB</code> и данный
дистрибутив MySQL не поддерживает таблиц <code>BDB</code>, то вместо этого будет
создана таблица <code>MyISAM</code>. Другие табличные опции используются для
оптимизации характеристик таблицы. Эти опции в большинстве случаев не
требуют специальной установки. Данные опции работают с таблицами всех
типов, если не указано иное:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>AUTO_INCREMENT </TD><TD> Следующая величина <code>AUTO_INCREMENT</code>, которую следует установить для данной таблицы (<code>MyISAM</code>).
</TD></TR>
<TR><TD>AVG_ROW_LENGTH </TD><TD> Приближенное значение средней длины строки для данной таблицы. Имеет смысл устанавливать только для обширных таблиц с записями переменной длины.
</TD></TR>
<TR><TD>CHECKSUM </TD><TD> Следует установить в <code>1</code>, чтобы в MySQL поддерживалась проверка контрольной суммы для всех строк (это делает таблицы немного более медленными при обновлении, но позволяет легче находить поврежденные таблицы) (<code>MyISAM</code>).
</TD></TR>
<TR><TD>COMMENT </TD><TD> Комментарий для данной таблицы длиной 60 символов.
</TD></TR>
<TR><TD>MAX_ROWS </TD><TD> Максимальное число строк, которые планируется хранить в данной таблице.
</TD></TR>
<TR><TD>MIN_ROWS </TD><TD> Минимальное число строк, которые планируется хранить в данной таблице.
</TD></TR>
<TR><TD>PACK_KEYS </TD><TD> Следует установить в <code>1</code> для получения меньшего индекса. Обычно это замедляет обновление и ускоряет чтение (<code>MyISAM</code>, <code>ISAM</code>). Установка в <code>0</code> отключит уплотнение ключей. При установке в <code>DEFAULT</code> (MySQL 4.0) обработчик таблиц будет уплотнять только длинные столбцы <code>CHAR/VARCHAR</code>.
</TD></TR>
<TR><TD>PASSWORD </TD><TD> Шифрует файл <tt>`.frm'</tt> с помощью пароля. Эта опция не функционирует в стандартной версии MySQL.
</TD></TR>
<TR><TD>DELAY_KEY_WRITE </TD><TD> Установка в <code>1</code> задерживает операции обновления таблицы ключей, пока не закроется указанная таблица (<code>MyISAM</code>).
</TD></TR>
<TR><TD>ROW_FORMAT </TD><TD> Определяет, каким образом должны храниться строки. В настоящее время эта опция работает только с таблицами <code>MyISAM</code>, которые поддерживают форматы строк <code>DYNAMIC</code> и <code>FIXED</code>. See section <A HREF="manual.ru_Table_types.html#MyISAM_table_formats">7.1.2  Форматы таблиц <code>MyISAM</code></A>.
</TD></TR>
</TABLE>

При использовании таблиц <code>MyISAM</code> MySQL вычисляет выражение <code>max_rows *
avg_row_length</code>, чтобы определить, насколько велика будет результирующая
таблица. Если не задана ни одна из вышеупомянутых опций, то максимальный
размер таблицы будет составлять 4Гб (или 2Гб если данная операционная
система поддерживает только таблицы величиной до 2Гб). Это делается для
того, чтобы, если нет реальной необходимости в больших файлах, ограничить
размеры указателей, что позволит сделать индексы меньше и быстрее. Если
опция <code>PACK_KEYS</code> не используется, то по умолчанию уплотняются только
строки, но не числа. При использовании <code>PACK_KEYS=1</code> числа тоже будут
уплотняться. При уплотнении двоичных числовых ключей MySQL будет
использовать сжатие префиксов. Это означает, что выгода от этого будет
значительной только в случае большого количества одинаковых чисел. При
сжатии префиксов для каждого ключа требуется один дополнительный байт, в
котором указано, сколько байтов предыдущего ключа являются такими же, как
и для следующего (следует учитывать, что указатель на строку хранится в
порядке "старший-байт-в-начале" сразу после ключа - чтобы улучшить
компрессию).

Это означает, что при наличии нескольких одинаковых ключей в двух
строках записи все последующие ``аналогичные'' ключи будут занимать
только по 2 байта (включая указатель строки). Сравним: в обычном
случае для хранения последующих ключей требуется <code>размер_хранения_ключа
+ размер_указателя (обычно 4)</code> байтов. С другой стороны, если все ключи
абсолютно разные, каждый ключ будет занимать на 1 байт больше, если
данный ключ не может иметь величину <code>NULL</code> (в этом случае уплотненный
ключ будет храниться в том же байте, который используется для
указания, что ключ равен <code>NULL</code>).

<LI>

Если после команды <code>CREATE</code> указывается команда <code>SELECT</code>, то  MySQL
создаст новые поля для всех элементов в данной команде <code>SELECT</code>.
Например:


<pre>
mysql&#62; CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,
        PRIMARY KEY (a), KEY(b))
        TYPE=MyISAM SELECT b,c FROM test2;
</pre>

Эта команда создаст таблицу <code>MyISAM</code> с тремя столбцами <code>a</code>, <code>b</code> и <code>c</code>. Отметим,
что столбцы из команды <code>SELECT</code> присоединяются к таблице справа, а не
перекрывают ее. Рассмотрим следующий пример:


<pre>
mysql&#62; SELECT * FROM foo;
+---+
| n |
+---+
| 1 |
+---+

mysql&#62; CREATE TABLE bar (m INT) SELECT n FROM foo;
Query OK, 1 row affected (0.02 sec)
Records: 1 Duplicates: 0 Warnings: 0

mysql&#62; SELECT * FROM bar;
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)
</pre>

Каждая строка в таблице <code>foo</code> вносится в таблицу <code>bar</code> со своим значением из
<code>foo</code>, при этом в новые столбцы в таблице <code>bar</code> записываются величины,
заданные по умолчанию. Команда <code>CREATE TABLE ... SELECT</code> не создает
автоматически каких-либо индексов. Это сделано преднамеренно, чтобы
команда была настолько гибкой, насколько возможно. Чтобы иметь индексы в
созданной таблице, необходимо указать их перед данной командой <code>SELECT</code>:


<pre>
mysql&#62; CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;
</pre>

Если возникает ошибка при копировании данных в таблицу, то они будут
автоматически удалены. Чтобы обеспечить возможность использовать для
восстановления таблиц журнал обновлений/двоичный журнал, в MySQL во время
выполнения команды <code>CREATE TABLE ... SELECT</code>  не разрешены параллельные
вставки.

<LI>

Воспользовавшись опцией <code>RAID_TYPE</code>, можно разбить файл данных <code>MyISAM</code> на
участки с тем, чтобы преодолеть 2Гб/4Гб лимит файловой системы под управлением ОС, 
не поддерживающих большие файлы. Разбиение не касается файла индексов.  
Следует учесть, что для файловых систем,
которые поддерживают большие файлы, эта опция не рекомендуется! Для
получения более высокой скорости ввода-вывода можно разместить
RAID-директории на различных физических дисках. <code>RAID_TYPE</code> будет
работать под любой операционной системой, если конфигурация MySQL
выполнена с параметром <code>--with-raid</code>. В настоящее время для опции
<code>RAID_TYPE</code> возможен только параметр <code>STRIPED</code> (<code>1</code> и <code>RAID0</code> являются
псевдонимами для него). Если указывается <code>RAID_TYPE=STRIPED</code> для таблицы
<code>MyISAM</code>, то <code>MyISAM</code> создаст поддиректории <code>RAID_CHUNKS</code> с именами <tt>`00'</tt>, <tt>`01'</tt>,
<tt>`02'</tt> в директории базы данных. В каждой из этих директорий <code>MyISAM</code>
создаст файл <tt>`table_name.MYD'</tt>. При записи данных в файл данных
обработчик RAID установит соответствие первых <code>RAID_CHUNKSIZE*1024</code>
байтов первому упомянутому файлу, следующих <code>RAID_CHUNKSIZE*1024</code>
байтов - следующему файлу и так далее.

<LI>

Опция <code>UNION</code> применяется, если необходимо использовать совокупность
идентичных таблиц как одну таблицу. Она работает только с таблицами
<code>MERGE</code>. See section <A HREF="manual.ru_Table_types.html#MERGE">7.2  Таблицы <code>MERGE</code></A>. На данный момент для таблиц,
сопоставляемых с таблицей <code>MERGE</code>, необходимо иметь привилегии <code>SELECT</code>,
<code>UPDATE</code> и <code>DELETE</code>. Все сопоставляемые таблицы должны принадлежать той же
базе данных, что и таблица <code>MERGE</code>.

<LI>

Для внесения данных в таблицу <code>MERGE</code> необходимо указать с помощью
<code>INSERT_METHOD</code>, в какую таблицу данная строка должна быть внесена.
See section <A HREF="manual.ru_Table_types.html#MERGE">7.2  Таблицы <code>MERGE</code></A>. Эта опция была введена в MySQL 4.0.0.

<LI>

В созданной таблице ключ <code>PRIMARY</code> будет помещен первым, за ним все
ключи <code>UNIQUE</code> и затем простые ключи. Это помогает оптимизатору MySQL
определять приоритеты используемых ключей, а также более быстро
определять сдублированные ключи <code>UNIQUE</code>.

<LI>

Используя опции <code>DATA DIRECTORY="каталог"</code> или <code>INDEX 
DIRECTORY="каталог"</code>, можно указать, где обработчик таблицы должен
помещать свои табличные и индексные файлы. Следует учитывать, что
указываемый параметр directory должен представлять собой полный путь к
требуемому каталогу (а не относительный путь). Данные опции работают
только для таблиц <code>MyISAM</code> в версии MySQL 4.0, если при этом не
используется опция <code>--skip-symlink</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#Symbolic_links_to_tables">5.6.1.2  Использование символических ссылок для таблиц</A>.
</ul>



<H4><A NAME="Silent_column_changes" HREF="manual.ru_toc.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A></H4>

<P>
<A NAME="IDX1417"></A>

</P>
<P>
В некоторых случаях MySQL без уведомления изменяет определение столбца,
заданное командой <code>CREATE TABLE</code> (Это может осуществляться также для
команды <code>ALTER TABLE</code>):

</P>

<ul>
<LI>

Столбец <code>VARCHAR</code> с длиной меньше, чем четыре, преобразуется в столбец
<code>CHAR</code>.

<LI>

Если некоторый столбец в таблице имеет переменную длину, то и вся
строка в результате будет переменной длины. Следовательно, если
таблица содержит любые столбцы переменной длины (<code>VARCHAR</code>, <code>TEXT</code> или
<code>BLOB</code>), то все столбцы <code>CHAR</code> с длиной, превышающей три символа,
преобразуются в столбцы <code>VARCHAR</code>. Это в любом случае не влияет на
использование столбцов; в MySQL столбец  <code>VARCHAR</code> представляет собой
просто иной способ хранения символов. MySQL выполняет данное
преобразование, поскольку оно позволяет сэкономить память и сделать
табличные операции более быстрыми. See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>.

<LI>

Количество выводящихся символов столбца  <code>TIMESTAMP</code> должно быть четным
и находиться в диапазоне от <code>2</code> до <code>14</code>. При задании размера вывода,
равного <code>0</code> или превышающего <code>14</code>, указанный размер приводится к <code>14</code>.
Нечетные величины размера вывода в пределах от <code>1</code> до <code>13</code> приводятся к
следующему четному числу.

<LI>

В столбце  <code>TIMESTAMP</code> не может храниться литерал <code>NULL</code>; установка
данного столбца в <code>NULL</code> устанавливает его в текущее значение даты и
времени. Поскольку столбцы <code>TIMESTAMP</code> ведут себя подобным образом, то
атрибуты <code>NULL</code> и <code>NOT NULL</code> неприменимы в обычном режиме и игнорируются
при их задании. <code>DESCRIBE tbl_name</code> всегда сообщает, что столбцу
<code>TIMESTAMP</code> могут быть присвоены величины <code>NULL</code>.

<LI>

MySQL приводит в соответствие определенные типы столбцов, используемые
другими производителями баз данных SQL, к типам, принятым в MySQL.
See section <A HREF="manual.ru_Reference.html#Other-vendor_column_types">6.2.5  Использование типов столбцов из других баз данных</A>.
</ul>

<P>
Если необходимо увидеть, использует ли MySQL иной тип столбца, чем был
первоначально задан, следует запустить команду <code>DESCRIBE tbl_name</code> после
создания или изменения данной таблицы.

</P>
<P>
Некоторые другие изменения типов столбцов могут происходить при сжатии
таблицы с использованием утилиты <code>myisampack</code>. See section <A HREF="manual.ru_Table_types.html#Compressed_format">7.1.2.3  Характеристики сжатых таблиц</A>.

</P>


<H3><A NAME="ALTER_TABLE" HREF="manual.ru_toc.html#ALTER_TABLE">6.5.4  Синтаксис оператора <code>ALTER TABLE</code></A></H3>

<P>
<A NAME="IDX1418"></A>
<A NAME="IDX1419"></A>
<A NAME="IDX1420"></A>

</P>

<pre>
ALTER [IGNORE] TABLE tbl_name alter_spec [, alter_spec ...]

alter_specification:
        ADD [COLUMN] create_definition [FIRST | AFTER column_name ]
  или   ADD [COLUMN] (create_definition, create_definition,...)
  или   ADD INDEX [index_name] (index_col_name,...)
  или   ADD PRIMARY KEY (index_col_name,...)
  или   ADD UNIQUE [index_name] (index_col_name,...)
  или   ADD FULLTEXT [index_name] (index_col_name,...)
  или   ADD [CONSTRAINT symbol] FOREIGN KEY [index_name] (index_col_name,...)
            [reference_definition]
  или   ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  или   CHANGE [COLUMN] old_col_name create_definition
               [FIRST | AFTER column_name]
  или   MODIFY [COLUMN] create_definition [FIRST | AFTER column_name]
  или   DROP [COLUMN] col_name
  или   DROP PRIMARY KEY
  или   DROP INDEX index_name
  или   DISABLE KEYS
  или   ENABLE KEYS
  или   RENAME [TO] new_tbl_name
  или   ORDER BY col
  или   table_options
</pre>

<P>
Оператор <code>ALTER TABLE</code> обеспечивает возможность изменять структуру
существующей таблицы. Например, можно добавлять или удалять столбцы,
создавать или уничтожать индексы или переименовывать столбцы либо саму
таблицу. Можно также изменять комментарий для таблицы и ее тип.
See section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>.

</P>
<P>
Если оператор <code>ALTER TABLE</code> используется для изменения определения типа
столбца, но <code>DESCRIBE tbl_name</code> показывает, что столбец не изменился, то,
возможно, MySQL игнорирует данную модификацию по одной из причин,
описанных в разделе section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>. Например, при
попытке изменить столбец <code>VARCHAR</code> на <code>CHAR</code>  MySQL будет продолжать
использовать <code>VARCHAR</code>, если данная таблица содержит другие столбцы с
переменной длиной.

</P>
<P>
Оператор <code>ALTER TABLE</code> во время работы создает временную копию исходной
таблицы. Требуемое изменение выполняется на копии, затем исходная таблица
удаляется, а новая переименовывается. Так делается для того, чтобы в новую
таблицу автоматически попадали все обновления кроме неудавшихся. Во время
выполнения <code>ALTER TABLE</code> исходная таблица доступна для чтения другими
клиентами. Операции обновления и записи в этой таблице приостанавливаются,
пока не будет готова новая таблица.

</P>
<P>
Следует отметить, что при использовании любой другой опции для <code>ALTER 
TABLE</code> кроме <code>RENAME</code>, MySQL всегда будет создавать временную таблицу, даже
если данные, строго говоря, и не нуждаются в копировании (например, при
изменении имени столбца). Мы планируем исправить это в будущем, однако,
поскольку <code>ALTER TABLE</code> выполняется не так часто, мы (разработчики MySQL)
не считаем эту задачу первоочередной. Для таблиц <code>MyISAM</code> можно увеличить
скорость воссоздания индексной части (что является наиболее медленной
частью в процессе восстановления таблицы) путем установки переменной
<code>myisam_sort_buffer_size</code> достаточно большого значения.

</P>

<ul>
<LI>

Для использования оператора <code>ALTER TABLE</code> необходимы привилегии <code>ALTER</code>,
<code>INSERT</code> и <code>CREATE</code> для данной таблицы.

<LI>

Опция  <code>IGNORE</code> является расширением MySQL по отношению к ANSI  SQL92.
Она управляет работой <code>ALTER TABLE</code> при наличии дубликатов уникальных
ключей в новой таблице. Если опция <code>IGNORE</code> не задана, то для данной
копии процесс прерывается и происходит откат назад. Если <code>IGNORE</code>
указывается, тогда для строк с дубликатами уникальных ключей только
первая строка используется, а остальные удаляются.

<LI>

Можно запустить несколько выражений <code>ADD</code>, <code>ALTER</code>, <code>DROP</code> и <code>CHANGE</code> в одной
команде <code>ALTER TABLE</code>. Это является расширением MySQL по отношению к
ANSI  SQL92, где допускается только одно выражение из упомянутых в
одной команде <code>ALTER TABLE</code>.

<LI>

Опции  <code>CHANGE col_name</code>, <code>DROP col_name</code> и <code>DROP INDEX</code> также являются
расширениями MySQL по отношению к ANSI  SQL92.

<LI>

Опция  <code>MODIFY</code> представляет собой расширение Oracle для команды <code>ALTER 
TABLE</code>.

<LI>

Необязательное слово <code>COLUMN</code> представляет собой ``белый шум'' и может
быть опущено.

<LI>

При использовании <code>ALTER TABLE имя_таблицы RENAME TO новое_имя</code> без
каких-либо других опций MySQL просто переименовывает файлы,
соответствующие заданной таблице. В этом случае нет
необходимости создавать временную таблицу. See section <A HREF="manual.ru_Reference.html#RENAME_TABLE">6.5.5  Синтаксис оператора  <code>RENAME TABLE</code></A>.

<LI>

В выражении  <code>create_definition</code> для <code>ADD</code> и <code>CHANGE</code> используется тот же
синтаксис, что и для <code>CREATE TABLE</code>. Следует учитывать, что этот
синтаксис включает имя столбца, а не просто его тип. See section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>.

<LI>

Столбец можно переименовывать, используя выражение <code>CHANGE имя_столбца
create_definition</code>. Чтобы сделать это, необходимо указать старое и
новое имена столбца и его тип в настоящее время. Например, чтобы
переименовать столбец <code>INTEGER</code> из <code>a</code> в <code>b</code>, можно сделать следующее:


<pre>
mysql&#62; ALTER TABLE t1 CHANGE a b INTEGER;
</pre>

При изменении типа столбца, но не его имени синтаксис выражения <code>CHANGE</code> все
равно требует указания обоих имен столбца, даже если они одинаковы.
Например:


<pre>
mysql&#62; ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;
</pre>

Однако начиная с версии MySQL 3.22.16a можно также использовать выражение
<code>MODIFY</code> для изменения типа столбца без переименовывания его:


<pre>
mysql&#62; ALTER TABLE t1 MODIFY b BIGINT NOT NULL;
</pre>

<LI>

При использовании <code>CHANGE</code> или <code>MODIFY</code> для того, чтобы уменьшить длину
столбца, по части которого построен индекс (например, индекс по первым
10 символам столбца <code>VARCHAR</code>), нельзя сделать столбец короче, чем число
проиндексированных символов.

<LI>

При изменении типа столбца с использованием <code>CHANGE</code> или <code>MODIFY</code>  MySQL
пытается преобразовать данные в новый тип как можно корректнее.

<LI>

В версии MySQL 3.22 и более поздних можно использовать <code>FIRST</code> или <code>ADD
... AFTER имя_столбца</code> для добавления столбца на заданную позицию внутри
табличной строки. По умолчанию столбец добавляется в конце. Начиная с
версии MySQL 4.0.1, можно также использовать ключевые слова <code>FIRST</code> и
<code>AFTER</code> в опциях <code>CHANGE</code> или <code>MODIFY</code>.

<A NAME="IDX1421"></A>
<A NAME="IDX1422"></A>
<A NAME="IDX1423"></A>
<A NAME="IDX1424"></A>
<A NAME="IDX1425"></A>
<LI>

Опция  <code>ALTER COLUMN</code> задает для столбца новое значение по умолчанию
или удаляет старое. Если старое значение по умолчанию удаляется и
данный столбец может принимать значение <code>NULL</code>, то новое значение по
умолчанию будет <code>NULL</code>. Если столбец не может быть <code>NULL</code>, то MySQL
назначает значение по умолчанию так, как описано в разделе section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>.

<LI>

<A NAME="IDX1426"></A>
<A NAME="IDX1427"></A>
<A NAME="IDX1428"></A>
Опция  <code>DROP INDEX</code> удаляет индекс. Это является расширением MySQL по
отношению к ANSI  SQL92. See section <A HREF="manual.ru_Reference.html#DROP_INDEX">6.5.8  Синтаксис оператора  <code>DROP INDEX</code></A>.

<LI>

Если столбцы удаляются из таблицы, то эти столбцы удаляются также и из
любого индекса, в который они входят как часть. Если все столбцы,
составляющие индекс, удаляются, то данный индекс также удаляется.

<LI>

Если таблица содержит только один столбец, то этот столбец не может
быть удален. Вместо этого можно удалить данную таблицу, используя
команду <code>DROP TABLE</code>.

<LI>

<A NAME="IDX1429"></A>
<A NAME="IDX1430"></A>
Опция  <code>DROP PRIMARY KEY</code> удаляет первичный индекс. Если такого
индекса в данной таблице не существует, то удаляется первый индекс
<code>UNIQUE</code> в этой таблице. (MySQL отмечает первый уникальный ключ <code>UNIQUE</code>
как первичный ключ <code>PRIMARY KEY</code>, если никакой другой первичный ключ
<code>PRIMARY KEY</code> не был явно указан). При добавлении <code>UNIQUE INDEX</code> или
<code>PRIMARY KEY</code> в таблицу они хранятся перед остальными неуникальными
ключами, чтобы можно было определить дублирующиеся ключи как можно
раньше.

<LI>

<A NAME="IDX1431"></A>
Опция  <code>ORDER BY</code> позволяет создавать новую таблицу со строками,
размещенными в заданном порядке. Следует учитывать, что созданная
таблица не будет сохранять этот порядок строк после операций вставки и
удаления. В некоторых случаях такая возможность может облегчить
операцию сортировки в MySQL, если таблица имеет такое расположение
столбцов, которое вы хотели бы иметь в дальнейшем. Эта опция в
основном полезна, если заранее известен определенный порядок, в
котором преимущественно будут запрашиваться строки. Использование
данной опции после значительных преобразований таблицы дает
возможность получить более высокую производительность.

<LI>

<A NAME="IDX1432"></A>
При использовании команды <code>ALTER TABLE</code> для таблиц <code>MyISAM</code> все
неуникальные индексы создаются в отдельном пакете (подобно <code>REPAIR</code>).
Благодаря этому команда <code>ALTER TABLE</code> при наличии нескольких индексов
будет работать быстрее.

<LI>

Начиная с MySQL 4.0, вышеуказанная возможность может быть
активизирована явным образом. Команда <code>ALTER TABLE ... DISABLE KEYS</code>
блокирует в MySQL обновление неуникальных индексов для таблиц <code>MyISAM</code>.
После этого можно применить команду  <code>ALTER TABLE ... ENABLE KEYS</code> для
воссоздания недостающих индексов. Так как MySQL делает это с помощью
специального алгоритма, который намного быстрее в сравнении со
вставкой ключей один за другим, блокировка ключей может дать
существенное ускорение на больших массивах вставок.

<LI>

<A NAME="IDX1433"></A>
Применяя функцию C  API  <code>mysql_info()</code>, можно определить, сколько
записей было скопировано, а также (при использовании <code>IGNORE</code>) - сколько
записей было удалено из-за дублирования значений уникальных ключей.

<LI>

<A NAME="IDX1434"></A>
<A NAME="IDX1435"></A>
Выражения <code>FOREIGN KEY</code>, <code>CHECK</code> и <code>REFERENCES</code> фактически
ничего не делают во всех типах таблиц, кроме InnoDB. InnoDB поддерживает
<code>ADD CONSTRAINT FOREIGN KEY (...) REFERENCES ... (...)</code>.  Заметьте, что
InnoDB не допускает указания <code>index_name</code>. See section <A HREF="manual.ru_Table_types.html#InnoDB">7.5  Таблицы <code>InnoDB</code></A>.  Поддержка
синтаксиса FOREIGH KEY введена только из соображений совместимости, чтобы
облегчить перенос кода с других серверов SQL и запуск приложений, создающих
таблицы со ссылками. See section <A HREF="manual.ru_Introduction.html#Differences_from_ANSI">1.9.4  Отличия MySQL от ANSI SQL92</A>.  
</ul>

<P>
Ниже приводятся примеры, показывающие некоторые случаи употребления
команды <code>ALTER TABLE</code>. Пример начинается с таблицы <code>t1</code>, которая создается
следующим образом:

</P>

<pre>
mysql&#62; CREATE TABLE t1 (a INTEGER,b CHAR(10));
</pre>

<P>
Для того чтобы переименовать таблицу из <code>t1</code> в <code>t2</code>:

</P>

<pre>
mysql&#62; ALTER TABLE t1 RENAME t2;
</pre>

<P>
Для того чтобы изменить тип столбца с <code>INTEGER</code> на <code>TINYINT NOT NULL</code>
(оставляя имя прежним) и изменить тип столбца <code>b</code> с <code>CHAR(10)</code> на <code>CHAR(20)</code> с
переименованием его с <code>b</code> на <code>c</code>:

</P>

<pre>
mysql&#62; ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</pre>

<P>
Для того чтобы добавить новый столбец <code>TIMESTAMP</code> с именем <code>d</code>:

</P>

<pre>
mysql&#62; ALTER TABLE t2 ADD d TIMESTAMP;
</pre>

<P>
Для того чтобы добавить индекс к столбцу <code>d</code> и сделать столбец a первичным
ключом:

</P>

<pre>
mysql&#62; ALTER TABLE t2 ADD INDEX (d), ADD PRIMARY KEY (a);
</pre>

<P>
Для того чтобы удалить столбец <code>c</code>:

</P>

<pre>
mysql&#62; ALTER TABLE t2 DROP COLUMN c;
</pre>

<P>
Для того чтобы добавить новый числовой столбец <code>AUTO_INCREMENT</code> с именем <code>c</code>:

</P>

<pre>
mysql&#62; ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
        ADD INDEX (c);
</pre>

<P>
Заметьте, что столбец <code>c</code> индексируется, так как столбцы <code>AUTO_INCREMENT</code>
должны быть индексированы, кроме того, столбец <code>c</code> объявляется как <code>NOT 
NULL</code>, поскольку индексированные столбцы не могут быть <code>NULL</code>.

</P>
<P>
При добавлении столбца <code>AUTO_INCREMENT</code> значения этого столбца автоматически
заполняются последовательными номерами (при добавлении записей). Первый
номер последовательности можно установить путем выполнения команды <code>SET
INSERT_ID=#</code> перед <code>ALTER TABLE</code> или использования табличной опции
<code>AUTO_INCREMENT = #</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A>.

</P>
<P>
Если столбец <code>AUTO_INCREMENT</code> для таблиц <code>MyISAM</code>, не изменяется, то номер
последовательности остается прежним. При удалении столбца <code>AUTO_INCREMENT</code> и
последующем добавлении другого столбца <code>AUTO_INCREMENT</code> номера будут
начинаться снова с <code>1</code>.

</P>
<P>
See section <A HREF="manual.ru_Problems.html#ALTER_TABLE_problems">A.6.1  Проблемы с <code>ALTER TABLE</code></A>.

</P>


<H3><A NAME="RENAME_TABLE" HREF="manual.ru_toc.html#RENAME_TABLE">6.5.5  Синтаксис оператора  <code>RENAME TABLE</code></A></H3>

<P>
<A NAME="IDX1436"></A>

</P>

<pre>
RENAME TABLE tbl_name TO new_tbl_name[, tbl_name2 TO new_tbl_name2,...]
</pre>

<P>
Операция переименования должна осуществляться как атомарная, т.е. при
выполнении переименования никакому другому потоку не разрешается доступ к
указанным таблицам. Благодаря этому возможно замещение таблицы пустой
таблицей:

</P>

<pre>
CREATE TABLE new_table (...);
RENAME TABLE old_table TO backup_table, new_table TO old_table;
</pre>

<P>
Переименование производится слева направо. Таким образом, для обмена
именами между двумя таблицами необходимо выполнить следующие действия:

</P>

<pre>
RENAME TABLE old_table TO backup_table,
        new_table TO old_table,
        backup_table TO new_table;
</pre>

<P>
Для двух баз данных, находящихся на одном и том же диске, можно также
осуществлять обмен именами:

</P>

<pre>
RENAME TABLE current_db.tbl_name TO other_db.tbl_name;
</pre>

<P>
При выполнении команды <code>RENAME</code> не должны иметь место заблокированные
таблицы или активные транзакции. Необходимо также иметь привилегии <code>ALTER</code> и
<code>DROP</code> для исходной таблицы и привилегии <code>CREATE</code> и <code>INSERT</code> - для новой.

</P>
<P>
Если MySQL сталкивается с какой-либо ошибкой при переименовании нескольких
таблиц, то произойдет обратное переименование для всех переименованных
таблиц, чтобы вернуть все в исходное состояние.

</P>
<P>
Оператор <code>RENAME TABLE</code> был добавлен в MySQL 3.23.23.

</P>


<H3><A NAME="DROP_TABLE" HREF="manual.ru_toc.html#DROP_TABLE">6.5.6  Синтаксис оператора  <code>DROP TABLE</code></A></H3>

<P>
<A NAME="IDX1437"></A>
<A NAME="IDX1438"></A>
<A NAME="IDX1439"></A>

</P>

<pre>
DROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name,...] [RESTRICT | CASCADE]
</pre>

<P>
Оператор <code>DROP TABLE</code> удаляет одну или несколько таблиц. Все табличные
данные и определения удаляются, так что будьте внимательны при работе с
этой командой!

</P>
<P>
В версии MySQL 3.22 и более поздних можно использовать ключевые слова <code>IF 
EXISTS</code>, чтобы предупредить ошибку, если указанные таблицы не существуют.

</P>
<P>
В 4.1 будет получено замечание (<code>NOTE</code>) для всех несуществующих таблиц при
использовании <code>IF EXISTS</code>.  See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_WARNINGS">4.5.6.9  <code>SHOW WARNINGS | ERRORS</code></A>.

</P>
<P>
Опции  <code>RESTRICT</code> и <code>CASCADE</code> позволяют упростить перенос программы. В данный
момент они не задействованы.

</P>
<P>
Примечание: <code>DROP TABLE</code> автоматически принимает текущую активную
транзакцию (за исключением случаев, когда вы используетее 4.1 и указано
ключевое слово <code>TEMPORARY</code>).

</P>
<P>
Опция <code>TEMPORARY</code> игнорируется в 4.0. В 4.1 эта опция работает следующим образом: 

</P>

<ul>
<LI>

Только уничтожает временные таблицы.
<LI>

Не закрывает открытую транзакцию.
<LI>

Права доступа не проверяются.
</ul>

<P>
Использование слова <code>TEMPORARY</code> - это хороший способ удостовериться что вы случайно
не уничтожите настоящую таблицу.

</P>


<H3><A NAME="CREATE_INDEX" HREF="manual.ru_toc.html#CREATE_INDEX">6.5.7  Синтаксис оператора <code>CREATE INDEX</code></A></H3>

<P>
<A NAME="IDX1440"></A>
<A NAME="IDX1441"></A>
<A NAME="IDX1442"></A>

</P>

<pre>
CREATE [UNIQUE|FULLTEXT] INDEX index_name
        ON tbl_name (col_name[(length)],... )
</pre>

<P>
Команда <code>CREATE INDEX</code> в версиях MySQL до 3.22 не выполняет никаких
действий. В версии 3.22 и более поздних <code>CREATE INDEX</code> соответствует
команде <code>ALTER TABLE</code> в части создания индексов. See section <A HREF="manual.ru_Reference.html#ALTER_TABLE">6.5.4  Синтаксис оператора <code>ALTER TABLE</code></A>.

</P>
<P>
Обычно все индексы создаются в таблице во время создания самой таблицы
командой <code>CREATE TABLE</code>. See section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>. <code>CREATE INDEX</code> дает
возможность добавить индексы к существующим таблицам.

</P>
<P>
Список столбцов в форме <code>(col1,col2,...)</code> создает индекс для нескольких
столбцов. Величины индексов формируются путем конкатенации величин
указанных столбцов.

</P>
<P>
Для столбцов типов <code>CHAR</code> и <code>VARCHAR</code> с помощью параметра
<code>col_name(length)</code> могут создаваться индексы, для которых используется только
часть столбца (для столбцов <code>BLOB</code> и <code>TEXT</code> нужно указывать длину). Команда,
приведенная ниже, создает индекс, используя первые 10 символов столбца
name:

</P>

<pre>
mysql&#62; CREATE INDEX part_of_name ON customer (name(10));
</pre>

<P>
Поскольку большинство имен обычно имеют отличия друг от друга в первых 10
символах, данный индекс не должен быть намного медленнее, чем созданный из
столбца name целиком. Кроме того, используя неполные столбцы для индексов,
можно сделать файл индексов намного меньше, а это позволяет сэкономить
место на диске и к тому же повысить скорость операций <code>INSERT</code>!

</P>
<P>
Следует учитывать, что в версии MySQL 3.23.2 и более поздних для таблиц
типа <code>MyISAM</code> можно добавлять индекс только для столбцов, которые могут
принимать величины <code>NULL</code> или для столбцов <code>BLOB/TEXT</code>.

</P>
<P>
Чтобы получить более подробную информацию о том, как <code>MySQL</code> использует
индексы, See section <A HREF="manual.ru_MySQL_Optimisation.html#MySQL_indexes">5.4.3  Использование индексов в MySQL</A>.

</P>
<P>
С помощью опции <code>FULLTEXT</code> можно индексировать только столбцы <code>VARCHAR</code> и <code>TEXT</code>
и только в таблицах <code>MyISAM</code>. Эта возможность доступна только в версии MySQL
3.23.23 и выше. See section <A HREF="manual.ru_Reference.html#Fulltext_Search">6.8  Полнотекстовый поиск в MySQL</A>.

</P>


<H3><A NAME="DROP_INDEX" HREF="manual.ru_toc.html#DROP_INDEX">6.5.8  Синтаксис оператора  <code>DROP INDEX</code></A></H3>

<P>
<A NAME="IDX1443"></A>
<A NAME="IDX1444"></A>
<A NAME="IDX1445"></A>

</P>

<pre>
DROP INDEX index_name ON tbl_name
</pre>

<P>
Оператор <code>DROP INDEX</code> удаляет индексы, указанные в <code>index_name</code> из таблицы
<code>tbl_name</code>. <code>DROP INDEX</code> не выполняет никаких действий в версиях MySQL до
3.22. В версиях 3.22 и более поздних <code>DROP INDEX</code> соответствует команде 
<code>ALTER TABLE</code> в части удаления индексов. See section <A HREF="manual.ru_Reference.html#ALTER_TABLE">6.5.4  Синтаксис оператора <code>ALTER TABLE</code></A>.

</P>


<H2><A NAME="Basic_User_Commands" HREF="manual.ru_toc.html#Basic_User_Commands">6.6  Основные команды пользовательских программ MySQL</A></H2>



<H3><A NAME="USE" HREF="manual.ru_toc.html#USE">6.6.1  Синтаксис команды <code>USE</code></A></H3>

<P>
<A NAME="IDX1446"></A>

</P>

<pre>
USE db_name
</pre>

<P>
Команда <code>USE db_name</code> предписывает MySQL использовать базу данных с именем
<code>db_name</code> в последующих запросах по умолчанию. Указанная база данных
остается в этом состоянии до конца данного сеанса или пока не будет выдана
еще одна команда <code>USE</code>:

</P>

<pre>
mysql&#62; USE db1;
mysql&#62; SELECT COUNT(*) FROM mytable; # selects from db1.mytable
mysql&#62; USE db2;
mysql&#62; SELECT COUNT(*) FROM mytable; # selects from db2.mytable
</pre>

<P>
То обстоятельство, что отдельная база данных посредством команды <code>USE</code>
выбирается как используемая в текущий момент по умолчанию, не является
препятствием для доступа к таблицам других баз данных. Следующий пример
иллюстрирует получение доступа к таблице <code>author</code> базы данных <code>db1</code> и к
таблице <code>editor</code> базы данных <code>db2</code>:

</P>

<pre>
mysql&#62; USE db1;
mysql&#62; SELECT author_name,editor_name FROM author,db2.editor
        WHERE author.editor_id = db2.editor.editor_id;
</pre>

<P>
<A NAME="IDX1447"></A>
Наличие команды <code>USE</code> обеспечивает совместимость с Sybase.

</P>


<H3><A NAME="DESCRIBE" HREF="manual.ru_toc.html#DESCRIBE">6.6.2  Синтаксис команды <code>DESCRIBE</code> (Получение информации о столбцах)</A></H3>

<P>
<A NAME="IDX1448"></A>
<A NAME="IDX1449"></A>

</P>

<pre>
{DESCRIBE | DESC} tbl_name [col_name | wild]
</pre>

<P>
Команда <code>DESCRIBE</code> представляет собой сокращенный вариант команды <code>SHOW
COLUMNS FROM</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_DATABASE_INFO">4.5.6.1  Получение информации по базам данных, таблицам, столбцам и индексам</A>.

</P>
<P>
Команда <code>DESCRIBE</code> предоставляет информацию о столбцах таблицы. Параметр
<code>col_name</code> может содержать имя столбца или строки, включающей такие
групповые символы SQL, как <samp>`%'</samp> и <samp>`_'</samp> (шаблонные символы, позволяющие
получить информацию о всех подходящих столбцах). В кавычки брать строку не нужно. 

</P>
<P>
Следует отметить, что типы столбцов в полученном описании могут отличаться
от ожидаемых, первоначально заданных командой <code>CREATE TABLE</code> при создании
таблицы, поскольку MySQL иногда изменяет типы столбцов. See section <A HREF="manual.ru_Reference.html#Silent_column_changes">6.5.3.1  Молчаливые изменения определений столбцов</A>.

</P>
<P>
<A NAME="IDX1450"></A>
Данная команда обеспечивает совместимость с Oracle.

</P>
<P>
Команда <code>SHOW</code> предоставляет аналогичную информацию.
See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW">4.5.6  Синтаксис команды <code>SHOW</code></A>.

</P>


<H2><A NAME="Transactional_Commands" HREF="manual.ru_toc.html#Transactional_Commands">6.7  Команды управления транзакциями и блокировками в MySQL</A></H2>

<P>
 


<H3><A NAME="COMMIT" HREF="manual.ru_toc.html#COMMIT">6.7.1  Синтаксис команд <code>BEGIN/COMMIT/ROLLBACK</code></A></H3>

<P>
<A NAME="IDX1451"></A>
<A NAME="IDX1452"></A>
<A NAME="IDX1453"></A>
<A NAME="IDX1454"></A>

</P>
<P>
По умолчанию MySQL работает в режиме <code>autocommit</code>. Это означает, что при
выполнении обновления данных MySQL будет сразу записывать обновленные
данные на диск.

</P>
<P>
При использовании таблиц, поддерживающих транзакции (таких как <code>InnoDB</code>,
<code>BDB</code>), в  MySQL  можно отключить режим autocommit при помощи следующей
команды:

</P>

<pre>
SET AUTOCOMMIT=0
</pre>

<P>
После этого необходимо применить команду <code>COMMIT</code> для записи изменений на
диск или команду <code>ROLLBACK</code>, которая позволяет игнорировать изменения,
произведенные с начала данной транзакции.

</P>
<P>
Если необходимо переключиться из режима <code>AUTOCOMMIT</code> только для выполнения
одной последовательности команд, то для этого можно использовать команду <code>START TRANSACTION</code>
или <code>BEGIN</code> или <code>BEGIN WORK</code>:

</P>

<pre>
START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summmary=@A WHERE type=1;
COMMIT;
</pre>

<P>
<code>START TRANSACTION</code> была добавлена в MySQL 4.0.11. Это - рекомендованный
способ открыть транзакцию, в соответствии с синтаксисом ANSI SQL. 

</P>
<P>
Отметим, что при использовании таблиц, не поддерживающих транзакции,
изменения будут записаны сразу же, независимо от статуса режима
<code>autocommit</code>.

</P>
<P>
При выполнении команды <code>ROLLBACK</code> после обновления таблицы, не
поддерживающей транзакции, пользователь получит ошибку
(<code>ER_WARNING_NOT_COMPLETE_ROLLBACK</code>) в виде предупреждения. Все таблицы,
поддерживающие транзакции, будут перезаписаны, но ни одна таблица, не
поддерживающая транзакции, не будет изменена.

</P>
<P>
При выполнении команд <code>START TRANSACTION</code> или <code>SET AUTOCOMMIT=0</code> необходимо использовать
двоичный журнал MySQL для резервных копий вместо более старого
журнала записи изменений. Транзакции сохраняются в двоичном системном
журнале как одна порция данных (перед операцией <code>COMMIT</code>), чтобы
гарантировать, что транзакции, по которым происходит откат, не
записываются. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Binary_log">4.9.4  Бинарный журнал обновлений</A>.

</P>
<P>
Следующие команды автоматически завершают транзакцию (как если бы перед
выполнением данной команды была сделана операция <code>COMMIT</code> ):

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Команда</strong> </TD><TD> <strong>Команда</strong> </TD><TD> <strong>Команда</strong>
</TD></TR>
<TR><TD><code>ALTER TABLE</code> </TD><TD> <code>BEGIN</code> </TD><TD> <code>CREATE INDEX</code>
</TD></TR>
<TR><TD><code>DROP DATABASE</code> </TD><TD> <code>DROP TABLE</code> </TD><TD> <code>RENAME TABLE</code>
</TD></TR>
<TR><TD><code>TRUNCATE</code> </TD><TD> </TD><TD> 
</TD></TR>
</TABLE>

<P>
Уровень изоляции для транзакций можно изменить с помощью команды <code>SET 
TRANSACTION ISOLATION LEVEL ...</code>. See section <A HREF="manual.ru_Reference.html#SET_TRANSACTION">6.7.3  Синтаксис команды <code>SET TRANSACTION</code></A>.

</P>


<H3><A NAME="LOCK_TABLES" HREF="manual.ru_toc.html#LOCK_TABLES">6.7.2  Синтаксис команд <code>LOCK TABLES/UNLOCK TABLES</code></A></H3>

<P>
<A NAME="IDX1455"></A>
<A NAME="IDX1456"></A>

</P>

<pre>
LOCK TABLES tbl_name [AS alias] {READ [LOCAL] | [LOW_PRIORITY] WRITE}
            [, tbl_name [AS alias] {READ [LOCAL] | [LOW_PRIORITY] WRITE} ...]
...
UNLOCK TABLES
</pre>

<P>
Команда <code>LOCK TABLES</code> блокирует указанные в ней таблицы для данного потока.
Команда <code>UNLOCK TABLES</code> снимает любые блокировки, удерживаемые данным
потоком. Все таблицы, заблокированные текущим потоком, автоматически
разблокируются при появлении в потоке иной команды <code>LOCK TABLES</code> или при
прекращении соединения с сервером.

</P>
<P>
Чтобы использовать команду <code>LOCK TABLES</code> в MySQL 4.0.2, необходимо иметь
глобальные привилегии <code>LOCK TABLES</code> и <code>SELECT</code> для заданных таблиц. В MySQL
3.23 для этого необходимы привилегии <code>SELECT</code>, <code>INSERT</code>, <code>DELETE</code> и <code>UPDATE</code> для
рассматриваемых таблиц.

</P>
<P>
Основные преимущества использования команды <code>LOCK TABLES</code> состоят в том,
что она позволяет осуществлять эмуляцию транзакций или получить более
высокую скорость при обновлении таблиц. Ниже это разъясняется более
подробно.

</P>
<P>
Если в потоке возникает блокировка операции <code>READ</code> для некоторой таблицы, то
только этот поток (и все другие потоки) могут читать из данной таблицы.
Если для некоторой таблицы в потоке существует блокировка <code>WRITE</code>, тогда
только поток, содержащий блокировку, может осуществлять операции чтения (<code>READ</code>) и
записи (<code>WRITE</code>) на данной таблице. Остальные потоки блокируются.

</P>

<P>
Различие между <code>READ LOCAL</code> и <code>READ</code> состоит в том, что <code>READ LOCAL</code> позволяет
выполнять неконфликтующие команды <code>INSERT</code> во время существования
блокировки. Однако эту команду нельзя использовать для работы с файлами
базы данных вне сервера MySQL во время данной блокировки.

</P>
<P>
При использовании команды <code>LOCK TABLES</code> необходимо блокировать все таблицы,
которые предполагается использовать в последующих запросах, употребляя при
этом те же самые псевдонимы, которые будут в запросах! Если таблица
упоминается в запросе несколько раз (с псевдонимами), необходимо
заблокировать каждый псевдоним!

</P>
<P>
Блокировка <code>WRITE</code> обычно имеет более высокий приоритет, чем блокировка <code>READ</code>,
чтобы гарантировать, что изменения обрабатываются так быстро, как
возможно. Это означает, что если один поток получает блокировку <code>READ</code> и
затем иной поток запрашивает блокировку <code>WRITE</code>, последующие запросы на
блокировку <code>READ</code> будут ожидать, пока поток <code>WRITE</code> не получит блокировку и не
снимет ее. Можно использовать блокировки <code>LOW_PRIORITY WRITE</code>, позволяющие
другим потокам получать блокировки <code>READ</code> в то время, как основной поток
находится в состоянии ожидания блокировки <code>WRITE</code>. Блокировки <code>LOW_PRIORITY</code> 
<code>WRITE</code> могут быть использованы только если есть уверенность, что в конечном
итоге будет период времени, когда ни один из потоков не будет иметь
блокировки <code>READ</code>.

</P>
<P>
Команда <code>LOCK TABLES</code> работает следующим образом:

</P>

<ol>
<LI>

Сортирует все блокируемые таблицы в порядке, который задан внутренним
образом, т.е. ``зашит'' (с точки зрения пользователя этот порядок не
задан).

<LI>

Блокировка <code>WRITE</code> ставится перед блокировкой  <code>READ</code>, если таблицы
блокируются с блокировками <code>READ</code> и <code>WRITE</code>.

<LI>

Блокирует одну таблицу единовременно, пока поток не получит все
блокировки.
</ol>

<P>
Описанный порядок действий гарантирует, что блокирование таблицы не
создает тупиковой ситуации. Однако есть и другие вещи, о которых
необходимо отдавать себе отчет при работе по описанной схеме:

</P>
<P>
Использование для таблицы блокировки <code>LOW_PRIORITY WRITE</code> всего лишь
означает, что MySQL будет выполнять данную конкретную блокировку, пока не
появится поток, запрашивающий блокировку <code>READ</code>. Если поток получил
блокировку <code>WRITE</code> и находится в ожидании блокировки следующей таблицы из
списка блокируемых таблиц, то все остальные потоки будут ожидать, пока
блокировка <code>WRITE</code> не будет снята. Если это представляет серьезную проблему
для вашего приложения, то следует подумать о преобразовании имеющихся
таблиц в таблицы иного вида, поддерживающие транзакции.

</P>
<P>
Поток, ожидающий блокировку таблицы, можно безопасно уничтожить с помощью
команды <code>KILL</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#KILL">4.5.5  Синтаксис команды <code>KILL</code></A>.

</P>
<P>
Учтите, что нельзя блокировать любые таблицы, используемые совместно с
оператором <code>INSERT DELAYED</code>, поскольку в этом случае команда <code>INSERT</code>
выполняется как отдельный поток.

</P>
<P>
Обычно нет необходимости блокировать таблицы, поскольку все единичные
команды <code>UPDATE</code> являются неделимыми; никакой другой поток не может
взаимодействовать с какой-либо SQL-командой, выполняемой в данное время.
Однако в некоторых случаях предпочтительно тем или иным образом
осуществлять блокировку таблиц:

</P>

<ul>
<LI>

Если предполагается выполнить большое количество операций на группе
взаимосвязанных таблиц, то быстрее всего это сделать, блокировав
таблицы, которые вы собираетесь использовать. Конечно, это имеет свою
обратную сторону, поскольку никакой другой поток управления не может
обновить таблицу с блокировкой <code>READ</code> или прочитать таблицу с
блокировкой <code>WRITE</code>. При блокировке <code>LOCK TABLES</code> операции выполняются
быстрее потому, что в этом случае MySQL не производит запись на диск
содержимого кэша ключей для заблокированных таблиц, пока не будет
вызвана команда <code>UNLOCK TABLES</code> (обычно кэш ключей записывается на диск
после каждой SQL-команды). Применение <code>LOCK TABLES</code> увеличивает
скорость записи/обновления/удаления в таблицах типа <code>MyISAM</code>.

<LI>

Если вы используете таблицы, не поддерживающие транзакций, то при использовании
программы обработки таблиц необходимо применять команду <code>LOCK TABLES</code>
для гарантии, что никакой другой поток не вклинился между операциями
<code>SELECT</code> и <code>UPDATE</code>. Ниже показан пример, требующий использования <code>LOCK 
TABLES</code> для успешного выполнения операций:


<pre>
mysql&#62; LOCK TABLES trans READ, customer WRITE;
mysql&#62; SELECT SUM(value) FROM trans WHERE customer_id=some_id;
mysql&#62; UPDATE customer SET total_value=sum_from_previous_statement
        WHERE customer_id=some_id;
mysql&#62; UNLOCK TABLES;
</pre>

Без использования <code>LOCK TABLES</code> существует вероятность того, что какой-либо
иной поток управления может вставить новую строку в таблицу <code>trans</code> между
выполнением операций <code>SELECT</code> и <code>UPDATE</code>.
</ul>

<P>
Используя пошаговые обновления (<code>UPDATE customer SET 
value=value+new_value</code>) или функцию <code>LAST_INSERT_ID()</code>, применения команды
<code>LOCK TABLES</code>  во многих случаях можно избежать.

</P>
<P>
Некоторые проблемы можно также решить путем применения блокирующих функций
на уровне пользователя <code>GET_LOCK()</code> и <code>RELEASE_LOCK()</code>. Эти блоки хранятся в
хэш-таблице на сервере и, чтобы обеспечить высокую скорость, реализованы в
виде <code>pthread_mutex_lock()</code> и <code>pthread_mutex_unlock()</code>.
See section <A HREF="manual.ru_Reference.html#Miscellaneous_functions">6.3.6.2  Разные функции</A>.

</P>
<P>
Чтобы получить дополнительную информацию о механизме блокировки,
обращайтесь к разделу section <A HREF="manual.ru_MySQL_Optimisation.html#Internal_locking">5.3.1  Как MySQL блокирует таблицы</A>.

</P>
<P>
Можно блокировать все таблицы во всех базах данных блокировкой <code>READ</code> с
помощью команды <code>FLUSH TABLES WITH READ LOCK</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#FLUSH">4.5.3  Синтаксис команды <code>FLUSH</code></A>.
Это очень удобно для получения резервной копии файловой системы, подобной
Veritas, при работе в которой могут потребоваться заблаговременные копии
памяти.

</P>
<P>
Примечание: Команда <code>LOCK TABLES</code> не сохраняет транзакции и автоматически
фиксирует все активные транзакции перед попыткой блокировать таблицы.

</P>


<H3><A NAME="SET_TRANSACTION" HREF="manual.ru_toc.html#SET_TRANSACTION">6.7.3  Синтаксис команды <code>SET TRANSACTION</code></A></H3>

<P>
<A NAME="IDX1457"></A>
<A NAME="IDX1458"></A>

</P>

<pre>
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
{ READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
</pre>

<P>
Устанавливает уровень изоляции транзакций.

</P>
<P>
По умолчанию уровень изоляции устанавливается для последующей (не
начальной) транзакции. При использовании ключевого слова <code>GLOBAL</code> данная
команда устанавливает уровень изоляции по умолчанию глобально для всех
новых соединений, созданных от этого момента. Однако для того чтобы
выполнить данную команду, необходима привилегия <code>SUPER</code>. При использовании
ключевого слова <code>SESSION</code> устанавливается уровень изоляции по умолчанию для
всех будущих транзакций, выполняемых в текущем соединении.

</P>
<P>
Установить глобальный уровень изоляции по умолчанию для утилиты <code>mysqld</code>
можно с помощью опции <code>--transaction-isolation=...</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>.

</P>


<H2><A NAME="Fulltext_Search" HREF="manual.ru_toc.html#Fulltext_Search">6.8  Полнотекстовый поиск в MySQL</A></H2>

<P>
<A NAME="IDX1459"></A>
<A NAME="IDX1460"></A>
<A NAME="IDX1461"></A>

</P>
<P>
С 3.23.23 MySQL поддерживает
полнотекстовый поиск и индексацию. Полнотекстовые индексы в MySQL обозначаются
как индексы типа <code>FULLTEXT</code>. Эти индексы могут быть созданы в таблицах
MyISAM в столбцах <code>VARCHAR</code> и <code>TEXT</code> во время создания таблицы
командой <code>CREATE TABLE</code> или добавлены позже с помощью команд <code>ALTER
TABLE</code> или <code>CREATE INDEX</code>.  Загрузка больших массивов данных в таблицу
будет происходить намного быстрее, если таблица не содержит индекс
<code>FULLTEXT</code>, который затем создается командой <code>ALTER TABLE</code> (или
<code>CREATE INDEX</code>). Загрузка данных в таблицу, уже имеющую индекс
<code>FULLTEXT</code>, будет более медленной.

</P>
<P>
Полнотекстовый поиск выполняется с помощью функции <code>MATCH()</code>.

</P>

<pre>
mysql&#62; CREATE TABLE articles (
        id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
        title VARCHAR(200),
        body TEXT,
        FULLTEXT (title,body)
        );
Query OK, 0 rows affected (0.00 sec)

mysql&#62; INSERT INTO articles VALUES
    -&#62; (NULL,'MySQL Tutorial', 'DBMS stands for DataBase ...'),
    -&#62; (NULL,'How To Use MySQL Efficiently', 'After you went through a ...'),
    -&#62; (NULL,'Optimising MySQL','In this tutorial we will show ...'),
    -&#62; (NULL,'1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
    -&#62; (NULL,'MySQL vs. YourSQL', 'In the following database comparison ...'),
    -&#62; (NULL,'MySQL Security', 'When configured properly, MySQL ...');
Query OK, 6 rows affected (0.00 sec)
Records: 6 Duplicates: 0 Warnings: 0

mysql&#62; SELECT * FROM articles
        WHERE MATCH (title,body) AGAINST ('database');
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
+----+-------------------+------------------------------------------+
2 rows in set (0.00 sec)
</pre>

<P>
Функция <code>MATCH()</code> выполняет поиск в естественном языке, сравнивая строку с
содержимым текста (совокупность одного или более столбцов, включенных в
индекс <code>FULLTEXT</code>). Строка поиска задается как аргумент в выражении
<code>AGAINST()</code>. Поиск выполняется без учета регистра символов. Для каждой
строки столбца в заданной таблице команда <code>MATCH()</code> возвращает величину
релевантности, т.е. степень сходства между строкой поиска и текстом,
содержащимся в данной строке указанного в списке оператора <code>MATCH()</code> столбца.

</P>
<P>
Когда команда <code>MATCH()</code> используется в выражении <code>WHERE</code> (см. пример выше),
возвращенные строки столбцов автоматически сортируются, начиная с наиболее
релевантных. Величина релевантности представляет собой неотрицательное
число с плавающей точкой. Релевантность вычисляется на основе количества
слов в данной строке столбца, количества уникальных слов в этой строке,
общего количества слов в тексте и числа документов (строк), содержащих
отдельное слово.

</P>
<P>
Поиск возможен также в логическом режиме, это объясняется ниже в данном
разделе.

</P>
<P>
Предыдущий пример представляет собой общую иллюстрацию использования
функции <code>MATCH()</code>. Строки возвращаются в порядке уменьшения релевантности.

</P>
<P>
В следующем примере показано, как извлекать величины релевантности в явном
виде. В случае отсутствия выражений <code>WHERE</code> и <code>ORDER BY</code> возвращаемые строки
не упорядочиваются.

</P>

<pre>
mysql&#62; SELECT id,MATCH (title,body) AGAINST ('Tutorial') FROM articles;
+----+-----------------------------------------+
| id | MATCH (title,body) AGAINST ('Tutorial') |
+----+-----------------------------------------+
|  1 |                        0.64840710366884 |
|  2 |                                       0 |
|  3 |                        0.66266459031789 |
|  4 |                                       0 |
|  5 |                                       0 |
|  6 |                                       0 |
+----+-----------------------------------------+
6 rows in set (0.00 sec)
</pre>

<P>
Следующий пример - более сложный. Запрос возвращает значение релевантности
и, кроме того, сортирует строки в порядке убывания релевантности. Чтобы
получить такой результат, необходимо указать <code>MATCH()</code> дважды. Это не
приведет к дополнительным издержкам, так как оптимизатор MySQL учтет, что
эти два вызова <code>MATCH()</code> идентичны, и запустит код полнотекстового поиска
только однажды.

</P>


<pre>
mysql&#62; SELECT id, body, MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root') AS score
    -&#62; FROM articles WHERE MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root');
+----+-------------------------------------+-----------------+
| id | body                                | score           |
+----+-------------------------------------+-----------------+
|  4 | 1. Never run mysqld as root. 2. ... | 1.5055546709332 |
|  6 | When configured properly, MySQL ... |   1.31140957288 |
+----+-------------------------------------+-----------------+
2 rows in set (0.00 sec)
</pre>

<P>
Для разбивки текста на слова MySQL использует очень простой синтаксический
анализатор. ``Словом'' является любая последовательность символов,
состоящая из букв, чисел, знаков <samp>`''</samp> и <samp>`_'</samp>. Любое ``слово'',
присутствующее в стоп-списке (stopword) или просто слишком короткое (3
символа или меньше), игнорируется.

</P>
<P>
Каждое правильное слово в наборе проверяемых текстов и в данном запросе
оценивается в соответствии с его важностью в этом запросе или наборе
текстов. Таким образом, слово, присутствующее во многих документах, будет
иметь меньший вес (и даже, возможно, нулевой), как имеющее более низкое
смысловое значение в данном конкретном наборе текстов. С другой стороны,
редко встречающееся слово получит более высокий вес. Затем полученные
значения весов слов объединяются для вычисления релевантности данной
строки столбца.

</P>
<P>
Описанная техника подсчета лучше всего работает для больших наборов
текстов (фактически она именно для этого тщательно настраивалась). Для
очень малых таблиц распределение слов не отражает адекватно их смысловое
значение, и данная модель иногда может выдавать некорректные результаты.

</P>

<pre>
mysql&#62; SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('MySQL');
Empty set (0.00 sec)
</pre>

<P>
Поиск по слову ``MySQL'' в предыдущем примере не приводит к каким-либо
результатам, так как это слово присутствует более чем в половине строк. По
существу, данное слово целесообразно трактовать как стоп-слово (т.е.
слово с нулевой смысловой ценностью). Это наиболее приемлемое решение -
запрос на естественном языке не должен возвращать каждую вторую строку из
таблицы размером 1Гб.

</P>
<P>
Маловероятно, что слово, встречающееся в половине строк таблицы,
определяет местонахождение релевантных документов. На самом деле, наиболее
вероятно, что будет найдено много не относящихся к делу документов.
Общеизвестно, что такое случается слишком часто при попытке найти что-либо
в Интернет с помощью поисковых машин. Именно на этом основании подобным
строкам должно быть назначено низкое смысловое значение в данном
конкретном наборе данных.

</P>
<P>
В MySQL 4.0.1 возможен полнотекстовый поиск также и в логическом режиме с
использованием модификатора <code>IN BOOLEAN MODE</code>.

</P>

<pre>
mysql&#62; SELECT * FROM articles WHERE MATCH (title,body)
    -&#62;     AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);
+----+------------------------------+-------------------------------------+
| id | title                        | body                                |
+----+------------------------------+-------------------------------------+
|  1 | MySQL Tutorial               | DBMS stands for DataBase ...        |
|  2 | How To Use MySQL Efficiently | After you went through a ...        |
|  3 | Optimising MySQL             | In this tutorial we will show ...   |
|  4 | 1001 MySQL Tricks            | 1. Never run mysqld as root. 2. ... |
|  6 | MySQL Security               | When configured properly, MySQL ... |
+----+------------------------------+-------------------------------------+
</pre>

<P>
Данный запрос вывел все строки, содержащие слово ``MySQL'' (заметьте,
50-процентная пороговая величина здесь не используется), но эти строки не
содержат слова ``YourSQL''. Следует отметить, что логический режим поиска
не сортирует автоматически строки в порядке уменьшения релевантности. Это
видно по результату предыдущего запроса, где строка с наиболее высокой
релевантностью (содержащая слово ``MySQL'' дважды) помещена последней, а
не первой. Логический режим полнотекстового поиска может работать даже без
индекса <code>FULLTEXT</code>, хотя и очень медленно.

</P>
<P>
В логическом режиме полнотекстового поиска поддерживаются следующие
операторы:

</P>
<DL COMPACT>

<DT><code>+</code>
<DD>
Предшествующий слову знак ``плюс'' показывает, что это слово должно
присутствовать в каждой возвращенной строке.

<DT><code>-</code>
<DD>
Предшествующий слову знак ``минус'' означает, что это слово не должно
присутствовать в какой-либо возвращенной строке.

<DT><code></code>
<DD>
По умолчанию (если ни плюс, ни минус не указаны) данное слово является не
обязательным, но содержащие его строки будут оцениваться более высоко. Это
имитирует поведение команды <code>MATCH() ... AGAINST()</code> без модификатора <code>IN
BOOLEAN MODE</code>.

<DT><code>&#60; &#62;</code>
<DD>
Эти два оператора используются для того, чтобы изменить вклад слова в
величину релевантности, которое приписывается строке. Оператор <code>&#60;</code> уменьшает
этот вклад, а оператор <code>&#62;</code> - увеличивает его. См. пример ниже.

<DT><code>( )</code>
<DD>
Круглые скобки группируют слова в подвыражения.

<DT><code>~</code>
<DD>
Предшествующий слову знак ``тильда'' воздействует как оператор отрицания,
обуславливая негативный вклад данного слова в релевантность строки. Им
отмечают нежелательные слова. Строка, содержащая такое слово, будет
оценена ниже других, но не будет исключена совершенно, как в случае
оператора - ``минус''.

<DT><code>*</code>
<DD>
Звездочка является оператором усечения. В отличие от остальных операторов,
она должна добавляться в конце слова, а не в начале.

<DT><code>"</code>
<DD>
Фраза, заключенная в двойные кавычки, соответствует только строкам,
содержащим эту фразу, написанную буквально.
</DL>

<P>
Ниже приведен ряд примеров:

</P>
<DL COMPACT>

<DT><code>apple banana</code>
<DD>
находит строки, содержащие по меньшей мере одно из этих слов.

<DT><code>+apple +juice</code>
<DD>
... оба слова.

<DT><code>+apple macintosh</code>
<DD>
... слово ``apple'', но ранг строки выше, если она также содержит слово
``macintosh''.

<DT><code>+apple -macintosh</code>
<DD>
... слово ``apple'',  но не ``macintosh''.

<DT><code>+apple +(&#62;pie &#60;strudel)</code>
<DD>
... ``apple'' и ``pie'', или ``apple'' и ``strudel'' (в любом порядке), но
ранг ``apple pie'' выше, чем ``apple strudel''.

<DT><code>apple*</code>
<DD>
... ``apple'', ``apples'', ``applesauce'', и ``applet''.

<DT><code>"some words"</code>
<DD>
... ``some words of wisdom'', но не ``some noise words''.
</DL>



<H3><A NAME="Fulltext_Restrictions" HREF="manual.ru_toc.html#Fulltext_Restrictions">6.8.1  Ограничения для полнотекстового поиска</A></H3>


<ul>
<LI>

Все параметры функции <code>MATCH()</code> должны быть столбцами одной и той же
таблицы, т.е. частью одного и того же индекса <code>FULLTEXT</code>, за исключением
работы <code>MATCH()</code> в режиме <code>IN BOOLEAN MODE</code>.

<LI>

Список столбцов в команде <code>MATCH()</code> должен точно соответствовать списку
столбцов в определении индекса <code>FULLTEXT</code> для этой таблицы, за
исключением работы данной функции <code>MATCH()</code> в режиме <code>IN BOOLEAN MODE</code>.

<LI>

Аргумент в выражении <code>AGAINST()</code> должен быть неизменяемой строкой.
</ul>



<H3><A NAME="Fulltext_Fine-tuning" HREF="manual.ru_toc.html#Fulltext_Fine-tuning">6.8.2  Тонкая настройка полнотекстового поиска в MySQL</A></H3>

<P>
К сожалению, полнотекстовый поиск имеет еще мало настраиваемых
пользователем параметров, хотя для последующих модификаций добавление
некоторого их количества является очень важной задачей (TODO). Однако при
наличии исходного дистрибутива MySQL (see section <A HREF="manual.ru_Installing.html#Installing_source">2.3  Установка исходного дистрибутива MySQL</A>) имеется больше возможностей управлять полнотекстовым
поиском.

</P>
<P>
Следует отметить, что полнотекстовый поиск был тщательно настроен так,
чтобы обеспечить наилучшую эффективность выполнения данной операции. Если
изменить установленный по умолчанию режим работы, то в большинстве случаев
результаты поиска станут только хуже. Поэтому не вносите какие-либо правки
в код MySQL, если не знаете наверняка, что вы делаете!

</P>

<ul>
Минимальная длина подлежащих индексации слов определяется в MySQL
переменной <code>ft_min_word_len</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>). Установите
желаемую величину этой переменной и создайте заново индексы <code>FULLTEXT</code>
(эта переменная доступна только в версии MySQL 4.0).

<LI>

Список стоп-слов может быть загружен с файла, указанного в переменной
<code>ft_stopword_file</code>.  See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>.
После модификации стоп-листа перестройте ваши полнотекствые индексы. 
(Эта переменная введена в MySQL 4.0.10)

<LI>

50-процентный порог определяется выбранной конкретной схемой
присваивания весовых коэффициентов. Чтобы отменить ее, измените
следующую строку в <tt>`myisam/ftdefs.h'</tt>:


<pre>
#define GWS_IN_USE GWS_PROB
</pre>

на:


<pre>
#define GWS_IN_USE GWS_FREQ
</pre>

Затем перекомпилируйте MySQL. Создавать заново индексы в этом случае нет
необходимости. 

Примечание: таким образом вы существенно ухудшите
способность MySQL продуцировать адекватные величины релевантности для
функции <code>MATCH()</code>. Если действительно необходим поиск для таких
общеупотребительных слов, то было бы лучше использовать вместо этого поиск
в режиме <code>IN BOOLEAN MODE</code>, при котором не предусмотрен 50-процентный
порог.

<LI>

Иногда отладчик поисковой машины желает изменить операторы,
используемые для логического поиска по полному тексту. Эти операторы
определяются переменной <code>ft_boolean_syntax</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>.
Однако эта переменная доступна только для чтения, ее значение
устанавливается в <tt>`myisam/ft_static.c'</tt>.
</ul>

<P>
Наиболее простым способом перестроить полнотекстовый индекс в тех случаях,
когда это нужно - это вот такая команда: 

</P>

<pre>
mysql&#62; REPAIR TABLE tbl_name QUICK;
</pre>



<H3><A NAME="Fulltext_TODO" HREF="manual.ru_toc.html#Fulltext_TODO">6.8.3  Предстоящие доработки по полнотекстовому поиску</A></H3>


<ul>
<LI>

Сделать все операции с индексом <code>FULLTEXT</code>  более быстрыми.

<LI>

Операторы схожести

<LI>

Поддержка для слов, тождественных индексам, - чтобы словами могли быть
любые строки, которые пользователь пожелает трактовать как слова,
например "C++", "AS/400", "TCP/IP" и т.д.

<LI>

Поддержка полнотекстового поиска в таблицах типа <code>MERGE</code>.

<LI>

Поддержка многобайтовых наборов символов.

<LI>

Сделать список стоп-слов (``stopword'') зависящим от языка данных.

<LI>

Стемминг (в зависимости от языка данных, конечно).

<LI>

Обобщенный синтаксический пре-анализатор с определяемым пользователем функциониями (UDF).

<LI>

Сделать данную модель поиска более гибкой (путем добавления ряда
регулируемых параметров к <code>FULLTEXT</code> в <code>CREATE/ALTER TABLE</code>).
</ul>



<H2><A NAME="Query_Cache" HREF="manual.ru_toc.html#Query_Cache">6.9  Кэш запросов в MySQL</A></H2>

<P>
<A NAME="IDX1462"></A>
<A NAME="IDX1463"></A>

</P>
<P>
Начиная с версии 4.0.1 сервер MySQL снабжен кэшем запросов. В процессе
работы кэш запросов хранит текст запроса <code>SELECT</code> вместе с соответствующим
результатом, который посылался клиенту. При получении другого идентичного
запроса сервер извлечет результаты из кэша запросов, а не
анализировать и выполнять снова тот же самый запрос.

</P>
<P>
Кэш запросов особенно полезен в средах, где (некоторые) таблицы не
обновляются слишком часто и присутствует много идентичных запросов. Эта
ситуация типична для многих веб-серверов с обширным активным
информационным наполнением.

</P>
<P>
Ниже приведены некоторые данные функционирования для кэша запросов (они
получены во время работы тестового комплекта MySQL под Linux Alpha 2x500
МГц с 2Гб ОЗУ и 64-мегабайтным кэшем запросов):

</P>

<ul>

<LI>

Если все производимые запросы являются простыми (такими как выбор
строки из таблицы с одной строкой), но различаются настолько, что не
могут быть кэшированы, непроизводительные затраты при активном
состоянии кэша запросов составляют 13%. Это можно было бы
рассматривать как сценарий наиболее неблагоприятного варианта. Однако
в реальной жизни запросы более сложны, чем приведенный простой пример,
так что непроизводительные затраты обычно значительно ниже.

<LI>

Поиск строки в таблице с одной строкой происходит на 238% быстрее.
Можно рассматривать эту величину, как близкую к минимальному
увеличению быстродействия, ожидаемого при кэшировании запроса.

<LI>

Если вы хотите запретить кеш запросов, установите переменную
<code>query_cache_size</code> в <code>0</code>. Запрещение кеша запросов не создает лишних
перегрузок для сервера. Вы можете целиком исключить код кеша запросов из
сервера путем указания при компиляции опции <code>--without-query-cache</code> в <code>configure</code>. 
</ul>



<H3><A NAME="Query_Cache_How" HREF="manual.ru_toc.html#Query_Cache_How">6.9.1  Как работает кэширование запросов</A></H3>

<P>
Перед синтаксическим анализом запросы сравниваются, поэтому запросы

</P>

<pre>
SELECT * FROM tbl_name
</pre>

<P>
и

</P>

<pre>
Select * from tbl_name
</pre>

<P>
для кэша запросов рассматриваются как различные, поскольку они должны быть
абсолютно одинаковыми (байт в байт), чтобы рассматриваться как идентичные.
Помимо этого, запрос может трактоваться как отличающийся, если, например,
какой-либо клиент использует протокол соединения нового формата или иной
набор символов, чем другой клиент.

</P>
<P>
Запросы, использующие различные базы данных, различные версии протоколов
или различные наборы символов по умолчанию, рассматриваются как различные
и кэшируются раздельно.

</P>
<P>
Рассматриваемый кэш надежно работает для запросов вида <code>SELECT CALC_ROWS
...</code> и <code>SELECT FOUND_ROWS() ...</code>, так как число найденных строк всегда
хранится в кэше.

</P>
<P>
Если результат запроса вернулся из кеша запросов, тогда статусная переменная
<code>Com_select</code> не будет увеличена, но вместо нее будет увеличена <code>Qcache_hits</code>.
See section <A HREF="manual.ru_Reference.html#Query_Cache_Status_and_Maintenance">6.9.4  Статус и поддержка кэша запросов</A>.

</P>
<P>
При изменениях таблицы (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>,
<code>TRUNCATE</code>, <code>ALTER</code> или <code>DROP TABLE|DATABASE</code>), все кэшированные
запросы, использовавшие данную таблицу (возможно, через таблицу
<code>MRG_MyISAM</code>!), становятся недействительными и удаляются из кэша.

</P>
<P>
Если изменения были произведены в поддерживающих транзакции таблицах вида
<code>InnoDB</code>, то все кэшированные запросы становятся недействительными при
выполнении команды <code>COMMIT</code>.

</P>
<P>
Запрос не будет кэширован, если содержит одну из приведенных ниже функций:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Функция</strong>
 </TD><TD> <strong>Функция</strong>
 </TD><TD> <strong>Функция</strong>
</TD></TR>
<TR><TD><code>Определяемые пользователем функции (UDF)</code>
 </TD><TD> <code>CONNECTION_ID</code>
 </TD><TD> <code>FOUND_ROWS</code>
</TD></TR>
<TR><TD><code>GET_LOCK</code>
 </TD><TD> <code>RELEASE_LOCK</code>
 </TD><TD> <code>LOAD_FILE</code>
</TD></TR>
<TR><TD><code>MASTER_POS_WAIT</code>
 </TD><TD> <code>NOW</code>
 </TD><TD> <code>SYSDATE</code>
</TD></TR>
<TR><TD><code>CURRENT_TIMESTAMP</code>
 </TD><TD> <code>CURDATE</code>
 </TD><TD> <code>CURRENT_DATE</code>
</TD></TR>
<TR><TD><code>CURTIME</code>
 </TD><TD> <code>CURRENT_TIME</code>
 </TD><TD> <code>DATABASE</code>
</TD></TR>
<TR><TD><code>ENCRYPT</code> (с одним параметром)
 </TD><TD> <code>LAST_INSERT_ID</code>
 </TD><TD> <code>RAND</code>
</TD></TR>
<TR><TD><code>UNIX_TIMESTAMP</code> (без параметров)
 </TD><TD> <code>USER</code>
 </TD><TD> <code>BENCHMARK</code>
</TD></TR>
</TABLE>

<P>
Запрос также не будет кэширован, если он содержит переменные пользователя,
работает с системными таблицами <code>mysql</code>, 
или выражен в форме <code>SELECT ... IN SHARE MODE</code>,
<code>SELECT ... INTO OUTFILE ...</code>,
<code>SELECT ... INTO DUMPFILE ...</code> 
или в форме <code>SELECT * FROM 
AUTOINCREMENT_FIELD IS NULL</code> (для получения последнего ID - это для ODBC). 

</P>
<P>
Однако <code>FOUND ROWS()</code> возвратит правильную величину, даже если из кэша был
выбран предыдущий запрос.

</P>
<P>
В случае если запрос не использует таблиц, или использует временные таблицы,
или если пользователь обладает привилегиями уровня столбца на какую-либо из
задействованных таблиц, запрос не будет кеширован.

</P>
<P>
Перед выборкой запроса из кэша запросов MySQL проверит, обладает ли
пользователь привилегией <code>SELECT</code> для всех включенных баз данных и таблиц.
Если это не так, то результат кэширования не используется.

</P>


<H3><A NAME="Query_Cache_Configuration" HREF="manual.ru_toc.html#Query_Cache_Configuration">6.9.2  Конфигурация кэша запросов</A></H3>

<P>
Для кэша запросов в MySQL добавляется несколько системных переменных для
<code>mysqld</code>, которые могут быть установлены в конфигурационном файле или из
командной строки при запуске <code>mysqld</code>.

</P>

<ul>
<LI><code>query_cache_limit</code>

Не кэшировать результаты, большие, чем указано (по
умолчанию 1Мб).

<LI><code>query_cache_size</code>

Память, выделенная для хранения результатов старых
запросов. Если равно <code>0</code>, то кэширование запроса блокируется (по
умолчанию). Указывается в байтах.

<LI><code>query_cache_type</code>

Можно установить следующие (только
числовые) значения:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>0 </TD><TD> <code>OFF</code> (``ВЫКЛЮЧЕНО''), результаты не кэшировать и не извлекать
</TD></TR>
<TR><TD>1 </TD><TD> <code>ON</code> (``ВКЛЮЧЕНО''), кэшировать все результаты, за исключением запросов <code>SELECT SQL_NO_CACHE ...</code>
</TD></TR>
<TR><TD>2 </TD><TD> <code>DEMAND</code> (``ПО ТРЕБОВАНИЮ''), кэшировать только запросы <code>SELECT SQL_CACHE ...</code>
</TD></TR>
</TABLE>

</ul>

<P>
Внутри потока (соединения) можно изменить функционирование кэша запросов
по сравнению с установленным по умолчанию. Синтаксис следующий:

</P>

<pre>
QUERY_CACHE_TYPE = OFF | ON | DEMAND  
QUERY_CACHE_TYPE = 0   | 1  | 2
</pre>

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>0 или OFF </TD><TD> Результаты не кэшировать и не извлекать.
</TD></TR>
<TR><TD>1 или ON </TD><TD> Кэшировать все результаты за исключением запросов <code>SELECT SQL_NO_CACHE ...</code>
</TD></TR>
<TR><TD>2 или DEMAND </TD><TD> Кэшировать только запросы <code>SELECT SQL_CACHE ...</code>
</TD></TR>
</TABLE>



<H3><A NAME="Query_Cache_in_SELECT" HREF="manual.ru_toc.html#Query_Cache_in_SELECT">6.9.3  Параметры кэша запросов в запросе <code>SELECT</code></A></H3>

<P>
<A NAME="IDX1464"></A>
<A NAME="IDX1465"></A>

</P>
<P>
В запросе <code>SELECT</code> можно указывать две опции для кэша запросов:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD><code>SQL_CACHE</code> </TD><TD> Если <code>QUERY_CACHE_TYPE</code> имеет опцию <code>DEMAND</code>, позволяет запросу
кэшироваться. Если <code>QUERY_CACHE_TYPE</code> имеет опцию <code>ON</code>, является
состоянием по умолчанию. Если <code>QUERY_CACHE_TYPE</code> имеет опцию
<code>OFF</code>, ничего не делать.
</TD></TR>
<TR><TD><code>SQL_NO_CACHE</code> </TD><TD> Делает данный запрос некэшируемым, не разрешает хранить в кэше данный запрос.
</TD></TR>
</TABLE>



<H3><A NAME="Query_Cache_Status_and_Maintenance" HREF="manual.ru_toc.html#Query_Cache_Status_and_Maintenance">6.9.4  Статус и поддержка кэша запросов</A></H3>

<P>
С помощью команды <code>FLUSH QUERY CACHE</code> можно дефрагментировать кэш запросов
с целью лучшего использования его памяти. Эта команда не удалит ни одного
запроса из кэша. Команда <code>FLUSH TABLES</code> также записывает на диск содержимое
кэша запросов.

</P>
<P>
Команда <code>RESET QUERY CACHE</code> удаляет все результаты запросов из кэша
запросов.

</P>
<P>
Можно контролировать функционирование кэша запросов в <code>SHOW STATUS</code>:

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Переменная</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>Qcache_queries_in_cache </TD><TD> Количество запросов, зарегистрированных в кэше.
</TD></TR>
<TR><TD>Qcache_inserts </TD><TD> Количество запросов, добавленных в кэш.
</TD></TR>
<TR><TD>Qcache_hits </TD><TD> Количество результативных обращений в кэш.
</TD></TR>
<TR><TD>Qcache_lowmem_prunes </TD><TD> Количество запросов, удаленных из кеша по причине недостаточного количества памяти.
</TD></TR>
<TR><TD>Qcache_not_cached </TD><TD> Количество не кэшированных запросов (не подлежащих кэшированию или из-за установок QUERY_CACHE_TYPE).
</TD></TR>
<TR><TD>Qcache_free_memory </TD><TD> Величина свободной памяти для кэша запросов.
</TD></TR>
<TR><TD>Qcache_total_blocks </TD><TD> Общее количество блоков в кэше запросов.
</TD></TR>
<TR><TD>Qcache_free_blocks </TD><TD> Количество свободных блоков памяти в кэше запросов.
</TD></TR>
</TABLE>

<P>
Общее количество запросов = <code>Qcache_inserts + Qcache_hits +
Qcache_not_cached</code>.

</P>
<P>
Кэш запросов использует блоки переменной длины, так что параметры
<code>Qcache_total_blocks</code> и <code>Qcache_free_blocks</code> могут показывать фрагментацию
памяти кэша запросов. После команды <code>FLUSH QUERY CACHE</code> остается только
один (большой) свободный блок.

</P>
<P>
Примечание: каждый запрос нуждается как минимум в двух блоках (один для
текста данного запроса и один или больше - для результатов запроса). Для
каждой используемой в запросе таблицы также требуется один блок, но если
два или более запросов используют одну и ту же таблицу, требуется
выделение только одного блока.

</P>
<P>
Вы можете использовать переменную <code>Qcache_lowmem_prunes</code> для настройки
размера кеша запросов. В ней подсчитывается количество запросов, которые были
удалены из кеша для освобождения памяти под новые результаты запросов. Кеш
запросов использует стратегию <code>используется реже всего</code> (<code>least
recently used, LRU</code>) для принятия решений о о том, какие запросы удалить из
кеша. 

</P>

<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_MySQL_Optimisation.html">previous</A>, <A HREF="manual.ru_Table_types.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
