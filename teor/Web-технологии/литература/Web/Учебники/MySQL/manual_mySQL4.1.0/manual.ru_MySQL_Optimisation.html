  <HTML>
  <HEAD>
  
  <TITLE>Справочное руководство по MySQL версии 4.1.0-alpha. - 5  Оптимизация в MySQL</TITLE>
   <style> code {color:purple} tt {color:green} samp {color:navy} pre {color:maroon} </style> <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  </HEAD>
  <BODY BGCOLOR=white TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_MySQL_Database_Administration.html">previous</A>, <A HREF="manual.ru_Reference.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="MySQL_Optimisation" HREF="manual.ru_toc.html#MySQL_Optimisation">5  Оптимизация в MySQL</A></H1>

<P>
Оптимизация - сложная задача, потому что она, в конечном счете, требует
понимания системы в целом. В отдельных случаях для выполнения локальной
оптимизации достаточно знать систему или приложение не в полном объеме,
однако чтобы сделать систему более оптимальной, нужно разбираться в том,
как она устроена.

</P>
<P>
В этой главе будут рассмотрены различные способы оптимизации MySQL и
представлены некоторые примеры ее выполнения. Не следует забывать, однако,
что всегда можно найти некоторые дополнительные возможности сделать
систему еще быстрее (хотя каждый следующий шаг в этом направлении будет
даваться все труднее и труднее).

</P>


<H2><A NAME="Optimise_Overview" HREF="manual.ru_toc.html#Optimise_Overview">5.1  Oбзор оптимизации</A></H2>

<P>
Чтобы увеличить скорость системы, необходимо, разумеется, прежде всего
разбираться в ее конструкции. Кроме того, нужно знать, какие функции будет
выполнять система и какие "узкие места" в ней имеются.

</P>
<P>
Ниже приведен список наиболее часто встречающихся "узких мест":

</P>

<ul>
<LI>Поиск данных на диске. Чтобы найти на диске какой-то фрагмент данных,

требуется некоторое время. Для устройств выпуска 1999 года среднее
время поиска составляет менее 10мс, так что теоретически можно
выполнять приблизительно 100 операций поиска в секунду. Это время
можно ненамного уменьшить, заменив диски более новыми. Для одной
таблицы поиск на диске оптимизировать очень сложно. Такую оптимизацию
можно выполнить путем распределения данных по нескольким дискам.

<LI>Дисковое чтение/запись. После выполнения поиска, когда найдена

соответствующая позиция на диске, мы можем считать данные. Для
устройств выпуска 1999 года производительность одного диска составляет
около 10-20Мб/с. Дисковое чтение/запись легче оптимизировать, чем
дисковый поиск, поэтому читать можно параллельно с нескольких дисков.

<LI>Циклы процессора. Когда мы помещаем данные в основную память (или если

они уже находятся там), мы должны обработать их, чтобы получить
результат. Наличие маленьких по сравнению с объемом ОЗУ таблиц -
наиболее часто встречающийся лимитирующий фактор. Но в этом случае, в
общем-то, скорость обработки маленьких таблиц значения не имеет.

<LI>Пропускная способность ОЗУ (memory bandwidth). Когда процессору

требуется больше данных, чем может вместить его кэш, узким местом
становится пропускная способность памяти. В большинстве систем это
узкое место встречается редко, однако о нем нужно знать.
</ul>



<H3><A NAME="Design_Limitations" HREF="manual.ru_toc.html#Design_Limitations">5.1.1  Конструктивные ограничения MySQL/компромиссы</A></H3>

<P>
<A NAME="IDX838"></A>
<A NAME="IDX839"></A>

</P>
<P>
При использовании обработчика таблиц <code>MyISAM</code> MySQL применяет очень быструю
блокировку таблиц (несколько потоков чтения/один поток записи). Самая
большая проблема при использовании этого типа таблиц возникает в случае
непрерывного потока обновлений в сочетании с медленными выборками из одной
и той же таблицы. Если эта проблема касается лишь некоторых таблиц, можно
использовать вместо них таблицы другого типа. See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>.

</P>

<P>
MySQL может работать как с транзакционными так и с нетранзакционными
таблицами. Чтобы обеспечить возможность нормальной работы с
нетранзакционными таблицами (для которых невозможен откат, если что-нибудь
произойдет не так, как надо), в MySQL существуют следующие правила:

</P>
<P>
<A NAME="IDX840"></A>

</P>

<ul>
<LI>Все столбцы имеют значения по умолчанию.

<LI>Если в столбец вставляется "неправильное" значение (например, <code>NULL</code> в

столбец <code>NOT NULL</code> или слишком большое числовое значение - в числовой
столбец), MySQL не будет выводить сообщение об ошибке, а просто
поместит в столбец "наиболее подходящее возможное значение". Для
числовых значений это 0, наименьшие возможные значения или наибольшее
возможное значение. Для строк это либо пустая строка, либо самая
длинная строка, которая может быть в столбце.

<LI>Все вычисляемые выражения возвращают значение, которое можно

использовать вместо того, чтобы сигнализировать об ошибке. Например,
выражение <code>1/0</code> возвратит <code>NULL</code>
</ul>

<P>
Существование приведенных выше правил объясняется тем, что перед началом
выполнения запроса невозможно проверить, сможет ли он выполниться. Если
проблема обнаружится после обновления нескольких строк, мы не можем
выполнить полный откат, поскольку это может не поддерживаться типом
таблицы. Остановиться в этот момент тоже нельзя, потому что тогда
обновления будут выполнены наполовину, что является, вероятно, самым
худшим возможным результатом. В данном случае лучше выбрать "наименьшее
из зол", а затем продолжать, как будто ничего не произошло.

</P>
<P>
Отсюда следует, что MySQL нельзя использовать для проверки содержимого
полей. Это нужно делать в приложении.

</P>


<H3><A NAME="Portability" HREF="manual.ru_toc.html#Portability">5.1.2  Вопросы переносимости</A></H3>

<P>
<A NAME="IDX841"></A>
<A NAME="IDX842"></A>
<A NAME="IDX843"></A>

</P>
<P>
Поскольку все SQL-серверы поддерживают разные части стандарта SQL, то
разработка переносимых SQL-приложений занимает время. Для очень простых
запросов/вставок это достаточно просто, однако чем сложнее становится ваше
приложение, тем сложнее делать запросы переносимыми. Если вы хотите чтобы
ваше приложение работало максимально быстро с разными серверами SQL,
задача еще более усложняется.

</P>
<P>
Чтобы сделать сложное приложение переносимым в области SQL, вам следует
выбрать те SQL-серверы, с которыми оно должно работать.

</P>
<P>
Чтобы узнать, какие функции, типы и ограничения существуют в выбранных
вами серверах, можно воспользоваться приложением MySQL <code>crash-me</code>. <code>crash-me</code>
пока еще далека от того, чтобы тестировать все, что возможно, но тем не
менее, является достаточно качественным сравнительным тестом по более чем
450 характеристикам.

</P>
<P>
Например, если вы хотите использовать Informix или DB2, имена полей не
должны быть длиннее 18 символов.

</P>
<P>
И тесты MySQL (MySQL benchmarks), и программа <code>crash-me</code> являются достаточно
независимыми от конкретной СУБД. Ознакомившись с тем, как мы решили этот
вопрос, вы можете получить представление о том, как следует писать
переносимые программы для работы с базами данных. Тесты можно найти в
каталоге <tt>`sql-bench'</tt> в поставке исходных текстов MySQL. Они написаны на Perl
с использованием интерфейса DBI (который, кстати, уже решает проблему
получения доступа к разным базам данных).

</P>
<P>
См. <a HREF="http://www.mysql.com/information/benchmarks.html">http://www.mysql.com/information/benchmarks.html</a> - там находятся
результаты тестов.

</P>
<P>
Как можно видеть по этим результатам, у каждой СУБД есть свои слабые
стороны. Все они построены по-разному и спроектированы с учетом различных
компромиссов, что приводит к различиям в поведении этих систем.

</P>
<P>
Если независимость от СУБД для вас очень важна, вам нужно хорошо ощущать,
где находятся слабые места в каждом сервере. MySQL - очень быстрый сервер,
если речь идет о выборках/вставках, но у нас все еще есть проблемы, когда
с одной таблицей в смешанном режиме работают медленные клиенты, делающие
выборки и обновления. С другой стороны, при работе в Oracle возникают
большие проблемы, когда вы хотите получить доступ к строке, которую только
что обновили (до тех пор, пока она не будет сохранена на диске).
Транзакционные базы данных обычно не очень подходят для генерации отчетов
по файлам журналов, так как в этом случае блокировки совершенно
бесполезны.

</P>
<P>
Чтобы сделать свое приложение <em>действительно</em> не зависящим от СУБД, вам
следует создать некий быстро расширяемый интерфейс, через который
происходит обработка данных. Поскольку C++ доступен на большинстве систем,
имеет смысл создать соответствующие классы-интерфейсы к базам данных.

</P>
<P>
Если вы используете некоторые специфические функции СУБД (скажем, <code>REPLACE</code>
в MySQL), вам следует написать код, реализующий этот метод для других
серверов SQL. С MySQL вы можете использовать такой синтаксис для того,
чтобы добавить некоторые специфические для MySQL ключевые слова в запрос:
<code>/*! */</code>. Код внутри <code>/* */</code> будет проигнорирован как комментарий большинством
других SQL-серверов.

</P>
<P>
Если скорость важнее точности данных, как в некоторых веб-приложениях, то
тогда можно создать промежуточный уровень, который кэширует запросы и
таким образом дает еще больший выигрыш по скорости. Убирая некоторые
запросы из кэша по истечении времени, вы можете держать кэш в достаточно
"свежем" состоянии. Таким образом можно избежать пиков повышения
нагрузки на сервер, т.к. вы можете динамически увеличить кэш и
продолжительность жизни информации, и сохранять эти параметры таковыми,
пока ситуация не стабилизируется.

</P>
<P>
В этом случае структура таблицы должна содержать информацию об изначальном
размере кэша и то, как часто таблица должна быть обновлена в общем случае.

</P>


<H3><A NAME="Internal_use" HREF="manual.ru_toc.html#Internal_use">5.1.3  Для чего мы использовали MySQL?</A></H3>

<P>
<A NAME="IDX844"></A>
<A NAME="IDX845"></A>
<A NAME="IDX846"></A>

</P>
<P>
На первых этапах развития MySQL его функциональные возможности
разрабатывались под потребности самого крупного из наших заказчиков. Это
делалось для обслуживания больших хранилищ данных для пары самых крупных
продавцов в Швеции.

</P>
<P>
По всем магазинам мы получаем еженедельный отчет по продажам по бонусным
карточкам, и обеспечиваем владельцам магазинов полезной информацией о том,
как рекламные компании влияют на их покупателей.

</P>
<P>
Объем этих данных весьма значителен (в сумме приблизительно 7 миллионов
транзакций в месяц), и, кроме того, мы должны предоставлять пользователям
данные за периоды от 4 до 10 лет. Каждую неделю мы получаем от клиентов
просьбы предоставить "мгновенный" доступ к новым отчетам на основе этих
данных.

</P>
<P>
Эта проблема была решена следующим образом. Мы сохраняем всю информацию за
месяц в сжатых таблицах "транзакций". У нас есть набор простых макросов
(сценарий), генерирующий итоговые таблицы, сгруппированные по различным
критериям (группа изделий, идентификатор заказчика, хранилище...) из
таблиц транзакций. Отчеты - это веб-страницы, динамически генерирующиеся
небольшим сценарием на Perl, который просматривает веб-страницу, выполняет
SQL-операторы, содержащиеся в ней и вставляет результаты. Для этих целей
можно было бы использовать PHP или модуль <code>mod_perl</code>, но в то время этих
средств еще не существовало.

</P>
<P>
Для графических данных мы написали простой инструмент на C, который может
создавать GIF-файлы на основе результата SQL-запроса (определенным образом
обработав результат). Это также динамически выполняется из создаваемой
Perl'ом странички.

</P>
<P>
В большинстве случаев новый отчет может быть создан просто путем
копирования существующего сценария и модифицирования SQL-запроса в нем.
Иногда требуется дополнительно добавить поля в существующую итоговую
таблицу или сгенерировать новую таблицу, но это также делается очень
просто, поскольку у нас все транзакционные таблицы хранятся на диске (в
настоящее время у нас имеется меньшей мере 50Гб транзакционных таблиц и
200Гб других клиентских данных.)

</P>
<P>
Кроме того, мы обеспечиваем для наших клиентов возможность обращаться к
итоговым таблицам непосредственно через интерфейс ODBC; таким образом,
продвинутые пользователи могут самостоятельно экспериментировать с
данными.

</P>
<P>
У нас не было каких-либо проблем при обработке этих данных на весьма
скромном Sun Ultra SPARCstation (2x200 МГц). Недавно мы заменили один из
наших серверов на двухпроцессорный UltraSPARC с тактовой частотой 400 МГц
и теперь планируем начать обрабатывать транзакции на уровне продукта, что
будет означать десятикратное увеличение объема данных. Мы полагаем, что
сможем справиться с этим объемом лишь только добавлением соответствующего
количества дисков.

</P>
<P>
Помимо этого мы экспериментируем с Intel-Linux, чтобы получить больше
производительности по низшей цене. Теперь, имея бинарно-переносимый формат
базы данных (появившийся в версии 3.23), мы начнем использовать его для
некоторых частей приложения.

</P>
<P>
Наша интуиция подсказывает, что у Linux производительность значительно
выше при низкой и средней загрузке, а у Solaris - когда высокая загрузка
начнет возникать из-за критического дискового ввода-вывода. Но у нас нет
пока никаких выводов по этому поводу. После обсуждения с разработчиками
ядра Linux мы выяснили, что в это может быть побочным эффектом работы
ядра: когда Linux дает слишком много ресурсов пакетным заданиям, задачи
взаимодействия начинают замедляться. Из-за этого машина работает очень
медленно и не реагирует ни на что, пока обрабатываются большие пакеты.
Надеемся, что в последующих ядрах Linux этот вопрос найдет свое решение.

</P>


<H3><A NAME="MySQL_Benchmarks" HREF="manual.ru_toc.html#MySQL_Benchmarks">5.1.4  Набор тестов MySQL (The MySQL Benchmark Suite)</A></H3>

<P>
<A NAME="IDX847"></A>
<A NAME="IDX848"></A>

</P>
<P>
В данном разделе будет находиться техническое описание набора эталонных
тестов MySQL (и <code>crash-me</code>), но оно пока еще не написано. В настоящее время
можно получить хорошее представление об эталонном тесте, глядя на код и
результаты в каталоге <tt>`sql-bench'</tt> любого исходного дистрибутива MySQL.

</P>
<P>
Данный набор эталонных создан с целью обеспечить эталонный тест, который
будет информировать любого пользователя о том, что в данной реализации SQL
выполняется хорошо, а что плохо.

</P>
<P>
Обратите внимание: этот эталонный тест - однопоточный, так что в нем
измеряется минимальное время выполнения операций. В будущем мы планируем
добавить в данный набор большое количество многопоточных тестов.

</P>
<P>
Например (выполнено на одной машине под NT 4.0):

</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Чтение 2000000 строк по индексу</strong> </TD><TD> <strong>Секунды</strong> </TD><TD> <strong>Секунды</strong>
</TD></TR>
<TR><TD>mysql </TD><TD> 367 </TD><TD> 249
</TD></TR>
<TR><TD>mysql_odbc </TD><TD> 464 </TD><TD>
</TD></TR>
<TR><TD>db2_odbc </TD><TD> 1206 </TD><TD>
</TD></TR>
<TR><TD>informix_odbc </TD><TD> 121126 </TD><TD>
</TD></TR>
<TR><TD>ms-sql_odbc </TD><TD> 1634 </TD><TD>
</TD></TR>
<TR><TD>oracle_odbc </TD><TD> 20800 </TD><TD>
</TD></TR>
<TR><TD>solid_odbc </TD><TD> 877 </TD><TD>
</TD></TR>
<TR><TD>sybase_odbc </TD><TD> 17614 </TD><TD>
</TD></TR>
</TABLE>

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Вставка 350768 строк</strong> </TD><TD> <strong>Секунды</strong> </TD><TD> <strong>Секунды</strong>
</TD></TR>
<TR><TD>mysql </TD><TD> 381 </TD><TD> 206
</TD></TR>
<TR><TD>mysql_odbc </TD><TD> 619 </TD><TD>
</TD></TR>
<TR><TD>db2_odbc </TD><TD> 3460 </TD><TD>
</TD></TR>
<TR><TD>informix_odbc </TD><TD> 2692 </TD><TD>
</TD></TR>
<TR><TD>ms-sql_odbc </TD><TD> 4012 </TD><TD>
</TD></TR>
<TR><TD>oracle_odbc </TD><TD> 11291 </TD><TD>
</TD></TR>
<TR><TD>solid_odbc </TD><TD> 1801 </TD><TD>
</TD></TR>
<TR><TD>sybase_odbc </TD><TD> 4802 </TD><TD>
</TD></TR>
</TABLE>

<P>
В предыдущем тесте MySQL запускался с 8-мегабайтным индексным кэшем.

</P>
<P>
Гораздо больше результатов тестов вы сможете найти по адресу
<a HREF="http://www.mysql.com/information/benchmarks.html">http://www.mysql.com/information/benchmarks.html</a>.

</P>
<P>
Обратите внимание: данные об Oracle отсутствуют - по просьбе компании
Oracle вся информация по их продукту была удалена. Все эталонные тесты для
Oracle должны быть пропущены через компанию Oracle! Мы считаем, однако,
что при таком способе тестирования результаты эталонных тестов для Oracle
будут в <strong>очень</strong> высокой степени различаться, поскольку приведенные на сайте
результаты призваны показывать на что способна стандартная инсталляция для
одного клиента.

</P>
<P>
Чтобы выполнить набор эталонных тестов, необходимо загрузить исходный
дистрибутив MySQL, установить драйвер perl DBI, драйвер perl DBD для той
базы данных, которую нужно проверить, а затем выполнить:

</P>

<pre>
cd sql-bench
perl run-all-tests --server=#
</pre>

<P>
где # - один из поддерживаемых серверов. Список всех опций и
поддерживаемых серверов можно получить, выполнив <code>run-all-tests --help</code>.

</P>
<P>
Программа <code>crash-me</code> пытается определить, какие функции поддерживаются СУБД,
и какие возможности и ограничения имеют эти функции при выполнении
запросов. Например, она определяет следующее:

</P>

<ul>
<LI>какие типы столбцов поддерживаются

<LI>сколько индексов поддерживается

<LI>какие функции поддерживаются

<LI>насколько большим может быть запрос

<LI>насколько большим может быть столбец <code>VARCHAR</code>

</ul>

<P>
<A NAME="IDX849"></A>
Результат, полученные <code>crash-me</code> для большого количества различных СУБД,
можно найти по адресу: <a HREF="http://www.mysql.com/information/crash-me.php">http://www.mysql.com/information/crash-me.php</a>.

</P>


<H3><A NAME="Custom_Benchmarks" HREF="manual.ru_toc.html#Custom_Benchmarks">5.1.5  Использование собственных тестов</A></H3>

<P>
<A NAME="IDX850"></A>
<A NAME="IDX851"></A>

</P>
<P>
Чтобы найти "узкие места" в своем приложении и базе данных, вы должны их
тщательно протестировать. После устранения "узкого места" (или после
замены его некой заглушкой) можно легко идентифицировать следующее "узкое
место" (и так далее). Даже если общая производительность приложения
достаточна, нужно по крайней мере выявить все "узкие места" и
определиться с тем, как их устранять, - на будущее, если когда-нибудь
потребуется дополнительная производительность.

</P>
<P>
Примеры переносимых программ программы для эталонного тестирования можно
найти в наборе тестов MySQL. See section <A HREF="manual.ru_MySQL_Optimisation.html#MySQL_Benchmarks">5.1.4  Набор тестов MySQL (The MySQL Benchmark Suite)</A>. 
Можно взять любую программу из
этого набора и модифицировать ее для своих потребностей. Таким образом
можно испытывать различные решения проблемы и проверять, которое из них
самое быстрое.

</P>
<P>
Зачастую некоторые проблемы проявляются только тогда, когда система очень
сильно загружена. К нам часто обращаются клиенты, которые, запустив
(протестированную) систему в производство, сталкиваются с проблемами,
связанными с нагрузкой. На сегодня причиной каждого из этих случаев были
либо проблемы, связанные с базовой конструкцией (при высокой нагрузке
<strong>нехорошо</strong> выполняется сканирование таблиц), либо проблемы
ОС/библиотек. И большинство таких проблем было бы <strong>намного</strong> легче устранить
до начала промышленной эксплуатации систем.

</P>
<P>
Чтобы избежать подобных проблем, нужно постараться выполнить эталонное
тестирование всего приложения при самой плохой возможной нагрузке! Для
этого можно использовать программу <code>Super Smack</code>, которая доступна по
адресу: <a HREF="http://www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz">http://www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz</a>.
Эта программа, как следует из ее имени (<em>smack - шлепок - прим. пер.</em>),
способна поставить систему на колени, так что используйте её только на
разрабатываемых системах (проще говоря, в девелопменте).

</P>


<H2><A NAME="Query_Speed" HREF="manual.ru_toc.html#Query_Speed">5.2  Оптимизация <code>SELECT</code> и других запросов</A></H2>

<P>
<A NAME="IDX852"></A>
<A NAME="IDX853"></A>
<A NAME="IDX854"></A>

</P>
<P>
Сначала приведем одно правило, касающееся всех запросов: Чем сложнее ваша
система привилений, тем больше издержек.

</P>
<P>
Если не было выполнено никаких операторов <code>GRANT</code>, MySQL каким-то образом
будет оптимизировать проверку полномочий. Таким образом при наличии очень
большого объема данных лучше, наверное, будет работать без привилегий. В
противном случае при большом количестве полномочий проверка результатов
будет происходить с увеличенными издержками.

</P>
<P>
Если проблема состоит в некоторой явной функции MySQL, всегда можно
протестировать ее в клиенте:

</P>

<pre>
mysql&#62; SELECT BENCHMARK(1000000,1+1);
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</pre>

<P>
Из приведенного выше примера видно, что MySQL может выполнять более
1000000 операций сложения за 0,32 секунды на PentiumII 400MHz.

</P>
<P>
Все функции MySQL достаточно хорошо оптимизированы, но могут попадаться
некоторые исключения, и функция <code>BENCHMARK(число_циклов,выражение)</code> -
хороший инструмент для выяснения, присутствует ли проблема в запросе.

</P>



<H3><A NAME="EXPLAIN" HREF="manual.ru_toc.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A></H3>

<P>
<A NAME="IDX855"></A>
<A NAME="IDX856"></A>

</P>

<pre>
    EXPLAIN имя_таблицы
или EXPLAIN SELECT опции_выборки
</pre>

<P>
<code>EXPLAIN имя_таблицы</code> является синонимом операторов <code>DESCRIBE имя_таблицы</code> и
<code>SHOW COLUMNS FROM имя_таблицы</code>.

</P>
<P>
Если оператор <code>SELECT</code> предваряется ключевым словом <code>EXPLAIN</code>, MySQL сообщит о
том, как будет производиться обработка <code>SELECT</code>, и предоставит информацию о
порядке и методе связывания таблиц.

</P>
<P>
При помощи <code>EXPLAIN</code> можно выяснить, когда стоит снабдить таблицы индексами,
чтобы получить более быструю выборку, использующую индексы для поиска
записей. 

</P>
<P>
Вы должны почаще запускать <code>ANALYZE TABLE</code> с тем, чтобы обновлялась статистика по 
таблицам, такая как кардинальность ключей, которые могут повлиять на выбор оптимизатора. 
See section <A HREF="manual.ru_MySQL_Database_Administration.html#ANALYZE_TABLE">4.5.2  Синтаксис команды <code>ANALYZE TABLE</code></A>.

</P>
<P>
Можно проверить, насколько удачный порядок связывания
таблиц был выбран оптимизатором. Заставить оптимизатор связывать таблицы в
заданном порядке можно при помощи указания <code>STRAIGHT_JOIN</code>.

</P>
<P>
Для непростых соединений <code>EXPLAIN</code> возвращает строку информации о каждой из
использованных в работе оператора <code>SELECT</code> таблиц. Таблицы перечисляются в
том порядке, в котором они будут считываться.
MySQL выполняет все связывания за один проход (метод называется
"single-sweep multi-join"). Делается это так: MySQL читает строку из
первой таблицы, находит совпадающую строку во второй таблице, затем - в
третьей, и так далее. Когда обработка всех таблиц завершается, MySQL
выдает выбранные столбцы и обходит в обратном порядке список таблиц до тех
пор, пока не будет найдена таблица с наибольшим совпадением строк.
Следующая строка считывается из этой таблицы и процесс продолжается в
следующей таблице.

</P>
<P>
В MySQL 4.1, вывод <code>EXPLAIN</code> был изменен с тем, чтобы работать лучше с конструкциями типа 
<code>UNION</code>, подзапросами, и наследованными (вторичными, derived) таблицами. 
Наиболее заметным изменением стало введение двух новых столбцов: <code>id</code> и <code>select_type</code>.

</P>
<P>
Вывод команды <code>EXPLAIN</code> включает следующие столбцы:

</P>
<DL COMPACT>

<DT><code>id</code>
<DD>
Идентификатор <code>SELECT</code>, последовательный номер этого конкретного <code>SELECT</code> в запросе. 

<DT><code>select_type</code>
<DD>
Тип оператора <code>SELECT</code>, который может быть один из следующих: 

<DL COMPACT>

<DT><code>SIMPLE</code>
<DD>
Простая выборка (<code>SELECT</code> без <code>UNION</code> или подзапросов). 

<DT><code>PRIMARY</code>
<DD>
Крайний <code>SELECT</code>.

<DT><code>UNION</code>
<DD>
Второй и дальнейшие <code>UNION SELECT</code>.

<DT><code>DEPENDENT UNION</code>
<DD>
Второй и дальнейшие <code>UNION SELECT</code>, зависящие от внешнего подзапроса. 

<DT><code>SUBSELECT</code>
<DD>
Первый <code>SELECT</code> в подзапросе. 

<DT><code>DEPENDENT SUBSELECT</code>
<DD>
Первый <code>SELECT</code>, зависящий от внешнего подзапроса. 

<DT><code>DERIVED</code>
<DD>
Наследованная (вторичная) таблица <code>SELECT</code>.
</DL>

<DT><code>table</code>
<DD>
Таблица, к которой относится выводимая строка.

<DT><code>type</code>
<DD>
Тип связывания. 
Ниже перечислены различные типы связывания, упорядоченные от лучшего к
худшему:

<A NAME="IDX857"></A>
<A NAME="IDX858"></A>

<DL COMPACT>

<DT><code>system</code>
<DD>
Таблица содержит только одну строку (= системная таблица). Это - частный
случай типа связывания <code>const</code>.

<A NAME="IDX859"></A>

<DT><code>const</code>
<DD>
Таблица содержит не более одной соответствующей строки, которая будет
считываться в начале запроса. Поскольку имеется только одна строка,
оптимизатор в дальнейшем может расценивать значения этой строки в столбце
как константы. Таблицы <code>const</code> являются очень быстрыми, поскольку они
читаются только однажды!

<DT><code>eq_ref</code>
<DD>
Для каждой комбинации строк из предыдущих таблиц будет cчитываться одна
строка из этой таблицы. Это наилучший возможный тип связывания среди
типов, отличных от <code>const</code>. Данный тип применяется, когда все части индекса
используются для связывания, а сам индекс - <code>UNIQUE</code> или <code>PRIMARY KEY</code>.

<DT><code>ref</code>
<DD>
Из этой таблицы будут считываться все строки с совпадающими значениями
индексов для каждой комбинации строк из предыдущих таблиц. Тип <code>ref</code>
применяется, если для связывания используется только крайний левый префикс
ключа, или если ключ не является <code>UNIQUE</code> или <code>PRIMARY KEY</code> (другими словами,
если на основании значения ключа для связывания не может быть выбрана одна
строка). Этот тип связывания хорошо работает, если используемый ключ
соответствует только нескольким строкам.

<DT><code>range</code>
<DD>
При помощи индекса для выборки строк будут извлечены только строки,
находящиеся в заданном диапазоне. Используемый индекс указывается в
столбце <code>key</code>. Столбец <code>key_len</code> содержит самую длинную часть ключа, которая
была использована. Столбец <code>ref</code> будет содержать значения <code>NULL</code> для этого
типа.

<DT><code>index</code>
<DD>
Данный тип аналогичен <code>ALL</code>, за исключением того, что просматривается только
дерево индексов. Этот тип обычно более быстрый чем <code>ALL</code>, поскольку
индексный файл, как правило, меньше файла данных.

<DT><code>ALL</code>
<DD>
Для каждой комбинации строк из предыдущих таблиц будет производиться
полный просмотр этой таблицы. Это обычно плохо, если таблица - первая из
не отмеченных как <code>const</code>, и <strong>очень</strong> плохо во всех остальных случаях. Как
правило, можно избегать типа связывания <code>ALL</code> - путем добавления большего
количества индексов таким образом, чтобы строка могла быть найдена при
помощи константных значений или значений столбца из предыдущих таблиц.
</DL>

<DT><code>possible_keys</code>
<DD>
Столбец <code>possible_keys</code> служит для указания индексов, которые может
использовать MySQL для нахождения строк в этой таблице. Обратите внимание:
этот столбец полностью независим от порядка таблиц. Это означает, что на
практике некоторые ключи в столбце <code>possible_keys</code> могут не годиться для
сгенерированного порядка таблиц. 

Если данный столбец пуст, то никаких
подходящих индексов не имеется. В этом случае для увеличения
производительности следует исследовать выражение <code>WHERE</code>, чтобы увидеть,
есть ли в нем ссылки на какой-либо столбец (столбцы), которые подходили бы
для индексации. Если да, создайте соответствующий индекс и снова проверьте
запрос при помощи оператора <code>EXPLAIN</code>. See section <A HREF="manual.ru_Reference.html#ALTER_TABLE">6.5.4  Синтаксис оператора <code>ALTER TABLE</code></A>. 

Чтобы увидеть, какие
индексы есть в таблице, используйте команду <code>SHOW INDEX FROM имя_таблицы</code>.

<DT><code>key</code>
<DD>
Столбец <code>key</code> содержит ключ (индекс), который MySQL решил использовать в
действительности. Если никакой индекс не был выбран, ключ будет иметь значение
<code>NULL</code>. Чтобы заставить MySQL применить индекс из <code>possible_keys</code>,
следует использовать оператор <code>USE INDEX/IGNORE INDEX</code> в запросе.
See section <A HREF="manual.ru_Reference.html#SELECT">6.4.1  Синтаксис оператора <code>SELECT</code></A>.

Также, выполнение <code>myisamchk --analyze</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#myisamchk_syntax">4.4.6.1  Синтаксис запуска <code>myisamchk</code></A>) или
<code>ANALYZE TABLE</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#ANALYZE_TABLE">4.5.2  Синтаксис команды <code>ANALYZE TABLE</code></A>) по таблицам даст возможность
оптимизатору принимать более правильные решения. 

<DT><code>key_len</code>
<DD>
Столбец <code>key_len</code> содержит длину ключа, которую решил использовать MySQL.
Если <code>key</code> имеет значение <code>NULL</code>, то длина ключа (<code>key_len</code>) тоже <code>NULL</code>. Обратите
внимание: по значению длины ключа можно определить, сколько частей
составного ключа в действительности будет использовать MySQL.

<DT><code>ref</code>
<DD>
Столбец <code>ref</code> показывает, какие столбцы или константы используются с ключом,
указанным в <code>key</code>, для выборки строк из таблицы.

<DT><code>rows</code>
<DD>
В столбце <code>rows</code> указывается число строк, которые MySQL считает нужным
проанализировать для выполнения запроса.

<DT><code>Extra</code>
<DD>
Этот столбец содержит дополнительную информацию о том, как MySQL будет
выполнять запрос. Ниже объясняется значение каждой из текстовых строк,
которые могут находиться в этом столбце:

<DL COMPACT>

<DT><code>Distinct</code>
<DD>
После нахождения первой совпадающей строки MySQL не будет продолжать поиск
строк для текущей комбинации строк.

<DT><code>Not exists</code>
<DD>
MySQL смог осуществить оптимизацию <code>LEFT JOIN</code> для запроса и после
нахождения одной строки, соответствующей критерию <code>LEFT JOIN</code>, не будет
искать в этой таблице последующие строки для предыдущей комбинации строк.

Например:


<pre>
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</pre>

Предположим, что столбец <code>t2.id</code> определен как <code>NOT NULL</code>. В этом случае MySQL
просмотрит таблицу <code>t1</code> и будет искать строки в <code>t2</code> соответствующие <code>t1.id</code>.
Если MySQL находит в <code>t2</code> нужную строку, он знает, что <code>t2.id</code> никогда не
может иметь значение <code>NULL</code>, и не будет искать в <code>t2</code> оставшуюся часть строк,
имеющих тот же самый <code>id</code>. Другими словами, для каждой строки в <code>t1</code> MySQL
должен выполнить только один поиск в <code>t2</code>, независимо от того, сколько
совпадающих строк содержится в <code>t2</code>.

<DT><code><code>range checked for each record (index map: #)</code></code>
<DD>
MySQL не нашел достаточно хорошего индекса для использования. Вместо этого
для каждой комбинации строк в предшествующих таблицах он будет проверять,
какой индекс следует использовать (если есть какой-либо индекс), и
применять его для поиска строк в таблице. Это делается не очень быстро, но
таким образом таблицы связываются быстрее, чем без индекса.

<DT><code>Using filesort</code>
<DD>
MySQL должен будет сделать дополнительный проход, чтобы выяснить, как
извлечь строки в порядке сортировки. Для выполнения сортировки выполняется
просмотр всех строк согласно типу связывания (<code>join type</code>) и сохраняются
ключ сортировки плюс указатель на строку для всех строк, удовлетворяющих
выражению <code>WHERE</code>. После этого ключи сортируются и строки извлекаются в
порядке сортировки.

<DT><code>Using index</code>
<DD>
Для извлечения данных из столбца используется только информация дерева
индексов; при этом нет необходимости производить собственно чтение записи.
Это применимо для случаев, когда все используемые столбцы таблицы являются
частью одного индекса.

<DT><code>Using temporary</code>
<DD>
Чтобы выполнить запрос, MySQL должен будет создать временную таблицу для
хранения результата. Это обычно происходит, если предложение <code>ORDER BY</code>
выполняется для набора столбцов, отличного от того, который используется в
предложении <code>GROUP BY</code>.

<DT><code>Using where</code>
<DD>
Выражение <code>WHERE</code> будет использоваться для выделения тех строк, которые
будут сопоставляться со следующей таблицей или тех, которые будут посланы
клиенту. Если этой информации нет, а таблица имеет тип <code>ALL</code> или <code>index</code>, то,
значит, в вашем запросе есть какая-то ошибка (если вы не собираетесь
делать выборку/тестирование всех строк таблицы).
</DL>

Если нужно, чтобы запросы выполнялись настолько быстро, насколько это
возможно, посмотрите, есть ли строки упоминания <code>Using filesort</code> и <code>Using temporary</code>.
</DL>

<P>
Существует неплохой способ определить, насколько хорошим является тип
связывания. Для этого нужно перемножить все значения столбца <code>rows</code>,
выводимого командой <code>EXPLAIN</code>. Результатом будет грубая оценка того, сколько
строк должен просмотреть MySQL для выполнения запроса. Это же число
используется для ограничения запросов в переменной <code>max_join_size</code>.
See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

</P>
<P>
В следующем примере показано, как можно постепенно оптимизировать <code>JOIN</code> при
помощи информации, выводимой оператором <code>EXPLAIN</code>.

</P>
<P>
Предположим, что имеется представленный ниже оператор <code>SELECT</code>, который
нужно исследовать при помощи команды <code>EXPLAIN</code>:

</P>

<pre>
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
            tt.ProjectReference, tt.EstimatedShipDate,
            tt.ActualShipDate, tt.ClientID,
            tt.ServiceCodes, tt.RepetitiveID,
            tt.CurrentProcess, tt.CurrentDPPerson,
            tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
            et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
            AND tt.ActualPC = et.EMPLOYID
            AND tt.AssignedPC = et_1.EMPLOYID
            AND tt.ClientID = do.CUSTNMBR;
</pre>

<P>
Для этого примера принимается, что:

</P>

<ul>
<LI>

Сравниваемые столбцы были объявлены следующим образом:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Таблица</strong> </TD><TD> <strong>Столбец</strong> </TD><TD> <strong>Тип столбца</strong>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ActualPC</code> </TD><TD> <code>CHAR(10)</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>AssignedPC</code> </TD><TD> <code>CHAR(10)</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ClientID</code> </TD><TD> <code>CHAR(10)</code>
</TD></TR>
<TR><TD><code>et</code> </TD><TD> <code>EMPLOYID</code> </TD><TD> <code>CHAR(15)</code>
</TD></TR>
<TR><TD><code>do</code> </TD><TD> <code>CUSTNMBR</code> </TD><TD> <code>CHAR(15)</code>
</TD></TR>
</TABLE>

<LI>

Таблицы проиндексированы следующим образом:

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Таблица</strong> </TD><TD> <strong>Индекс</strong>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ActualPC</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>AssignedPC</code>
</TD></TR>
<TR><TD><code>tt</code> </TD><TD> <code>ClientID</code>
</TD></TR>
<TR><TD><code>et</code> </TD><TD> <code>EMPLOYID</code> (primary key)
</TD></TR>
<TR><TD><code>do</code> </TD><TD> <code>CUSTNMBR</code> (primary key)
</TD></TR>
</TABLE>

<LI>

Значения <code>tt.ActualPC</code> распределены не равномерно.
</ul>

<P>
На начальном этапе перед выполнением какой-либо оптимизации оператор
<code>EXPLAIN</code> выведет следующую информацию:

</P>

<pre>
table type possible_keys                key  key_len ref  rows  Extra
et    ALL  PRIMARY                      NULL NULL    NULL 74
do    ALL  PRIMARY                      NULL NULL    NULL 2135
et_1  ALL  PRIMARY                      NULL NULL    NULL 74
tt    ALL  AssignedPC,ClientID,ActualPC NULL NULL    NULL 3872
      range checked for each record (key map: 35)
</pre>

<P>
Поскольку каждая таблица имеет тип (<code>type</code>) <code>ALL</code>, из приведенного выше вывода видно,
что MySQL будет делать полное связывание всех таблиц! Это займет долгое
время, поскольку для выполнения такого связывания должно быть рассмотрено
произведение числа строк в каждой таблице! Для нашего случая такое
произведение - 74 * 2135 * 74 * 3872 = 45268558720 строк. Если таблицы
большие, трудно даже представить себе, как долго они будут связываться.

</P>
<P>
Одна проблема здесь состоит в том, что MySQL не может (пока еще)
эффективно применять индексы к столбцам, если они объявлены по-разному. В
этом контексте тип <code>VARCHAR</code> и тип <code>CHAR</code> - одинаковы, если они не объявлены с
различной длиной. Поскольку столбец <code>tt.ActualPC</code> объявлен как <code>CHAR(10)</code>, а
<code>et.EMPLOYID</code> - как <code>CHAR(15)</code>, имеется несоответствие по длине значений.

</P>
<P>
Чтобы устранить это несоответствие между длинами столбцов, следует
использовать команду <code>ALTER TABLE</code> для удлинения столбца <code>ActualPC</code> от 10
символов до 15 символов:

</P>

<pre>
mysql&#62; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</pre>

<P>
Теперь оба столбца <code>tt.ActualPC</code> и <code>et.EMPLOYID</code> имеют тип <code>VARCHAR(15)</code>. При
повторном выполнении оператора <code>EXPLAIN</code> будет выведен следующий результат:

</P>

<pre>
table type   possible_keys   key     key_len ref         rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL 3872    Using where
do    ALL    PRIMARY         NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY         NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC 1
</pre>

<P>
Это не идеально, но уже намного лучше (произведение значений строк (<code>rows</code>) теперь
уменьшилось в 74 раза). Такое связывание выполнится за пару секунд.

</P>
<P>
Можно сделать еще одно изменение - чтобы устранить несоответствие длин
столбцов для сравнений <code>tt.AssignedPC = et_1.EMPLOYID</code> и <code>tt.ClientID =
do.CUSTNMBR</code>.

</P>

<pre>
mysql&#62; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
    -&#62;                MODIFY ClientID   VARCHAR(15);
</pre>

<P>
Теперь оператор <code>EXPLAIN</code> будет выводить такую информацию:

</P>

<pre>
table type   possible_keys   key      key_len ref           rows Extra
et    ALL    PRIMARY         NULL     NULL    NULL          74
tt    ref    AssignedPC,     ActualPC 15      et.EMPLOYID   52   Using where
             ClientID,
             ActualPC
et_1  eq_ref PRIMARY         PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY         PRIMARY  15      tt.ClientID   1
</pre>

<P>
Это почти идеально.

</P>
<P>
Осталась еще одна проблема. Она заключается в том, что по умолчанию MySQL
принимает, что значения в столбце <code>tt.ActualPC</code> распределены равномерно, но
в таблице <code>tt</code> это не так. К счастью, проинформировать MySQL об этом можно
очень просто:

</P>

<pre>
shell&#62; myisamchk --analyze PATH_TO_MYSQL_DATABASE/tt
shell&#62; mysqladmin refresh
</pre>

<P>
Теперь связывание совершенно, и оператор <code>EXPLAIN</code> выведет такой результат:

</P>

<pre>
table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using where
             ClientID,
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</pre>

<P>
Обратите внимание: столбец rows в выводе оператора <code>EXPLAIN</code> - опытное
предположение оптимизатора связей MySQL. Чтобы оптимизировать запрос,
нужно проверить, являются ли числа близкими к действительным. Если нет,
можно получить лучшую производительность, используя в операторе <code>SELECT</code>
соединение <code>STRAIGHT_JOIN</code> и попытаться задать другой порядок таблиц в
выражении <code>FROM</code>.

</P>


<H3><A NAME="Estimating_performance" HREF="manual.ru_toc.html#Estimating_performance">5.2.2  Оценка производительности запроса</A></H3>

<P>
<A NAME="IDX860"></A>
<A NAME="IDX861"></A>
<A NAME="IDX862"></A>

</P>
<P>
В большинстве случаев можно оценивать производительность путем подсчета
дисковых операций. Для маленьких таблиц можно обычно принимать 1 строку за
1 операцию дискового поиска (поскольку индекс, скорее всего, в кэше). Для
больших таблиц можно считать, что (при использовании индексов типа B++
деревьев) для нахождения строки потребуется 

</P>
<P>
<code>log(количество_строк) / log(длина_индексного_блока / 3 * 2 / 
(длина_индекса + длина_указателя_на_данные)) + 1</code>

</P>
<P>
дисковая операция для получения строки.

</P>
<P>
Обычно в MySQL индексный блок занимает 1024 байта, а указательн - 4 байта.
Для таблицы, содержащей 500000 строк и имеющей длину индекса 3 (<code>medium
integer</code>) потребуется <code>log(500,000)/log(1024/3*2/(3+4)) + 1 = 4</code> дисковых
операции поиска.

</P>
<P>
Поскольку вышеупомянутый индекс будет занимать приблизительно 500000 * 7 *
3/2 = 5,2Mб (если учитывать, что индексные буфера обычно заполняются на
2/3), большая часть индекса, скорее всего, окажется в памяти, и для того,
чтобы найти строку, потребуется лишь 1-2 обращения к ОС для чтения.

</P>
<P>
Для записи, однако, потребуется 4 дисковых запроса (таких, какие
рассматривались выше) чтобы найти место для помещения нового индекса, и
обычно 2 дисковых операции, чтобы обновить индекс и вставить строку.

</P>
<P>
Обратите внимание: сказанное выше не означает, что производительность
приложения будет ухудшаться в <code>log N</code> раз! Поскольку все кэшируется в OС или
на SQL-сервере, замедление работы при увеличении таблицы будет
незначительным. И лишь после того, как данных станет так много, что они
перестанут помещаться в кэш, замедление работы там, где работа приложения
сводится только к операциям дискового поиска (количество которых растет в
<code>log N</code>), станет гораздо ощутимей. Чтобы избежать этого, следует увеличить
индексный кэш так, чтобы он вмещал возросшее количество данных. 
See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

</P>


<H3><A NAME="SELECT_speed" HREF="manual.ru_toc.html#SELECT_speed">5.2.3  Скорость выполнения запросов <code>SELECT</code></A></H3>

<P>
<A NAME="IDX863"></A>

</P>
<P>
<A NAME="IDX864"></A>

</P>
<P>
В общем случае для того, чтобы заставить медленный <code>SELECT ... WHERE</code>
работать быстрее, прежде всего нужно выяснить, можно ли добавить индекс.
 Для всех ссылок между различными таблицами должны, как
правило, применяться индексы. Чтобы определить, какие индексы используются
для выборки <code>SELECT</code>, можно использовать <code>EXPLAIN</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A>.

</P>
<P>
Вот несколько общих советов:

</P>

<ul>
<LI>Чтобы MySQL лучше оптимизировал запросы, можно выполнить <code>myisamchk

--analyze</code> для таблицы после того, как она загружена соответствующими
данными. Таким образом для каждой части индекса будет обновлено
значение, указывающее среднее число строк, имеющих одинаковые значения
(для уникальных индексов это всегда 1, разумеется). MySQL будет
использовать это число, чтобы решить, какой индекс следует выбрать для
связывания двух таблиц при помощи "неконстантного выражения".
Результат работы <code>analyze</code> можно увидеть в столбце <code>Cardinality</code> после
выполнения команды <code>SHOW INDEX FROM имя_таблицы</code>.

<LI>Чтобы отсортировать индекс и данные в соответствии с индексом,

используйте <code>myisamchk --sort-index --sort-records=1</code> (если нужно
отсортировать по индексу 1). Если имеется уникальный индекс, по
которому вы хотите считывать все записи в порядке, соответствующем
данному индексу, это - хороший способ ускорить считывание записей.
Обратите внимание, однако, что эта сортировка написана не оптимально и
для большой таблицы будет выполняться долго!
</ul>



<H3><A NAME="Where_optimisations" HREF="manual.ru_toc.html#Where_optimisations">5.2.4  Как MySQL оптимизирует выражения <code>WHERE</code></A></H3>

<P>
<A NAME="IDX865"></A>

</P>
<P>
<A NAME="IDX866"></A>

</P>
<P>
Описание оптимизации выражений <code>WHERE</code> помещено в раздел, посвященный
<code>SELECT</code>, потому что они главным образом используются в запросах <code>SELECT</code>, но
для выражений <code>WHERE</code> в операторах <code>DELETE</code> и <code>UPDATE</code> используются те же
способы оптимизации.

</P>
<P>
Отметим также, что данный раздел неполон. В MySQL реализовано много
возможностей оптимизации, и у нас не было времени, чтобы задокументировать
их все.

</P>
<P>
Ниже перечислены некоторые из оптимизации, выполняемых MySQL:

</P>

<ul>

<LI>Удаляются ненужные скобки:


<pre>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&#62; (a AND b AND c) OR (a AND b AND c AND d)
</pre>

<LI>Константы заменяются значениями:


<pre>
   (a&#60;b AND b=c) AND a=5
-&#62; b&#62;5 AND b=c AND a=5
</pre>

<LI>Удаляются условия для констант (требуется при замене констант

значением):

<pre>
   (B&#62;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&#62; B=5 OR B=6
</pre>

<LI>Константные выражения, используемые индексами, оцениваются только один

раз.

<LI>Для таблиц <code>HEAP</code> и <code>MyISAM</code> функция <code>COUNT(*)</code>, которая вызывается для

одной таблицы и не содержит предложения <code>WHERE</code>, берется непосредственно
из табличной информации. Это делается также для любого выражения <code>NOT</code>
<code>NULL</code>, в котором используется только одна таблица.

<LI>Недопустимые константные выражения выявляются на ранних этапах. MySQL

быстро обнаруживает, что некоторые операторы <code>SELECT</code> неосуществимы и не
возвращают строк.

<LI>Выполняется слияние выражения <code>HAVING</code> с <code>WHERE</code>, если не используется

предложение <code>GROUP BY</code> или групповые функции (<code>COUNT(), MIN()...</code>).

<LI>Для каждого подчиненного связывания создается более простое

предложение <code>WHERE</code>, чтобы ускорить оценку <code>WHERE</code> для каждого
подчиненного связывания а также чтобы пропустить записи как можно
быстрее.

<LI>Все константные таблицы считываются в первую очередь, перед любыми

другими таблицами в запросе. К константным таблицам относятся
следующие:


<ul>

<LI>Пустая таблица или таблица с 1 строкой.

<LI>Таблица, которая используется с выражением <code>WHERE</code> для индекса <code>UNIQUE</code>,

или <code>PRIMARY KEY</code>, где все части индекса используются с константными
выражениями и части индекса определены как <code>NOT NULL</code>.
</ul>

Все эти таблицы используются как константные таблицы:


<pre>
mysql&#62; SELECT * FROM t WHERE primary_key=1;
mysql&#62; SELECT * FROM t1,t2
    -&#62;          WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
</pre>

<LI>Лучшая комбинацию связывания для связывания таблиц находится путем

испытания всех возможных вариантов. Если все столбцы в предложениях
<code>ORDER BY</code> и <code>GROUP BY</code> принадлежат одной таблице, эта таблица
рассматривается первой при связывании.

<LI>Если имеется выражение <code>ORDER BY</code> и отличное от него выражение <code>GROUP BY</code>,

или если выражения <code>ORDER BY</code> или <code>GROUP BY</code> содержат столбцы не только из
первой таблицы в очереди на связывание, но и из других таблиц, то
тогда создается временная таблица.

<LI>Если используется <code>SQL_SMALL_RESULT</code>, MySQL будет применять временную

таблицу, которую разместит в памяти.

<LI>Запрашивается каждый индекс таблицы, и используется лучший,

охватывающий менее 30% строк. Если такой индекс найти нельзя,
используется быстрое сканирование таблицы.

<LI>В некоторых случаях MySQL может читать данные из индекса даже без

обращения к файлу данных. Если все столбцы, используемые в индексе,
числовые, то для выполнения запроса будет использоваться только
индексное дерево.

<LI>Перед выводом каждой записи пропускаются те, которые не соответствуют

выражению <code>HAVING</code>.
</ul>

<P>
Вот некоторые примеры очень быстрых запросов:

</P>

<pre>
mysql&#62; SELECT COUNT(*) FROM tbl_name;
mysql&#62; SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
mysql&#62; SELECT MAX(key_part2) FROM tbl_name
    -&#62;        WHERE key_part_1=constant;
mysql&#62; SELECT ... FROM tbl_name
    -&#62;        ORDER BY key_part1,key_part2,... LIMIT 10;
mysql&#62; SELECT ... FROM tbl_name
    -&#62;        ORDER BY key_part1 DESC,key_part2 DESC,... LIMIT 10;
</pre>

<P>
Для выполнения следующих запросов используется только индексное дерево
(предполагается, что индексированные столбцы числовые):

</P>


<pre>
mysql&#62; SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
mysql&#62; SELECT COUNT(*) FROM tbl_name
    -&#62;        WHERE key_part1=val1 AND key_part2=val2;
mysql&#62; SELECT key_part2 FROM tbl_name GROUP BY key_part1;
</pre>

<P>
Следующие запросы используют индексацию, чтобы получить отсортированные
строки без дополнительного прохода для сортировки:

</P>


<pre>
mysql&#62; SELECT ... FROM tbl_name
    -&#62;            ORDER BY key_part1,key_part2,... ;
mysql&#62; SELECT ... FROM tbl_name
    -&#62;            ORDER BY key_part1 DESC,key_part2 DESC,... ;
</pre>



<H3><A NAME="DISTINCT_optimisation" HREF="manual.ru_toc.html#DISTINCT_optimisation">5.2.5  Как MySQL оптимизирует <code>DISTINCT</code></A></H3>

<P>
<A NAME="IDX867"></A>

</P>
<P>
<A NAME="IDX868"></A>

</P>
<P>
<code>DISTINCT</code> преобразовывается к <code>GROUP BY</code> для всех столбцов, для <code>DISTINCT</code> в
сочетании с <code>ORDER BY</code>, помимо этого, во многих случаях также требуется
временная таблица.

</P>
<P>
Если <code>LIMIT #</code> указывается совместно с <code>DISTINCT</code>, MySQL остановится, как
только найдет # уникальных строк.

</P>
<P>
Если не все столбцы и не во всех таблицах используются, MySQL прекратит
сканирование неиспользуемых таблиц, как только найдет первое совпадение.

</P>

<pre>
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
</pre>

<P>
В случае, если, предположим, таблица <code>t1</code> используется перед <code>t2</code> (это
проверяется при помощи <code>EXPLAIN</code>), MySQL прекратит чтение в <code>t2</code> (для каждой
отдельной строки из <code>t1</code>), после того как найдет первую строку в <code>t2</code>.

</P>


<H3><A NAME="LEFT_JOIN_optimisation" HREF="manual.ru_toc.html#LEFT_JOIN_optimisation">5.2.6  Как MySQL оптимизирует <code>LEFT JOIN</code> и <code>RIGHT JOIN</code></A></H3>

<P>
<A NAME="IDX869"></A>

</P>
<P>
<A NAME="IDX870"></A>

</P>
<P>
Выражение "<code>A LEFT JOIN B</code>" в MySQL реализовано следующим образом:

</P>

<ul>
<LI>Таблица B устанавливается как зависимая от таблицы A и от всех таблиц,

от которых зависит A.

<LI>Таблица A устанавливается как зависимая ото всех таблиц (кроме B),

которые используются в условии <code>LEFT JOIN</code>.

<LI>Все условия <code>LEFT JOIN</code> перемещаются в предложение <code>WHERE</code>.

<LI>Выполняются все стандартные способы оптимизации соединения, за

исключением того, что таблица всегда читается после всех таблиц, от
которых она зависит. Если имеется циклическая зависимость, MySQL
выдаст ошибку.

<LI>Выполняются все стандартные способы оптимизации <code>WHERE</code>.

<LI>Если в таблице A имеется строка, соответствующая выражению <code>WHERE</code>, но в

таблице B ни одна строка не удовлетворяет условию <code>LEFT JOIN</code>,
генерируется дополнительная строка B, в которой все значения столбцов
устанавливаются в <code>NULL</code>.

<LI>Если <code>LEFT JOIN</code> используется для поиска тех строк, которые отсутствуют

в некоторой таблице, и в предложении <code>WHERE</code> выполняется следующая
проверка: <code>column_name IS NULL</code>, где <code>column_name</code> - столбец, который
объявлен как <code>NOT NULL</code>, MySQL пререстанет искать строки (для отдельной
комбинации ключа) после того, как найдет строку, соответствующую
условию <code>LEFT JOIN</code>.
</ul>

<P>
<code>RIGHT JOIN</code> реализован аналогично <code>LEFT JOIN</code>.

</P>
<P>
При указании жесткого порядка чтения таблиц в <code>LEFT JOIN</code> и <code>STRAIGHT JOIN</code>
оптимизатор связей (который определяет, в каком порядке
таблицы должны быть связаны) будет выполнять работу намного быстрее, так
как ему потребуется проверять меньшее количество перестановок таблиц.

</P>
<P>
Обратите внимание: отсюда следует, что если выполняется запрос типа

</P>

<pre>
SELECT * FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key)
         WHERE b.key=d.key
</pre>

<P>
MySQL будет делать полный просмотр таблицы <code>b</code>, поскольку <code>LEFT JOIN</code> заставит
его читать эту таблицу перед <code>d</code>.

</P>
<P>
В этом случае, чтобы предотвратить полный просмотр таблицы <code>b</code>, нужно
изменить запрос таким образом:

</P>

<pre>
SELECT * FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key)
         WHERE b.key=d.key
</pre>



<H3><A NAME="ORDER_BY_optimisation" HREF="manual.ru_toc.html#ORDER_BY_optimisation">5.2.7  Как MySQL оптимизирует <code>ORDER BY</code></A></H3>

<P>
В некоторых случаях MySQL может использовать индекс, чтобы выполнить
запрос <code>ORDER BY</code> или <code>GROUP BY</code> без выполнения дополнительной сортировки.

</P>
<P>
Индекс может также использоваться и тогда, когда предложение <code>ORDER BY</code> не
соответствует индексу в точности, если все неиспользуемые части индекса и
все столбцы, не указанные в <code>ORDER BY</code> - константы в выражении <code>WHERE</code>.
Следующие запросы будут использовать индекс, чтобы выполнить 
<code>ORDER BY / GROUP BY</code>.

</P>

<pre>
SELECT * FROM t1 ORDER BY key_part1,key_part2,...
SELECT * FROM t1 WHERE key_part1=constant ORDER BY key_part2
SELECT * FROM t1 WHERE key_part1=constant GROUP BY key_part2
SELECT * FROM t1 ORDER BY key_part1 DESC,key_part2 DESC
SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC,key_part2 DESC
</pre>

<P>
Ниже приведены некоторые случаи, когда MySQL <strong>не может</strong> использовать
индексы, чтобы выполнить <code>ORDER BY</code> (обратите внимание, что MySQL тем не
менее будет использовать индексы, чтобы найти строки, соответствующие
выражению <code>WHERE</code>):

</P>

<ul>
<LI>

Сортировка <code>ORDER BY</code> делается по нескольким ключам: 
<code>SELECT * FROM t1 ORDER BY key1,key2</code>

<LI>

Сортировка <code>ORDER BY</code> делается, при использовании непоследовательных
частей  ключа: <code>SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2</code>

<LI>

Смешиваются <code>ASC</code> и <code>DESC</code>. 
<code>SELECT * FROM t1 ORDER BY key_part1 DESC,key_part2 ASC</code>

<LI>

Для выборки строк и для сортировки <code>ORDER BY</code> используются разные ключи:
<code>SELECT * FROM t1 WHERE key2=constant ORDER BY key1</code>

<LI>

Связываются несколько таблиц, и столбцы, по которым делается
сортировка <code>ORDER BY</code>, относятся не только к первой неконстантной
(const) таблице, используемой для выборки строк (это первая таблица в
выводе <code>EXPLAIN</code>, в которой не используется константный, <code>const</code>, метод
выборки строк).

<LI>

Имеются различные выражения <code>ORDER BY</code> и <code>GROUP BY</code>.

<LI>

Используемый индекс таблицы имеет такой тип, который не обеспечивает
сортированного хранения строк (как индекс <code>HASH</code> в таблицах <code>HEAP</code>).

</ul>

<P>
В тех случаях, когда MySQL должен сортировать результат, он использует
следующий алгоритм:

</P>

<ul>
<LI>

Считываются все строки согласно ключу или путем сканирования таблицы.
Строки, которые не соответствует предложению WHERE, пропускаются.

<LI>

Ключ сортировки сохраняется в буфере сортировки (размера <code>sort_buffer</code>)

<LI>

Когда буфер заполняется, содержимое буфера сортируется алгоритмом
<code>qsort</code>, результаты сохраняются во временном файле. Сохраняется
указатель на отсортированный блок (в том случае, когда все строки
умещаются в буфере сортировки, временный файл не создается).

<LI>

Вышеупомянутое действие повторяется, пока не будут считаны все строки.

<LI>

Делается мультислияние до <code>MERGEBUFF</code> (7) областей в один блок в другом
временном файле. Это действие повторяется, пока все блоки из первого
файла не окажутся во втором файле.

<LI>

Предыдущий пункт повторяется, пока не останется менее <code>MERGEBUFF2</code> (15)
блоков.

<LI>

При последнем мультислиянии в результирующий файл записывается только
указатель на строку (последняя часть ключа сортировки).

<LI>

Теперь код в файле <tt>`sql/records.cc'</tt> будет использоваться для чтения
данных в отсортированном порядке, с использованием указателей на
строки из результирующего файла. Чтобы оптимизировать этот процесс, мы
считываем большой блок указателей на строки, сортируем их, и затем
считываем строки в отсортированном порядке в буфер строк
(<code>record_rnd_buffer</code>).
</ul>

<P>
При помощи команды <code>EXPLAIN SELECT ... ORDER BY</code> можно проверить, может ли
MySQL использовать индексы для выполнения запроса. Если в столбце <code>extra</code>
содержится значение <code>Using filesort</code>, то MySQL не может использовать индексы
для выполнения сортировки <code>ORDER BY</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A>.

</P>
<P>
Чтобы сортировка <code>ORDER BY</code> выполнялась с большей скоростью, нужно сначала
посмотреть, можно ли заставить MySQL использовать индексы взамен
дополнительной фазы сортировки. Если это невозможно, то можно сделать
следующее:

</P>

<ul>
<LI>

Увеличить значение переменной <code>sort_buffer</code>.

<LI>

Увеличить значение переменной <code>record_rnd_buffer</code>.

<LI>

Изменить переменную <code>tmpdir</code>, чтобы она указывала на выделенный диск с
большим количеством свободного пространства.
Начиная с MySQL 4.1, в <code>tmpdir</code> могут быть указаны несколько путей, разделенных
двоеточием <code>:</code> (точкой с запятой на Windows <code>;</code>). Эти пути будут 
использованы в ротации. 

<strong>Внимание:</strong> Эти пути должны находится на разных <strong>физических</strong>
дисках, не на разных разделах одного и того же диска. 

</ul>

<P>
MySQL по умолчанию сортирует все <code>GROUP BY x,y[,...]</code> запросы так, как
если бы вы указали <code>ORDER BY x,y[,...]</code>. MySQL будет оптимизировать любой
<code>ORDER BY</code> как сказано выше, без всяких потерь производительности. Если,
как в некоторых случаях, вы не хотите иметь результат отсортированным, вы
можете указать <code>ORDER BY NULL</code>: 

</P>

<pre>
INSERT INTO foo SELECT a,COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
</pre>



<H3><A NAME="LIMIT_optimisation" HREF="manual.ru_toc.html#LIMIT_optimisation">5.2.8  Как MySQL оптимизирует <code>LIMIT</code></A></H3>

<P>
<A NAME="IDX871"></A>

</P>
<P>
<A NAME="IDX872"></A>

</P>
<P>
В некоторых случаях, когда используется <code>LIMIT #</code> и не используется <code>HAVING</code>,
MySQL будет выполнять запрос несколько иначе:

</P>

<ul>
<LI>

Если при помощи <code>LIMIT</code> выбираются только несколько строк, MySQL будет
использовать индексы в тех некоторых случаях, когда он обычно
предпочел бы делать полное сканирование таблицы.

<LI>

Если <code>LIMIT #</code> используется с <code>ORDER BY</code>, MySQL закончит сортировку, как
только найдет первые <code>#</code> строк, вместо того, чтобы сортировать всю
таблицу.

<LI>

При сочетании <code>LIMIT #</code> с <code>DISTINCT</code> MySQL остановится, как только найдет
<code>#</code> уникальных строк.

<LI>

В некоторых случаях группировка <code>GROUP BY</code> может быть выполнена путем
упорядоченного считывания ключа (или путем выполнения сортировки по
ключу) и последующего вычисления итогового результата пока не
изменится значение ключа. В этом случае <code>LIMIT #</code> не будет вычислять
какие-либо ненужные предложения <code>GROUP BY</code>.

<LI>

После того как MySQL пошлет первые <code>#</code> строк клиенту, он прервет
выполнение запроса (если не используется <code>SQL_CALC_FOUND_ROWS</code>).

<LI>

<code>LIMIT 0</code> всегда будет быстро возвращать пустую выборку. Эта команда
полезна для проверки запроса и получения типов столбцов результата.

<LI>

Если сервер для выполнения запроса использует временные таблицы, <code>LIMIT
#</code> применяется для вычисления того, сколько для них потребуется места.
</ul>



<H3><A NAME="Insert_speed" HREF="manual.ru_toc.html#Insert_speed">5.2.9  Скорость выполнения запросов <code>INSERT</code></A></H3>

<P>
<A NAME="IDX873"></A>

</P>
<P>
<A NAME="IDX874"></A>
<A NAME="IDX875"></A>

</P>
<P>
Время, необходимое для вставки записи, можно грубо разделить на такие
промежутки:

</P>

<ul>
<LI>

Подсоединение: (3)
<LI>

Посылка запроса на сервер: (2)
<LI>

Синтаксический анализ запроса: (2)
<LI>

Вставка записи: (1 * размер записи)
<LI>

Вставка индексов: (1 * число индексов)
<LI>

Закрытие: (1)
</ul>

<P>
где числа в скобках пропорциональны полному времени. При этом не
учитывается время в начале вставки, требующееся для открытия таблиц
(таблицы открываются один раз для каждого конкурентно выполняющегося
запроса).

</P>
<P>
Размер таблицы замедляет вставку индексов в <code>log N</code> раз (B-деревья).

</P>
<P>
Некоторые способы ускорения вставки:

</P>

<ul>
<LI>

Если с одного клиента одновременно вставляется большое количество
строк, используйте операторы <code>INSERT</code> в форме, содержащей множество
записей. При этом вставка будет происходить намного быстрее (в
некоторых случаях в несколько раз), чем при использовании отдельных
операторов <code>INSERT</code>. При добавлении данных в непустую таблицу можно
настроить переменную <code>bulk_insert_buffer_size</code> так, чтобы это
делалось еще быстрее. See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>.

<LI>

При вставке нескольких строк с различных клиентов можно повысить
скорость, используя оператор <code>INSERT DELAYED</code>. See section <A HREF="manual.ru_Reference.html#INSERT">6.4.3  Синтаксис оператора <code>INSERT</code></A>.

<LI>

Обратите внимание: при использовании таблиц <code>MyISAM</code> можно вставлять
строки во время выполнения операторов <code>SELECT</code>, если в таблицах нет
удаленных строк.

<LI>

При загрузке таблицы из текстового файла используйте команду <code>LOAD DATA
INFILE</code>. При этом обычно вставка будет происходить в 20 раз быстрее,
чем при использовании соответствующего количества операторов <code>INSERT</code>.
See section <A HREF="manual.ru_Reference.html#LOAD_DATA">6.4.9  Синтаксис оператора  <code>LOAD DATA INFILE</code></A>.

<LI>

Если таблица имеет много индексов, можно проделать некоторую
дополнительную работу, чтобы команда <code>LOAD DATA INFILE</code> выполнялась еще
быстрее. Используйте следующую процедуру:


<ol>

<LI>

При необходимости создайте таблицу при помощи оператора <code>CREATE TABLE</code>
(например, используя <code>mysql</code> или <code>Perl-DBI</code>).

<LI>

Выполните оператор <code>FLUSH TABLES</code> или команду оболочки: 
<code>mysqladmin flush-tables</code>.

<LI>

Используйте <code>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</code>. После
этого индексы не будут использоваться для данной таблицы.

<LI>

Вставьте данные в таблицу при помощи <code>LOAD DATA INFILE</code>. При этом
никакие индексы обновляться не будут и, следовательно, скорость будет
высокой весьма.

<LI>

Если вы собираетесь в будущем только лишь читать таблицу, выполните
<code>myisampack</code> для этой таблицы, чтобы уменьшить ее размер. See section <A HREF="manual.ru_MySQL_Database_Administration.html#myisampack">4.7.4  <code>myisampack</code>, MySQL-генератор сжатых таблиц (только для чтения)</A>.

<LI>

Воссоздайте индексы при помощи команды <code>myisamchk -r -q
/path/to/db/tbl_name</code>. Эта процедура создает индексное дерево в памяти,
перед тем как записать его на диск, что гораздо быстрее за счет
исключения большого количества дисковых операций. Индексное дерево,
получившееся в результате, к тому же отлично сбалансировано.

<LI>

Выполните оператор <code>FLUSH TABLES</code> или команду оболочки: 
<code>mysqladmin flush-tables</code>.
</ol>

Обратите внимание: команда <code>LOAD DATA INFILE</code> также выполняет вышеупомянутую
оптимизацию при вставках в пустую таблицу. Главное отличие этой команды от
вышеупомянутой процедуры заключается в том, что при помощи <code>myisamchk</code> можно
выделить намного больше временной памяти для создания индекса, чем MySQL,
по вашему мнению, должен выделять для каждого воссоздания индексов.
Начиная с MySQL 4.0 можно также использовать команду <code>ALTER TABLE tbl_name
DISABLE KEYS</code> вместо <code>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</code> и
<code>ALTER TABLE tbl_name ENABLE KEYS</code> вместо <code>myisamchk -r -q
/path/to/db/tbl_name</code>. Таким образом можно также пропускать шаги <code>FLUSH
TABLES</code>.

<LI>

Можно ускорять операции вставки, выполняемые несколькими операторами,
путем установки блокировки таблиц:


<pre>
mysql&#62; LOCK TABLES a WRITE;
mysql&#62; INSERT INTO a VALUES (1,23),(2,34),(4,33);
mysql&#62; INSERT INTO a VALUES (8,26),(6,29);
mysql&#62; UNLOCK TABLES;
</pre>

Главный фактор, влияющий на скорость, - то, что буфер индексов
сбрасывается на диск только один раз, после завершения всех операторов
<code>INSERT</code>. Обычно содержимое индексных буферов сбрасывалось бы на диск
столько раз, сколько имеется различных операторов <code>INSERT</code>. Блокировка не
нужна, если можно вставить все строки при помощи одного оператора. Для
транзакционных таблиц, чтобы повысить скорость, следует использовать
<code>BEGIN/COMMIT</code> вместо <code>LOCK TABLES</code>. Блокировка также понизит полное время
проверки подсоединений (multi-connection tests), но максимальное время
ожидания для некоторых потоков повысится (потому что они ожидают снятия
блокировки). Например:


<pre>
поток 1 делает 1000 вставок
потоки 2, 3 и 4 делают 1 вставку
поток 5 делает 1000 вставок
</pre>

Если блокировка не используется, 2, 3, и 4 завершат выполнение раньше, чем
1 и 5. Если блокировка используется, 2, 3 и 4, видимо, не закончат
выполнение раньше, чем 1 или 5, но общее время должно приблизительно
уменьшиться на 40%. Так как в MySQL операции <code>INSERT</code>, <code>UPDATE</code> и <code>DELETE</code> очень
быстрые, общая производительность будет улучшаться, если добавлять
блокировки ко всем командам, делающим более 5 вставок или обновлений
подряд. Если делается очень много вставок строк, можно время от времени
сопровождать команду <code>LOCK TABLES</code> командой <code>UNLOCK TABLES</code> (после каждых 1000
строк), чтобы позволить другим потокам обращаться к таблице. Результатом
всего этого будет получение хорошей производительности. Конечно, для
загрузки данных намного более быстрой является команда <code>LOAD DATA INFILE</code>.

</ul>

<P>
Чтобы дополнительно повысить скорость выполнения команд <code>LOAD DATA INFILE</code> и
<code>INSERT</code>, увеличьте буфер ключа (<code>key buffer</code>). See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

</P>


<H3><A NAME="Update_speed" HREF="manual.ru_toc.html#Update_speed">5.2.10  Скорость выполнения запросов <code>UPDATE</code></A></H3>

<P>
<A NAME="IDX876"></A>

</P>
<P>
Запросы <code>UPDATE</code> оптимизируются как запрос <code>SELECT</code> с дополнительными
издержками на запись. Скорость записи зависит от размера обновляемых
данных и количества обновляемых индексов. Индексы, которые не были
изменены, обновлены не будут.

</P>
<P>
Существует и другой способ произвести операции обновления быстро:
задерживать операции обновления, а потом делаеть сразу несколько
обновлений. Несколько обновлений подряд выполняются намного быстрее, чем
отдельные обновления если вы блокируете таблицу.

</P>
<P>
Обратите внимание: при использовании динамического формата записи, если
запись обновляется более длинной, может произойти "расслоение" записи.
Таким образом, если вы делаете это часто, очень важно время от времени
выполнять команду <code>OPTIMIZE TABLE</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  Синтаксис  команды <code>OPTIMIZE TABLE</code></A>.

</P>


<H3><A NAME="Delete_speed" HREF="manual.ru_toc.html#Delete_speed">5.2.11  Скорость выполнения запросов <code>DELETE</code></A></H3>

<P>
Чтобы удалить все строки в таблице, нужно использовать команду <code>TRUNCATE
TABLE table_name</code>. See section <A HREF="manual.ru_Reference.html#TRUNCATE">6.4.7  Синтаксис оператора <code>TRUNCATE</code></A>.

</P>
<P>
Время, необходимое для удаления записи, прямо пропорционально числу
индексов. Чтобы записи удалялись быстрее, можно увеличить размер
индексного кэша. See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

</P>


<H3><A NAME="Tips" HREF="manual.ru_toc.html#Tips">5.2.12  Другие советы по оптимизации</A></H3>

<P>
<A NAME="IDX877"></A>
<A NAME="IDX878"></A>

</P>
<P>
Несортированные советы для повышения скорости систем:

</P>

<ul>
<LI>

Используйте постоянные соединения с базой данных, чтобы избежать
издержек на подключения. Если невозможно использовать постоянные
соединения и осуществляется большое количество новых подключений к
базе данных, то можно изменить значение переменной <code>thread_cache_size</code>.
See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

<LI>

Всегда проверяйте, чтобы все ваши запросы действительно использовали
созданные вами в таблицах индексы. В MySQL это можно сделать с помощью
команды <code>EXPLAIN</code>. See section <A HREF="manual.ru_MySQL_Optimisation.html#EXPLAIN">5.2.1  Синтаксис оператора <code>EXPLAIN</code> (получение информации о <code>SELECT</code>)</A>.

<LI>

Старайтесь избегать сложных запросов <code>SELECT</code> на часто обновляемых
таблицах типа MyISAM. Это помогает избежать проблем с блокировкой
таблиц.

<LI>

Новые таблицы MyISAM могут вносить записи в таблицу без удаляемых
записей, которые в то же самое время читает иная таблица. Если это
имеет для вас значение, то следует рассмотреть методы, не требующие
удаления записей или запускать <code>OPTIMIZE TABLE</code> после удаления большого
количества строк.

<LI>

Используйте <code>ALTER TABLE ... ORDER BY expr1,expr2...</code> если вы большей
частью извлекаете записи в порядке <code>expr1,expr2...</code> Можно получить более
высокую производительность, используя эту опцию после больших
преобразований в таблице.

<LI>

В некоторых случаях может оказаться целесообразным введение столбца,
базирующегося на "хэшированной" информации из других столбцов. Если
этот столбец невелик и достаточно уникален, то он может быть намного
быстрее, чем большой индекс на многих столбцах. В MySQL очень просто
использовать подобный дополнительный столбец: 

<code>SELECT * FROM table_name
WHERE hash=MD5(CONCAT(col1,col2)) AND col_1='constant' AND
col_2='constant</code>'

<LI>

Для часто изменяющихся таблиц следует избегать типов <code>VARCHAR</code> или <code>BLOB</code>
для всех столбцов. При использовании единичного столбца <code>VARCHAR</code> или
<code>BLOB</code> вы получите динамическую длину строки. See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>.

<LI>

Разделение таблицы на несколько различных таблиц просто потому, что
строки получаются "большими", обычно не приносит пользы. Чтобы
получить доступ к строке, наиболее трудоемким оказывается поиск по
диску для нахождения первого байта этой строки. После нахождения этих
данных большинство новых дисков могут прочесть всю строку достаточно
быстро для большинства приложений. Разделение таблицы имеет значение
только в следующих случаях: когда это таблица с динамическим размером
строки (смотрите выше), которую можно изменить на строку
фиксированного размера, или когда необходимо просматривать таблицу
очень часто и нет необходимости в большинстве столбцов.
See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>.

<LI>

Если очень часто приходится производить вычисления, базирующиеся на
информации из большого количества строк (такие как подсчет
предметов), то, вероятно, намного лучше ввести новую таблицу и
обновлять счетчик в режиме реального времени. Обновление вида <code>UPDATE
table SET count=count+1 WHERE index_column=constant</code> является очень
быстрым! 

Это действительно важно при использовании типов таблиц MySQL, вроде MyISAM или
ISAM, имеющих только блокирование таблиц (многочисленные читающие/единственный
записывающий). Для многих баз данных это обеспечит также более высокую
производительность, поскольку программа управления блокировкой строк в этом
случае будет иметь меньше работы.

<LI>

Если необходимо собирать статистические данные из больших журнальных
таблиц, то используйте сводные таблицы вместо сканирования целой
таблицы. Поддерживать сводные таблицы должно быть намного быстрее, чем
пытаться сделать ``живую'' статистику. Намного быстрее воспроизвести
новые сводные таблицы из журналов, когда что-либо изменяется (в
зависимости от деловых решений), чем изменять работающее приложение!

<LI>

Если возможно, необходимо классифицировать отчеты как "реальные" или
"статистические", где данные, необходимые для статистических
отчетов, генерируются только на основе сводных таблиц, которые
формируются из реальных данных.

<LI>

Воспользуйтесь преимуществом того факта, что столбцы имеют значения по
умолчанию. Вносите величины явно только тогда, когда значения вносимых
величин отличаются от установленных по умолчанию. Это уменьшает объем
анализа, который необходимо произвести в MySQL, и улучшает скорость
внесения.

<LI>

В некоторых случаях удобно упаковывать и хранить данные в столбцах
<code>BLOB</code>. В этом случае необходимо добавить дополнительный код для
запаковывания в <code>BLOB</code> и распаковывания обратно, но на некотором этапе
это может сэкономить много обращений. Это практично, когда ваши данные
не согласуются со структурой статической таблицы.

<LI>

Обычно следует стремиться сохранять все данные в безизбыточной форме
(которая называется 3-й нормальной формой в теории баз данных), но не
следует опасаться дублирования данных или создания сводных таблиц,
если это необходимо для достижения большей скорости.

<LI>

Хранимые процедуры или <code>UDF</code> (функции, определяемые пользователем) могут
быть хорошим способом получить большую производительность. В этом
случае, однако, следует иметь в запасе некоторый иной (более
медленный) путь, если используемая вами база данных не поддерживает
этих возможностей.

<LI>

Вы всегда можете кое-чего достичь путем кэширования запросов/ответов в
своем приложении и стараясь выполнить много вставок/обновлений в одно
и то же время. Если ваша база данных поддерживает блокировку таблиц
(как MySQL и Oracle), то это должно помочь гарантировать, что кэш
индексов сбрасывается только однажды после всех обновлений.

<LI>

Используйте <code>INSERT /*! DELAYED */</code>, если нет необходимости знать,
когда ваши данные записываются. Это повысит скорость работы, поскольку
многие табличные записи могут быть внесены с помощью одной дисковой
записи.

<LI>

Используйте <code>INSERT /*! LOW_PRIORITY */</code>, если хотите сделать ваши
выборки более важными.

<LI>

Используйте <code>SELECT /*! HIGH_PRIORITY */</code>, чтобы получить выборки,
которые перепрыгивают очередь. То есть, выборка выполняется, даже если
кто-либо ожидает, чтобы сделать запись.

<LI>

Используйте многострочную команду <code>INSERT</code> для хранения многих строк в
одной SQL-команде (многие SQL-серверы поддерживают это).

<LI>

Используйте <code>LOAD DATA INFILE</code> для загрузки больших количеств данных.
Это быстрее, чем обычные вставки и будет еще быстрее при интеграции
<code>myisamchk</code> в <code>mysqld</code>.

<LI>

Используйте столбцы <code>AUTO_INCREMENT</code>, чтобы сделать величины
уникальными.

<LI>

Используйте время от времени <code>OPTIMIZE TABLE</code>, чтобы избежать
фрагментации при использовании динамического табличного формата.
See section <A HREF="manual.ru_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  Синтаксис  команды <code>OPTIMIZE TABLE</code></A>.

<LI>

Используйте таблицы <code>HEAP</code>, чтобы получить более высокую скорость,
когда это возможно. See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>.

<LI>

При использовании нормальной установки веб-сервера рисунки должны
храниться как файлы. То есть, храните в базе данных только ссылку на
файл. Главная причина этого состоит в том, что обычный веб-сервер
намного лучше кэширует файлы, чем содержание базы данных. Таким
образом, при использовании файлов намного легче получить быструю
систему.

<LI>

Используйте в памяти таблицы для неответственных данных, к которым
часто обращаются (таким, как информация о последнем показанном баннере
для пользователей, не имеющих cookies).

<LI>

Столбцы с идентичной информацией в различных таблицах должны
объявляться одинаково и иметь одинаковые имена. До версии 3.23 в
противном случае получались медленные соединения (slow joins).
Старайтесь сохранять имена простыми (используйте <code>name</code> вместо
<code>customer_name</code> в таблице <code>customer</code>). Чтобы ваши имена были переносимыми
на другие SQL-серверы, они должны быть короче, чем 18 символов.

<LI>

Если вам действительно нужна высокая скорость, вы должны взглянуть на
интерфейсы нижнего уровня для хранения данных, поддерживаемые
различными SQL-серверами! Например, обращаясь к таблицам <code>MyISAM</code> в
MySQL напрямую, можно было бы получить увеличение скорости в 2-5 раз
по сравнению с использованием интерфейса SQL. Для возможности сделать
это, данные должны находиться на том же самом сервере, что и
приложение, и, обычно, должны иметь доступ только в одном процессе
обработки (поскольку внешняя файловая блокировка действительно
медленна). Можно было бы избавиться от вышеуказанных проблем введением
низко-уровневых команд <code>MyISAM</code> в сервере MySQL (это был бы один из
простых путей получить большую производительность, если необходимо).
Путем тщательного проектирования интерфейса базы данных было бы
достаточно просто поддерживать этот тип оптимизации.

<LI>

Во многих случаях быстрее получить доступ к данным из базы данных
(используя действующее соединение), чем обращаться к текстовому файлу,
просто из-за того, что база данных, вероятно, более компактна, чем
текстовый файл (если вы используете числовые данные), и это приведет к
меньшему количеству обращений к диску. Вы также сэкономите на коде,
поскольку не должны анализировать текстовые файлы, чтобы найти границы
строк и столбцов.

<LI>

Для увеличения скорости можно также использовать репликацию. 
See section <A HREF="manual.ru_MySQL_Database_Administration.html#Replication">4.10  Репликация в MySQL</A>.

<LI>

Объявление таблицы с <code>DELAY_KEY_WRITE=1</code> сделает обновление индексов
более быстрым, так как они не записываются на диск, пока файл закрыт.
Обратная сторона этого заключается в том, что необходимо запускать
<code>myisamchk</code> на этих таблицах перед началом работы <code>mysqld</code>, для
уверенности, что все в порядке, если что-либо уничтожит <code>mysqld</code> в
середине работы. Поскольку ключевая информация всегда может быть
воспроизведена из данных, то вы не должны что-либо потерять при
использовании <code>DELAY_KEY_WRITE</code>.
</ul>



<H2><A NAME="Locking_Issues" HREF="manual.ru_toc.html#Locking_Issues">5.3  Вопросы блокировок</A></H2>



<H3><A NAME="Internal_locking" HREF="manual.ru_toc.html#Internal_locking">5.3.1  Как MySQL блокирует таблицы</A></H3>

<P>
<A NAME="IDX879"></A>
<A NAME="IDX880"></A>
<A NAME="IDX881"></A>

</P>
<P>
Описание различных методов блокировки дается в приложении, в разделе
section <A HREF="manual.ru_Porting.html#Locking_methods">E.4  Методы блокировки</A>.

</P>
<P>
В MySQL все блокировки, кроме блокировок таблиц типов <code>InnoDB</code> <code>и</code> BDB, не
создают тупиковых ситуаций. Это обеспечивается за счет того, что все
необходимые блокировки всегда запрашиваются единожды в начале запроса и
блокировка таблиц всегда происходит в одном и том же порядке.

</P>
<P>
В таблицах типа <code>InnoDB</code> устанавливается блокировка строк, а в таблицах типа
<code>BDB</code> - блокировка страниц в процессе выполнения SQL-команд, а не в начале
транзакции.

</P>
<P>
Метод блокирования, используемый в MySQL для блокировок записи (<code>WRITE</code>),
работает следующим образом:

</P>

<ul>
<LI>

Если на данной таблице нет никаких блокировок, то на нее накладывается
блокировка записи.

<LI>

В противном случае запрос на данную блокировку ставится в очередь
блокировок записи.
</ul>

<P>
Метод блокирования, используемый в MySQL для блокировок чтения (<code>READ</code>),
работает следующим образом:

</P>

<ul>
<LI>

Если на данной таблице нет блокировок записи, то на нее накладывается
блокировка чтения.

<LI>

В противном случае запрос на данную блокировку ставится в очередь
блокировок чтения.
</ul>

<P>
При освобождении текущей блокировки становится возможной следующая
блокировка для потоков из очереди блокировок записи, затем для потоков из
очереди блокировок чтения.

</P>
<P>
Это означает, что, если таблица подвергается многочисленным обновлениям,
то команды <code>SELECT</code> будут ожидать, пока обновления не закончатся.

</P>
<P>
Чтобы обойти это в случае, когда для таблицы требуется выполнить много
операций <code>INSERT</code> и <code>SELECT</code>, можно внести строки во временную таблицу и время
от времени обновлять реальную таблицу записями из временной.

</P>
<P>
Для этого можно применить следующий код:

</P>

<pre>
mysql&#62; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&#62; INSERT INTO real_table SELECT * FROM insert_table;
mysql&#62; TRUNCATE TABLE insert_table;
mysql&#62; UNLOCK TABLES;
</pre>

<P>
В некоторых случаях, когда необходимо установить приоритеты извлечения
данных, для команд <code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code> можно указывать опцию
<code>LOW_PRIORITY</code>, а  для  команды   <code>SELECT</code> - <code>HIGH_PRIORITY</code>. Тот же результат
можно получить, запустив <code>mysqld</code> с <code>--low-priority-updates</code>.

</P>
<P>
Использование <code>SQL_BUFFER_RESULT</code> тоже способствует уменьшению времени
блокировок таблиц. See section <A HREF="manual.ru_Reference.html#SELECT">6.4.1  Синтаксис оператора <code>SELECT</code></A>.

</P>
<P>
Можно также изменить блокировочный код в <tt>`mysys/thr_lock.c'</tt> - чтобы
использовать только одну очередь блокировок. В этом случае блокировки
записи и чтения будут иметь одинаковый приоритет, что может оказаться
полезным для некоторых приложений.

</P>


<H3><A NAME="Table_locking" HREF="manual.ru_toc.html#Table_locking">5.3.2  Вопросы блокирования таблиц</A></H3>

<P>
<A NAME="IDX882"></A>

</P>
<P>
Код блокирования таблиц в MySQL не создает тупиковых ситуаций.

</P>
<P>
Чтобы получить высокую скорость блокирования, в MySQL на таблицах всех
типов, кроме <code>InnoDB</code> <code>и</code> BDB,используется табличная блокировка (вместо
блокирования строк или столбцов). Если таблицы большие, то для большинства
приложений табличная блокировка намного лучше, чем строковая, но
существуют, конечно, и определенные подводные камни.

</P>
<P>
Для таблиц типов <code>InnoDB</code> и <code>BDB</code> в MySQL табличная блокировка используется
только в случае, если данная таблица явно блокируется командой <code>LOCK
TABLES</code>. Мы вообще не рекомендуем применять <code>LOCK TABLES</code> для упомянутых
типов таблиц, поскольку для таблицы <code>InnoDB</code> используется автоматическая
блокировка строкового уровня, а для таблиц <code>BDB</code> - блокировка страничного
уровня. Это делается, чтобы гарантировать изоляцию транзакций.

</P>
<P>
В версии MySQL 3.23.7 и выше можно вставлять строки в таблицы MyISAM в то
время, когда другие потоки производят чтение из этой таблицы. Следует
учитывать, что в настоящее время эта функция работает только при условии,
что в таблице в момент вставки отсутствуют какие-либо пустые пространства,
оставшиеся после удаленных из нее записей. Как только все пустые места
будут заполнены новыми данными, автоматически будет восстановлена
возможность делать одновременные вставки.

</P>
<P>
Табличная блокировка обеспечивает возможность одновременного выполнения
чтения из таблицы несколькими потоками, но если какой-нибудь поток
попробует произвести запись в таблицу, то вначале он должен получить
исключительный доступ. Во время обновления таблицы все другие потоки,
стремящиеся получить доступ к этой конкретной таблице, будут ожидать, пока
данное обновление не будет завершено.

</P>
<P>
Поскольку обновление обычно считается более важной операцией, чем <code>SELECT</code>,
то все команды, производящие обновления таблицы, имеют более высокий
приоритет, чем команды извлечения данных. Такой алгоритм гарантирует, что
обновления не зависнут в случае, если для некоторой таблицы выполняется
большое количество тяжелых запросов (этот порядок действий можно изменить,
используя <code>LOW_PRIORITY</code> с командой обновления или <code>HIGH_PRIORITY</code> с командой
<code>SELECT</code>).

</P>
<P>
Начиная с версии MySQL 3.23.7 можно использовать переменную
<code>max_write_lock_count</code>, чтобы заставить MySQL временно предоставить всем
командам <code>SELECT</code>, ожидающим доступ к таблице, более высокий приоритет после
заданного числа вставок в таблицу.

</P>
<P>
Табличную блокировку, однако, нецелесообразно использовать в случае
следующего сценария:

</P>

<ul>
<LI>

Клиент запускает <code>SELECT</code>, требующий длительного времени для выполнения.

<LI>

Затем другой клиент запускает команду <code>UPDATE</code> на используемой таблице.
Этот клиент будет ожидать, пока <code>SELECT</code> не закончит свою работу.

<LI>

Другой клиент запускает еще одну команду <code>SELECT</code> на той же таблице.
Поскольку <code>UPDATE</code> имеет более высокий приоритет, чем <code>SELECT</code>, то эта
команда <code>SELECT</code> будет ждать, пока <code>UPDATE</code> не закончит свою работу. Кроме
того, вторая команда <code>SELECT</code> будет также ждать, пока не завершится
первая команда <code>SELECT</code>!

<LI>

Поток ждет ситуации заполненного диска. В таком случае все потоки,
которые хотят получить доступ к проблемной таблице, будут переведены в
состояние ожидания до тех пор, пока не освободится немного дискового
пространства.
</ul>

<P>
Ниже представлены некоторые возможные решения данной проблемы:

</P>

<ul>
<LI>

Постарайтесь заставить команды <code>SELECT</code> выполняться быстрее. Возможно,
для этого необходимо будет создать сводные таблицы.

<LI>

Запустите  <code>mysqld</code>  с  <code>--low-priority-updates</code>. Этим вы назначите всем
командам обновления таблицы более низкий приоритет, чем у команды 
<code>SELECT</code>. Тогда последняя команда <code>SELECT</code> в предыдущем сценарии будет
выполняться перед командой <code>INSERT</code>.

<LI>

Конкретным командам <code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code> можно назначить более
низкий приоритет с помощью атрибута <code>LOW_PRIORITY</code>.

<LI>

Запустите <code>mysqld</code> с небольшим значением <code>max_write_lock_count</code>, чтобы
разрешить блокировки чтения (<code>READ</code>) после определенного количества
блокировок записи (<code>WRITE</code>).

<LI>

SQL-командой: <code>SET LOW_PRIORITY_UPDATES=1</code> можно указать, что все
обновления из конкретного потока должны выполняться с низким
приоритетом. See section <A HREF="manual.ru_MySQL_Optimisation.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A>.

<LI>

Можно указать, что команда <code>SELECT</code> является очень важной, - с помощью
атрибута <code>HIGH_PRIORITY</code>. See section <A HREF="manual.ru_Reference.html#SELECT">6.4.1  Синтаксис оператора <code>SELECT</code></A>.

<LI>

Если имеются проблемы при выполнении команд  <code>INSERT</code> совместно с
<code>SELECT</code>, перейдите на новые таблицы <code>MyISAM</code>, которые поддерживают
одновременное выполнение команд <code>SELECT</code> и <code>INSERT</code>.

<LI>

Если совместно выполняются преимущественно команды <code>INSERT</code> и <code>SELECT</code>, то
решить возникающие при этом проблемы иногда помогает атрибут <code>DELAYED</code>
для <code>INSERT</code>. See section <A HREF="manual.ru_Reference.html#INSERT">6.4.3  Синтаксис оператора <code>INSERT</code></A>.

<LI>

Если имеются проблемы с командами <code>SELECT</code> и <code>DELETE</code>, то может помочь
опция <code>LIMIT</code> для <code>DELETE</code>. See section <A HREF="manual.ru_Reference.html#DELETE">6.4.6  Синтаксис оператора <code>DELETE</code></A>.
</ul>



<H2><A NAME="Optimising_Database_Structure" HREF="manual.ru_toc.html#Optimising_Database_Structure">5.4  Оптимизация структуры базы данных</A></H2>



<H3><A NAME="Design" HREF="manual.ru_toc.html#Design">5.4.1  Конструктивные особенности MySQL</A></H3>

<P>
<A NAME="IDX883"></A>
<A NAME="IDX884"></A>
<A NAME="IDX885"></A>

</P>
<P>
В MySQL данные и индексы хранятся отдельно, в разных файлах, в то время
как во многих (практически во всех) базах данных данные и индексы
помещаются вместе в одном и том же файле. Мы полагаем, что конструкция
MySQL лучше подходит для очень широкого диапазона современных систем.

</P>
<P>
Существует еще один способ хранения исходных данных - когда данные для
каждого столбца содержатся в отдельной области (примерами являются SDBM и
Focus). При такой организации данных неизбежно снижение производительности
для каждого запроса, затрагивающего более, чем один столбец. Поскольку при
доступе к более чем одному столбцу ситуация очень быстро начинает
ухудшаться, то мы полагаем, что эта модель не вполне годится для баз
данных общего назначения.

</P>
<P>
Модель, когда индексы и данные хранятся вместе (как в Oracle/Sybase и
других), встречается чаще. В этом случае запись будет находиться в
странице соответствующего индекса. Преимущества такой схемы во многих
случаях заключаются в том, что считывание с диска получается более
экономным - в зависимости от того, насколько хорошо кэшируется индекс.
Недостатки же здесь следующие:

</P>

<ul>
<LI>

Сканирование таблиц выполняется намного медленнее, поскольку
необходимо прочитать индексы, чтобы добраться до данных.

<LI>

Нельзя использовать только таблицу индексов для извлечения данных по
запросу.

<LI>

Теряется много дискового пространства, поскольку необходимо
дублировать индексы из узлов (так как нельзя хранить строку в узлах)

<LI>

Удаления со временем приводят к вырождению таблицы (так как индексы в
узлах обычно не обновляются при операции удаления).

<LI>

Более сложно выполняется кэширование только данных об индексах.
</ul>



<H3><A NAME="Data_size" HREF="manual.ru_toc.html#Data_size">5.4.2  Сделайте объем данных как можно меньше</A></H3>

<P>
<A NAME="IDX886"></A>
<A NAME="IDX887"></A>
<A NAME="IDX888"></A>
<A NAME="IDX889"></A>
<A NAME="IDX890"></A>

</P>
<P>
Одна из основных задач оптимизации заключается в том, чтобы данные (и
индексы) занимали как можно меньше места на диске (и в памяти). Это дает
значительные преимущества в работе, поскольку ускоряется чтение диска, а
оперативная память, как правило, используется меньше. Индексирование также
требует меньших ресурсов, если оно выполняется на меньших столбцах.

</P>
<P>
MySQL поддерживает большое количество различных типов таблиц и форматов
строк. Значительный выигрыш в производительности можно получить за счет
правильного выбора формата таблицы (see section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>).

</P>
<P>
Чтобы увеличить производительность работы с таблицей и минимизировать
требуемое пространство памяти, можно применять перечисленные ниже
технические приемы:

</P>

<ul>
<LI>

Используйте по возможности наиболее эффективные (наименьшие по объему)
типы данных. В MySQL имеется много специализированных типов данных,
применение которых позволяет экономить пространство на диске и в
памяти.

<LI>

Используйте, если это возможно, целочисленные типы меньшей длины,
чтобы получить таблицы меньшего размера. Например, <code>MEDIUMINT</code> часто
лучше, чем <code>INT</code>.

<LI>

Объявляйте везде, где возможно, столбцы как <code>NOT NULL</code>. Это позволяет
ускорить все операции и сэкономить по одному биту для каждого столбца.
Однако если для данного приложения действительно нужен <code>NULL</code>, то вы
все-таки его (<code>NULL</code>) используйте. Нужно просто избегать наличия <code>NULL</code> во
всех столбцах по умолчанию.

<LI>

Если отсутствуют какие-либо столбцы переменной длины (столбцы типов
<code>VARCHAR</code>, <code>TEXT</code> или <code>BLOB</code>), то нужно применять формат записи
фиксированного размера. Такой метод дает увеличение скорости, но при
этом, к сожалению, может потребоваться лишнее место на диске. 
See section <A HREF="manual.ru_Table_types.html#MyISAM_table_formats">7.1.2  Форматы таблиц <code>MyISAM</code></A>.

<LI>

Первичные индексы в таблице должны быть как можно короче. Это делает
идентификацию конкретной записи простой и эффективной.

<LI>

Метод хранения/индексации нужно выбрать для каждой таблицы. 
See section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>.

<LI>

Создавайте только те индексы, которые действительно необходимы.
Индексы хороши для извлечения данных, но плохи при необходимости
быстрого сохранения информации. Если работа с таблицей большей частью
сводится к поиску на некотором сочетании столбцов, то следует сделать
по ним индекс. Первая часть этого индекса должна представлять собой
наиболее используемый столбец. Если <strong>всегда</strong> задействовано много
столбцов, то следует первым использовать столбец с большим количеством
повторений, чтобы получить лучшее сжатие этого индекса.

<LI>

Если в столбце с большой степенью вероятности в начальной части
символов присутствует уникальный префикс, то лучше индексировать
только этот префикс. MySQL поддерживает индекс по части символов
столбца. Более короткие индексы работают быстрее не только за счет
того, что они занимают меньше дискового пространства, но также и
потому, что они обеспечивают больше попаданий в кэш индексов,
благодаря чему уменьшается количество операций поиска на диске. 
See section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>.

<LI>

Иногда целесообразно разбить очень часто просматриваемую таблицу на
две, особенно если таблица имеет динамический формат и при просмотре
данной таблицы для поиска соответствующих строк можно использовать
таблицу с меньшим статическим форматом.
</ul>



<H3><A NAME="MySQL_indexes" HREF="manual.ru_toc.html#MySQL_indexes">5.4.3  Использование индексов в MySQL</A></H3>

<P>
<A NAME="IDX891"></A>

</P>
<P>
Индексы применяются для быстрого поиска строк с указанным значением одного
столбца. Без индекса чтение таблицы осуществляется по всей таблице начиная
с первой записи, пока не будут найдены соответствующие строки. Чем больше
таблица, тем больше накладные расходы. Если же таблица содержит индекс по
рассматриваемым столбцам, то MySQL может быстро определить позицию для
поиска в середине файла данных без просмотра всех данных. Для таблицы,
содержащей 1000 строк, это будет как минимум в 100 раз быстрее по
сравнению с последовательным перебором всех записей. Однако в случае,
когда необходим доступ почти ко всем 1000 строкам, быстрее будет
последовательное чтение, так как при этом не требуется операций поиска по
диску.

</P>
<P>
Все индексы MySQL (<code>PRIMARY</code>, <code>UNIQUE</code>, и <code>INDEX</code>) хранятся в виде B-деревьев.
Строки автоматически сжимаются с удалением пробелов в префиксах и
оконечных пробелов (see section <A HREF="manual.ru_Reference.html#CREATE_INDEX">6.5.7  Синтаксис оператора <code>CREATE INDEX</code></A>).

</P>
<P>
Индексы используются для того, чтобы:

</P>

<ul>

<LI>

Быстро найти строки, соответствующие выражению <code>WHERE</code>.

<LI>

Извлечь строки из других таблиц при выполнении объединений.

<LI>

Найти величины <code>MAX()</code> или <code>MIN()</code> для заданного индексированного столбца.
Эта операция оптимизируется препроцессором, который проверяет, не
используете ли вы <code>WHERE key_part_4 = константа</code>, по всем частям
составного ключа <code>&#60; N</code>. В этом случае MySQL сделает один просмотр ключа
и заменит выражение константой <code>MIN()</code>. Если все выражения заменяются
константой, запрос моментально вернет результат:


<pre>
SELECT MIN(key_part2),MAX(key_part2) FROM table_name where key_part1=10
</pre>

<LI>

Производить сортировку или группирование в таблице, если эти операции
делаются на крайнем слева префиксе используемого ключа (например <code>ORDER
BY key_part_1,key_part_2</code>). Если за всеми частями ключа следует <code>DESC</code>,
то данный ключ читается в обратном порядке (see section <A HREF="manual.ru_MySQL_Optimisation.html#ORDER_BY_optimisation">5.2.7  Как MySQL оптимизирует <code>ORDER BY</code></A>).

<LI>

В некоторых случаях запрос можно оптимизировать для извлечения величин
без обращения к файлу данных. Если все используемые столбцы в
некоторой таблице являются числовыми и образуют крайний слева префикс
для некоторого ключа, то чтобы обеспечить большую скорость, искомые
величины могут быть извлечены непосредственно из индексного дерева:


<pre>
SELECT key_part3 FROM table_name WHERE key_part1=1
</pre>

</ul>

<P>
Предположим, что вызывается следующий оператор <code>SELECT</code>:

</P>

<pre>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
</pre>

<P>
<A NAME="IDX892"></A>
<A NAME="IDX893"></A>

</P>
<P>
Если по столбцам <code>col1</code> и <code>col2</code> существует многостолбцовый индекс, то
соответствующие строки могут выбираться напрямую. В случае, когда по
столбцам <code>col1</code> и <code>col2</code> существуют раздельные индексы, оптимизатор пытается
найти наиболее ограничивающий индекс путем определения, какой индекс
найдет меньше строк, и использует данный индекс для выборки этих строк.

</P>
<P>
Если данная таблица имеет многостолбцовый индекс, то любой крайний слева
префикс этого индекса может использоваться оптимизатором для нахождения
строк. Например, если имеется индекс по трем столбцам (<code>col1,col2,col3</code>), то
существует потенциальная возможность индексированного поиска по (<code>col1</code>),
(<code>col1,col2</code>) и (<code>col1,col2,col3</code>).

</P>
<P>
В MySQL нельзя использовать частичный индекс, если столбцы не образуют
крайний слева префикс этого индекса. Предположим, что имеются команды
<code>SELECT</code>, показанные ниже:

</P>

<pre>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
</pre>

<P>
Если индекс существует по (<code>col1,col2,col3</code>), то только первый показанный
выше запрос использует данный индекс. Второй и третий запросы
действительно включают индексированные столбцы, но (<code>col2</code>) и  (<code>col2,col3</code>) не
являются крайней слева частью префиксов (<code>col1,col2,col3</code>).

</P>
<P>
<A NAME="IDX894"></A>
<A NAME="IDX895"></A>
<A NAME="IDX896"></A>
<A NAME="IDX897"></A>

</P>
<P>
MySQL применяет индексы также для сравнений <code>LIKE</code>, если аргумент в
выражении <code>LIKE</code> представляет собой постоянную строку, не начинающуюся с
символа-шаблона. Например, следующие команды <code>SELECT</code> используют индексы:

</P>

<pre>
mysql&#62; SELECT * FROM tbl_name WHERE key_col LIKE "Patrick%";
mysql&#62; SELECT * FROM tbl_name WHERE key_col LIKE "Pat%_ck%";
</pre>

<P>
В первой команде рассматриваются только строки с <code>"Patrick" &#60;= key_col &#60;
"Patricl"</code>, а во второй - только строки с <code>"Pat" &#60;= key_col &#60; "Pau"</code>.

</P>
<P>
Следующие команды <code>SELECT</code> не будут использовать индексы:

</P>

<pre>
mysql&#62; SELECT * FROM tbl_name WHERE key_col LIKE "%Patrick%";
mysql&#62; SELECT * FROM tbl_name WHERE key_col LIKE other_col;
</pre>

<P>
В первой команде величина <code>LIKE</code> начинается с шаблонного символа. Во второй
команде величина <code>LIKE</code> не является константой.

</P>
<P>
В версии MySQL 4.0 производится другая оптимизация на выражении <code>LIKE</code>. Если
используется выражение <code>... LIKE "%string%"</code> и длина строки (string) больше, чем 3
символа, то MySQL будет применять алгоритм Турбо Бойера-Мура для
инициализации шаблона для строки и затем использовать этот шаблон, чтобы
выполнить поиск быстрее.

</P>
<P>
<A NAME="IDX898"></A>
<A NAME="IDX899"></A>

</P>
<P>
При поиске с использованием <code>column_name IS NULL</code> будут использоваться
индексы, если <code>column_name</code> является индексом.

</P>
<P>
MySQL обычно использует тот индекс, который находит наименьшее количество
строк. Индекс применяется для столбцов, которые сравниваются с помощью
следующих операторов: <code>=, &#62;, &#62;=, &#60;, &#60;=, BETWEEN</code> и <code>LIKE</code> с префиксом, не
содержащим шаблонного символа, такого как <code>something%</code>.

</P>
<P>
Если индекс не охватывает все уровни <code>AND</code> в выражении <code>WHERE</code>, то он не
применяется для оптимизации данного запроса. Другими словами: чтобы индекс
можно было использовать, префикс этого индекса должен входить в каждую
группу <code>AND</code>.

</P>
<P>
Следующие выражения <code>WHERE</code> используют индексы:

</P>

<pre>
... WHERE index_part1=1 AND index_part2=2 AND other_column=3
... WHERE index=1 OR A=10 AND index=2 /* индекс = 1 ИЛИ индекс = 2 */
... WHERE index_part1='hello' AND index_part_3=5

/* оптимизировано как "index_part1='hello'" */

... WHERE index1=1 and index2=2 or index1=3 and index3=3;

/* Можно использовать индекс по index1, но не по index2 или index 3 */
</pre>

<P>
Следующие выражения <code>WHERE</code> <strong>не</strong> используют индексы:

</P>

<pre>
... WHERE index_part2=1 AND index_part3=2 
/* index_part_1 не используется */

... WHERE index=1 OR A=10 
/* Индекс не используется в обеих частях AND */

... WHERE index_part1=1 OR index_part2=10 
/* Нет индекса, покрывающего все строки*/
</pre>

<P>
В некоторых случаях MySQL не использует индекс, даже если это возможно.
Несколько примеров таких ситуаций приведено ниже:

</P>

<ul>
<LI>

Если использование индекса требует от MySQL прохода более чем по 30%
строк в данной таблице (в таких случаях просмотр таблицы, по всей
видимости, окажется намного быстрее, так как потребуется выполнить
меньше операций поиска). Следует учитывать, что если подобный запрос
использует <code>LIMIT</code> по отношению только к извлекаемой части строк, то
MySQL будет применять индекс в любом случае, так как небольшое
количество строк можно найти намного быстрее, чтобы вернуть результат.
</ul>



<H3><A NAME="Indexes" HREF="manual.ru_toc.html#Indexes">5.4.4  Индексы столбцов</A></H3>

<P>
<A NAME="IDX900"></A>
<A NAME="IDX901"></A>
<A NAME="IDX902"></A>

</P>
<P>
В MySQL могут быть проиндексированы столбцы всех типов. Использование
индексов на соответствующих столбцах представляет собой хороший способ
ускорения выполнения операций <code>SELECT</code>.

</P>
<P>
Максимальное количество ключей и максимальная длина индексов определяется
обработчиком таблиц (see section <A HREF="manual.ru_Table_types.html#Table_types">7  Типы  таблиц MySQL</A>). Можно иметь по меньшей
мере 16 ключей на всех обработчиках таблиц и общую длину индексов по
меньшей мере 256 байтов.

</P>
<P>
Для столбцов типов <code>CHAR</code> и <code>VARCHAR</code> можно индексировать префикс столбца. Это
намного быстрее и требует меньше дискового пространства, чем индексация
всего столбца. Используемый в команде <code>CREATE TABLE</code> синтаксис для
индексации префикса столбца выглядит примерно так:

</P>

<pre>
KEY index_name (col_name(length))
</pre>

<P>
В следующем примере создается индекс для первых 10 символов в столбце <code>name</code>:

</P>

<pre>
mysql&#62; CREATE TABLE test (
    -&#62;        name CHAR(200) NOT NULL,
    -&#62;        KEY index_name (name(10)));
</pre>

<P>
Для столбцов типа <code>BLOB</code> и <code>TEXT</code> индексировать необходимо префикс столбца.
Нельзя индексировать столбец целиком.

</P>
<P>
В версии MySQL 3.23.23 и более поздних можно также создавать специальные
индексы <code>FULLTEXT</code>. Они используются для полнотекстового поиска.
Полнотекстовые индексы <code>FULLTEXT</code> поддерживают только таблицы типа <code>MyISAM</code>.
Они могут создаваться только по столбцам <code>VARCHAR</code> и <code>TEXT</code>. Индексация всегда
производится для целого столбца, а частичная индексация не поддерживается.
See section <A HREF="manual.ru_Reference.html#Fulltext_Search">6.8  Полнотекстовый поиск в MySQL</A>.

</P>


<H3><A NAME="Multiple-column_indexes" HREF="manual.ru_toc.html#Multiple-column_indexes">5.4.5  Многостолбцовые индексы</A></H3>

<P>
<A NAME="IDX903"></A>
<A NAME="IDX904"></A>
<A NAME="IDX905"></A>

</P>
<P>
MySQL может создавать индексы по нескольким столбцам. Индекс может
включать в себя до 15 столбцов (на столбцах <code>CHAR</code> и <code>VARCHAR</code> можно также
использовать префикс столбца в качестве части индекса)

</P>
<P>
Многостолбцовый индекс может рассматриваться как упорядоченный массив,
содержащий величины, созданные конкатенацией величин проиндексированных
столбцов.

</P>
<P>
MySQL использует многостолбцовые индексы таким образом, что запросы
выполняются быстро, когда указывается известная часть для первого столбца
в индексе в выражении <code>WHERE</code>, даже если не заданы  величины для других
столбцов.

</P>
<P>
Предположим, создается следующая таблица:

</P>

<pre>
mysql&#62; CREATE TABLE test (
    -&#62;       id INT NOT NULL,
    -&#62;       last_name CHAR(30) NOT NULL,
    -&#62;       first_name CHAR(30) NOT NULL,
    -&#62;       PRIMARY KEY (id),
    -&#62;       INDEX name (last_name,first_name));
</pre>

<P>
Индекс <code>name</code> является индексом по столбцам <code>last_name</code> и <code>first_name</code>. Этот
индекс будет применяться для запросов, указывающих величины в известной
области для <code>last_name</code> или для обоих столбцов <code>last_name</code> и <code>first_name</code>. Таким
образом, индекс <code>name</code> будет использоваться в следующих запросах:

</P>

<pre>
mysql&#62; SELECT * FROM test WHERE last_name="Widenius";

mysql&#62; SELECT * FROM test WHERE last_name="Widenius"
    -&#62;                    AND first_name="Michael";

mysql&#62; SELECT * FROM test WHERE last_name="Widenius"
    -&#62;                    AND (first_name="Michael" OR first_name="Monty");

mysql&#62; SELECT * FROM test WHERE last_name="Widenius"
    -&#62;                    AND first_name &#62;="M" AND first_name &#60; "N";
</pre>

<P>
Чтобы получить более подробную информацию о том, как в MySQL используются
индексы для улучшения работы запросов, See section <A HREF="manual.ru_MySQL_Optimisation.html#MySQL_indexes">5.4.3  Использование индексов в MySQL</A>.

</P>


<H3><A NAME="Open_tables" HREF="manual.ru_toc.html#Open_tables">5.4.6  Почему так много открытых таблиц?</A></H3>

<P>
<A NAME="IDX906"></A>
<A NAME="IDX907"></A>

</P>
<P>
При запуске <code>mysqladmin status</code> можно увидеть что-нибудь вроде этого:

</P>

<pre>
Uptime: 426 Running threads: 1 Questions: 11082 Reloads: 1 Open tables: 12
</pre>

<P>
В чем же дело, ведь у вас всего 6 таблиц?

</P>
<P>
MySQL является многопоточной базой данных, поэтому для одной и той же
таблицы могут одновременно присутствовать несколько запросов. Чтобы
минимизировать эту проблему для двух потоков, имеющих различный статус на
одном и том же файле, таблица открывается независимо каждым конкурирующим
потоком. Это требует дополнительной памяти, но, как правило, повышает
производительность. Кроме того, для таблиц типа <code>ISAM</code> и <code>MyISAM</code> требуется
дополнительный дескриптор для файла данных. В таблицах этого типа
дескриптор индексного файла используется совместно всеми потоками.

</P>
<P>
В следующем разделе вы найдете более подробную информацию по этой теме
(see section <A HREF="manual.ru_MySQL_Optimisation.html#Table_cache">5.4.7  Открытие и закрытие таблиц в MySQL</A>).

</P>


<H3><A NAME="Table_cache" HREF="manual.ru_toc.html#Table_cache">5.4.7  Открытие и закрытие таблиц в MySQL</A></H3>

<P>
<A NAME="IDX908"></A>

</P>
<P>
<A NAME="IDX909"></A>
<A NAME="IDX910"></A>
<A NAME="IDX911"></A>
<A NAME="IDX912"></A>
<A NAME="IDX913"></A>

</P>
<P>
Параметры <code>table_cache</code>, <code>max_connections</code> и <code>max_tmp_tables</code> задают
максимальное количество файлов, которые сервер держит открытыми. Если
увеличить один или оба этих параметра, то можно столкнуться с
ограничением, накладываемым данной операционной системой на количество
открытых файловых дескрипторов для одного процесса. Во многих системах,
однако, этот предел можно увеличить. Поскольку способы изменения данного
значения для разных систем могут быть совершенно различными, в каждом
конкретном случае вам следует обращаться к документации по своей
операционной системе.

</P>
<P>
Значения  <code>table_cache</code> и <code>max_connections</code> взаимосвязаны. Например, для 200
одновременно работающих соединений необходимо иметь кэш для таблиц
размером по меньшей мере 200 * n, где n - максимальное количество
связанных таблиц. Необходимо также зарезервировать несколько
дополнительных файловых дескрипторов для временных таблиц и файлов.

</P>
<P>
Следует удостовериться, что ваша операционная система способна
обрабатывать такое количество открытых файловых дескрипторов, какое
предполагает данная установка <code>table_cache</code>. Если устанавливается слишком
высокое значение <code>table_cache</code>, то MySQL может выйти за пределы допустимого
количества файловых дескрипторов, прервать соединение, не выполнять
запросы и стать очень ненадежным. Необходимо также принять во внимание,
что для обработчика таблиц <code>MyISAM</code> требуется по два файловых дескриптора
для каждой уникальной открытой таблицы. Допустимое для MySQL количество
файловых дескрипторов можно увеличить с помощью опции запуска
<code>--open-files-limit=#</code> (see section <A HREF="manual.ru_Problems.html#Not_enough_file_handles">A.2.16  Не найден файл (<code>File not found</code>)</A>).

</P>
<P>
Максимальное количество таблиц в кэше открытых таблиц будет равно
количеству, указанному в <code>table_cache</code> (по умолчанию - 64; это число можно
изменить с помощью опции <code>-O table_cache=#</code> для <code>mysqld</code>). Следует учитывать,
что для выполнения запросов MySQL может временно открыть и больше таблиц.

</P>
<P>
Неиспользуемая таблица закрывается и удаляется из кэша таблиц в следующих
ситуациях:

</P>

<ul>
<LI>

Когда кэш заполнен и поток старается открыть таблицу, отсутствующую в
этом кэше.

<LI>

Когда кэш содержит более, чем <code>table_cache</code> входных величин, и поток
больше не использует таблицу.

<LI>

Когда кто-либо выполняет <code>mysqladmin refresh</code> или <code>mysqladmin
flush-tables</code>.

<LI>

Когда кто-либо выполняет <code>FLUSH TABLES</code>.
</ul>

<P>
Когда табличный кэш заполняется, сервер использует следующую процедуру
размещения входных данных кэша для их использования:

</P>

<ul>
<LI>

Не используемые в данное время таблицы освобождаются в порядке
наиболее давнего использования.

<LI>

Если кэш заполнен и ни одна таблица не может быть высвобождена, а
необходимо открыть новую таблицу, то кэш временно расширяется
настолько, насколько необходимо.

<LI>

Если кэш находится во временно расширенном состоянии и таблица
переходит из используемого в неиспользуемое состояние, то такая
таблица закрывается и освобождается из кэша.
</ul>

<P>
Таблица открывается для каждого одновременного доступа. Это означает, что,
если существуют два потока, получающие доступ к одной и той же таблице,
или происходит обращение к этой таблице дважды в одном и том же запросе (с
помощью <code>AS</code>), то данная таблица должна быть открыта дважды. Для первого
открытия любой таблицы требуется два файловых дескриптора; для каждого
дополнительного использования - только один. Дополнительный дескриптор для
первого открытия используется для индексного файла; этот дескриптор
используется совместно всеми потоками.

</P>
<P>
При открытии таблицы командой <code>HANDLER table_name OPEN</code> создается выделенный
табличный объект для данного потока. Этот табличный объект недоступен для
других потоков и не будет закрыт, пока данный поток не вызовет команду
<code>HANDLER table_name CLOSE</code> или сам поток не уничтожится (see section <A HREF="manual.ru_Reference.html#HANDLER">6.4.2  Синтаксис оператора  <code>HANDLER</code></A>). Если это произойдет, то данная таблица помещается обратно в кэш
таблиц (если он не заполнен).

</P>
<P>
Чтобы узнать, не слишком ли мал кэш таблиц, следует проверить переменную
<code>Opened_tables</code>. Если ее значение достаточно велико, даже если вы не
выполняли слишком часто команду <code>FLUSH TABLES</code>, то необходимо увеличить
данный кэш таблиц (see section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_STATUS">4.5.6.3  <code>SHOW STATUS</code></A>).

</P>


<H3><A NAME="Creating_many_tables" HREF="manual.ru_toc.html#Creating_many_tables">5.4.8  Недостатки создания множества таблиц в одной базе данных</A></H3>

<P>
<A NAME="IDX914"></A>

</P>
<P>
Если в каталоге присутствует большое количество файлов, то операции
открытия, закрытия и создания будут медленными. Выполнение значительного
количества команд <code>SELECT</code> на большом количестве разных таблиц приводит к
небольшим непроизводительным затратам при заполненном табличном кэше,
поскольку для открытия одной таблицы требуется закрыть другую. Чтобы
сократить эту перегрузку, следует увеличить табличный кэш.

</P>


<H2><A NAME="Optimising_the_Server" HREF="manual.ru_toc.html#Optimising_the_Server">5.5  Оптимизация сервера MySQL</A></H2>



<H3><A NAME="System" HREF="manual.ru_toc.html#System">5.5.1  Настройка параметров системы, компляции и запуска</A></H3>

<P>
<A NAME="IDX915"></A>
<A NAME="IDX916"></A>
<A NAME="IDX917"></A>

</P>
<P>
Мы начинаем с вопросов системного уровня, поскольку некоторые из них
требуют решения на самых ранних этапах. В других случаях может оказаться
достаточно только беглого просмотра этого материала, поскольку
значительного выигрыша в оптимизации он не обеспечивает. Однако всегда
хорошо иметь представление о том, какую пользу можно получить при
изменении параметров на этом уровне.

</P>
<P>
Используемая по умолчанию операционная система имеет действительно большое
значение! Чтобы получить максимальную выгоду от применения
многопроцессорных компьютеров, следует применять Solaris (так как под этой
ОС потоки работают в самом деле хорошо) или Linux (поскольку ядро 2.2
обеспечивает действительно хорошую поддержку SMP). Однако на 32-разрядных
компьютерах Linux по умолчанию имеет ограничение размера файлов в 2 Гб.
Будем надеяться, что это ограничение в скором времени будет снято при
выпуске новых файловых систем (XFS/Reiserfs). Но если вам действительно не
обойтись без файлов с размерами более чем 2 Гб на 32-разрядном ПК с
Linux-intel, то следует использовать патч LFS для файловой системы ext2.

</P>
<P>
На многих платформах MySQL еще не находился в промышленной эксплуатации,
поэтому мы рекомендуем прежде, чем остановить свой выбор на какой-либо
платформе, сначала ее протестировать.

</P>
<P>
<A NAME="IDX918"></A>
Другие советы:

</P>

<ul>
<LI>

Если оперативной памяти достаточно, то можно было бы удалить все
внешние запоминающие устройства. Существуют операционные системы,
которые при некоторых обстоятельствах будут использовать внешние
запоминающие устройства даже при наличии свободной памяти.

<LI>

Чтобы избежать внешнего блокирования, используйте опцию MySQL
<code>--skip-external-locking</code>. Следует учитывать, что пока работает только один
сервер, это не будет оказывать большого влияния на функциональные
возможности MySQL. Только не забудьте остановить сервер (или
блокировать соответствующие части) перед запуском <code>myisamchk</code>. В
некоторых системах такое переключение обязательно, поскольку внешнее
блокирование не работает в любом случае. 

Опция <code>--skip-external-locking</code> включена
по умолчанию при компилировании с потоками <code>MIT-pthreads</code>, поскольку
функция <code>flock()</code> не полностью поддерживается потоками <code>MIT-pthreads</code> на
всех платформах. Для Linux также подразумевается, что блокирование
файлов пока еще ненадежно. 

Нельзя использовать <code>--skip-external-locking</code> только в
одном случае - при запуске нескольких <em>серверов</em> (не клиентов) MySQL на
одних и тех же данных, или при запуске <code>myisamchk</code> на таблице без
предварительного сбрасывания на диск и блокирования демона <code>mysqld</code> для
сервера, содержащего эти таблицы. Можно также применять команду <code>LOCK
TABLES/UNLOCK TABLES</code> даже при использовании <code>--skip-external-locking</code>.
</ul>



<H3><A NAME="Server_parameters" HREF="manual.ru_toc.html#Server_parameters">5.5.2  Настройка параметров сервера</A></H3>

<P>
<A NAME="IDX919"></A>
<A NAME="IDX920"></A>
<A NAME="IDX921"></A>
<A NAME="IDX922"></A>

</P>
<P>
Размеры буферов, используемые по умолчанию сервером <code>mysqld</code>, можно узнать с
помощью следующей команды:

</P>

<pre>
shell&#62; mysqld --help
</pre>

<P>
<A NAME="IDX923"></A>
<A NAME="IDX924"></A>
Эта команда выдает список всех опций <code>mysqld</code> и конфигурируемых переменных.
Вывод включает в себя величины по умолчанию и выглядит примерно следующим
образом:

</P>

<pre>
Possible variables for option --set-variable (-O) are:
back_log                 current value: 5
bdb_cache_size           current value: 1048540
binlog_cache_size        current value: 32768
connect_timeout          current value: 5
delayed_insert_timeout   current value: 300
delayed_insert_limit     current value: 100
delayed_queue_size       current value: 1000
flush_time               current value: 0
interactive_timeout      current value: 28800
join_buffer_size         current value: 131072
key_buffer_size          current value: 1048540
lower_case_table_names   current value: 0
long_query_time          current value: 10
max_allowed_packet       current value: 1048576
max_binlog_cache_size    current value: 4294967295
max_connections          current value: 100
max_connect_errors       current value: 10
max_delayed_threads      current value: 20
max_heap_table_size      current value: 16777216
max_join_size            current value: 4294967295
max_sort_length          current value: 1024
max_tmp_tables           current value: 32
max_write_lock_count     current value: 4294967295
myisam_sort_buffer_size  current value: 8388608
net_buffer_length        current value: 16384
net_retry_count          current value: 10
net_read_timeout         current value: 30
net_write_timeout        current value: 60
read_buffer_size         current value: 131072
record_rnd_buffer_size   current value: 131072
slow_launch_time         current value: 2
sort_buffer              current value: 2097116
table_cache              current value: 64
thread_concurrency       current value: 10
tmp_table_size           current value: 1048576
thread_stack             current value: 131072
wait_timeout             current value: 28800
</pre>

<P>
Не забывайте, что <code>--set-variable</code> не используется в MySQL 4.0. Просто
указывайте <code>--var=option</code>.

</P>
<P>
Если сервер <code>mysqld</code> в настоящее время работает, то для того, чтобы увидеть,
какие величины реально используются для переменных, необходимо выполнить
следующую команду:

</P>

<pre>
shell&#62; mysqladmin variables
</pre>

<P>
Полное описание всех переменных можно найти в разделе <code>SHOW VARIABLES</code> этого
руководства (see section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>).

</P>
<P>
Некоторые статистические данные по работающему серверу можно также
просмотреть с помощью команды <code>SHOW STATUS</code> (see section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_STATUS">4.5.6.3  <code>SHOW STATUS</code></A>).

</P>
<P>
В MySQL используются алгоритмы, масштабируемые в широких пределах, так что
обычно можно работать с очень небольшой памятью. Однако если выделить для
MySQL больше памяти, то и производительность, как правило, будет выше.

</P>
<P>
При настройке сервера MySQL наиболее важными из используемых являются две
переменные <code>key_buffer_size</code> и <code>table_cache</code>. Но прежде чем пытаться изменить
ту или иную переменную, вначале следует убедиться, что вы обладаете
необходимыми для этого правами.

</P>
<P>
Если имеется большая память (&#62;=256 Mб) и много таблиц, то для обеспечения
максимальной производительности путем регулирования количества клиентов
следует использовать что-нибудь вроде этого:

</P>

<pre>
shell&#62; safe_mysqld -O key_buffer=64M -O table_cache=256 \
                   -O sort_buffer=4M -O read_buffer_size=1M &#38;
</pre>

<P>
Если память составляет только 128 Mб и количество таблиц невелико, но тем
не менее, выполняется много сортировок, то можно использовать что-нибудь
вроде:

</P>

<pre>
shell&#62; safe_mysqld -O key_buffer=16M -O sort_buffer=1M
</pre>

<P>
При малой памяти и большом количестве соединений следует использовать
что-нибудь вроде следующего:

</P>

<pre>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=100k \
                   -O read_buffer_size=100k &#38;
</pre>

<P>
или даже:

</P>

<pre>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=16k \
                   -O table_cache=32 -O read_buffer_size=8k \
                   -O net_buffer_length=1K &#38;
</pre>

<P>
Если выполняются операции <code>GROUP BY</code> или <code>ORDER BY</code> на файлах, которые намного
больше, чем доступная память, то следует увеличить величину
<code>record_rnd_buffer</code> для ускорения чтения строк после выполнения сортировки.

</P>
<P>
После установки MySQL каталог <tt>`support-files'</tt> будет содержать несколько
различных файлов-примеров <tt>`my.cnf'</tt>, а именно: <tt>`my-huge.cnf'</tt>, <tt>`my-large.cnf'</tt>,
<tt>`my-medium.cnf'</tt> и <tt>`my-small.cnf'</tt>, которые можно использовать как основу для
оптимизации вашей системы.

</P>
<P>
Если демон <code>mysqld</code> не отконфигурирован для использования очень малой памяти
для каждого соединения, то в условиях очень большого количества соединений
могут возникнуть проблемы с подкачкой виртуальной памяти. При наличии
достаточной памяти для всех соединений <code>mysqld</code>, конечно, будет
функционировать лучше.

</P>
<P>
Следует учитывать, что при изменении какой-либо опции для <code>mysqld</code> это
изменение действительно только для данного экземпляра сервера.

</P>
<P>
Чтобы увидеть воздействие изменения параметра, нужно выполнить что-нибудь
вроде этого:

</P>

<pre>
shell&#62; mysqld -O key_buffer=32m --help
</pre>

<P>
Следует удостовериться, что опция <code>--help</code> расположена последней; в
противном случае влияние любой опции, следующей после нее в командной
строке, в данном выводе отражено не будет.

</P>


<H3><A NAME="Compile_and_link_options" HREF="manual.ru_toc.html#Compile_and_link_options">5.5.3  Как компиляция и линкование влияет на скорость MySQL</A></H3>

<P>
<A NAME="IDX925"></A>
<A NAME="IDX926"></A>
<A NAME="IDX927"></A>
<A NAME="IDX928"></A>

</P>
<P>
Большинство из последующих тестов выполняются под Linux с использованием
тестов производительности MySQL, но они должны дать некоторое
представление и для других операционных систем и рабочих нагрузок.

</P>
<P>
Самый быстрый исполняемый код получается при линковании с помощью <code>-static</code>.

</P>
<P>
Под Linux наиболее быстрый код можно получить при компилировании 
<code>pgcc</code> с опицей <code>-O3</code>. Чтобы скомпилировать <code>sql_yacc.cc</code> с этой опцией, требуется
около 200 Mб памяти, поскольку компилятор <code>gcc/pgcc</code> забирает много памяти.
При конфигурировании MySQL следует также
установить <code>CXX=gcc</code> - чтобы не линковалась библиотека <code>libstdc++</code> (в этом
нет необходимости). Следует учитывать, что при некоторых версиях
компилятора <code>pgcc</code> результирующий код будет работать только на настоящих
процессорах Pentium, даже если использовать возможность компилятора
выдавать результирующий код, работоспособный на всех процессорах типа x586
(например AMD).

</P>
<P>
Используя просто лучший компилятор и/или лучшую опцию компилятора, можно
получить для приложения увеличение скорости на 10-30%. Это особенно важно,
если вы компилируете сервер SQL самостоятельно!

</P>
<P>
Мы протестировали такие компиляторы как Cygnus CodeFusion и Fujitsu, но ни
тот, ни другой не были достаточно свободны от ошибок, чтобы можно было
скомпилировать MySQL с оптимизирующими параметрами.

</P>
<P>
При компилировании MySQL необходимо включать только наборы кодировок,
которые вы собираетесь использовать (опция <code>--with-charset=xxx</code>).
Стандартная поставка MySQL скомпилирована с поддержкой всех кодировок.

</P>
<P>
Ниже приводится обзор некоторых действий, которые мы предпринимали для
ускорения работы:

</P>

<ul>
<LI>

При использовании <code>pgcc</code> и компиляции всего кода с <code>-O6</code> сервер <code>mysqld</code> на
1% быстрее, чем при <code>gcc 2.95.2</code>.

<LI>

При динамическом связывании (без опции <code>-static</code>) результирующий
исполняемый файл сервера будет на 13% медленнее работать под
управлением Linux. Обратите  внимание: вы спокойно можете использовать
динамическую библиотеку MySQL. Это касается только сервера и актуально
только там, где нужна высокая производительность.

<LI>

При сокращении двоичного кода <code>mysqld</code> с помощью <code>strip libexec/mysqld</code> 
можно получить прирост скорости результирующего двоичного кода до 4%.

<LI>

При соединении с использованием протокола TCP/IP, а не сокетов Unix
работа будет на 7,5% медленнее на том же самом
компьютере (при подключении к <code>localhost</code> MySQL по умолчанию будет
использовать сокеты).

<LI>

При соединении с использованием протокола TCP/IP с другим компьютером
по сети Ethernet с пропускной способностью 100Mбит/сек скорость будет
на 8-11% ниже.

<LI>

При запуске наших тестов производительности с использованием
безопасных соединений (все данные зашифрованы с поддержкой 
протокола SSL) скорость была на 55% ниже.

<LI>

Если код компилируется с параметром <code>--with-debug=full</code>, то для
большинства запросов потери в производительности будут составлять до
20%, но некоторые запросы могут выполняться значительно дольше (тесты
производительности MySQL работают на 35% медленнее). При использовании
опции <code>--with-debug</code> теряется только 15% производительности. При запуске
mysqld, откомпилированного с <code>--with-debug=full</code> и <code>--skip-safemalloc</code>,
результат должен почти таким же, как и при компиляции с <code>--with-debug</code>.

<LI>

На компьютере Sun UltraSPARC-IIe, Forte 5.0 дает на 4% более быстрый код чем <code>gcc 3.2</code>

<LI>

На компьютере Sun UltraSPARC-IIe, Forte 5.0 дает на  4% более быстрый код в 32-разрядном режиме чем в 64-разрядном. 

<LI>

Компилирование посредством <code>gcc 2.95.2</code> для UltraSPARC с опцией <code>-mcpu=v8
-Wa,-xarch=v8plusa</code> дает прирост производительности на 4%.

<LI>

Под операционной системой Solaris 2.5.1 потоки MIT-pthreads на 8-12%
медленнее, чем собственные потоки Solaris для единичного процессора.
При возрастании нагрузки на процессоры разница должна получиться
больше.

<LI>

Запуск с <code>--log-bin</code> делает <code>mysqld</code>  на 1% медленнее.

<LI>

Компилирование под Linux-x86 с использованием <code>gcc</code> без указателей
фреймов <code>-fomit-frame-pointer</code> или <code>-fomit-frame-pointer -ffixed-ebp</code>
делает mysqld на 1-4% быстрее.
</ul>

<P>
Поставка MySQL под Linux, которую предоставляет  MySQL AB, обычно
компилировалась с <code>pgcc</code>, но мы должны были вернуться к обычному компилятору
<code>gcc</code> из-за ошибок в <code>pgcc</code>, которая могут генерировать код, не исполняемый на
AMD. Пока эти ошибки не будут устранены, мы будем продолжать использовать
<code>gcc</code>, однако если ваш компьютер не относится к типу AMD, то можно получить
более быстрый двоичный код, компилируя его с <code>pgcc</code>. Стандартный двоичный
код MySQL для Linux слинкован статически, чтобы сделать его более быстрым
и более переносимым.

</P>


<H3><A NAME="Memory_use" HREF="manual.ru_toc.html#Memory_use">5.5.4  Как MySQL использует память</A></H3>

<P>
<A NAME="IDX929"></A>

</P>
<P>
В следующем перечне дано описание некоторых  аспектов использования памяти
сервером <code>mysqld</code>. Там, где это возможно, приводятся имена серверных
переменных, относящихся к использованию памяти:

</P>

<ul>
<LI>

Буфер ключей (переменная <code>key_buffer_size</code>) используется совместно всеми
потоками; другие буферы, используемые данным сервером, выделяются при
необходимости (see section <A HREF="manual.ru_MySQL_Optimisation.html#Server_parameters">5.5.2  Настройка параметров сервера</A>).

<LI>

Каждое соединение использует определенное пространство в памяти для
конкретного потока: стек (по умолчанию 64Kб, переменная <code>thread_stack</code>),
буфер соединения (переменная <code>net_buffer_length</code>) и буфер результата
(переменная <code>net_buffer_length</code>). Буфер соединения и буфер результата
при необходимости динамически расширяются вплоть до
<code>max_allowed_packet</code>. При выполнении запроса также выделяется память для
копии строки данного текущего запроса.

<LI>

Все потоки совместно используют одну и туже базовую память.

Только сжатые таблицы типа <code>ISAM/MyISAM</code> имеют распределенную память.
Это объясняется тем, что 4 Гб памяти (адресуемой в рамках 32-битной
разрядности) мало для достаточно больших таблиц. Когда системы с
64-разрядными адресным пространством получат более широкое
распространение, мы сможем добавить в сервер общую поддержку для
распределения памяти.

<LI>

Каждый запрос, выполняющий последовательный просмотр таблицы,
размещается в буфере чтения (переменная <code>record_buffer</code>).

<LI>

При чтении строк в "случайном" порядке (например, после сортировки)
выделяется буфер "случайного чтения", чтобы избежать поиска по диску
(переменная <code>record_rnd_buffer</code>).

<LI>

Все объединения выполняются за одну операцию, и большинство
объединений может производиться даже без временных таблиц. Большинство
временных таблиц располагаются в оперативной памяти (в динамически
выделяемой области <code>HEAP</code>). Временные таблицы с записями большой длины
(вычисляемой как сумма длин всех столбцов) или таблицы, содержащие
столбцы <code>BLOB</code>, хранятся на диске. В версиях MySQL до 3.23.2 существует
проблема, заключающаяся в том, что если таблицы <code>HEAP</code> в динамически
выделяемой области превышают размер <code>tmp_table_size</code>, то возникает
ошибка <code>The table tbl_name is full</code>. В более новых версиях эта проблема
при необходимости решается путем автоматического преобразования
хранящихся в оперативной памяти <code>HEAP</code>-таблиц в таблицы <code>MyISAM</code>,
расположенные на диске. Чтобы обойти эту проблему, можно увеличить
размер временных таблиц установкой опции <code>tmp_table_size</code> в <code>mysqld</code> или
установкой SQL-опции <code>SQL_BIG_TABLES</code> в клиентской программе (see section <A HREF="manual.ru_MySQL_Optimisation.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A>). 
В версии MySQL 3.20 максимальный размер временной таблицы
был равен <code>record_buffer*16</code>, так что при использовании данной версии
необходимо увеличить значение <code>record_buffer</code>. Можно также запустить
<code>mysqld</code> с опцией <code>--big-tables</code> - для того, чтобы всегда хранить
временные таблицы на диске. Однако это будет влиять на скорость многих
сложных запросов.

<LI>

Большинство запросов, выполняющих сортировку, размещаются в буфере
сортировки и в 0-2 временных файлах, в зависимости от размера
результирующего набора данных (see section <A HREF="manual.ru_Problems.html#Temporary_files">A.4.4  Где MySQL хранит временные файлы</A>).

<LI>

Почти все операции, связанные с анализом и вычислениями, выполняются в
пространстве локальной памяти. Для небольших задач не требуется
никаких дополнительных затрат памяти и удается избежать обычно
медленных процессов выделения и освобождения памяти. Память выделяется
только для непредвиденно больших строк (это делается с помощью функций
<code>malloc()</code> и <code>free()</code>).

<LI>

Каждый файл индексов и файл данных открываются сразу для каждого
параллельно работающего потока. Для каждого параллельного потока
выделяется место в памяти для структуры таблицы, структур столбцов для
каждого столбца и буфер размером 3 * n (где n представляет
максимальную длину строки без учета столбцов <code>BLOB</code>). Для столбца <code>BLOB</code>
используется от 5 до 8 байтов плюс длина данных <code>BLOB</code>. Обработчики
таблиц <code>ISAM/MyISAM</code> будут использовать один дополнительный буфер строки
для внутреннего представления.

<LI>

Для каждой таблицы, имеющей столбцы <code>BLOB</code>, буфер динамически
увеличивается при чтении больших величин <code>BLOB</code>. При просмотре таблицы
выделяется буфер с размером, равным наибольшей величине <code>BLOB</code>.

<LI>

Обработчики всех находящихся в употреблении таблиц хранятся в кэше и
обрабатываются в порядке их поступления (режим FIFO). Обычно этот кэш
содержит 64 элемента. Если данная таблица была использована двумя
работающими потоками в одно и то же время, то кэш содержит два
элемента для такой таблицы (see section <A HREF="manual.ru_MySQL_Optimisation.html#Table_cache">5.4.7  Открытие и закрытие таблиц в MySQL</A>).

<LI>

Команда <code>mysqladmin flush-tables</code> закрывает все неиспользуемые таблицы и
отмечает все используемые таблицы, которые необходимо закрыть после
окончания выполнения текущего потока. Такой алгоритм позволяет
эффективно освобождать большое количество используемой памяти.

</ul>

<P>
Программа <code>ps</code> и другие программы контроля состояния системы могут сообщать,
что <code>mysqld</code> использует слишком много памяти. Это может быть вызвано
расположением стеков памяти потоков по различным адресам в памяти.
Например, версия программы ps для Solaris интерпретирует неиспользуемую
память между стеками как используемую. Это можно проверить путем
выполнения допустимой перестановки с помощью <code>swap -s</code>. Мы тестировали
<code>mysqld</code> при помощи коммерческих детекторов утечки памяти, так что никаких
потерь памяти быть не должно.

</P>


<H3><A NAME="DNS" HREF="manual.ru_toc.html#DNS">5.5.5  Как MySQL использует DNS</A></H3>

<P>
<A NAME="IDX930"></A>
<A NAME="IDX931"></A>

</P>
<P>
Когда к <code>mysqld</code> подключается новый клиент, <code>mysqld</code> выделяет новый поток
для обработки данного запроса. Этот поток вначале проверяет, имеется ли в
кэше имен хостов имя требуемого хоста. Если нет, то поток вызовет функции
<code>gethostbyaddr_r()</code> и <code>gethostbyname_r()</code>, чтобы определить имя хоста.

</P>
<P>
Если операционная система не обеспечивает вышеописанные вызовы с
поддержкой потоков, то данный поток заблокирует флаг и вызовет вместо
этого функции  <code>gethostbyaddr()</code> и <code>gethostbyname()</code>. Следует учитывать, что в
таком случае никакой другой поток не сможет определять имена других
хостов, отсутствующих в кэше имен хостов, пока первый поток не будет
готов.

</P>
<P>
Можно заблокировать поиск DNS хоста, запустив <code>mysqld</code> с параметром
<code>--skip-name-resolve</code>. В этом случае, однако, в таблицах привилегий MySQL
можно использовать только IP-адреса.

</P>
<P>
Если процесс установления DNS очень медленный и хостов очень много, то
можно получить более высокую производительность либо путем блокировки
поиска DNS при помощи <code>--skip-name-resolve</code>, либо увеличив размер
определения <code>HOST_CACHE_SIZE</code> (по умолчанию: 128) и перекомпилировав <code>mysqld</code>.

</P>
<P>
Заблокировать кэш имен хостов можно с помощью <code>--skip-host-cache</code>. Можно
также очистить этот кэш с помощью команды <code>FLUSH HOSTS</code> или <code>mysqladmin
flush-hosts</code>.

</P>
<P>
Можно запретить соединения по протоколу TCP/IP, запустив <code>mysqld</code> с опцией
<code>--skip-networking</code>.

</P>


<H3><A NAME="SET_OPTION" HREF="manual.ru_toc.html#SET_OPTION">5.5.6  Синтаксис команды <code>SET</code></A></H3>

<P>
<A NAME="IDX932"></A>

</P>

<pre>
SET [GLOBAL | SESSION] sql_variable=expression, [[GLOBAL | SESSION] sql_variable=expression...]
</pre>

<P>
Команда <code>SET</code> устанавливает различные опции, влияющие на работу
сервера или клиента. 

</P>
<P>
Следующие примеры иллюстрируют различный синтаксис, который можно использовать для установки
переменных. 

</P>
<P>
В старых версиях MySQL мы допускали использование <code>SET OPTION</code>, но этот синтакс теперь
считается морально устаревшим. 

</P>
<P>
В MySQL 4.0.3 мы также добавили режимы <code>GLOBAL</code> и <code>SESSION</code> и реализовали доступ к 
наиболее важным переменным запуска. 

</P>
<P>
<code>LOCAL</code> может использоваться как синоним для <code>SESSION</code>.

</P>
<P>
Если вы устанавливаете несколько переменных в одной команде, то последний указанный режим
<code>GLOBAL | SESSION</code> будет использован. 

</P>

<pre>
SET sort_buffer_size=10000;
SET @@local.sort_buffer_size=10000;
SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;
SET @@sort_buffer_size=1000000;
SET @@global.sort_buffer_size=1000000, @@local.sort_buffer_size=1000000;
</pre>

<P>
Синтаксис <code>@@variable_name</code> поддерживается с тем, чтобы сделать MySQL более
совместимым с другими СУБД. 

</P>
<P>
Различные системные переменные, которые вы можете установить, описаниы в этом руководстве. 
See section <A HREF="manual.ru_Reference.html#System_Variables">6.1.5  Системные переменные</A>.

</P>
<P>
Если вы используете режим <code>SESSION</code> (по умолчанию), то значения
переменных, которые вы устанавливаете, остаются в в действии до тех пор, пока
текущая сессия не будет завершена, или до тех пор, пока вы не установите
переменные в другое значение. Если вы используете <code>GLOBAL</code>, который
требует привилегии <code>SUPER</code>, это значение запоминается и используется для
всех новых соединений до тех пор, пока сервер не будет перезагружен. Если вы
хотите сделать какое-либо значение перманентным, то вам следует указать его в
одном из файлов конфигураций MySQL.  See section <A HREF="manual.ru_MySQL_Database_Administration.html#Option_files">4.1.2  Файлы параметров <tt>`my.cnf'</tt></A>.

</P>
<P>
Чтобы избежать неправильного использования, MySQL будет сообщать об ошибке, если 
вы будете выполнять <code>SET GLOBAL</code> на переменной, которую только можно изменять в 
<code>SET SESSION</code> или если вы не выбираете режим <code>GLOBAL</code> для глобальной переменной. 

</P>
<P>
Если вы хотите установить сессионную (<code>SESSION</code>) переменную в значение
глобальной (<code>GLOBAL</code>) или просто в значение по умолчанию - вы можете
установить это значение в <code>DEFAULT</code>. 

</P>

<pre>
SET max_join_size=DEFAULT;
</pre>

<P>
Это аналогично: 

</P>

<pre>
SET @@session.max_join_size=@@global.max_join_size;
</pre>

<P>
Если вам необходимо ограничить максимальное значение, которое может принимать стартовая
переменная с помощью <code>SET</code>, вы можете указать это с помощью использования опции командной строки
<code>--maximum-variable-name</code>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>.

</P>
<P>
Список большинства переменных можно получить с помощью <code>SHOW VARIABLES</code>.
See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>. Вы можете получить конкретное значение с помощью синтаксиса
<code>@@[global.|local.]variable_name</code>:

</P>

<pre>
SHOW VARIABLES like "max_join_size";
SHOW GLOBAL VARIABLES like "max_join_size";
SELECT @@max_join_size, @@global.max_join_size;
</pre>

<P>
Далее следует описание переменных, использующих нестандартный синтаксис
<code>SET</code> и некоторых других. 
Описание других переменных можно найти в секции, описывающих системные переменные, 
вместе с описанием стартовых опций или в описании команды <code>SHOW VARIABLES</code>.
See section <A HREF="manual.ru_Reference.html#System_Variables">6.1.5  Системные переменные</A>. See section <A HREF="manual.ru_MySQL_Database_Administration.html#Command-line_options">4.1.1  Параметры командной строки <code>mysqld</code></A>.  See section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <code>SHOW VARIABLES</code></A>.

</P>

<DL COMPACT>

<DT><code>CHARACTER SET character_set_name | DEFAULT</code>
<DD>
Преобразует все строки, передающиеся от клиента, и строки передающиеся
клиенту, в соответствии с заданным набором символов. В настоящее время
единственной опцией для <code>character_set_name</code> является <code>cp1251_koi8</code>, но можно
легко добавить новые наборы символов, отредактировав файл <code>sql/convert.cc</code> в
дистрибутиве исходного кода MySQL. Чтобы восстановить установку по
умолчанию, следует установить значение <code>character_set_name</code> в <code>DEFAULT</code>.

Следует учитывать, что синтаксис установки опции <code>CHARACTER SET</code> отличается
от синтаксиса установки других опций.

<DT><code>PASSWORD = PASSWORD('некий пароль')</code>
<DD>
<A NAME="IDX933"></A>
Устанавливает пароль для текущего пользователя. Любой не анонимный
пользователь может изменить свой собственный пароль!

<DT><code>PASSWORD FOR user = PASSWORD('некий пароль')</code>
<DD>
Устанавливает пароль для особого пользователя для текущего серверного
хоста. Это может сделать только пользователь, имеющий доступ к базе данных
<code>mysql</code>. Данный пользователь должен быть представлен в формате
<code>user@hostname</code>, где <code>user</code> и <code>hostname</code> в точности соответствуют записям этих
позиций в столбцах <code>User</code> и <code>Host</code> в таблице <code>mysql.user</code>. Например, если записи
в полях <code>User</code> и <code>Host</code> соответственно были <code>bob</code> и <code>%.loc.gov</code>, то необходимо
писать:


<pre>
mysql&#62; SET PASSWORD FOR bob@"%.loc.gov" = PASSWORD("newpass");
</pre>

или


<pre>
mysql&#62; UPDATE mysql.user SET password=PASSWORD("newpass")
    -&#62;                   WHERE user="bob" AND host="%.loc.gov";
</pre>

<DT><code>SQL_AUTO_IS_NULL = 0 | 1</code>
<DD>
Если установить в <code>1</code> (значение по умолчанию), то можно найти последнюю
внесенную строку для таблицы со столбцом <code>AUTO_INCREMENT</code> с помощью
следующей конструкции: <code>WHERE auto_increment_column IS NULL</code>. Эта
возможность используется некоторыми ODBC-программами, такими как Access.

<DT><code>AUTOCOMMIT = 0 | 1</code>
<DD>
Если установить в <code>1</code>, то все изменения в таблицу будут вноситься
немедленно. Чтобы открыть многокомандную транзакцию, необходимо
использовать команду <code>BEGIN</code> (see section <A HREF="manual.ru_Reference.html#COMMIT">6.7.1  Синтаксис команд <code>BEGIN/COMMIT/ROLLBACK</code></A>). Если
установить данную опцию в <code>0</code>, то необходимо использовать <code>COMMIT / ROLLBACK</code>
для того, чтобы принять/отменить эту транзакцию (see section <A HREF="manual.ru_Reference.html#COMMIT">6.7.1  Синтаксис команд <code>BEGIN/COMMIT/ROLLBACK</code></A>). 
Следует учитывать, что при переходе из
режима работы без <code>AUTOCOMMIT</code> в режим <code>AUTOCOMMIT</code> MySQL автоматически
выполнит <code>COMMIT</code> для любой открытой транзакции.

<DT><code>BIG_TABLES = 0 | 1</code>
<DD>
Если установить в 1, то предпочтительным местом хранения всех временных
таблиц будет диск, а не оперативная память. Это вызовет некоторое
замедление работы, зато для больших операций <code>SELECT</code>, требующих обширных
временных таблиц, не будет выдаваться ошибка <code>The table tbl_name is full</code>.
Для нового соединения значение этой величины по умолчанию равно 0 (т.е.
использовать для временных таблиц оперативную память). Эта переменная раньше называлась
<code>SQL_BIG_TABLES</code>.

<DT><code>SQL_BIG_SELECTS = 0 | 1</code>
<DD>
При установке в 0 MySQL будет прерывать выполнение запроса, если
поступившая команда <code>SELECT</code> может потребовать  слишком много времени для
выполнения. Такая возможность полезна при нерационально написанном
выражении <code>WHERE</code>. Запрос классифицируется как слишком большой, если оператору
<code>SELECT</code>, видимо, пришлось бы обрабатывать больше строк, чем задано в
<code>max_join_size</code>. Для нового соединения значение по умолчанию равно 1 (т.е.
разрешаются любые команды <code>SELECT</code>).

<DT><code>SQL_BUFFER_RESULT = 0 | 1</code>
<DD>
<code>SQL_BUFFER_RESULT</code> будет заносить результат выполнения команд <code>SELECT</code> во
временную таблицу. Это поможет MySQL раньше освободить блокировки таблиц и
окажется полезным в случаях, когда требуется значительное время для
пересылки результирующего набора данных клиенту.

<DT><code>LOW_PRIORITY_UPDATES = 0 | 1</code>
<DD>
При установке в 1 все команды <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> и
<code>LOCK TABLE WRITE</code> будут ожидать, пока не будет ни одной ожидающей решения
команды <code>SELECT</code> или <code>LOCK TABLE READ</code> на обрабатываемой таблице.
Эта переменная раньше называлась <code>SQL_LOW_PRIORITY_UPDATES</code>.

<DT><code>MAX_JOIN_SIZE = значение | DEFAULT</code>
<DD>
Запрещает команды <code>SELECT</code>, которым, возможно, придется обрабатывать более,
чем указанное значение комбинаций строк. Установив эту величину, можно определить
команды <code>SELECT</code>, в которых ключи используются неправильно и которые,
возможно, потребуют длительного времени для исполнения. При установке этой
опции в величину, отличную от <code>DEFAULT</code>, сбрасывается флаг <code>SQL_BIG_SELECTS</code>.
Если вновь установить флаг <code>SQL_BIG_SELECTS</code>, то переменная
<code>SQL_MAX_JOIN_SIZE</code> будет игнорироваться. Значение по умолчанию для этой
переменной можно установить, запустив <code>mysqld</code> с <code>-O max_join_size=#</code>. 
Эта переменная раньше называлась <code>SQL_MAX_JOIN_SIZE</code>.

Следует
учитывать, что если результат запроса всегда находится в кэше запросов, то
упомянутая выше проверка выполняться не будет. Вместо этого MySQL будет
отсылать результат клиенту, поскольку результат запроса уже вычислен и
отсылка его клиенту не создаст нагрузки для сервера.

<DT><code>QUERY_CACHE_TYPE = OFF | ON | DEMAND</code>
<DD>
<DT><code>QUERY_CACHE_TYPE = 0 | 1 | 2</code>
<DD>
Определяет установку кэша запросов для данного потока.

<TABLE BORDER WIDTH="100%">
<TR><TD><strong>Опция</strong> </TD><TD> <strong>Описание</strong>
</TD></TR>
<TR><TD>0 or OFF </TD><TD> Не кэшировать или не извлекать результаты
</TD></TR>
<TR><TD>1 or ON </TD><TD> Кэшировать все результаты за исключением запросов <code>SELECT SQL_NO_CACHE ...</code>
</TD></TR>
<TR><TD>2 or DEMAND </TD><TD> Кэшировать только запросы <code>SELECT SQL_CACHE ...</code>
</TD></TR>
</TABLE>

<DT><code>SQL_SAFE_UPDATES = 0 | 1</code>
<DD>
Если установить в 1, то MySQL будет прерывать выполнение поступивших
команд <code>UPDATE</code> или <code>DELETE</code>, в которых не используется ключ или <code>LIMIT</code> в
выражении <code>WHERE</code>. Это позволяет обнаружить ошибочные обновления при ручном
создании команд SQL.

<DT><code>SQL_SELECT_LIMIT = value | DEFAULT</code>
<DD>
Максимальное количество записей, возвращаемых командой <code>SELECT</code>. Если <code>SELECT</code>
содержит выражение <code>LIMIT</code>, то <code>LIMIT</code> превосходит по старшинству величину в
<code>SQL_SELECT_LIMIT</code>. Для нового соединения значение по умолчанию равно
"<code>unlimited</code>". Если предел был изменен, то его можно вернуть в значение по
умолчанию указанием величины <code>DEFAULT</code> в выражении <code>SQL_SELECT_LIMIT</code>.

<DT><code>SQL_LOG_OFF = 0 | 1</code>
<DD>
При установке в 1 для данного клиента в стандартный журнал не будут
заноситься никакие записи, если клиент имеет привилегии <code>SUPER</code>. Это не
относится к журналу обновлений!

<DT><code>SQL_LOG_UPDATE = 0 | 1</code>
<DD>
При установке в 0 для данного клиента в журнал обновлений не будут
заноситься никакие записи, если клиент имеет привилегии <code>SUPER</code>. Это не
относится к стандартному журналу!

<DT><code>SQL_QUOTE_SHOW_CREATE = 0 | 1</code>
<DD>
При установке этой опции в 1  <code>SHOW CREATE TABLE</code> будет заключать в кавычки
имена таблиц и столбцов. Имеет значение <strong>Включено</strong> по умолчанию, чтобы
работала репликация таблиц с изощренными именами столбцов (see section <A HREF="manual.ru_MySQL_Database_Administration.html#SHOW_CREATE_TABLE">4.5.6.8  <code>SHOW CREATE TABLE</code></A>).

<DT><code>TIMESTAMP = timestamp_value | DEFAULT</code>
<DD>
Устанавливает время для данного клиента. Применяется для получения
первоначальной временной метки при использовании журнала обновлений для
восстановления строк. Переменная <code>timestamp_value</code> должна представлять
системное время Unix, а не временную метку MySQL.

<DT><code>LAST_INSERT_ID = #</code>
<DD>
Устанавливает величину, возвращаемую функцией <code>LAST_INSERT_ID()</code>. Хранится в
журнале обновлений при использовании функции <code>LAST_INSERT_ID()</code> в команде,
обновляющей таблицу.

<DT><code>INSERT_ID = #</code>
<DD>
Устанавливает величину, которую следует использовать в следующей команде
<code>INSERT</code> или <code>ALTER TABLE</code> при внесении величины <code>AUTO_INCREMENT</code>. В основном
используется с журналом обновлений.

</DL>



<H2><A NAME="Disk_issues" HREF="manual.ru_toc.html#Disk_issues">5.6  Вопросы, относящиеся к диску</A></H2>

<P>
<A NAME="IDX934"></A>
<A NAME="IDX935"></A>

</P>

<ul>
<LI>

Как уже упоминалось ранее, наиболее узким местом для
производительности  является  поиск на диске. Эта проблема становится
все более и более очевидной по мере того,  как объем данных
увеличивается  настолько, что эффективное кэширование становится
невозможным. Для крупных баз данных, где доступ к данным
осуществляется более или менее случайным образом, можно с уверенностью
сказать, что потребуется по меньшей мере один поиск по диску для
чтения и пара поисков по диску  для записи некоторой информации. Чтобы
свести эту проблему к минимуму, следует использовать диски с малыми
временами поиска.

<LI>

Можно увеличить количество доступных дисковых "блоков" (и, таким
образом, уменьшить  нагрузку на диски). Это делается  либо путем
установления символических ссылок на разные диски, либо использованием
RAID (stripe).

<DL COMPACT>

<DT><strong>Использование символических ссылок</strong>
<DD>
Это означает, что создаются символические ссылки индекса и/или
файла/файлов данных из обычного каталога данных на иной диск (для
которого, помимо этого, можно использовать RAID (stripe)). Применение
символических ссылок улучшает как время  поиска, так и время чтения (если
эти диски не используются для других операций). See section <A HREF="manual.ru_MySQL_Optimisation.html#Symbolic_links">5.6.1  Использование символических ссылок</A>.

<A NAME="IDX936"></A>
<DT><strong>Использование RAID (stripe)</strong>
<DD>
Использование RAID (stripe) подразумевает, что при наличии нескольких
дисков первый блок данных помещается на первом диске, второй блок - на
втором диске, N-ный блок на диске с номером, равным остатку от
целочисленного деления количества блоков N на число дисков, и т.д. При
этом подразумевается, что если нормальный размер данных меньше, чем размер
RAID-блока (или в точности равен ему), то производительность будет намного
лучше. Следует учитывать, что процесс разделения дисков на RAID-блоки в
значительной степени зависит от операционной системы и размера RAID-блока.
Поэтому тесты производительности конкретного приложения необходимо
производить для разных размеров RAID-блока  (see section <A HREF="manual.ru_MySQL_Optimisation.html#Custom_Benchmarks">5.1.5  Использование собственных тестов</A>). 

Следует также учитывать, что разница в скорости при
разделении дисков на RAID-блоки <strong>сильно</strong> зависит от заданных параметров. В
зависимости от того, как установлены параметры разделения на RAID-блоки и
каково количество дисков, можно получить величины с разницей в несколько
порядков. Следует помнить, что необходимо выбрать оптимизацию отдельно для
случайного и отдельно для последовательного доступа.
</DL>

<LI>

Для надежности можно использовать режим RAID 0+1 (разделение на
RAID-блоки + зеркальное отображение), но в этом случае будет
необходимо 2*N дисководов для хранения информации N дисководов данных.
Если возможности позволяют, то такой вариант выбора - наилучший!
Однако при этом могут понадобиться также инвестиции и в программное
обеспечение для эффективного управления этим объемом оборудования.

<LI>

Существует еще одна неплохая возможность: хранить не слишком важные данные
(которые могут быть воспроизведены) на диске RAID 0, а действительно
важные данные (такие как информация о хостах и журналы) - на диске RAID
0+1 или диске RAID N. Использование RAID N может оказаться проблемой, если
у вас много операций записи, потому что обновление битов четности занимает
время.

<LI>

Можно также задать требуемые параметры для используемой базой данных
файловой системы. Легко поддается изменению монтирование файловой
системы с опцией <code>noatime</code>. Использование этой опции позволяет
пропускать обновление при последнем обращении в данном режиме и тем
самым избежать поиска по диску.

<LI>

Под Linux можно получить намного большую производительность (под
нагрузкой нередко вплоть до 100%), используя <code>hdpram</code> для конфигурации
интерфейса диска! Приведенные ниже опции для <code>hdparm</code> зарекомендовали
себя как очень полезные для MySQL (и, возможно, для многих других
приложений):


<pre>
hdparm -m 16 -d 1
</pre>

Следует учитывать, что производительность/надежность при использовании
приведенных выше рекомендаций зависит от конкретного оборудования, так что
мы настоятельно рекомендуем вам основательно протестировать систему после
использования <code>hdparm</code>! Для получения более подробной информации о
применении <code>hdparm</code>, обращайтесь, пожалуйста, к соответствующей странице
руководства! Некомпетентное применение <code>hdparm</code> может привести к разрушению
файловой системы. Прежде чем экспериментировать, сделайте полную резервную
копию!

<LI>

Во многих операционных системах можно монтировать диски с флагом
<code>async</code> - для того, чтобы данная файловая система могла обновляться
асинхронно. Если ваш компьютер достаточно стабилен, это должно
обеспечить повышение производительности без слишком большой потери
надежности (под Linux этот флаг включен по умолчанию).

<LI>

Если нет необходимости знать, к какому файлу было последнее обращение
(что реально не используется на сервере баз данных), можно
смонтировать файловые системы с флагом <code>noatime</code>.
</ul>



<H3><A NAME="Symbolic_links" HREF="manual.ru_toc.html#Symbolic_links">5.6.1  Использование символических ссылок</A></H3>

<P>
<A NAME="IDX937"></A>
<A NAME="IDX938"></A>

</P>
<P>
Таблицы и базы данных можно перемещать из каталога баз данных в другие
места, заменив их символическими ссылками на новые адреса. Это можно
сделать, например, для того, чтобы поместить базу данных в файловую
систему с большим количеством свободного места или чтобы увеличить
скорость системы путем распространения таблиц на иной диск.

</P>
<P>
Рекомендуется создавать символические ссылки на другой диск для баз
данных, а символические ссылки для таблиц - только в крайних случаях.

</P>



<H4><A NAME="Symbolic_links_to_databases" HREF="manual.ru_toc.html#Symbolic_links_to_databases">5.6.1.1  Использование символических ссылок для баз данных</A></H4>

<P>
<A NAME="IDX939"></A>

</P>
<P>
Для создания символической ссылки для базы данных вначале следует создать
каталог на некотором диске, где имеется свободное место, а затем создать
символическую ссылку на него из каталога баз данных MySQL.

</P>

<pre>
shell&#62; mkdir /dr1/databases/test
shell&#62; ln -s /dr1/databases/test mysqld-datadir
</pre>

<P>
MySQL не поддерживает ссылку из одного каталога на несколько баз данных.
Замещение каталога базы данных символической ссылкой будет хорошо работать
только в случае, если вы не создаете символическую ссылку между базами
данных. Предположим, имеется база данных <code>db1</code> в каталоге данных MySQL и
создается символическая ссылка <code>db2</code>, указывающая на <code>db1</code>:

</P>

<pre>
shell&#62; cd /path/to/datadir
shell&#62; ln -s db1 db2
</pre>

<P>
Теперь для любой таблицы <code>tbl_a</code> в <code>db1</code> должна существовать  таблица <code>tbl_a</code> в
<code>db2</code>. Если один поток обновляет <code>db1.tbl_a</code>, а другой поток - <code>db2.tbl_a</code>, то
возникнут проблемы.

</P>
<P>
Если описанная выше возможность действительно необходима, то нужно
изменить следующий код в <code>mysys/mf_format.c</code>:

</P>

<pre>
if (flag &#38; 32 || (!lstat(to,&#38;stat_buff) &#38;& S_ISLNK(stat_buff.st_mode)))
</pre>

<P>
на

</P>

<pre>
if (1)
</pre>

<P>
Под Windows можно использовать внутренние символические ссылки на каталоги
(путем компиляции MySQL с <code>-DUSE_SYMDIR</code>). Это позволяет размещать различные
базы данных на различных дисках (see section <A HREF="manual.ru_Installing.html#Windows_symbolic_links">2.6.2.5  Распределение данных в Windows между несколькими различными дисками</A>).

</P>


<H4><A NAME="Symbolic_links_to_tables" HREF="manual.ru_toc.html#Symbolic_links_to_tables">5.6.1.2  Использование символических ссылок для таблиц</A></H4>

<P>
<A NAME="IDX940"></A>

</P>
<P>
Не следует использовать символические ссылки для таблиц в версиях до MySQL
4.0, где при работе с ними требуется особая тщательность. Проблема
заключается в том, что, если запускаются команды <code>ALTER TABLE</code>, <code>REPAIR TABLE</code>
или <code>OPTIMIZE TABLE</code> на таблице, связанной символической ссылкой, то
символические ссылки будут удалены и заменены исходными файлами. Это
происходит потому, что любая вышеназванная команда работает путем создания
временного файла в каталоге базы данных и по завершении команды происходит
замещение исходного файла временным.

</P>
<P>
Не следует связывать символическими ссылками таблицы в системах, где вызов
функции <code>realpath()</code> работает не полностью (по крайней мере,
<code>realpath()</code> поддерживают Linux и Solaris).

</P>
<P>
В MySQL 4.0 символические ссылки полностью поддерживаются только для
таблиц <code>MyISAM</code>. Для других типов таблиц при выполнении какой-либо из
вышеупомянутых команд могут возникать непонятные проблемы.

</P>
<P>
Обработка символических ссылок в MySQL 4.0 происходит следующим образом
(это в основном относится только к таблицам <code>MyISAM</code>).

</P>

<ul>
<LI>

В каталоге данных всегда будет находиться файл определения таблицы и
файлы данных/индексов.

<LI>

Можно связывать символическими ссылками файл индексов и файл данных с
различными каталогами независимо друг от друга.

<LI>

Связывание символическими ссылками можно выполнить из операционной
системы (если не запущен <code>mysqld</code>) или с помощью команды <code>INDEX/DATA
DIRECTORY="path-to-dir"</code> в <code>CREATE TABLE</code> (see section <A HREF="manual.ru_Reference.html#CREATE_TABLE">6.5.3  Синтаксис оператора <code>CREATE TABLE</code></A>).

<LI>

<code>myisamchk</code> не замещает символическую ссылку на индекс/файл, а работает
напрямую с файлами, на которые указывает символическая ссылка. Все
временные файлы будут создаваться в том же каталоге, где находится
файл данных/индексов.

<LI>

При удалении таблицы, в которой используются символические ссылки, как
ссылка, так и файл, на который ссылка указывает, удаляются. Это веская
причина для того, чтобы <strong>не</strong> запускать <code>mysqld</code> в качестве
суперпользователя (<code>root</code>) и не позволять другим иметь доступ к записи
в каталоги баз данных MySQL.

<LI>

Если таблица переименовывается с помощью <code>ALTER TABLE RENAME</code>, и вы не переносите
таблицу в другую базу данных, то данная символическая ссылка в каталоге базы
данных будет переименована и файл данных/индексов соответственно будет
переименован.

<LI>

Если <code>ALTER TABLE RENAME</code> используется для переноса таблицы в другую
базу данных, то эта таблица будет перенесена в другой каталог базы
данных, а старые символические ссылки и файлы, на которые они
указывают, будут удалены. Иными словами, новая таблица не будет ссылкой. 

<LI>

Если символические ссылки не применяются, то необходимо использовать
опцию <code>--skip-symlink</code> в <code>mysqld</code> для уверенности, что никто не сможет
удалить или переименовать файл вне каталога данных этого потока.
</ul>

<P>
Возможности, которые пока еще не поддерживаются:

</P>

<ul>
<LI>

<code>ALTER TABLE</code>  игнорирует  все  опции  <code>INDEX/DATA DIRECTORY="path"</code>.

<LI>

<code>CREATE TABLE</code> не сообщает, что данная таблица имеет символические
ссылки.

<LI>

<code>mysqldump</code> не включает в вывод информацию о символических ссылках.

<LI>

<code>BACKUP TABLE</code> и <code>RESTORE TABLE</code> не признают символические ссылки.
</ul>

<P><HR><P>
Go to the <A HREF="manual.ru_Introduction.html">first</A>, <A HREF="manual.ru_MySQL_Database_Administration.html">previous</A>, <A HREF="manual.ru_Reference.html">next</A>, <A HREF="manual.ru_Concept_Index.html">last</A> section, <A HREF="manual.ru_toc.html">table of contents</A>.
 </BODY>
 </HTML>
