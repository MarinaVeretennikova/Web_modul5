<html><head><META http-equiv=Content-Type content="text/html;charset=windows-1251"><style>div.main {margin-left: 20pt; margin-right: 20pt}</style></head><body leftmargin=0 rightmargin=0 topmargin=0 marginheight=0 marginwidth=0><link REL=stylesheet HREF=http://emanual.ru/style.css TYPE=text/css><table border=0 width=100% cellspacing=0 cellpadding=0><tr><td bgcolor=gold><a href=http://emanual.ru/><img src=http://emanual.ru/logo.gif width=150 height=60 vspace=4 hspace=4 border=0></a></td><td align=center bgcolor=gold valign=center width=100%><iframe src="http://www.xbn.ru/cgi-bin/iframe/emanual?8 " width=468 height=60 marginwidth=0 marginheight=0 scrolling=no frameborder=0><a href="http://www.xbn.ru/cgi-bin/href/emanual?8 " target=_top><img src="http://www.xbn.ru/cgi-bin/banner/emanual?8 " alt="eXclusive Banner Network" width=468 height=60 border=0 ismap></a></iframe><img src=http://emanual.ru/blank.gif width=4 height=1 vspace=0 hspace=0 border=0><iframe src="http://120.goodoo.ru/cgi-bin/iframe/emanual?8&" width=120 height=60 marginwidth=0 marginheight=0 scrolling=no frameborder=0><a href="http://120.goodoo.ru/cgi-bin/href/emanual?8" target=_top>></a><img src="http://120.goodoo.ru/cgi-bin/banner/emanual?8&" alt="GooDoo 120" width=120 height=60 border=0 ismap></a></iframe></td></tr><tr><td bgcolor=black colspan=2 background=http://emanual.ru/line_bg.gif align=center class=fine height=20><font color=white><a href=http://softarea.ru class=top>Программы</a> &#149;<a color=white href=http://hardarea.ru class=top>Железо</a> &#149; <a color=white href=http://softarea.ru/drivers class=top>Драйверы</a> &#149; <a href=http://majordomo.ru/hosting class=top>Хостинг</a> &#149;<a href=http://reklamist.com class=top>Энциклопедия рекламы</a></font></td></tr></table><div class=main>
<BLOCKQUOTE><BR><FONT face=Arial size=+1><B>Программируем на 
  РНР</B></FONT><FONT face=Arial> <FONT size=-1>
  <P><B>Это не только очень просто — это еще и увлекательно! К такому выводу 
  неизменно приходишь, если начинаешь знакомиться с основами</B> 
  <B>программирования на языке гипертекстового препроцессора РНР. Ну вот, еще 
  только начало, а уже непонятные слова пошли. Это ж надо было придумать такое — 
  гипертекстовый препроцессор! Так что для улучшения восприятия материала 
  давайте заранее условимся, что будем применять упрощенные и понятные всем 
  термины, что бы было понятно буквально всем. И еще одна непременная условность 
  — делаем все так, как делаем. Есть несколько способов открыть Панель 
  Управления в Windows, есть разные способы приготовить одно и то же блюдо, и 
  есть разные способы и методы программирования. С поставленной задачей можно 
  справиться и так, как описано, и совсем по-другому. Но в нашем случае упор 
  будет делаться на простоту и логичность, а не на скорость и чистоту кода. Все 
  это придет несколько позже, а пока наша цель — учиться, учиться, и еще раз 
  учиться. В продолжение темы, поднятой в статье "РНР для всех!", мы углубимся 
  дальше в удивительный мир программирования.<BR><BR>Циклы в РНР<BR></B>Циклы в 
  программировании — это повторяющиеся несколько раз операции. Начало (точка 
  отсчета) указывается в начале цикла, а длительность его выполнения 
  ограничивается каким-либо условием. Примером цикла может служить копирование 
  нескольких файлов. Алгоритм выполнения этого задания можно описать так: 
  установить счетчик скопированных файлов в ноль, скопировать файл, проверить, 
  закончились файлы или нет, если нет — увеличить счетчик скопированных файлов, 
  вернуться к началу цикла (опять скопировать файл), если да — закончить цикл. 
  Теперь рассмотрим, как циклы реализуются в синтаксисе РНР.</P><PRE>&lt;?php
$i = 0; $n = 10;
while ($i &lt;= $n):
echo $i."&lt;br&gt;\n";
$i++;
endwhile;
?&gt;</PRE>
  <P>Смысл скрипта очень прост. Присваиваем переменной $i значение, 
  соответствующее началу цикла, а переменной $n — значение конца цикла. Далее 
  открываем цикл оператором WHILE ( ), и внутри его скобок описываем условие, 
  при выполнении которого цикл будет продолжать свою работу. В нашем случае 
  выполнение не прервется, пока $i &lt;= $n. Как только это условие будет 
  нарушено, управление будет передано следующей за циклом операции РНР. Внутри 
  цикла могут быть любые команды РНР (разделенные между собой, как обычно, 
  точкой с запятой). Только нужно следить за тем, чтобы переменная $i, 
  используемая в цикле, была увеличена (и совсем не обязательно на единицу), 
  иначе цикл станет бесконечным, и интерпретатор РНР будет выполнять его, пока 
  не закроется сессия (окно браузера). Оператор ENDWHILE означает конец цикла. 
  Скрипт, описанный здесь, выводит на экран браузера цифры, начиная с 0 до 10. 
  Причем цифры будут выведены в столбик, так как после вывода на экран значения 
  переменной $i мы выводим HTML-тег перевода строки (&lt;br&gt;). После него 
  идет перевод строки для кода, переданного клиенту (его можно посмотреть, 
  выбрав просмотр в виде HTML в меню Вашего браузера). Это не обязательно, но 
  таким образом достигается удобочитаемость кода. Для примера я привожу еще один 
  вариант выполнения указанной выше задачи, но уже гораздо более правильно с 
  точки зрения чистоты кода и скорости выполнения.</P><PRE>&lt;?php 
$i = 0; while ($i &lt;= 10) { echo $i++."&lt;br&gt;"; }
?&gt;</PRE>
  <P>Удивительно, но эти два примера абсолютно идентичны в смысле результата. Но 
  сам скрипт уместился в одну строчку! Разница — в стиле применения оператора 
  цикла и в том, что переменная цикла выводится на экран одновременно с 
  увеличением. И в этом — вся прелесть программирования. Иногда бывает что-то 
  простое сделать очень трудно, а сложное — легко. Никогда не стоит 
  останавливаться на уже достигнутом, а пробовать применять другие алгоритмы и 
  решения. Вот Вам еще один вариант решения. Он основан на применении 
  конструкции РНР DO…WHILE. Это тоже цикл, но отличается он от просто WHILE тем, 
  что значение логического выражения проверяется не до (как в случае с WHILE), а 
  после окончания работы операторов, включенных в сам цикл. Таким образом, 
  DO…WHILE гарантированно будет выполнен хотя бы один раз, что в случае с WHILE 
  совсем не обязательно. Ведь если условие есть ложь, управление сразу будет 
  передано дальше. Для циклов DO..WHILE существует только один вид 
  синтаксиса:&nbsp;</P><PRE>&lt;?php
$i = 0; do { echo $i."&lt;br&gt;\n"; $i++; } while ($i &lt;=10);
?&gt;</PRE>
  <P>Казалось бы, достаточно вариантов, но это не все — существует еще несколько 
  вариантов цикла. И, как правило, именно они и используются программистами. 
  Циклы FOR — наиболее мощные циклы в PHP. Они работают подобно их аналогам в 
  языке программирования C. Синтаксис цикла FOR:<BR>FOR (expr1; expr2; expr3) 
  statement&nbsp;<BR>Первое выражение (expr1), безусловно, вычисляется 
  (выполняется) в начале цикла. В начале каждой итерации (проход цикла) 
  вычисляется expr2. Если оно равно TRUE (истина), то цикл продолжается и 
  выполняются вложенный(е) оператор(ы). Если оно равно FALSE (ложь), то цикл 
  заканчивается. В конце каждой итерации вычисляется (исполняется) expr3. Каждое 
  из этих выражений может быть пустым. Если expr2 пусто, то цикл продолжается 
  бесконечно (PHP по умолчанию считает его равным TRUE, как и в языке С). Это не 
  так бесполезно, как могло бы показаться, так как зачастую требуется закончить 
  выполнение цикла, используя оператор BREAK в сочетании с логическим условием, 
  вместо использования логического выражения в FOR. Если внутри цикла (любого) 
  встречается этот оператор (BREAK), цикл прекращает выполнение итерации и 
  управление передается следующей за циклом команде. Если встречается оператор 
  CONTINUE — управление передается на начало следующего ближайшего цикла. Для 
  примера посмотрим, как можно еще реализовать вывод на экран пользователя 
  список чисел. Не забывайте про переход из HTML в PHP.</P><PRE>/* пример 1 */
for ($i = 1; $i &lt;= 10; $i++) 
{ print $i; }
/* пример 2 */
for ($i = 1;;$i++) 
{ if ($i &gt; 10) { break; } print $i; }
/* пример 3 */
$i = 1; for (;;)
{ if ($i &gt; 10) { break; } print $i; $i++; }
/* пример 4 */
for ($i = 1; $i &lt;= 10; print $i, $i++) ;</PRE>
  <P>Так что не говорите потом, что у Вас не было выбора :-). На примере 
  тривиальной задачи мы рассмотрели, как РНР позволяет разными способами достичь 
  одной цели. Как правило, на практике применяется наиболее подходящая 
  конструкция, но часто в этом нет никакой необходимости, достаточно 
  использовать самый простой и логичный вариант.<BR><BR><B>Отправка 
  почты<BR></B>Очень часто хочется знать, что происходит на сайте за время 
  Вашего отсутствия. Конечно, можно периодически проверять форум, гостевую и 
  т.д. на предмет новых сообщений, но есть способ лучше! Почему бы не присылать 
  самому себе сообщение на почтовый ящик, когда на сайте происходит то или иное 
  событие? Как пример могу предложить такие варианты: регистрация в рассылке, 
  ввод сообщения в форум, гостевую и т.д., ошибка открытия файла, организация 
  обратной связи, опрос мнения читателей о размещенной статье и т.д и т.п. 
  Способов применить эту возможность РНР — масса, осталось разобраться, как это 
  работает. Как всегда — просто! Синтаксис таков:<BR>Mail ( $email, "Введено 
  сообщение", $str, "From: сообщение ");&nbsp;<BR>Конечно, перед этим 
  соответствующие переменные должны быть введены либо вручную, либо с помощью 
  формы (нужно следить за соответствием имен переменных в форме и в скрипте). 
  При выполнении данной команды интерпретатор РНР пошлет письмо с текстом из 
  переменной $str по адресу, указанному в переменной $email. Все остальное — 
  служебная информация, которая может быть в некоторых случаях опущена за 
  ненадобностью. Для примера рассмотрим систему контроля за посетителями 
  определенных страниц сайта. Такая возможность может понадобиться для анализа 
  посещений определенных статей, страниц и т.д. Нам потребуется информация о 
  посетителе, которая в РНР автоматически доступна через переменные окружения. 
  Эту информацию мы будем отсылать себе на почтовый ящик. Только не 
  переусердствуйте — каждое посещение такой страницы вызовет отправку письма, и 
  ящик может оказаться переполненным.</P><PRE>&lt;?php
if (isset ($HTTP_X_FORWARDED_FOR)) 
{ 
$host = gethostbyaddr($HTTP_X_FORWARDED_FOR); 
}else{ 
$host = gethostbyaddr($REMOTE_ADDR); } 

$ip=getenv('REMOTE_ADDR');
$date=date('d M Y, H:i:s');
$host1=gethostbyaddr("$ip");

$str=("
Дата — $date
Хост — $host
IP-адрес — $ip
---------------------");
mail( $email, "статистика", $str, "From:информация");
?&gt;</PRE>
  <P>Если Вы разместите на одной из Ваших страниц этот код РНР, информация о 
  посетителе (это дата входа, хост и IP-адрес) будет в Вашем почтовом ящике. Еще 
  можно прислать себе сообщение при возникновении ошибки (например, открытия 
  файла) на сайте:</P><PRE>$filename = "data.txt"; 
$fp = @fopen($filename,"r"); 
if ( !$fp ) { @mail( $email, "Ошибка!", "Ошибка открытия файла $filename !"); }</PRE>
  <P>Как обычно, можно поставить знак @, и если возникнет ошибка при отправке 
  почты, сообщение об этом не будет выведено на экран. А можно просто проверить, 
  ушло письмо или нет: if ( @mail( $email, "Тест", $str) ) { … что сделать если 
  письмо ушло … } else { … что делать, если произошла ошибка отправки (не 
  доступен ящик, сайт и т.д) }. Собственно говоря, есть возможность забирать 
  почту с любого аккаунта, но это требует расширения РНР за счет подключения 
  дополнительных модулей, и в стандартной поставке недоступно. Если в переменной 
  $email указать несколько адресов, разделенных пробелами, информация будет 
  разослана по всем указанным адресам. Это открывает простой путь к организации 
  собственной, ни от кого не зависящей системы почтовых 
  рассылок.<BR><BR><B>Времена и даты<BR></B>Раз уж разговор коснулся даты, 
  попробуем разобраться, как все это можно использовать в своих собственных 
  целях. В РНР наиболее часто используется функция DATE в формате 
  $date=date('параметр');. Параметров может быть несколько, и разделяются они 
  между собой запятой. Вот список допустимых параметров.<BR>• a — "am" или 
  "pm"<BR>• A — "AM" или "PM"<BR>• d — день месяца, цифровой, 2 цифры (на первом 
  месте ноль)<BR>• D — день недели, текстовый, 3 буквы; т.е. "Fri"<BR>• F — 
  месяц, текстовый, длинный; т.е. "January"<BR>• h — час, цифровой, 12-часовой 
  формат<BR>• H — час, цифровой, 24-часовой формат<BR>• i — минуты, 
  цифровой<BR>• j — день месяца, цифровой, без начальных нулей<BR>• l (строчная 
  'L') — день недели, текстовый, длинный; т.е. "Friday"<BR>• m — месяц, 
  цифровой<BR>• M — месяц, текстовый, 3 буквы; т.е. "Jan"<BR>• s — секунды, 
  цифровой<BR>• S — английский порядковый суффикс, текстовый, 2 символа; т.е. 
  "th", "nd"<BR>• U — секунды с начала века<BR>• Y — год, цифровой, 4 цифры<BR>• 
  w — день недели, цифровой, 0 означает воскресенье<BR>• y — год, цифровой, 2 
  цифры<BR>• z — день года, цифровой; т.е. "299"</P>
  <P>Обратите внимание на отличия в регистре. Каждый символ в разных регистрах 
  имеет разные функции. Теперь Вы легко можете получить информацию о текущем 
  времени и использовать ее на своем сайте. Один из самых распространенных 
  вариантов — вывод текущего времени и даты. Конечно, все это делается без 
  проблем на JavaScript, но кто видел эти скрипты, тот поймет разницу (по 
  крайней мере, в размере и скорости выполнения, не говоря уже о трафике от 
  сервера к браузеру). Ну, время, на мой взгляд, выводить бесполезно, так как 
  оно есть у каждого пользователя в трее Windows-а, а вот вывести число, месяц и 
  день недели (да еще на русском языке) бывает полезно. Начнем с приветствия 
  посетителю. Было бы неплохо вывести соответствующую фразу в зависимости от 
  времени посещения. Сказано — сделано:</P><PRE>&lt;?php 
$h=date('H');
if ($h&gt;=5 &amp;&amp; $h&lt;=11) echo "Доброе утро!";
if ($h&gt;=12 &amp;&amp; $h&lt;=18) echo "Здравствуйте!";
if ($h&gt;=19 &amp;&amp; $h&lt;=24) echo "Добрый вечер!";
if ($h&gt;=1 &amp;&amp; $h&lt;=4) echo "Доброй ночи!";
?&gt;</PRE>
  <P>Цифры желаемого времени можно проставить любые, в зависимости от личного 
  понятия дня и ночи :-). Следующий шаг — вывод числа, дня недели и имени 
  месяца. Но прежде чем мы приступим к реализации алгоритма, нам нужно 
  познакомиться еще с одним важным моментом в языках 
  программирования.<BR><BR><B>Массивы в РНР<BR></B>Если Вы четко представляете 
  себе, что такое массив, предлагаю Вам сразу перейти к чтению следующего 
  абзаца. Если нет, тогда именно это Вы сейчас и узнаете. Массив — это ряд 
  переменных, упорядоченных по имени и имеющих различный индекс. Для примера 
  представьте, что у Вас есть двадцать названий, и все их нужно внести в 
  программу. Можно для удобства обозвать переменные одинаковым именем и ставить 
  в конце каждого имени переменной число в соответствии с номером названия. У 
  Вас получится простейший одномерный массив. Только любой язык программирования 
  (и РНР тоже!) предоставляет набор средств для более детальной и удобной работы 
  с таким набором-массивом. И число (так называемый индекс) нужно заключать в 
  квадратные скобки. Допустим, есть ряд строковых переменных: компьютер, 
  Интернет, модем, монитор. Имя для массива выберем $m, хотя доступно любое, как 
  и у обычной переменной. Индекс в массивах начинается не с единицы, а с нуля, и 
  таким образом для внесения наших слов в массив надо сделать так:</P><PRE>$m[0] = "компьютер";
$m[1] = "Интернет";
$m[2] = "модем";
$m[3] = "монитор";</PRE>
  <P>Теперь у нас создан массив с именем $m и максимальным индексом (это 
  количество элементов в массиве) — 4. Именно 4, хотя последний заполненный 
  элемент — 3. Если мы попробуем считать элемент с 4-ым индексом, результат 
  будет равен пустой строке, так как там просто ничего нет. Обращаться к 
  элементам массива нужно по имени массива и его индексу, что и составляет 
  основное удобство. Например, мы можем вывести на экран все элементы 
  массива:</P><PRE>$i = 0; while ($i &lt; count($m)) { echo $m[$i]."&lt;br&gt;"; $i++; }</PRE>
  <P>Функция count($m) выдает нам число, соответствующее максимальному индексу 
  массива. Таким образом, у нас всегда есть возможность знать, сколько элементов 
  присутствует в данном массиве. Что еще можно узнать о массивах в РНР? Кое-что 
  можно… Например, функция current возвращает текущий элемент массива. Каждая 
  переменная-массив имеет внутренний указатель (это не индекс, а специальный 
  параметр, который, как правило, либо совпадает с индексом, либо превышает его 
  на единицу, но необязательно), который указывает на один из своих элементов. 
  Кроме того, все элементы в массиве связываются двунаправленным списком 
  указателей для дополнительных целей. Внутренний указатель указывает на первый 
  элемент, который включался в массив, пока Вы не выполняли одну из функций, 
  которые модифицируют этот указатель в этом массиве. Функция current() просто 
  возвращает элемент массива, на который в данный момент указывает внутренний 
  указатель. Она никак не перемещает указатель. Если внутренний указатель 
  указывает на конец списка элементов, current() возвращает false (ложно). 
  Внимание: если массив содержит пустые элементы (0 или "", пустую строку), то 
  функция возвратит "false" для каждого из них. Это показывает, что текущий 
  элемент является нулевым значением или вы дошли до конца массива. End — 
  устанавливаете внутренний указатель массива на последнем элементе. Next — 
  передвигает внутренний указатель массива. Возвращает следующий элемент 
  массива, от текущей позиции внутреннего указателя массива, или "ложь"(false), 
  если нет больше элементов. Если массив содержит пустые элементы, тогда эта 
  функция возвратит "ложь" (false) и для этих элементов. next() ведет себя 
  подобно current(), с одной лишь разницей: он передвигает внутренний указатель 
  массива на один элемент вперед прежде, чем возвратить элемент. Это означает, 
  что он возвращает значение следующего элемента и передвигает на него 
  внутренний указатель массива. Если при обращении к следующему элементу 
  обнаружен конец массива — next() возвращает "ложь" (false). Prev — перемещает 
  внутренний указатель массива. Возвращает предыдущий элемент массива, или 
  "ложь" (false), если перед текущим нет больше элементов. Если массив содержит 
  пустые элементы, то функция возвратит "ложь" и на этих элементах. prev() ведет 
  себя подобно next(), за исключением того, что он переводит внутренний 
  указатель массива на одну позицию назад, а не вперед. Reset () — устанавливает 
  внутренний указатель массива на первом элементе. Rsort () — сортирует массив в 
  обратном порядке (по убыванию), по алфавиту в том числе. К сожалению, русский 
  алфавит тут не при чем. Sort () — сортирует массив. Точно то же, что и 
  предыдущее, только по возрастанию. Конечно, это далеко не все функции, которые 
  есть в РНР относительно массивов. Но остальное часто очень специфично и 
  решается иногда более простыми методами.<BR><BR><B>Дата 
  по-русски<BR></B>Скрипт, который мы сейчас рассмотрим, позволяет вывести на 
  экран посетителя дату в формате русского языка. Сразу предупреждаю, что 
  реализация алгоритма этой задачи не самая лучшая, но работоспособная, ясная во 
  всех отношениях и простая. А главное — используется только то, что уже было 
  описано. Сначала я приведу сам текст скрипта, а потом подробно опишу его.</P><PRE>&lt;?php
//-- определяем массив для месяцев --
$q[]="";
$q[]="января"; 
$q[]="февраля"; 
$q[]="марта"; 
$q[]="апреля"; 
$q[]="мая";
$q[]="июня"; 
$q[]="июля"; 
$q[]="августа"; 
$q[]="сентября"; 
$q[]="октября"; 
$q[]="ноября";
$q[]="декабря";

//-- определяем массив для дней недели --
$e[0]="воскресенье"; 
$e[1]="понедельник"; 
$e[2]="вторник"; 
$e[3]="среда"; 
$e[4]="четверг";
$e[5]="пятница"; 
$e[6]="суббота"; 

// ---- считываем месяц
$m=date('m');
if ($m=="01") $m=1; 
if ($m=="02") $m=2;
if ($m=="03") $m=3;
if ($m=="04") $m=4; 
if ($m=="05") $m=5;
if ($m=="06") $m=6;
if ($m=="07") $m=7;
if ($m=="08") $m=8; 
if ($m=="09") $m=9;

// ---- считываем день недели
$we=date('w');

// ---- считываем число
$chislo=date('d');

// — извлекаем день недели
$den_nedeli = $e[$we];

// — извлекаем значение месяца
$mesyac = $q[$m];

echo "Сегодня ".$chislo." ".$mesyac.", ".$den_nedeli;
?&gt;</PRE>
  <P>Теперь рассмотрим, как работает этот скрипт. Сначала нам нужно определить 
  два массива, в которых будут храниться соответственно русское название месяца 
  и русское название дня недели. Так как месяц не может быть нулевым, нам нужно 
  позаботиться о вводе элемента массива с нулевым индексом. Если индекс массива 
  не указан, он принимается равным внутреннему указателю. Если массив пуст и еще 
  не определен, внутренний указатель указывает на первый элемент (имеющий индекс 
  ноль). Ввод нового элемента массива перемещает внутренний указатель на единицу 
  вверх, и, таким образом, обеспечивается последующий ввод значения массива в 
  ячейку массива, имеющую индекс на единицу больший, чем предыдущий. В принципе, 
  можно обеспечить ввод данных в массив разными способами. Но указанный здесь — 
  самый простой и примитивный. Мы просто присваиваем поочередно нужные нам 
  данные элементам массива и, таким образом, заполняем его. Точно такая же 
  история наблюдается и со вторым массивом. Только тут уже индекс нужных ячеек 
  массива указывается явно, и внутренний указатель устанавливается на тот 
  индекс, который указан, а после ввода значения перемещается вверх на единицу. 
  Разница между этими двумя методами в том, что если массив уже был определен 
  ранее и индекс при вводе не указан, заполнится ячейка массива, на которую 
  указывает внутренний указатель. А он ведь может находиться и в конце! А если 
  индекс указан явно, внутренний указатель устанавливается на его значение и 
  запись происходит в явно указанную ячейку. Собственно, чаще массивы бывают 
  гораздо длиннее приведенных в примере, и удобнее воспользоваться специальной 
  функцией, которая позволяет считать указанный в ней файл и ввести все, что 
  есть в этом файле, в массив. Причем разделителем считается перевод строки, что 
  очень удобно. Синтаксис этой функции — $имя массива = file ("имя файла");. 
  Дальше формируется массив с указанным именем и значениями, соответствующими 
  строкам файла.&nbsp;<BR>Когда массивы определены, нам нужно считать номер 
  месяца. Он считывается с ведущим нулем, если номер месяца менее десяти, и 
  поэтому нам нужно позаботиться об его отсечении. Тут можно применить тоже 
  разные алгоритмы и методы, но мы воспользуемся лобовым решением — просто 
  сравним полученное решение с рядом заранее известных вариантов и изменим номер 
  месяца на правильный без нуля. Решение грубое, зато понятное и уже знакомое 
  нам. Хотя так делать не правильно — есть более изящные методы, например, 
  проверить полученное значение на ведущий ноль, и если проверка есть истина 
  (самый первый символ в строке — ноль), удалить первый символ.<BR>Далее по ходу 
  скрипта мы считываем день недели и число. С числом делать ничего не нужно, так 
  как дата будет понятна всем, а вот день недели и месяц должны подвергнуться 
  обработке. Извлекаем из введенного нами ранее массива день недели. Номер дня 
  недели указывает на ячейку нашего массива, где хранится нужное русское имя, и 
  таким образом мы в любом случае получим правильное значение. Меняется номер 
  дня недели, меняется номер (индекс) ячейки, из которой считывается значение. 
  Причем тут, в отличие от массива с именем месяца, нулю соответствует 
  воскресенье, что мы и учли при вводе массива дней недели. Точно такую же 
  операцию проводим и для месяца. Его номер указывает на ячейку массива, где 
  хранится правильное имя месяца на русском языке. А дальше — выводим результат 
  на экран в произвольной форме.&nbsp;<BR><BR><B>Заключение<BR></B>Итак, мы 
  познакомились с очень важными в любом языке программирования принципами 
  организации циклов и массивов, а также узнали, как применять на практике 
  возможность отправки почты и считывание даты. Не сомневаюсь, что вы сможете 
  придумать еще много примеров для применения этих вещей. Не стесняйтесь 
  экспериментировать и пробовать различные варианты. Именно так и изучаются 
  языки программирования — на примерах. Используйте для поиска новых решений и 
  скриптов Интернет, подпишитесь на рассылки по РНР для получения новой 
  информации. Если не все понятно — смело задавайте вопросы, я постараюсь по 
  мере сил и знаний ответить на них. И никогда не останавливайтесь на 
  достигнутом, так как всегда существует то, что мы еще пока не знаем, а ведь 
  так хочется…<BR><BR><B>Андрей Кухарчик @ июнь 2001<BR><A 
  href="http://virtual.bresttelecom.by/php">http://virtual.bresttelecom.by/php</A>&nbsp;<BR><A 
  href="mailto:virtualphp@tut.by">virtualphp@tut.by</A>&nbsp;</B></P>
</div></body></html>