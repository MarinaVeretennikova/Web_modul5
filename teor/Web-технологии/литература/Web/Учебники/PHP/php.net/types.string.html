<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Language" content="ru"><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE>Строки</TITLE>
<LINK REL="stylesheet" HREF="style.css"></HEAD>
<body><TABLE BORDER="0" WIDTH="100%" HEIGHT="100%"><TR><TD COLSPAN="3">
<TABLE BGCOLOR="#CCCCFF" BORDER="0" WIDTH="100%"><TR><TD>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="3"><TR><TH COLSPAN="3">Учебник РНР</TH></TR><TR>
<TD WIDTH="10%"><A HREF="types.float.html">Назад</A></TD>
<th WIDTH="80%">Глава 6. Типы</th><TD WIDTH="10%" ALIGN="right">
<A HREF="types.array.html">Вперёд</A></TD></TR></TABLE></TD></TR><TR BGCOLOR="#333366"><TD>
<IMG SRC="imag/spacer.gif" BORDER="0" width="1" height="1"><BR></TD></TR></TABLE></TD></TR><TR><TD>
<IMG SRC="imag/spacer.gif" WIDTH="10" HEIGHT="1"></TD><TD HEIGHT="100%" VALIGN="TOP" WIDTH="100%">
<H1><a name="language.types.string">Строки</a></H1>
<P><A HREF="types.string.html"><B>string</B></A> это серия символов. В PHP символ
это то же самое, что и байт, то есть имеется точно
256 различных возможных символов. Это также предполагает, что в PHP нет встроенной поддержки Unicode.</P>
<BLOCKQUOTE><P><B>Примечание: </B>строки могут быть очень большими. 
Практически нет ограничений на размер строк в PHP, поэтому нет никаких причин заботиться о длине строк.</P></BLOCKQUOTE>
<H2><a name="language.types.string.syntax">Синтаксис</a></H2>
<P>Строковой литерал может специфицироваться тремя способами.<UL><LI>
<P><a href="#language.types.string.syntax.single">одинарными кавычками</a></P></LI>
<LI><P><a href="#language.types.string.syntax.double">двойными кавычками</a></P></LI>
<LI><P><A HREF="#language.types.string.syntax.heredoc">heredoc-синтаксисом</A></P></LI></UL>
<H3><a name="language.types.string.syntax.single">Одинарные кавычки</a></H3>
<P>Простейший способ специфицировать строку - заключить её в одинарные кавычки (символ <TT>'</TT>).</P>
<P>Для специфицирования литеральной одинарной кавычки вам нужно мнемонизировать/escape её с помощью backslash
(<TT>\</TT>), как во многих других языках.
Если backslash должен появиться перед одинарной кавычкой или в конце строки, нужно его удвоить.
Обратите внимание, что если вы захотите мнемонизировать любой другой символ, backslash 
также будет напечатан! Поэтому обычно нет необходимости мнемонизировать сам backslash.
<BLOCKQUOTE><P><B>Примечание: </B>в PHP 3 при этом будет выведено предупреждение уровня
<TT>E_NOTICE</TT>.</P></BLOCKQUOTE><BLOCKQUOTE><P><B>Примечание: </B>
  в отличие от двух других видов синтаксиса, переменные здесь <i>не</i> 
разворачиваются (не обсчитываются), когда находятся внутри строки, заключённой в одинарные кавычки.</P></BLOCKQUOTE>
<A NAME="AEN3642"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>echo 'Это простая строка.';
echo 'Вы можете также внедрять в строки символы newline,
как здесь.';
echo 'Arnold once said: "I\'ll be back"';
// на выходе: ... "I'll be back"
echo 'Are you sure you want to delete C:\\*.*?';
// на выходе: ... delete C:\*.*?
echo 'Are you sure you want to delete C:\*.*?';
// на выходе: ... delete C:\*.*?
echo 'I am trying to include at this point: \n a newline';
// на выходе: ... this point: \n a newline</PRE></TD></TR></TABLE>
<H3><a name="language.types.string.syntax.double">Двойные кавычки</a></H3>
<P>Если строка заключена в двойные кавычки ("),
PHP понимает б&#x0301;ольшее количество escape-последовательностей (мнемоник) специальных символов:</P>
<A NAME="AEN3647"></A><h6>Таблица 6-1. Мнемоники символов</h6><TABLE BORDER="1"><TR>
<TH>последовательность</TH><TH>значение</TH></TR><TR><TD><TT>\n</TT></TD><TD>linefeed/прогон строки (LF или 0x0A (10) в ASCII)</TD>
</TR><TR><TD><TT>\r</TT></TD><TD>carriage return/возврат каретки (CR или 0x0D (13) в ASCII)</TD></TR>
<TR><TD><TT>\t</TT></TD><TD>horizontal tab/горизонтальная табуляция (HT или 0x09 (9) в ASCII)</TD></TR>
<TR><TD><TT>\\</TT></TD><TD>backslash/обратная наклонная черта</TD></TR><TR><TD><TT>\$</TT></TD>
<TD>знак dollar/доллар</TD></TR><TR><TD><TT>\"</TT></TD><TD>double-quote/двойная кавычка</TD></TR>
<TR><TD><TT>\[0-7]{1,3}</TT></TD><TD>последовательность символов, совпадающая с регулярным выражением, 
символ в 8-ричной нотации</TD></TR><TR><TD><TT>\x[0-9A-Fa-f]{1,2}</TT></TD><TD>
последовательность символов, совпадающая с регулярным выражением, символ в 16-ричной нотации</TD></TR></TABLE>
<P>Ещё раз напоминает, что если вы захотите мнемнонизировать любой другой 
символ, backslash также будет напечатан!</P>
<P>Но самым важным свойством строки, заключённой в двойные кавычки, является 
то, что имена переменных разворачиваются.
См. <a href="#language.types.string.parsing">разбор строк</a>.</P>
<H3><A NAME="language.types.string.syntax.heredoc">Heredoc</A></H3>
<P>Другой способ ограничения строки - использовать синтаксис heredoc ("&#60;&#60;&#60;").
После <TT>&#60;&#60;&#60;</TT> необходимо предоставить идентификатор, затем строку, а затем - тот же 
идентификатор как закрывающую кавычку.</P>
<P>Закрывающий идентификатор <i>обязан</i> начинаться в первом столбце строчки.  Используемый идентификатор также обязан следовать тем же 
правилам именования, что и все другие метки в PHP:<br>
он может содержать только алфавитные символы, числа и символ подчёркивания и обязан начинаться с не-цифры или с символа подчёркивания.</P>
<TABLE CLASS="warning" BORDER="1" WIDTH="100%"><TR><th>Предупреждение!</th></TR><TR><TD>
<P>Важно отметить, что строчка с закрывающим идентификатором не содержит 
больше никаких символов, за исключением, <i>возможно</i>, точки с запятой (<TT>;</TT>).
Это означает, что идентификатор <i>не может вводится с отступом</i> 
и что не может быть никаких пробельных символов и знаков табуляции до и после точки с запятой.</P>
<P>Самое, возможно, неприятное, что в конце строки не может быть также и символа carriage return (
<TT>\r</TT>), только form feed, AKA newline (<TT>\n</TT>).
Поскольку Microsoft Windows использует последовательность <TT>\r\n</TT> как терминатор строки, ваш heredoc может не сработать, если вы запишете ваш 
скрипт в редакторе под Windows. Однако большинство 
программ-редакторов дают возможность сохранять ваши файлы с терминатором строк UNIX.</P></TD></TR></TABLE>
<P>Heredoc текст ведёт себя так же, как строка в двойных кавычках. Это 
значит, что вам не нужно мнемонизировать кавычки в heredocs, но можно 
продолжать использовать коды-мнемоники, перечисленные выше. Переменные 
разворачиваются, но с комплексными переменными в heredoc нужно работать 
так же внимательно, как и со строками.<TABLE WIDTH="100%" BORDER="0"><TR><TD>
<h5>
<A NAME="AEN3706"></A>Пример 6-2. Heredoc-пример строк в кавычках</h5>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE>&#60;?php
$str = &#60;&#60;&#60;EOD
Пример строки,
захватывающей несколько строчек,
с использованием синтаксиса heredoc.
EOD;

/* Более сложный пример, с переменными. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this-&#62;foo = 'Foo';
        $this-&#62;bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo &#60;&#60;&#60;EOT
My name is "$name". I am printing some $foo-&#62;foo.
Now, I am printing some {$foo-&#62;bar[1]}.
This should print a capital 'A': \x41
EOT;
?&#62;</PRE></TD></TR></TABLE></TD></TR></TABLE><BLOCKQUOTE><P><B>Примечание: </B>
  поддержка heredoc была введена в PHP 4.</P></BLOCKQUOTE>
<H3><a name="language.types.string.parsing">Разбор переменных</a></H3>
<P>Когда строка специфицируется двойными кавычками или heredoc, переменные внутри неё разбираются.</P>
<P>Есть два типа синтаксиса: <a href="#language.types.string.parsing.simple">
простой</a> и <a href="#language.types.string.parsing.complex">сложный</a>.
Простой синтаксис более распространён и удобнее, он предоставляет способ 
разбора переменной, переменной массива или свойства объекта.</P>
<P>Сложный синтаксис был введён в PHP 4 и может распознаваться по фигурным 
скобкам {} вокруг выражения.</P><H4><a name="language.types.string.parsing.simple">Простой синтаксис</a></H4>
<P>Если обнаружен знак dollar (<TT>$</TT>), разборщик захватывает как можно больше лексем для образования правильного 
имени. Заключайте имя переменной в фигурные скобки, если вы хотите явным образом специфицировать конец имени.</P>
<A NAME="AEN3722"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE>$beer = 'Heineken';
echo "$beer's taste is great"; // не будет работать, "'" это неправильный
			      // символ для имён переменных (у меня работает - <i>прим. пер.</i>)
echo "He drunk some $beers"; // работает, 's' это правильный символ
			      // для имён переменных
echo "He drunk some ${beer}s"; // работает</PRE></TD></TR></TABLE>
<P>Аналогично вы можете заставить разобрать индекс массива или свойство 
объекта. В индексах массивов закрывающая квадратная скобка
(<TT>]</TT>) обозначает конец индекса. Для свойств объекта применяются те же правила, что и для простых переменных,
хотя со свойствами объекта невозможен трюк, как с переменными.</P>
<A NAME="AEN3726"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>$fruits = array( 'strawberry' =&#62; 'red' , 'banana' =&#62; 'yellow' );

// заметьте, что это работает по-другому вне закавыченной строки.
echo "A banana is $fruits[banana].";

echo "This square is $square-&#62;width meters broad.";

// не будет работать. Для решения см. сложный синтаксис.
echo "This square is $square-&#62;width00 centimeters broad.";</PRE></TD></TR></TABLE>
<P>Для чего-либо более сложного вы должны использовать сложный синтаксис.</P>
<H4><A NAME="language.types.string.parsing.complex">Сложный (фигурный) синтаксис</A></H4>
<P>Он называется сложным не потому, что сложен, а потому что вы можете включать таким способом сложные выражения.</P>
<P>Фактически вы можете включать любое значение, которое находится в 
пространстве имён строки с этим синтаксисом. Вы просто записываете 
выражение тем же способом, что и вне строки, а затем окружаете его 
символами { и }. Поскольку вы не может заменить '{' мнемоникой, этот 
синтаксис будет распознаваться, только когда $ идёт непосредственно после {.<br>
(Используйте "{\$" или "\{$" для получения литерала "{$").<br>Вот некоторые примеры для пояснения:</P>
<A NAME="AEN3733"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>$great = 'fantastic';
echo "This is { $great}"; // не будет работать, выведет: This is { fantastic}
echo "This is {$great}";  // работает, выведет: This is fantastic
echo "Это квадрат шириной {$square-&#62;width}00 сантиметров."; 
echo "Это работает: {$arr[4][3]}";     

// Неверно по той причине,
// что $foo[bar] неверно вне строки.
echo "Это неправильно: {$arr[foo][3]}"; 

echo "Вы должны сделать это так: {$arr['foo'][3]}";
echo "Вы можете даже записать {$obj-&#62;values[3]-&#62;name}";
echo "Это значение переменной $name: {${$name}}";</PRE></TD></TR></TABLE>
<H3><a name="language.types.string.substr">Доступ к символу в строке</a></H3>
<P>Можно получить доступ к символам в строке путём специфицирования смещения 
с базой 0 в фигурных скобках для нужного символа.</P><BLOCKQUOTE><P><B>Примечание: </B>
  для обеспечения обратной совместимости вы можете по-прежнему использовать скобки массива.
Однако этот синтаксис не рекомендуется, начиная с PHP 4.</P></BLOCKQUOTE>
<TABLE WIDTH="100%" BORDER="0"><TR><TD>
  <h5><A NAME="AEN3741"></A>Пример 6-3. Некоторые примеры строк</h5>
  <TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE>&#60;?php
/* Присвоение строкового значения. */
$str = "This is a string";

/* Присоединение к ней. */
$str = $str . " with some more text";

/* Другой способ присоединения с мнемоникой для newline. */
$str .= " and a newline at the end.\n";

/* Эта строка будет выглядеть '&#60;p&#62;Number: 9&#60;/p&#62;' */
$num = 9;
$str = "&#60;p&#62;Number: $num&#60;/p&#62;";

/* А эта - '&#60;p&#62;Number: $num&#60;/p&#62;' */
$num = 9;
$str = '&#60;p&#62;Number: $num&#60;/p&#62;';

/* Получить первый символ строки */
$str = 'This is a test.';
$first = $str{0};

/* Получить последний символ строки */
$str = 'This is still a test.';
$last = $str{strlen($str)-1};
?&#62;</PRE></TD></TR></TABLE></TD></TR></TABLE>
<H2><a name="language.types.string.useful-funcs">Используемые функции</a></H2>
<P>Строки можно объединять (конкатенировать) с помощью операции '.' (точка). 
Заметьте, что операция сложения '+' здесь не работает. См. также раздел
<a href="operators.string.html">Строковые операции</a>.</P>
<P>Имеется большое количество функций для работы со строками.</P>
<P>См. <a href="f/ref.strings.html">раздел строковых функций</a>, функции 
регулярных выражений для продвинутого поиска &#38; замены (в двух частях: 
<A HREF="f/ref.pcre.html">Perl</A> и <A HREF="f/ref.regex.html">POSIX расширенный</A>).</P>
<P>Имеются также <A HREF="f/ref.url.html">функции для работы с URL-строками</A> и функции
для кодирования/декодирования строк (<A HREF="f/ref.mcrypt.html">mcrypt</A> и <A HREF="f/ref.mhash.html">mhash</A>).</P>
<P>Наконец, если вы ещё не нашли то, что нужно, посмотрите
<a href="f/ref.ctype.html">функции для символьного типа</a>.</P>
<H2><a name="language.types.string.conversion">Конвертация строк</a></H2>
<P>Когда строка вычисляется как числовое значение, результирующее значение и его тип определяются так.</P>
<P>Строка вычисляется как <A HREF="types.float.html"><B>float</B></A>, если
содержит любой из символов '.', 'e' или 'E'. Иначе она вычисляется как integer.</P>
<P>Значение даётся по начальной части строки. Если строка начинается с 
правильного числового значения, используется это значение. Иначе значение 
будет 0 (нуль). Верным числовым символом является знак с последующими одной 
или более цифрами (с возможной десятичной точкой), с последующей 
необязательной экспонентой. Экспонента это 'e' или 'E' с последующими одной или более цифрами.</P>
<A NAME="AEN3765"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>$foo = 1 + "10.5";                // $foo это float (11.5)
$foo = 1 + "-1.3e3";              // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
$foo = 1 + "bob3";                // $foo это integer (1)
$foo = 1 + "10 Small Pigs";       // $foo это integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
$foo = "10.0 pigs " + 1;          // $foo это float (11)
$foo = "10.0 pigs " + 1.0;        // $foo это float (11)</PRE></TD></TR></TABLE>
<P>Дополнительно об этой конвертации см. учебник Unix, страницы о strtod(3).</P>
<P>Если вы хотите протестировать любой из примеров этого раздела,
вы может скопировать его и вставить следующую строку, чтобы посмотреть, что будет:</p><A NAME="AEN3769"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>echo "\$foo==$foo; type is " . gettype ($foo) . "&#60;br /&#62;\n";</PRE></TD></TR></TABLE>
</TD><TD><IMG SRC="imag/spacer.gif" WIDTH="10" HEIGHT="1"></TD></TR><TR><TD COLSPAN="3">
<TABLE BGCOLOR="#CCCCFF" BORDER="0" WIDTH="100%"><TR BGCOLOR="#333366"><TD>
<IMG SRC="imag/spacer.gif" BORDER="0" width="1" height="1"><BR></TD></TR><TR><TD>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="3"><TR><TD WIDTH="33%" VALIGN="top">
<A HREF="types.float.html">Назад</A></TD><th WIDTH="34%" VALIGN="top">
<A HREF="index.html">Оглавление</A></th><TD WIDTH="33%" ALIGN="right" VALIGN="top">
<A HREF="types.array.html">Вперёд</A></TD></TR><TR><TD WIDTH="33%" VALIGN="top">Числа с плавающей точкой</TD>
<th WIDTH="34%" VALIGN="top"><a href="types.html">Вверх</a></th>
<TD WIDTH="33%" ALIGN="right" VALIGN="top">Массивы</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>
</BODY></HTML>