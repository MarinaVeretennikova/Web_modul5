<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><TITLE>Безопасность Баз Данных</TITLE>
<meta http-equiv="Content-Language" content="ru"><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<LINK REL="stylesheet" HREF="style.css"></HEAD>
<body><TABLE BORDER="0" WIDTH="100%" HEIGHT="100%"><TR><TD COLSPAN="3">
<TABLE BGCOLOR="#CCCCFF" BORDER="0" WIDTH="100%"><TR><TD><TABLE WIDTH="100%" BORDER="0" CELLPADDING="3"><TR>
<TH COLSPAN="3">Учебник РНР</TH></TR><TR><TD WIDTH="10%">
<A HREF="filesystem.html">Назад</A></TD><th WIDTH="80%">Глава 4. Безопасность</th>
<TD WIDTH="10%" ALIGN="right"><A HREF="error-message.html">Вперёд</A></TD></TR></TABLE>
</TD></TR><TR BGCOLOR="#333366"><TD><IMG SRC="imag/spacer.gif" BORDER="0" width="1" height="1"><BR></TD>
</TR></TABLE></TD></TR><TR><TD><IMG SRC="imag/spacer.gif" WIDTH="10" HEIGHT="1"></TD>
<TD HEIGHT="100%" VALIGN="TOP" WIDTH="100%"><H1><a name="security.database">Безопасность баз данных</a></H1>
<P>В настоящее время БД являются ключевыми компонентами любого web-приложения, 
давая web-сайтам возможность предоставлять разнообразное динамическое 
содержимое. Поскольку в таких БД может храниться очень секретная или 
высокоточная информация, вы должны предусмотреть их основательную защиту.</P>
<P>Для получения или сохранения любой информации вам необходимо установить соединение с БД,
отправить верный запрос, получить результат и закрыть соединение.<br>
В настоящее время чаще всего используется язык запросов
Structured Query Language (SQL). См., как взломщик может <A HREF="#security.database.sql-injection">вторгнуться с помощью SQL-запроса</A>.</P>
<P>PHP сам по себе не может защитить вашу БД. Последующие разделы являются 
введением в основы доступа и манипулирования БД в PHP-скриптах.</P>
<P>Запомните простое правило: максимальная защита. Необходимо защищать БД как 
можно сильнее, что уменьшит вероятность успеха взлома и получения, нарушения или уничтожения ценной информации.</P>
<H2><a name="security.database.design">Дизайн БД</a></H2>
<P>Первый шаг - это всегда создание БД, если только вы не хотите 
использовать готовую БД стороннего производителя. Когда БД создаётся, она 
назначается пользователю, который выполняет оператор создания. Обычно только 
владелец/owner (или superuser) может выполнять действия с объектами в БД, а 
чтобы и другие пользователи могли пользоваться этой БД, необходимо дать привилегии доступа.</P>
<P>Приложения никогда не должны соединяться с БД как её owner или
superuser, поскольку эти бюджеты могут выполнять любой запрос, 
модифицировать схему (например, стереть таблицы) или удалять всё содержимое полностью.</P>
<P>Вы можете создать различных пользователей БД для каждого аспекта вашего 
приложения с ограничениями на использование объектов БД. Нужно давать только 
самые необходимые привилегии и необходимо исключать возможность работы с БД 
одного пользователя в разных вариантах использования. Это значит, что, если 
взломщик получает доступ к вашей БД с использованием одних привилегий,
он сможет делать все изменения, какие только можно сделать ваше приложение.</P>
<P>Мы советуем не реализовывать всю бизнес-логику в web-приложении (т.е. в 
ваших скриптах), а использовать для этого схему БД с триггерами, просмотрами 
или правилами. Если система разрастается, понадобятся новые порты для БД, и 
вы должны будете заново реализовывать всю логику для каждого отдельного 
клиента БД. Вместо этого, можно использовать тригеры для прозрачной и 
автоматической обработки полей, что часто необходимо при отладке ваших 
приложений или при трассировке отката транзакций.</P>
<H2><a name="security.database.connection">Соединение с БД</a></H2>
<P>Вы можете установить соединение через SSL с целью шифровки соединения 
клиент/сервер для повышения защиты или использовать ssh для шифровки 
сетевого соединения между клиентами и сервером БД.
Если вы реализуете что-нибудь из этого, то мониторинг вашего трафика и 
получение информации значительно усложнится.</P>
<H2>Модель шифровки при хранении/<A NAME="security.database.storage">Encrypted Storage</A></H2>
<P>SSL/SSH защищает передачу данных с клиента на сервер, SSL/SSH не защищает 
постоянные данные, хранимые в БД. SSL это протокол on-the-wire.</P>
<P>Если взломщик получил прямой доступ к вашей БД (в обход web-сервера), он 
получит доступ к закрытым данным и может использовать их или повредить, если 
информация не защищена на уровне самой БД. Шифровка данных - хороший способ 
предотвратить это, но мало какие БД предлагают этот тип шифровки данных.</P>
<P>Простейший способ решения этой проблемы - создать сначала ваш собственный 
пакет шифрования данных, а затем использовать его PHP-скриптах. PHP
может в этом случае помочь вам различными расширениями, такими как
<A HREF="f/ref.mcrypt.html">Mcrypt</A> и <A HREF="f/ref.mhash.html">Mhash</A>, покрывающими
большое количество алгоритмов шифрования данных. Скрипт сначала 
шифрует сохраняемые данные, а затем дешифрует их при запросе. См. в описании 
следующих примеров о том, как работает шифрование.</P>
<P>В случае со скрытыми/hidden данными, если их необработанное представление не нужно
(то есть оно не отображается), можно предусмотреть хэширование.
Хорошо известный пример хэширования - хранение MD5-хэша пароля в БД, вместо хранения самого пароля. См. также
<A HREF="f/crypt.html"><B>crypt()</B></A> и <A HREF="f/md5.html"><B>md5()</B></A>.</P>
<TABLE WIDTH="100%" BORDER="0"><TR><TD>
  <h5><A NAME="AEN3184"></A>
  Пример 4-5. Использование хэшированного поля password</h5>
  <TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5">
<TR><TD><PRE>// хранение хэша пароля
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// запросить, если пользователь ввёл правильный пароль
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) &#62; 0) {
    echo "Welcome, $username!";
}
else {
    echo "Authentication failed for $username.";
}</PRE></TD></TR></TABLE></TD></TR></TABLE>
<H2>Инъекция <A NAME="security.database.sql-injection">SQL</A></H2>
<P>Многие web-разработчики не в курсе того, как запросы SQL могут быть 
подделаны, и считают, что SQL-запрос это надёжная команда.<br>
SQL-запросы могут обойти управление доступом, стандартную аутентификацию и 
проверку авторизации, а некоторые SQL-запросы могут даже дать доступ к командам ОС хоста.</P>
<P>Direct SQL Command Injection это такая техника, когда взломщик создаёт или 
изменяет текущие команды SQL для получения доступа к скрытым данным, их 
переопределения или даже для выполнения опасных команд системного уровня на 
хосте БД. Это выполняется с помощью приложения, принимающего 
пользовательский ввод, и сочетания его со static-параметрами для построения SQL-запроса. 
Следующие примеры (к сожалению...) основаны на реальных фактах.</P>
<P>Благодаря отсутствию проверки ввода и соединения с БД или поведению superuser'а 
или того, кто может создавать пользователей, взломщик может создать superuser'а в вашей БД.
<TABLE WIDTH="100%" BORDER="0"><TR><TD>
  <h5><A NAME="AEN3192"></A>
  Пример 4-6. Разделение результата выполнения запроса на страницы...<br>и создание superuser'ов
(PostgreSQL и MySQL)</h5>
  <TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>$offset = argv[0]; // видите, никакой проверки ввода!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// с PostgreSQL 
$result = pg_exec($conn, $query);
// с MySQL
$result = mysql_query($query);</PRE></TD></TR></TABLE></TD></TR></TABLE>
<p>Обычно пользователи щёлкают ссылки 'next', 'prev', где <TT>$offset</TT> кодируется в URL.
Скрипт ожидает, что входящее <TT>$offset</TT> это 10-ричное число. Однако кто-нибудь может попытаться
вломиться, присоединив <A HREF="f/urlencode.html"><B>urlencode()</B></A>'ированную форму
следующей информации к URL:</p><A NAME="AEN3198"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5">
<TR><TD><PRE>// в PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// в MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;</PRE></TD></TR></TABLE>
<p>Если это произойдёт, то скрипт даст доступ superuser'а к нему.
Заметьте, что <TT>0;</TT> предоставлен для того, чтобы задать правильное смещение/offset для запроса-оригинала и прервать его.</p>
<BLOCKQUOTE><P><B>Примечание: </B>
  обычной техникой является форсирование игнорирования SQL-разборщиком 
остальной части запроса, написанного разработчиком, с помощью <TT>--</TT> (знака комментария в SQL).</P></BLOCKQUOTE>
<P>Возможно получение паролей путём обмана ваших страниц с результатами поиска.
Взломщику нужно лишь проверить, имеется ли отправленная переменная, 
используемая в SQL-операторе, которая не обрабатывается надлежащим образом. 
Эти фильтры могут быть установлены обычно в предыдущей форме для специализирования вариантов <TT>WHERE,
ORDER BY, LIMIT</TT> и <TT>OFFSET</TT> в операторах <TT>SELECT</TT>. Если ваша БД поддерживает
конструкцию <TT>UNION</TT>, взломщик может попытаться присоединить к оригинальному запросу целый запрос 
на список паролей из произвольной таблицы. Использование шифрованных полей password 
настоятельно рекомендуется.<TABLE WIDTH="100%" BORDER="0"><TR><TD>
  <h5><A NAME="AEN3209"></A>
  Пример 4-7. Листинг статей ... и некоторых паролей (любой сервер БД)</h5>
  <TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);</PRE></TD></TR></TABLE></TD></TR></TABLE>
<p>Статическая часть запроса может комбинироваться с другим оператором <TT>SELECT</TT>, который
выявит все пароли:</p><A NAME="AEN3213"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR>
<TD><PRE>'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--</PRE></TD></TR></TABLE><p>Если этот запрос (играя с <TT>'</TT> и <TT>--</TT>) присоединить к
одной из переменных, используемых в <TT>$query</TT>, запрос чудовищно изменится.</p>
<P>SQL UPDATEs также являются субъектами атаки на ваши БД. Есть угроза их 
расчленения и присоединения к ним совершенно нового запроса. Взломщик может поработать с
<TT>SET</TT>. В этом случае нужно обладать некоторой схемой информации для успешного 
манипулирования запросом. Это можно сделать, проверив имена переменных формы, 
или просто выполнив грубое форсирование. Есть не так уж много соглашений по 
именованию полей для хранения паролей и имён пользователей.<TABLE WIDTH="100%" BORDER="0"><TR>
<TD>
<h5><A NAME="AEN3220"></A>Пример 4-8. От восстановления значения пароля ...<br>
до получения дополнительных привилегий (любой сервер БД)</h5>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5">
<TR><TD><PRE>$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";</PRE></TD></TR></TABLE></TD>
</TR></TABLE><p>Но пользователь-злоумышленник отправляет значение <TT>' or uid like'%admin%'; --</TT> в <TT>$uid</TT>
для изменения пароля admin'а или просто устанавливает в <TT>$pwd</TT> значение <TT>"hehehe', admin='yes', trusted=100 "</TT>
(с ведомым пробелом) для получения дополнительных привилегий. Затем запрос скручивается:</p>
<A NAME="AEN3227"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD>
<PRE>// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"</PRE></TD></TR></TABLE>
<P>Устрашающий пример того, как может быть получен доступ к командам уровня 
ОС на некоторых хостах БД.<TABLE WIDTH="100%" BORDER="0"><TR><TD>
  <h5><A NAME="AEN3230"></A>
  Пример 4-9. Атака на ОС-хост БД (MSSQL Server)</h5>
  <TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5">
<TR><TD><PRE>$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);</PRE></TD></TR></TABLE></TD></TR></TABLE>
<p>Если взломщик отправляет значение <TT>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</TT>
в <TT>$prod</TT>, то <TT>$query</TT> будет:</p><A NAME="AEN3236"></A><TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5">
<TR><TD><PRE>$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);</PRE></TD></TR></TABLE>
<p>MSSQL Server выполняет операторы SQL в пакетном режиме, включая и 
команды добавления нового пользователя в локальную БД бюджетов. Если такое 
приложение запущено как <TT>sa</TT
> и служба MSSQLSERVER запущена с достаточными привилегиями, хакер сможет 
получить бюджет для доступа к данной машине.</p><BLOCKQUOTE><P><B>Примечание: </B>
  некоторые из вышеприведённых примеров касаются определённых серверов БД. 
Это не означает, что аналогичные действия невозможны в отношении других продуктов.
Работа вашего сервера БД может быть нарушена каким-нибудь другим способом.</P></BLOCKQUOTE>
<H3><a name="security.database.avoiding">Как этого избежать</a></H3>
<P>Вы можете утешать себя тем, что хакер, в большинстве примеров, обязан 
владеть некоторой информацией о схеме БД. Вы правы, но вы никогда не 
знаете, когда и как будет предпринята попытка взлома, и если это произойдёт,
ваша БД может оказаться доступной для просмотра. Если вы используете 
свободный ресурс или публично доступный пакет работы с БД, который может 
относиться к системе менеджмента содержимого или форуму, взломщики легко 
создадут копию участка вашего кода. Риск для системы безопасности может 
быть также и в случае плохо сформированного кода.</P>
<P>Этим атакам в основном подвергается код, написанный без учёта требований 
безопасности. Никогда не доверяйте вводу любого рода, особенно тому, 
который поступает со стороны клиента, даже если он приходит от select-списка,
скрытого/hidden поля или куки/cookie. Первый пример показывает, что такой 
небезупречный запрос может привести к тяжким последствиям.</P><UL><LI>
<P>Никогда не соединяйтесь с БД как superuser или как владелец БД (owner).
Всегда используйте специализированных пользователей с максимально ограниченными правами.</P></LI>
<LI><P>Проверяйте, содержит ли ввод данные ожидаемого типа. В PHP есть большое 
количество функций проверки ввода: от простейших из групп
<a href="f/ref.variables.html">Функции переменных</a> и
<a href="f/ref.ctype.html">Функции типов символов</a> (например, <A HREF="f/is-numeric.html">
<B>is_numeric()</B></A>, <A HREF="f/ctype-digit.html"><B>ctype_digit()</B></A>,
соответственно) до поддержки <A HREF="f/ref.pcre.html">Perl-совместимых регулярных выражений</A>.</P></LI>
<LI><P>Если приложение ожидает цифровой ввод, предусмотрите проверку данных с помощью
<A HREF="f/is-numeric.html"><B>is_numeric()</B></A>, или скрыто измените его тип с
использованием <A HREF="f/settype.html"><B>settype()</B></A>, или используйте его числовое
представление через <A HREF="f/sprintf.html"><B>sprintf()</B></A>.
<TABLE WIDTH="100%" BORDER="0"><TR><TD>
  <h5><A NAME="AEN3260"></A>
  Пример 4-10. Более безопасный способ<br>составления запроса для разбивки на страницы</h5>
  <TABLE BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE>settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// обратите внимание на %d в строке формата, использование %s было бы бессмысленно
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);</PRE></TD></TR></TABLE></TD></TR></TABLE></LI>
<LI><P>Закавычивайте любой нечисловой пользовательский ввод, передаваемый в БД, с помощью
<A HREF="f/addslashes.html"><B>addslashes()</B></A> или <A HREF="f/addcslashes.html">
<B>addcslashes()</B></A>. См. <a href="#security.database.storage">первый пример</a>.
Как видно из примеров, кавычек, вставленных в статическую часть запроса, недостаточно, и это можно легко взломать.</P>
</LI><LI><P>Не выводите специфичную для БД информацию, особенно о схеме. См. также
<a href="error-message.html">Сообщение об ошибке</a> и <A HREF="f/ref.errorfunc.html">Обработка ошибок и функции логинга</A>.</P></LI>
<LI><P>Вы можете использовать хранимые процедуры и ранее определённые курсоры для абстрактного доступа к данным, чтобы пользователи не имели прямого 
доступа к таблицам или просмотрам/views, но это решение имеет свою специфику.</P></LI></UL>
<P>Помимо всего прочего, вы можете извлечь пользу из запросов логинга в 
вашем скрипте или  в самой БД, если она это поддерживает. Очевидно, что логинг не может предотвратить попытку нанесения вреда, но может помочь для 
трассировки &quot;обманутого&quot; приложения.<br>
log полезен не сам по себе, а содержащейся в нём информацией. Чем больше деталей, тем обычно лучше.</P>
</TD><TD><IMG SRC="imag/spacer.gif" WIDTH="10" HEIGHT="1"></TD></TR><TR><TD COLSPAN="3">
<TABLE BGCOLOR="#CCCCFF" BORDER="0" WIDTH="100%"><TR BGCOLOR="#333366"><TD>
<IMG SRC="imag/spacer.gif" BORDER="0" width="1" height="1"><BR></TD></TR><TR><TD>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="3"><TR><TD WIDTH="33%" VALIGN="top">
<A HREF="filesystem.html">Назад</A></TD><th WIDTH="34%" VALIGN="top">
<A HREF="index.html">Оглавление</A></th><TD WIDTH="33%" ALIGN="right" VALIGN="top">
<A HREF="error-message.html">Вперёд</A></TD></TR><TR><TD WIDTH="33%" VALIGN="top">Безопасность
файловой системы</TD><th WIDTH="34%" VALIGN="top"><a href="security.html">Вверх</a></th>
<TD WIDTH="33%" ALIGN="right" VALIGN="top">Сообщение об ошибках</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>
</BODY></HTML>