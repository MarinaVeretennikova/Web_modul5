<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><TITLE>Постоянные Соединения с БД</TITLE>
<meta http-equiv="Content-Language" content="ru"><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<LINK REL="stylesheet" HREF="style.css"></HEAD>
<body><TABLE BORDER="0" WIDTH="100%" HEIGHT="100%"><TR><TD COLSPAN="3"><TABLE BGCOLOR="#CCCCFF" BORDER="0" WIDTH="100%"><TR><TD>
<TABLE WIDTH="100%"><TR><TH COLSPAN="3">Учебник РНР</TH></TR><TR>
<TD WIDTH="10%"><A HREF="connection-handling.html">Назад</A></TD><TD WIDTH="80%"></TD>
<TD WIDTH="10%" ALIGN="right"><A HREF="safe-mode.html">Вперёд</A></TD></TR></TABLE></TD></TR><TR BGCOLOR="#333366"><TD>
<IMG SRC="imag/spacer.gif" BORDER="0" width="1" height="1"><BR></TD></TR></TABLE></TD></TR><TR><TD><IMG SRC="imag/spacer.gif" WIDTH="10" HEIGHT="1"></TD><TD HEIGHT="100%" VALIGN="TOP" WIDTH="100%">
<H1><A NAME="features.persistent-connections">Глава 22. Постоянные соединения с базами данных</A></H1>
<P>Постоянные соединения это SQL-ссылки, которые не закрываются по окончании 
работы скрипта. Когда постоянное соединение запрашивается, PHP проверяет, 
имеется ли уже идентичное постоянное соединение (которое осталось открытым 
после предыдущего запроса), и, если имеется, использует его. Если не имеется, 
РНР создаёт ссылку. 'Идентичным' является соединение, которое было открыто с тем же хостом, с тем же username 
и с тем же password (если имеются).</P><BLOCKQUOTE><P><B>Примечание: </B>имеются другие расширения, которые предоставляют постоянные соединения, такие как
<A HREF="f/ref.imap.html">IMAP</A>.</P></BLOCKQUOTE><P>Те, кто не вполне знакомы со способами работы web-серверов и распределением 
нагрузки, могут ошибочно посчитать постоянным соединением соединение, таковым 
не являющееся. Постоянные соединения <i>не</i> дают возможности открывать 'user sessions' 
по той же самой SQL-ссылке, они <i>не</i> дают возможности эффективно строить 
транзакции и не делают ещё много чего. Фактически, чтобы внести полную ясность,
постоянные соединения не предоставляют <i>никакой</i> функциональности, которая была бы возможна в их не-постоянных собратьях.</P>
<P>Патщему?</P><P>Это зависит от способа работы web-серверов. Есть три способа использования 
РНР вашим web-сервером для генерации web-страниц.</P>
<P>Первый метод - использование PHP как CGI "wrapper/оболочки". При этом 
экземпляр PHP-интерпретатора создаётся и разрушается для каждого запроса страницы (PHP-страницы) к вашему web-серверу.
Поскольку он уничтожается после выполнения каждого запроса, при этом 
закрываются все ресурсы, которые он использовал (такие как ссылка на SQL-сервер 
БД). В этом случае вы ничего не получите от использования постоянных соединений - они просто не существуют.</P>
<P>Второй, самый популярный метод, - запускать PHP как модуль в многопроцессном web-сервере, 
которым на данный момент является только Apache. На многопроцессном сервере 
обычно имеется один процесс (parent/родительский), координирующий работу 
набора других процессов (его потомков), которые фактически выполняют работу по 
обслуживанию web-страниц. При поступлении каждого запроса от клиента, запрос 
направляется одному из дочерних процессов, который в данный момент не 
обслуживает другого клиента. Это означает, что, когда тот же самый клиент 
выполняет второй запрос к серверу, он может быть обработан другим дочерним 
процессом, а не тем, который был в первый раз. При этом постоянное соединение 
делает так, что каждый дочерний процесс должен соединиться с вашим SQL-сервером 
в первый раз при обслуживании страницы, которая использует это соединение. 
Если другая страница затем требует установления соединения с SQL-сервером, она 
может использовать соединение, которое дочерний процесс установил ранее.</P>
<P>Третий метод - использовать PHP как plug-in на многопоточном web-сервере. В 
настоящее время в PHP 4 имеется поддержка ISAPI, WSAPI и NSAPI (под
Windows), которые все позволяют использовать PHP как plug-in на многопоточных 
серверах, таких как Netscape FastTrack (iPlanet), Microsoft Internet Information
Server (IIS) и O'Reilly WebSite Pro. Поведение будет точно таким же, как и 
для многопроцессной модели, рассмотренной ранее. Обратите внимание, что поддержка SAPI отсутствует в PHP 3.</P>
<P>Если постоянные соединения не имеют дополнительной функциональности, то чем они тогда хороши?</P>
<P>Ответ предельно прост - своей эффективностью. Постоянные соединения 
пригодятся, если велика нагрузка при создании большого количества ссылок на 
ваш SQL-сервер. То, насколько реально велика эта нагрузка, зависит от многих 
факторов. Например, какого типа БД, находится ли она на том же компьютере, что 
и ваш web-сервер, насколько загружена машина, на которой установлен SQL-сервер, 
и так далее. Важно то, что, если нагрузка по созданию соединений велика, 
постоянные соединения могут оказать существенную помощь. Они позволяют 
дочернему процессу соединиться только один раз для каждого жизненного цикла, 
вместо того чтобы делать это каждый раз при обработке страницы, которой нужно 
соединение с SQL-сервером. Это значит, что каждый дочерний процесс, который 
открыл постоянное соединение, будет иметь своё собственное постоянное 
соединение с сервером. Например, если у вас 20 дочерних процессов, которые 
запустили скрипт, выполняющий постоянное соединение с вашим SQL-сервером,
у вас будет 20 различных соединений с SQL-сервером, одно для каждого дочернего процесса.</P>
<P>Заметьте, однако, что этот подход имеет и некоторые недостатки, если вы 
используете БД с ограничением на количество соединений, которое превзойдено 
постоянными соединениями. Если ваша БД имеет лимит в 16 одновременных 
соединений и, при работающей сессии сервера, 17 дочерних потоков пытаются 
соединиться, один из них не сможет это сделать. Если в скриптах есть ошибки, 
которые не позволяют отключать соединения (такие как бесконечные циклы), БД с 
лишь 32 соединениями может быть быстро перегружена. Проверьте в документации к 
вашей БД информацию об обработке оставленных и незанятых соединений.</P>
<TABLE CLASS="warning" BORDER="1" WIDTH="100%"><TR><th>Предупреждение!</th></TR><TR><TD>
<P>При использовании постоянных соединений необходимо помнить также ещё две вещи.<br>
Первое - при использовании блокировки таблицы при постоянном соединении, 
если скрипт по каким-то причинам не может освободить блокировку, 
последующие скрипты, использующие то же самое соединение, будут 
блокированы бесконечно долго и могут потребовать рестарта httpd-сервера или сервера БД.<br>
Второе - что, при использовании транзакций, блок транзакции также будет 
перенесён в следующий скрипт, использующий это соединение, если 
выполнение скрипта заканчивается до окончания выполнения блока 
транзакции. В этом случае вы можете использовать <A HREF="f/register-shutdown-function.html">
<B>register_shutdown_function()</B></A> для регистрации простой функции зачистки для разблокирования ваших таблиц или 
отката ваших транзакций. Ещё лучше избежать этих проблем полностью, не 
используя постоянные соединения в скриптах, где используются блокировка 
таблиц или транзакции (вы всё ещё можете использовать их в других местах).</P></TD></TR></TABLE>
<P>Важное резюме. Постоянные соединения были созданы для отображения 
один-в-один регулярных соединений. Это значит, что вы должны <i>всегда</i> иметь 
возможность заменить постоянное соединение на не-постоянное, и это не должно 
изменить поведение вашего скрипта. Это <i>может</i> (и, возможно, будет) 
изменять эффективность работы скрипта, но не его поведение!</P>
<P>См. также <A HREF="f/fbsql-pconnect.html"><B>fbsql_pconnect()</B></A>,
<A HREF="f/ibase-pconnect.html"><B>ibase_pconnect()</B></A>,
<A HREF="f/ifx-pconnect.html"><B>ifx_pconnect()</B></A>,
<A HREF="f/imap-popen.html"><B>imap_popen()</B></A>,
<A HREF="f/ingres-pconnect.html"><B>ingres_pconnect()</B></A>,
<A HREF="f/msql-pconnect.html"><B>msql_pconnect()</B></A>,
<A HREF="f/mssql-pconnect.html"><B>mssql_pconnect()</B></A>,
<A HREF="f/mysql-pconnect.html"><B>mysql_pconnect()</B></A>, <B>OCIPLogon()</B>,
<A HREF="f/odbc-pconnect.html"><B>odbc_pconnect()</B></A>, <B>Ora_pLogon()</B>,
<A HREF="f/pfsockopen.html"><B>pfsockopen()</B></A>,
<A HREF="f/pg-pconnect.html"><B>pg_pconnect()</B></A> и
<A HREF="f/sybase-pconnect.html"><B>sybase_pconnect()</B></A>.</P>
</TD><TD><IMG SRC="imag/spacer.gif" WIDTH="10" HEIGHT="1"></TD></TR><TR><TD COLSPAN="3"><TABLE BGCOLOR="#CCCCFF" BORDER="0" WIDTH="100%"><TR BGCOLOR="#333366"><TD>
<IMG SRC="imag/spacer.gif" BORDER="0" width="1" height="1"><BR></TD></TR><TR><TD>
<TABLE WIDTH="100%" BORDER="0" CELLPADDING="3"><TR><TD WIDTH="33%" VALIGN="top">
<A HREF="connection-handling.html">Назад</A></TD><th WIDTH="34%" VALIGN="top">
<A HREF="index.html">Оглавление</A></th><TD WIDTH="33%" ALIGN="right" VALIGN="top">
<A HREF="safe-mode.html">Вперёд</A></TD></TR><TR><TD WIDTH="33%" VALIGN="top">Обслуживание соединений</TD>
<th WIDTH="34%" VALIGN="top"><a href="features.html">Вверх</a></th><TD WIDTH="33%" ALIGN="right" VALIGN="top">Безопасный режим</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE></BODY></HTML>