<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0055)http://www.intuit.ru/department/pl/plphp/5/plphp_5.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="Функции в PHP.files/printable.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=6 marginwidth="0" marginheight="6">
<DIV align=left><SPAN style="FONT-WEIGHT: bold; COLOR: #000000">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD colSpan=3 height=8><IMG height=8 src="Функции в PHP.files/empty.gif" 
      width=1></TD></TR>
  <TR>
    <TD class=orang colSpan=3 height=1><IMG height=1 
      src="Функции в PHP.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD colSpan=3 height=8><IMG height=8 src="Функции в PHP.files/empty.gif" 
      width=1></TD></TR>
  <TR vAlign=top>
    <TD><IMG height=1 src="Функции в PHP.files/empty.gif" width=8></TD>
    <TD><!-- content -->
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD class=head>Язык программирования PHP</TD></TR>
        <TR>
          <TD height=4><IMG height=4 src="Функции в PHP.files/empty.gif" 
            width=1></TD></TR>
        <TR>
          <TD class=orang height=1><IMG height=1 
            src="Функции в PHP.files/empty.gif" width=1></TD></TR>
        <TR>
          <TD height=8><IMG height=8 src="Функции в PHP.files/empty.gif" 
            width=1></TD></TR>
        <TR>
          <TD><SPAN class=headsub>5. Лекция: Функции в PHP: версия для печати 
            и PDA</SPAN> <BR><SPAN class=rtxt>В лекции рассматриваются: понятие 
            функции, функции, определяемые пользователем, аргументы функций, 
            передача аргументов по значению и по ссылке, значение аргументов по 
            умолчанию и значения, возвращаемые функцией (функция return()). 
            Пример – создание web-интерфейс для генерации HTML-формы.</SPAN> 
        </TD></TR>
        <TR>
          <TD height=8><IMG height=8 src="Функции в PHP.files/empty.gif" 
            width=1></TD></TR>
        <TR>
          <TD class=orang height=1><IMG height=1 
            src="Функции в PHP.files/empty.gif" width=1></TD></TR>
        <TR>
          <TD height=8><IMG height=8 src="Функции в PHP.files/empty.gif" 
            width=1></TD></TR>
        <TR>
          <TD>
            <H3></H3>
            <P>В этой лекции будут рассматриваться вопросы создания и 
            использования функций в PHP. Говоря «функции», мы не имеем в виду 
            все существующие в PHP функции, а лишь функции, определяемые 
            пользователем. Мы рассмотрим способы задания таких функций, методы 
            передачи аргументов, использование аргументов со значением по 
            умолчанию и значения, возвращаемые функцией.</P>
            <P>В качестве примера создадим web-интерфейс для генерации 
            html-формы. То есть пользователь выбирает, не прибегая к 
            программированию, какие элементы формы нужно создать, и 
            характеристики этих элементов, а наша программа генерирует нужную 
            форму.</P>
            <H4>Функции, определяемые пользователем</H4>
            <P>Для чего нужны функции? Чтобы ответить на этот вопрос, нужно 
            понять, что вообще представляют собой функции. В программировании, 
            как и в математике, функция есть отображение множества ее аргументов 
            на множество ее значений. То есть функция для каждого набора 
            значений аргумента возвращает какие-то значения, являющиеся 
            результатом ее работы. Зачем нужны функции, попытаемся объяснить на 
            примере. Классический пример функции в программировании – это 
            функция, вычисляющая значение факториала числа. То есть мы задаем ей 
            число, а она возвращает нам его факториал. При этом не нужно для 
            каждого числа, факториал которого мы хотим получить, повторять один 
            и тот же код – достаточно просто вызвать функцию с аргументом, 
            равным этому числу.</P>
            <P>Функция вычисления факториала натурального числа</P>
            <DIV class=example><PRE>&lt;?php
function fact($n){
  if ($n==0) return 1;
  else return $fact = $n * fact($n-1);
}
echo fact(3);  
   // можно было бы написать echo (3*2);
   // но если число большое,
echo fact(50); 
   // то удобнее пользоваться функцией,
   // чем писать echo (50*49*48*...*3*2);
?&gt;
</PRE></DIV>
            <P>Таким образом, когда мы осуществляем действия, в которых 
            прослеживается зависимость от каких-то данных, и при этом, возможно, 
            нам понадобится выполнять такие же действия, но с другими исходными 
            данными, удобно использовать механизм функций – оформить блок 
            действий в виде <SPAN class=keyword>тела функции</SPAN>, а 
            меняющиеся данные – в качестве ее параметров.</P>
            <P>Посмотрим, как в общем виде выглядит задание (объявление) 
            функции. Функция может быть определена с помощью следующего 
            синтаксиса:</P>
            <DIV class=example><PRE>function Имя_функции (параметр1, параметр2,
   ... параметрN){
   Блок_действий
   return "значение возвращаемое функцией";
}
</PRE></DIV>
            <P>Если прямо так написать в php-программе, то работать ничего не 
            будет. Во-первых, <SPAN class=texample>Имя_функции</SPAN> и имена 
            <SPAN class=keyword>параметров функции</SPAN> (<SPAN 
            class=texample>параметр1</SPAN>, <SPAN 
            class=texample>параметр2</SPAN> и т.д.) должны соответствовать 
            правилам наименования в PHP (и русских символов в них лучше не 
            использовать). Имена функций нечувствительны к регистру. Во-вторых, 
            <SPAN class=keyword>параметры функции</SPAN> – это переменные языка, 
            поэтому перед названием каждого из них должен стоять знак $. Никаких 
            троеточий ставить в списке параметров нельзя. В-третьих, вместо слов 
            <SPAN class=texample>блок_действий</SPAN> в <SPAN class=keyword>теле 
            функции</SPAN> должен находиться любой правильный PHP-код (не 
            обязательно зависящий от параметров). И наконец, после ключевого 
            слова <SPAN class=keyword>return</SPAN> должно идти корректное 
            php-выражение (что-либо, что имеет значение). Кроме того, у функции 
            может и не быть параметров, как и возвращаемого значения. Пример 
            правильного объявления функции – функция вычисления факториала, 
            приведенная выше.</P>
            <P>Как происходит вызов функции? Указывается имя функции и в круглых 
            скобках список значений ее параметров, если таковые имеются:</P>
            <DIV class=example><PRE>&lt;?php
Имя_функции ("значение_для_параметра1",
  "значение_для_параметра2",...);
// пример вызова функции – вызов функции 
// вычисления факториала приведен выше, 
// там для вычисления факториала числа 3 
// мы писали: fact(3); 
// где fact – имя вызываемой функции, 
// а 3 – значение ее параметра с именем $n
?&gt;
</PRE></DIV>
            <P>Когда можно вызывать функцию? Казалось бы, странный вопрос. 
            Функцию можно вызвать после ее определения, т.е. в любой строке 
            программы ниже блока <SPAN class=texample>function 
            f_name(){...}</SPAN>. В PHP3 это было действительно так. Но уже в 
            PHP4 такого требования нет. Все дело в том, как интерпретатор 
            обрабатывает получаемый код. Единственное исключение составляют 
            функции, определяемые условно (внутри условных операторов или других 
            функций). Когда функция определяется таким образом, ее определение 
            должно предшествовать ее вызову.</P><A name=example.5.1></A>
            <DIV class=example><PRE>&lt;?
$make = true;
/* здесь нельзя вызвать Make_event(); 
потому что она еще не существует, но можно
вызвать Save_info() */

Save_info("Вася","Иванов", 
   "Я выбрал курс по PHP");

if ($make){
// определение функции Make_event()
  function Make_event(){
    echo "&lt;p&gt;Хочу изучать Python&lt;br&gt;";
  }
}
// теперь можно вызывать Make_event()
Make_event();
// определение функции Save_info
function Save_info($first, $last, $message){
  echo "&lt;br&gt;$message&lt;br&gt;";
  echo "Имя: ". $first . " ". $last . "&lt;br&gt;";
}
Save_info("Федя","Федоров",
          "А я выбрал Lisp");
// Save_info можно вызывать и здесь
?&gt;
</PRE><SPAN class=objectName>Пример 5.1. Определение функции внутри 
            условного оператора</SPAN></DIV>
            <P>Если функция однажды определена в программе, то переопределить 
            или удалить ее позже нельзя. Несмотря на то, что имена функций 
            нечувствительны к регистру, лучше вызывать функцию по тому же имени, 
            каким она была задана в определении.</P><A name=example.5.2></A>
            <DIV class=example><PRE>&lt;?php
/* нельзя сохранить данные, т.е. вызвать
функцию DataSave() до того, как выполнена
проверка их правильности, т.е. вызвана 
функция DataCheck() */

DataCheck();
DataSave();

function DataCheck(){
// проверка правильности данных
  function DataSave(){
  // сохраняем данные
  }
}
?&gt;
</PRE><SPAN class=objectName>Пример 5.2. Определение функции внутри 
            функции</SPAN></DIV>
            <P>Рассмотрим подробнее аргументы функций, их назначение и 
            использование.</P>
            <H4>Аргументы функций</H4>
            <P>У каждой функции может быть, как мы уже говорили, список 
            аргументов. С помощью этих аргументов в функцию передается различная 
            информация (например, значение числа, факториал которого надо 
            подсчитать). Каждый аргумент представляет собой переменную или 
            константу.</P>
            <P>С помощью аргументов данные в функцию можно передавать тремя 
            различными способами. Это передача аргументов по значению 
            (используется по умолчанию), по ссылке и <SPAN class=keyword>задание 
            значения аргументов по умолчанию</SPAN>. Рассмотрим эти способы 
            подробнее.</P>
            <P>Когда аргумент передается в функцию по значению, изменение 
            значения аргумента внутри функции не влияет на его значение вне 
            функции. Чтобы позволить функции изменять ее аргументы, их нужно 
            передавать по ссылке. Для этого в определении функции перед именем 
            аргумента следует написать знак амперсанд <SPAN 
            class=texample>«&amp;»</SPAN>.</P><A name=example.5.3></A>
            <DIV class=example><PRE>&lt;?php
// напишем функцию, которая бы добавляла
// к строке слово checked
function add_label(&amp;$data_str){
  $data_str .= "checked";
}
$str = "&lt;input type=radio name=article ";
  // пусть имеется такая строка
echo $str ."&gt;&lt;br&gt;"; 
    // выведет элемент формы –
    // не отмеченную радио кнопку
add_label($str);             
    // вызовем функцию
echo $str ."&gt;&lt;br&gt;"; 
    // это выведет уже отмеченную
    // радио кнопку
?&gt;
</PRE><SPAN class=objectName>Пример 5.3. Передача аргументов по 
            ссылке</SPAN></DIV>
            <P>В функции можно определять значения аргументов, используемые по 
            умолчанию. Само значение по умолчанию должно быть константным 
            выражением, а не переменной и не представителем класса или вызовом 
            другой функции.</P>
            <P>У нас есть функция, создающая информационное сообщение, подпись к 
            которому меняется в зависимости от значения переданного ей 
            параметра. Если значение параметра не задано, то используется 
            подпись <SPAN class=texample>"Оргкомитет"</SPAN>.</P><A 
            name=example.5.4></A>
            <DIV class=example><PRE>&lt;?php
function Message($sign="Оргкомитет"){
// здесь параметр sign имеет по умолчанию
// значение "Оргкомитет"
  echo "Следующее собрание состоится завтра.";
  echo "$sign .&lt;br&gt;";
}
Message(); 
    // вызываем функцию без параметра.
    // В этом случае подпись – это Оргкомитет
Message("С уважением, Вася"); 
    // В этом случае подпись
    // будет "С уважением, Вася"
?&gt;
</PRE><SPAN class=objectName>Пример 5.4. Значения аргументов по 
            умолчанию</SPAN></DIV>
            <P>Результатом работы этого скрипта будет:</P>
            <DIV class=example><PRE>Следующее собрание состоится завтра. 
Оргкомитет.
Следующее собрание состоится завтра. 
С уважением, Вася.
</PRE></DIV>
            <P>Если у функции несколько параметров, то те аргументы, для которых 
            задаются значения по умолчанию, должны быть записаны после всех 
            остальных аргументов в определении функции. В противном случае 
            появится ошибка, если эти аргументы будут опущены при вызове 
            функции.</P>
            <P>Например, мы хотим внести описание статьи в каталог. Пользователь 
            должен ввести такие характеристики статьи, как ее название, автор и 
            краткое описание. Если пользователь не вводит имя автора статьи, 
            считаем, что это Иванов Иван.</P>
            <DIV class=example><PRE>&lt;?php
function Add_article($title, $description,
    $author="Иванов Иван"){
  echo "Заносим в каталог статью: $title,";
  echo "автор $author";
  echo "&lt;br&gt;Краткое описание: ";
  echo "$description &lt;hr&gt;";
}
Add_article("Информатика и мы",
    "Это статья про информатику ...",
   "Петров Петр");
Add_article("Кто такие хакеры", 
    "Это статья про хакеров ...");
?&gt;
</PRE></DIV>
            <P>В результате работы скрипта получим следующее</P>
            <DIV class=example><PRE>Заносим в каталог статью: Информатика и мы,
   автор Петров Петр.
Краткое описание: 
   Это статья про информатику...

Заносим в каталог статью: Кто такие хакеры,
   автор Иванов Иван.
Краткое описание: 
   Это статья про хакеров...
</PRE></DIV>
            <P>Если же мы напишем вот так:</P>
            <DIV class=example><PRE>&lt;?php
function Add_article($author="Иванов Иван",
    $title, $description){
// ...действия как в предыдущем примере
}
Add_article("Кто такие хакеры", 
    "Это статья про хакеров...");
?&gt;
</PRE></DIV>
            <P>То в результате получим:</P>
            <DIV class=example><PRE>Warning: Missing argument 3 for 
    add_article() in
c:\users\nina\tasks\func\def_bad.php 
    on line 2
</PRE></DIV>
            <H5>Списки аргументов переменной длины</H5>
            <P>В PHP4 можно создавать функции с переменным числом аргументов. То 
            есть мы создаем функцию, не зная заранее, со сколькими аргументами 
            ее вызовут. Для написания такой функции никакого специального 
            синтаксиса не требуется. Все делается с помощью <SPAN 
            class=keyword>встроенных функций</SPAN> <SPAN 
            class=keyword>func_num_args()</SPAN>, <SPAN 
            class=keyword>func_get_arg()</SPAN>, <SPAN 
            class=keyword>func_get_args()</SPAN>.</P>
            <P><A name=keyword-context.1></A>Функция <SPAN 
            class=keyword_def>func_num_args()</SPAN> возвращает число 
            аргументов, переданных в текущую функцию. Эта функция может 
            использоваться только внутри определения пользовательской функции. 
            Если она появится вне функции, то интерпретатор выдаст 
            предупреждение.</P><A name=example.5.5></A>
            <DIV class=example><PRE>&lt;?php
function DataCheck(){
  $n = func_num_args();
  echo "Число аргументов функции $n";
}
DataCheck(); 
   // выведет строку 
   // "Число аргументов функции 0"
DataCheck(1,2,3); 
   // выведет строку
   // "Число аргументов функции 3"
?&gt;
</PRE><SPAN class=objectName>Пример 5.5. Использование функции 
            func_num_args()</SPAN></DIV>
            <P><A name=keyword-context.2></A>Функция <SPAN 
            class=keyword_def>func_get_arg</SPAN> (целое <SPAN 
            class=texample>номер_аргумента</SPAN> ) возвращает аргумент из 
            списка переданных в функцию аргументов, порядковый номер которого 
            задан параметром <SPAN class=texample>номер_аргумента</SPAN>. 
            Аргументы функции считаются начиная с нуля. Как и <SPAN 
            class=keyword>func_num_args()</SPAN>, эта функция может 
            использоваться только внутри определения какой-либо функции.</P>
            <P>Номер_аргумента не может превышать число аргументов, переданных в 
            функцию. Иначе будет сгенерировано предупреждение, и функция <SPAN 
            class=keyword>func_get_arg()</SPAN> возвратит <SPAN 
            class=texample>False</SPAN>.</P>
            <P>Создадим функцию для проверки типа данных, ее аргументов. 
            Считаем, что проверка прошла успешно, если первый аргумент функции – 
            целое число, второй – строка.</P><A name=example.5.6></A>
            <DIV class=example><PRE>&lt;?
function DataCheck(){
  $check =true;
  $n = func_num_args(); 
     // число аргументов,
     // переданных в функцию
  /* проверяем, является ли первый 
  переданный аргумент целым числом */
  if ($n&gt;=1) if (!is_int(func_get_arg(0)))
      $check = false;
  /* проверяем, является ли второй 
  переданный аргумент строкой */
  if ($n&gt;=2) 
     if (!is_string(func_get_arg(1)))
        $check = false;
return $check;
}

if (DataCheck(a123,"text")) 
   echo "Проверка прошла успешно&lt;br&gt;";
else echo "Данные не удовлетворяют 
   условиям&lt;br&gt;";
if (DataCheck(324)) 
   echo "Проверка прошла успешно&lt;br&gt;";
else echo "Данные не удовлетворяют условиям&lt;br&gt;";
?&gt;
</PRE><SPAN class=objectName>Пример 5.6. Функция для проверки типа 
            данных, ее аргументов</SPAN></DIV>
            <P>Результатом работы будет следующее.</P>
            <DIV class=example><PRE>Данные не удовлетворяют условиям
Проверка прошла успешно
</PRE></DIV>
            <P><A name=keyword-context.3></A>Функция <SPAN 
            class=keyword_def>func_get_args()</SPAN> возвращает массив, 
            состоящий из списка аргументов, переданных функции. Каждый элемент 
            массива соответствует аргументу, переданному функции. Если функция 
            используется вне определения пользовательской функции, то 
            генерируется предупреждение.</P>
            <P>Перепишем предыдущий пример, используя эту функцию. Будем 
            проверять, является ли целым числом каждый четный аргумент, 
            передаваемый функции:</P>
            <DIV class=example><PRE>&lt;?
function DataCheck(){
  $check =true;
  $n = func_num_args(); 
  // число аргументов,
  // переданных в функцию
  
  $args = func_get_args(); 
  // массив аргументов функции
  for ($i=0;$i&lt;$n;$i++){
    $v = $args[$i];
    if ($i % 2 == 0){
      if (!is_int($v)) $check = false; 
     // проверяем,
      // является ли четный аргумент целым
    }
  }
return $check;
}
if (DataCheck("text", 324)) 
   echo "Проверка прошла успешно&lt;br&gt;";
else echo "Данные не удовлетворяют 
   условиям&lt;br&gt;";
?&gt;
</PRE></DIV>
            <P>Как видим, комбинации функций <SPAN 
            class=keyword>func_num_args()</SPAN>, <SPAN 
            class=keyword>func_get_arg()</SPAN> и <SPAN 
            class=keyword>func_get_args()</SPAN> используется для того, чтобы 
            функции могли иметь переменный список аргументов. Эти функции были 
            добавлены только в PHP 4. В PHP3 для того, чтобы добиться подобного 
            эффекта, можно использовать в качестве аргумента функции массив. 
            Например, вот так можно написать скрипт, проверяющий, является ли 
            каждый нечетный <SPAN class=keyword>параметр функции</SPAN> целым 
            числом:</P>
            <DIV class=example><PRE>&lt;?
function DataCheck($params){
  $check =true;
  $n = count($params); 
  // число аргументов,
  // переданных в функцию
  
  for ($i=0;$i&lt;$n;$i++){
    $v = $params[$i];
    if ($i % 2 !== 0){
      // проверяем, является ли нечетный
      // аргумент целым
if (!is_int($v)) $check = false;
    }
  }
return $check;
}
if (DataCheck("text", 324))
    echo "Проверка прошла успешно&lt;br&gt;";
else echo "Данные не удовлетворяют условиям&lt;br&gt;";
?&gt;
</PRE></DIV>
            <H4>Использование переменных внутри функции</H4>
            <H5>Глобальные переменные</H5>
            <P>Чтобы использовать внутри функции переменные, заданные вне нее, 
            эти переменные нужно объявить как глобальные. Для этого в <SPAN 
            class=keyword>теле функции</SPAN> следует перечислить их имена после 
            ключевого слова <SPAN class=keyword>global</SPAN>:</P>
            <DIV class=example><PRE>global $var1, $var2;
</PRE></DIV><A name=example.5.7></A>
            <DIV class=example><PRE>&lt;?
$a=1;
function Test_g(){
global $a;
  $a = $a*2;
  echo 'в результате работы функции $a=',$a;
}
echo 'вне функции $a=',$a,', ';
Test_g();
echo "&lt;br&gt;";
echo 'вне функции $a=',$a,', ';
Test_g();
?&gt;
</PRE><SPAN class=objectName>Пример 5.7. Глобальные 
            переменные</SPAN></DIV>
            <P>В результате работы этого скрипта получим:</P>
            <DIV class=example><PRE>вне функции $a=1, в результате работы 
   функции $a=2
вне функции $a=2, в результате работы 
   функции $a=4
</PRE></DIV>
            <P>Когда переменная объявляется как глобальная, фактически создается 
            ссылка на <SPAN class=keyword>глобальную переменную</SPAN>. Поэтому 
            такая запись эквивалентна следующей (массив <SPAN 
            class=texample>GLOBALS</SPAN> содержит все переменные, глобальные 
            относительно текущей области видимости):</P>
            <DIV class=example><PRE>$var1 = &amp; $GLOBALS["var1"];
$var2 = &amp; $GLOBALS["var2"];
</PRE></DIV>
            <P>Это значит, например, что удаление переменной <SPAN 
            class=texample>$var1</SPAN> не удаляет <SPAN 
            class=keyword>глобальной переменной</SPAN> <SPAN 
            class=texample>$_GLOBALS["var1"]</SPAN>.</P>
            <H5>Статические переменные</H5>
            <P>Чтобы использовать переменные только внутри функции, при этом 
            сохраняя их значения и после выхода из функции, нужно объявить эти 
            переменные как статические. <A name=keyword-context.4></A><SPAN 
            class=keyword_def>Статические переменные</SPAN> видны только внутри 
            функции и не теряют своего значения, если выполнение программы 
            выходит за пределы функции. Объявление таких переменных производится 
            с помощью ключевого слова <SPAN class=keyword>static</SPAN>:</P>
            <DIV class=example><PRE>static $var1, $var2;
</PRE></DIV>
            <P><SPAN class=keyword>Статической переменной</SPAN> может быть 
            присвоено любое значение, но не ссылка.</P><A name=example.5.8></A>
            <DIV class=example><PRE>&lt;?
function Test_s(){
static $a = 1; 
// нельзя присваивать выражение или ссылку
  $a = $a*2;
  echo $a;
}
Test_s(); // выведет 2
echo $a;  // ничего не выведет, так как 
          // $a доступна только 
        // внутри функции
Test_s(); // внутри функции $a=2, поэтому 
          // результатом работы функции 
        // будет число 4
?&gt;
</PRE><SPAN class=objectName>Пример 5.8. Использование статической 
            переменной</SPAN></DIV>
            <H4>Возвращаемые значения</H4>
            <P>Все функции, приведенные выше в качестве примеров, выполняли 
            какие-либо действия. Кроме подобных действий, любая функция может 
            возвращать как результат своей работы какое-нибудь значение. Это 
            делается с помощью утверждения <SPAN class=keyword>return</SPAN>. 
            Возвращаемое значение может быть любого типа, включая списки и 
            объекты. Когда интерпретатор встречает команду <SPAN 
            class=keyword>return</SPAN> в <SPAN class=keyword>теле 
            функции</SPAN>, он немедленно прекращает ее исполнение и переходит 
            на ту строку, из которой была вызвана функция.</P>
            <P>Например, составим функцию, которая возвращает возраст человека. 
            Если человек не умер, то возраст считается относительно текущего 
            года.</P>
            <DIV class=example><PRE>&lt;?php
/* если второй параметр вычисляется 
как true, то он рассматривается как 
дата смерти, */

function Age($birth, $is_dead){
  if ($is_dead) return $is_dead-$birth;
  else return date("Y")-$birth;
}
echo Age(1971, false); // выведет 33
echo Age(1971, 2001); // выведет 30
?&gt;
</PRE></DIV>
            <P>В этом пример можно было и не использовать функцию <SPAN 
            class=keyword>return</SPAN>, а просто заменить ее функцией вывода 
            <SPAN class=texample>echo</SPAN>. Однако если мы все же делаем так, 
            что функция возвращает какое-то значение (в данном случае возраст 
            человека), то в программе мы можем присвоить любой переменной 
            значение этой функции:</P>
            <DIV class=example><PRE>$my_age = Age(1981, 2004);
</PRE></DIV>
            <P>В результате работы функции может быть возвращено только одно 
            значение. Несколько значений можно получить, если возвращать список 
            значений (одномерный массив). Допустим, мы хотим получить полный 
            возраст человека с точностью до дня.</P>
            <DIV class=example><PRE>&lt;?php
function Full_age($b_day, $b_month, $b_year){
  if (date("m")&gt;$b_month &amp;&amp; date("d")&gt;$b_day)
  {
    $day = date ("d") - $b_day;
    $month = date("m") - $b_month;
    $year = date("Y") - $b_year;
  } else {
    $year = date("Y") - $b_year - 1;
    $day = 31 - ($b_day - date ("d"));
    $month = 12 - ($b_month - date("m"));
  }
return array ($day,$month,$year);
}
$age = Full_age("07","08","1974");
echo "Вам $age[2] лет, $age[1] месяцев 
    и $age[0] дней";
// выведет "Вам 29 лет, 11 месяцев и 5 дней"
?&gt;
</PRE></DIV>
            <P>Когда функция возвращает несколько значений для их обработки в 
            программе, удобно использовать языковую конструкцию <SPAN 
            class=keyword>list</SPAN>(), которая позволяет одним действием 
            присвоить значения сразу нескольким переменным. Например, в 
            предыдущем примере, оставив без изменения функцию, обработать 
            возвращаемые ей значения можно было так:</P>
            <DIV class=example><PRE>&lt;?
// задание функции Full_age()
list($day,$month,$year) = Full_age("07",
    "08","1974");
echo "Вам $year лет, $month месяцев и 
    $day дней";
?&gt;
</PRE></DIV>
            <P>Вообще конструкцию <SPAN class=keyword>list</SPAN>() можно 
            использовать для присвоения переменным значений элементов любого 
            массива.</P><A name=example.5.9></A>
            <DIV class=example><PRE>&lt;?
$arr = array("first","second");
list($a,$b) = $arr; 
   // переменной $a присваивается первое
   // значение массива, $b – второе
echo $a," ",$b;     
   // выведет строку «first second»
?&gt;
</PRE><SPAN class=objectName>Пример 5.9. Использование 
            list()</SPAN></DIV>
            <H5>Возвращение ссылки</H5>
            <P>В результате своей работы функция также может возвращать ссылку 
            на какую-либо переменную. Это может пригодиться, если требуется 
            использовать функцию для того, чтобы определить, какой переменной 
            должна быть присвоена ссылка. Чтобы получить из функции ссылку, 
            нужно при объявлении перед ее именем написать знак амперсанд (<SPAN 
            class=texample>&amp;</SPAN>) и каждый раз при вызове функции перед 
            ее именем тоже писать амперсанд (<SPAN class=texample>&amp;</SPAN>). 
            Обычно функция возвращает ссылку на какую-либо <SPAN 
            class=keyword>глобальную переменную</SPAN> (или ее часть – ссылку на 
            элемент глобального массива), ссылку на <SPAN 
            class=keyword>статическую переменную</SPAN> (или ее часть) или 
            ссылку на один из аргументов, если он был также передан по 
            ссылке.</P><A name=example.5.10></A>
            <DIV class=example><PRE>&lt;?
$a = 3; $b = 2;
function &amp; ref($par){
global $a, $b;
  if ($par % 2 == 0) return $b;
  else return $a;
}
$var =&amp; ref(4);
echo $var, " и ", $b, "&lt;br&gt;"; 
   //выведет 2 и 2
$b = 10;
echo $var, " и ", $b, "&lt;br&gt;"; 
   // выведет 10 и 10
?&gt;
</PRE><SPAN class=objectName>Пример 5.10. Возвращение 
            ссылки</SPAN></DIV>
            <P>При использовании синтаксиса ссылок в переменную <SPAN 
            class=texample>$var</SPAN> нашего примера не копируется значение 
            переменной <SPAN class=texample>$b</SPAN> возвращенной функцией 
            <SPAN class=texample>$ref</SPAN>, а создается ссылка на эту 
            переменную. То есть теперь переменные <SPAN 
            class=texample>$var</SPAN> и <SPAN class=texample>$b</SPAN> 
            идентичны и будут изменяться одновременно.</P>
            <H4>Переменные функции</H4>
            <P>PHP поддерживает концепцию <SPAN class=keyword>переменных 
            функций</SPAN>. Это значит, что если имя переменной заканчивается 
            круглыми скобками, то PHP ищет функцию с таким же именем и пытается 
            ее выполнить.</P><A name=example.5.11></A>
            <DIV class=example><PRE>&lt;?
/* создадим две простые функции: 
Add_sign – добавляет подпись к строке и
Show_text – выводит строку текста */

function Add_sign($string, 
   $sign="С уважением, Петр"){
   echo $string ." ".$sign;
}
function Show_text(){
  echo "Отправить сообщение по почте&lt;br&gt;";
}
$func = "Show_text"; 
   // создаем переменную со значением,
   // равным имени функции Show_text
$func(); 
   // это вызовет функцию Show_text
$func = "Add_sign";  
   // создаем переменную со значением,
   // равным имени функции Add_sign
$func("Привет всем &lt;br&gt;"); 
   // это вызовет функцию
   // Add_sign с параметром "Привет всем"
?&gt;
</PRE><SPAN class=objectName>Пример 5.11. Использование переменных 
            функций</SPAN></DIV>
            <P>В этом примере функция <SPAN class=texample>Show_text</SPAN> 
            просто выводит строку текста. Казалось бы, зачем для этого создавать 
            отдельную функцию, если существует специальная функция <SPAN 
            class=texample>echo()</SPAN>. Дело в том, что такие функции, как 
            <SPAN class=texample>echo()</SPAN>, <SPAN 
            class=texample>print()</SPAN>, <SPAN class=texample>unset()</SPAN>, 
            <SPAN class=texample>include()</SPAN> и т.п. нельзя использовать в 
            качестве <SPAN class=keyword>переменных функций</SPAN>. То есть если 
            мы напишем:</P>
            <DIV class=example><PRE>&lt;?
$func = "echo ";
$func("TEXT");
?&gt;
</PRE></DIV>
            <P>то интерпретатор выведет ошибку:</P>
            <DIV class=example><PRE>Fatal error: Call to undefined function: 
    echo() in
c:\users\nina\tasks\func\var_f.php on line 2
</PRE></DIV>
            <P>Поэтому для того, чтобы использовать любую из перечисленных выше 
            функций как <SPAN class=keyword>переменную функцию</SPAN>, нужно 
            создать собственную функцию, что мы и сделали в предыдущем 
            примере.</P>
            <H4>Внутренние (встроенные) функции</H4>
            <P>Говоря о функциях, определяемых пользователем, все же нельзя не 
            сказать пару слов о <SPAN class=keyword>встроенных функциях</SPAN>. 
            С некоторыми из <SPAN class=keyword>встроенных функций</SPAN>, 
            такими как <SPAN class=texample>echo()</SPAN>, <SPAN 
            class=texample>print()</SPAN>, <SPAN class=texample>date()</SPAN>, 
            <SPAN class=texample>include()</SPAN>, мы уже познакомились. На 
            самом деле все перечисленные функции, кроме <SPAN 
            class=texample>date()</SPAN>, являются языковыми конструкциями. Они 
            входят в ядро PHP и не требуют никаких дополнительных настроек и 
            модулей. Функция <SPAN class=texample>date()</SPAN> тоже входит в 
            состав ядра PHP и не требует настроек. Но есть и функции, для работы 
            с которыми нужно установить различные библиотеки и подключить 
            соответствующий модуль. Например, для использования функций работы с 
            базой данных <SPAN class=texample>MySql</SPAN> следует 
            скомпилировать PHP с поддержкой этого расширения. В последнее время 
            наиболее распространенные расширения и соответственно их функции 
            изначально включают в состав PHP так, чтобы с ними можно работать 
            без каких бы то ни было дополнительных настроек интерпретатора.</P>
            <H4>Решение задачи</H4>
            <P>Напомним, в чем состоит задача. Мы хотим написать интерфейс, 
            который позволял бы создавать html-формы. Пользователь выбирает, 
            какие элементы и в каком количестве нужно создать, придумывает им 
            названия, а наша программа сама генерирует требуемую форму.</P>
            <P>Разобьем задачу на несколько подзадач: выбор типов элементов 
            ввода и их количества, создание названий элементов ввода и обработка 
            полученных данных, т.е. непосредственно генерация формы. Первая 
            задача достаточно проста: нужно написать соответствующую форму, 
            например подобную приведенной ниже (<A 
            href="http://www.intuit.ru/department/pl/plphp/5/task_form.html" 
            target=_blank>task_form.html</A>):</P><A name=example.5.12></A>
            <DIV class=example><PRE>&lt;form action="ask_names.php"&gt;
Создать элемент "строка ввода текста": &lt;input
  type=checkbox name=types[] 
  value=string&gt;&lt;br&gt;
Количество элементов: &lt;input type=text 
  name=numbers[string]
  size=3&gt;&lt;br&gt;
&lt;br&gt;
Создать элемент "текстовая область": &lt;input
  type=checkbox
  name=types[] value=text&gt;&lt;br&gt;
Количество элементов: &lt;input type=text 
  name=numbers[text]
  size=3&gt;&lt;br&gt;
&lt;input type=submit value="Создать"&gt;
&lt;/form&gt;
</PRE><SPAN class=objectName>Листинг 5.12. 
            task_form.html</SPAN></DIV>
            <P>Когда мы пишем в имени элемента формы, например <SPAN 
            class=texample>types[]</SPAN>, это значит, что его имя – следующий 
            элемент массива <SPAN class=texample>types</SPAN>. То есть у нас 
            первый элемент формы (<SPAN class=texample>"строка ввода 
            текста"</SPAN>) будет иметь имя <SPAN 
            class=texample>types[0]</SPAN>, а второй (текстовая область) – <SPAN 
            class=texample>types[1]</SPAN>. В браузере <SPAN 
            class=texample>task_form.html</SPAN> будет выглядеть примерно 
            так:</P>
            <P align=center><A name=image.5.1></A><IMG height=144 
            alt="Форма для выбора создаваемых элементов и их количества" 
            src="Функции в PHP.files/5-1.gif" width=306><BR><B>Рис. 
            5.1.</B>&nbsp; Форма для выбора создаваемых элементов и их 
            количества</P>
            <P>После отправки данных этой формы мы получим информацию о том, 
            какие элементы и сколько элементов каждого типа нужно создать. 
            Следующий скрипт запрашивает названия для этих элементов:</P><A 
            name=example.5.13></A>
            <DIV class=example><PRE>&lt;?
$file = "task.php"; 
/* файл, который будет обрабатывать
сгенерированную этим скриптом форму */

function Ask_names(){ 
   // функция генерирует форму для
   // ввода названий элементов ввода

global $file; 
   //объявляем, что хотим использовать эту
   // переменную, заданную вне функции
if (isset($_GET["types"])){
  $st = '&lt;form action="'.$file.'"&gt;';
  foreach ($_GET["types"] as $k =&gt; $type){
/* перебираем все типы элементов, 
   которые нужно создать */
  
  $num = $_GET["numbers"][$type]; 
     // сколько элементов каждого типа нужно
  for ($i=1;$i&lt;=$num;$i++){ 
     // создаем $num строк для ввода
    $st.= "Введите имя $i-го элемента типа $type: ";
    $st.= "&lt;input type=text name=names[$type][]&gt;&lt;br&gt;";
  }
  // сохраняем тип и число необходимых 
  // элементов ввода этого типа
  $st.= "&lt;input type=hidden name=types[] value=$type&gt;";
  $st.= "&lt;input type=hidden name=numbers[] value=$num&gt;&lt;br&gt;";
}
  $st .= "&lt;input type=submit name=send value=send&gt;&lt;/form&gt;";
return $st; 
   // в переменной $st содержится код формы
   // для запроса имен
} else echo "Select type";
}
echo Ask_names(); 
   // вызываем функцию и выводим
   // результаты ее работы
?&gt;
</PRE><SPAN class=objectName>Листинг 5.13. 
ask_names.php</SPAN></DIV>
            <P>Допустим, нужно создать два элемента типа «текстовая строка» и 
            один элемент типа «текстовая область», как и отмечено в форме выше. 
            Тогда скрипт <SPAN class=texample>ask_names.php</SPAN> обработает ее 
            таким образом, что мы получим такую форму:</P>
            <P align=center><A name=image.5.2></A><IMG height=126 
            alt="Форма для ввода названий создаваемых элементов" 
            src="Функции в PHP.files/5-2.gif" width=366><BR><B>Рис. 
            5.2.</B>&nbsp; Форма для ввода названий создаваемых элементов</P>
            <P>Введем в эту форму, например, строки «Название», «Автор» и 
            «Краткое содержание». Эти данные будет обрабатывать скрипт <SPAN 
            class=texample>task.php.</SPAN></P><A name=example.5.14></A>
            <DIV class=example><PRE>&lt;?
$show_file = "task_show.php"; 
/* файл, который будет обрабатывать данные
   созданной этим файлом формы */

function Create_element($type,$name){ 
   // функция создает элемент ввода 
   // по типу и названию
  switch($type){
  case"string":
    $str .= "$name: &lt;input type=text name=string[]&gt;&lt;br&gt;";
  break;
  case "text":
    $str .= "$name: &lt;textarea name=text[]&gt;&lt;/textarea&gt;&lt;br&gt;";
  break;
  }
return $str;
}
function Create_form(){ 
    // функция создает форму
    // с нужными элементами
global $show_file;
  $str = '&lt;form action="'.$show_file.'"&gt;';
  foreach ($_GET["types"] as $k =&gt; $type){ 
  // перебираем типы элементов
    $num = $_GET["numbers"][$k]; 
   // число элементов этого типа
    
   for ($i=1;$i&lt;=$num;$i++){
      $arr = $_GET["names"][$type][$i-1]; 
     // имя создаваемого элемента
      
     $str .= Create_element($type,$arr); 
     // вызываем функцию для 
     // создания элемента
    }
  }
  $str .= "&lt;input type=submit value=send&gt;&lt;/form&gt;";
echo $str;
}
$crt = "Create_form";
$crt(); // вызываем функцию создания 
        // формы Create_form
?&gt;
</PRE><SPAN class=objectName>Листинг 5.14. task.php</SPAN></DIV>
            <P>Результатом работы этого скрипта с входными данными, приведенными 
            выше, будет следующая форма:</P>
            <P align=center><A name=image.5.3></A><IMG height=156 
            alt="Пример формы, сгенерированной нашей программой" 
            src="Функции в PHP.files/5-3.gif" width=340><BR><B>Рис. 
            5.3.</B>&nbsp; Пример формы, сгенерированной нашей программой</P>
            <H4>Заключение</H4>
            <P>Подведем итоги. В этой лекции мы изучили функции, определяемые 
            пользователем, их синтаксис и семантику, способы передачи их 
            аргументов и возвращаемых значений. Кроме того, обсуждались способы 
            задания и работы с функциями, имеющими переменное число аргументов и 
            альтернативный способ вызова функции (с помощью переменной, значение 
            которой есть имя функции). В следующей лекции будет рассмотрена 
            объектная модель языка PHP.</P></TD></TR>
        <TR>
          <TD height=8><IMG height=8 src="Функции в PHP.files/empty.gif" 
            width=1></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG height=1 src="Функции в PHP.files/empty.gif" 
  width=8></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG height=1 src="Функции в PHP.files/empty.gif" 
      width=1></TD></TR>
  <TR>
    <TD class=ltxt align=middle>© 2003-2005 INTUIT.ru. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom --></BODY></HTML>
