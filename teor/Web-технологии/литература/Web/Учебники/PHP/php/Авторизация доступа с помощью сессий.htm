<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://www.intuit.ru/department/pl/plphp/12/plphp_12.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="Авторизация доступа с помощью сессий.files/printable.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=6 marginwidth="0" marginheight="6">
<DIV align=left><SPAN style="FONT-WEIGHT: bold; COLOR: #000000">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD colSpan=3 height=8><IMG height=8 
      src="Авторизация доступа с помощью сессий.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD class=orang colSpan=3 height=1><IMG height=1 
      src="Авторизация доступа с помощью сессий.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD colSpan=3 height=8><IMG height=8 
      src="Авторизация доступа с помощью сессий.files/empty.gif" width=1></TD></TR>
  <TR vAlign=top>
    <TD><IMG height=1 
      src="Авторизация доступа с помощью сессий.files/empty.gif" width=8></TD>
    <TD><!-- content -->
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD class=head>Язык программирования PHP</TD></TR>
        <TR>
          <TD height=4><IMG height=4 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR>
        <TR>
          <TD class=orang height=1><IMG height=1 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR>
        <TR>
          <TD><SPAN class=headsub>12. Лекция: Авторизация доступа с помощью 
            сессий: версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>Лекция 
            посвящена изучению вопросов обеспечения безопасности в сети и 
            использованию для этих целей механизма сессий. Рассматриваются: 
            инициализация сессий, передача идентификатора пользователя, 
            регистрация переменных сессии, уничтожение сессии. Также 
            рассматривается настройка сессий в файлах php.ini, httpd.conf, 
            .htaccess. В завершение приводится пример авторизации пользователя с 
            помощью механизма сессий.</SPAN> </TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR>
        <TR>
          <TD class=orang height=1><IMG height=1 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR>
        <TR>
          <TD>
            <H3></H3>
            <P>В этой лекции мы разберем, что такое <SPAN 
            class=keyword>сессии</SPAN> и в чем их специфика в PHP, решим одну 
            из основных задач, возникающих при построении более-менее сложных 
            информационных систем (сайтов) - задачу <SPAN 
            class=keyword>авторизации доступа</SPAN> пользователей к ресурсам 
            системы, а также обсудим безопасность построенного решения.</P>
            <H3>Авторизация доступа</H3>
            <P>Что такое <SPAN class=keyword>авторизация доступа</SPAN>? 
            Попробуем объяснить на примере из обычной жизни. Вы хотите взять в 
            библиотеке книгу. Но эта услуга доступна только тем, у кого есть 
            читательский билет. Можно сказать, что с помощью этого билета 
            производится <SPAN class=keyword>"авторизация доступа"</SPAN> к 
            библиотечным ресурсам. Библиотекарь после предъявления ему 
            читательского билета знает, кто берет книгу, и в случае 
            необходимости (например, книгу долго не возвращают) может принять 
            меры (позвонить должнику домой). Библиотекарь имеет гораздо больше 
            прав, чем обычный посетитель: он может давать или не давать книги 
            определенному посетителю, может выставлять напоказ новинки и убирать 
            в архив редко читаемые книги и т.п.</P>
            <P>В информационных технологиях все примерно так же. В сети 
            существует огромное количество ресурсов, т.е. множество "библиотек". 
            У каждой из них свой "библиотекарь", т.е. человек или группа людей, 
            отвечающих за содержание ресурса и предоставление пользователям 
            информации. Их называют администраторами. Функции администратора, 
            как правило, включают добавление новой информации, удаление и 
            редактирование существующей, настройка способов отображения 
            информации пользователю. А в функции пользователя (простого 
            посетителя ресурса) входит только поиск и просмотр информации.</P>
            <P>Как же отличить пользователя от администратора? В реальной 
            библиотеке это как-то очевидно, но если роли библиотекаря и 
            посетителя библиотеки перенести в виртуальную реальность, то эта 
            очевидность исчезает. Библиотекарь, как и посетитель, имеет доступ к 
            библиотечным ресурсам через Internet. А согласно протоколу HTTP все 
            клиенты абсолютно равноправны. Как же понять, кто зашел на сайт? 
            Обычный пользователь (посетитель) или администратор (библиотекарь)? 
            Если это простой пользователь, то как сохранить это знание, чтобы не 
            допустить посетителя в закрытые архивы сайта? То есть возникает 
            вопрос, как идентифицировать клиента, который послал запрос, и 
            сохранять сведения о нем, пока он находится на сайте?</P>
            <P>Самый простой вариант, который приходит в голову, - это 
            регистрация человека в системе и выдача ему аналога читательского 
            билета, а именно логина и пароля для входа в административную часть 
            системы. Эта информация хранится на компьютере-сервере, и при входе 
            в систему проверяется соответствие введенных пользователем логина и 
            пароля тем, что хранятся в системе. Правда, здесь по сравнению с 
            реальной библиотекой ситуация изменяется: читательский билет 
            требуется библиотекарю для входа в закрытую часть системы, а 
            читатель может заходить на сайт свободно. В принципе можно 
            регистрировать и простых посетителей. Тогда всех зарегистрированных 
            пользователей нужно разделить на группы: библиотекари 
            (администраторы) и читатели (простые пользователи), наделив их 
            соответствующими правами. Мы не будем вдаваться в эти тонкости и 
            воспользуемся самым простым вариантом, когда ввод логина и пароля 
            требуется для доступа к некоторым страницам сайта.</P>
            <P><B>Пример 12.1.</B></P>
            <P>У нас имеется файл <SPAN class=texample>index.html</SPAN> - 
            домашняя страничка Васи Петрова</P><A name=example.12.1></A>
            <DIV class=example><PRE>&lt;html&gt;
&lt;head&gt;&lt;title&gt;My home page&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
Привет всем! 
Меня зовут Вася Петров и 
это моя домашняя страничка.
&lt;a href="secret_info.html"&gt;Для Пети&lt;/a&gt;
&lt;/body&gt;&lt;/html&gt;
</PRE><SPAN class=objectName>Листинг 12.1. Домашняя страничка Васи 
            Петрова</SPAN></DIV>
            <P>и файл <SPAN class=texample>secret_info.html</SPAN>, который 
            содержит секретную информацию, читать которую разрешено только 
            Васиному другу Пете.</P><A name=example.12.1a></A>
            <DIV class=example><PRE>&lt;html&gt;
&lt;head&gt;&lt;title&gt;Secret info&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
Здесь я хочу делиться секретами 
с другом Петей.&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
</PRE><SPAN class=objectName>Листинг 12.1a. 
            secret_info.html</SPAN></DIV>
            <P>Если оставить оба эти файла как есть, то любой посетитель, 
            кликнув на ссылку "Для Пети", попадет на секретную страничку. Чтобы 
            этого избежать, нужно добавить промежуточный скрипт, который будет 
            проверять, действительно ли Петя хочет попасть на секретную 
            страничку. И сделать так, чтобы главный файл ссылался не сразу на 
            <SPAN class=texample>secret_info.html</SPAN>, а сначала на этот 
            скрипт.</P><A name=example.12.1b></A>
            <DIV class=example><PRE>&lt;html&gt;
&lt;head&gt;&lt;title&gt;My home page&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Привет всем! 
Меня зовут Вася Петров и 
это моя домашняя страничка.
&lt;/p&gt;
&lt;a href="authorize.php"&gt;Для Пети&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE><SPAN class=objectName>Листинг 12.1b. Index.html</SPAN></DIV>
            <P>Сам скрипт авторизации должен предоставлять форму для ввода 
            логина и пароля, проверять их правильность и перенаправлять на 
            секретную страничку, если проверка прошла успешно, и выдавать 
            сообщение об ошибке в противном случае.</P><A 
name=example.12.1c></A>
            <DIV class=example><PRE>&lt;?
if (!isset($_GET['go'])){   
    // проверяем, отправлены ли данные формой
    echo "&lt;form&gt; 
    // форма для авторизации 
    //(ввода логина и пароля)
    Login: &lt;input type=text name=login&gt;
    Password: &lt;input type=password 
                        name=passwd&gt;
    &lt;input type=submit name=go value=Go&gt;
    &lt;/form&gt;";
}else { 
// если форма заполнена, то сравниваем логин
// и пароль с правильными логином и  паролем
    if ($_GET['login']=="pit" &amp;&amp; 
        $_GET['passwd']=="123") { 
    Header("Location: secret_info.html");
    //и перенаправляем на секретную страницу
    }else echo "Неверный ввод, 
                попробуйте еще раз&lt;br&gt;";
}
?&gt;
</PRE><SPAN class=objectName>Листинг 12.1c. 
            authorize.php</SPAN></DIV>
            <P>Вроде бы все достаточно просто. Но допустим, у нас не одна 
            секретная страничка, а несколько. Причем они связаны между собой 
            перекрестными ссылками. Тогда возникает необходимость постоянно 
            помнить пароль и логин посетителя сайта (если он таковой имеет). 
            Чтобы решить эту проблему, можно в каждую страницу встроить скрипт, 
            который будет передавать логин и пароль от страницы к странице в 
            качестве скрытых параметров формы. Но такой способ не совсем 
            безопасен: эти параметры можно перехватить и подделать. В PHP 
            существует более удобный и безопасный метод решения проблемы 
            хранения данных о посетителе в течение сеанса его работы с сайтом - 
            это механизм <SPAN class=keyword>сессий</SPAN>.</P>
            <H3>Механизм сессий</H3>
            <P>Cессии - это механизм, который позволяет создавать и использовать 
            переменные, сохраняющие свое значение в течение всего времени работы 
            пользователя с сайтом.</P>
            <P>Эти переменные для каждого пользователя имеют различные значения 
            и могут использоваться на любой странице сайта до выхода 
            пользователя из системы. При этом каждый раз, заходя на сайт, 
            пользователь получает новые значения переменных, позволяющие 
            идентифицировать его в течение этого сеанса или <SPAN 
            class=keyword>сессии</SPAN> работы с сайтом. Отсюда и название 
            механизма - <SPAN class=keyword>сессии</SPAN>.</P>
            <P>Задача <SPAN class=keyword>идентификации пользователя</SPAN> 
            решается путем присвоения каждому пользователю уникального номера, 
            так называемого <SPAN class=keyword>идентификатора сессии</SPAN> 
            (SID, Session IDentifier). Он генерируется PHP в тот момент, когда 
            пользователь заходит на сайт, и уничтожается, когда пользователь 
            уходит с сайта, и представляет собой строку из 32 символов 
            (например, ac4f4a45bdc893434c95dcaffb1c1811). Этот идентификатор 
            передается на сервер вместе с каждым запросом клиента и возвращается 
            обратно вместе с ответом сервера.</P>
            <P>Существует несколько способов передачи <SPAN 
            class=keyword>идентификатора сессии</SPAN>:</P>
            <UL>
              <LI>
              <P>С помощью <SPAN class=keyword>cookies</SPAN>.</P>
              <P><SPAN class=keyword>Cookies</SPAN> были созданы специально как 
              метод однозначной идентификации клиентов и представляют собой 
              расширение протокола HTTP. В этом случае <SPAN 
              class=keyword>идентификатор сессии</SPAN> сохраняется во временном 
              файле на компьютере клиента, пославшего запрос. Метод, несомненно, 
              хорош, но многие пользователи отключают поддержку <SPAN 
              class=keyword>cookies</SPAN> на своем компьютере из-за проблем с 
              безопасностью.</P>
              <LI>
              <P>С помощью параметров командной строки.</P>
              <P>В этом случае <SPAN class=keyword>идентификатор сессии</SPAN> 
              автоматически встраивается во все запросы (URL), передаваемые 
              серверу, и хранится на стороне сервера.</P></LI></UL>
            <P>Например: адрес <A href="http://green.nsu.ru/test.php" 
            target=_blank>http://green.nsu.ru/test.php</A> превращается в адрес 
            <A 
            href="http://green.nsu.ru/test.php?PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811" 
            target=_blank>http://green.nsu.ru/test.php?PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811</A></P>
            <P>Этот способ передачи идентификатора используется автоматически, 
            если у браузера, отправившего запрос, выключены <SPAN 
            class=keyword>cookies</SPAN>. Он достаточно надежный - передавать 
            параметры в командной строке можно всегда. С другой стороны, <SPAN 
            class=keyword>идентификатор сессии</SPAN> можно подглядеть, 
            воспользоваться сохраненным вариантом в строке браузера или 
            подделать. Хотя, конечно, все эти проблемы либо надуманны либо их 
            можно решить. Например, кто сможет запомнить строку из 32 различных 
            символов? А если правильно организовать работу с <SPAN 
            class=keyword>сессиями</SPAN> (вовремя их уничтожать), то даже 
            сохранившийся в браузере номер <SPAN class=keyword>сессии</SPAN> 
            ничего не даст. К вопросам безопасности мы еще вернемся в конце 
            лекции.</P>
            <P>Кроме перечисленных вариантов передачи <SPAN 
            class=keyword>идентификатора сессии</SPAN>, известно еще несколько, 
            но мы их рассматривать не будем ввиду их сложности.</P>
            <H3>Настройка сессий</H3>
            <P>Прежде чем начать работать с <SPAN class=keyword>сессиями</SPAN>, 
            следует разобраться в том, как корректно настраивать их обработку 
            интерпретатором PHP. Сама работа с <SPAN 
            class=keyword>сессиями</SPAN> в PHP поддерживается по умолчанию. Это 
            значит, что устанавливать никаких дополнительных элементов не нужно. 
            А вот знать, что записано в настройках этого модуля, полезно, чтобы 
            избежать ошибок при работе с ним.</P>
            <P>Настройки PHP, в том числе и для работы с <SPAN 
            class=keyword>сессиями</SPAN>, прописываются в файле php.ini. 
            Обратимся к этому файлу.</P>
            <P>Как мы уже знаем, <SPAN class=keyword>идентификатор сессии</SPAN> 
            (число, по которому можно уникально идентифицировать клиента, 
            пославшего запрос) сохраняется либо на компьютере-сервере, либо на 
            компьютере-клиенте, либо и там, и там.</P>
            <P><A name=keyword-context.1></A>Параметр <SPAN 
            class=keyword_def>session.save_path</SPAN> в php.ini, определяет, 
            где на сервере будут храниться данные <SPAN 
            class=keyword>сессии</SPAN>. Из-за него чаще всего возникают 
            проблемы для Windows-серверов, потому что по умолчанию значение 
            <SPAN class=keyword>session.save_path</SPAN> установлено в <SPAN 
            class=texample>/tmp</SPAN>. И если в корневой директории сервера 
            такой папки нет, то при запуске <SPAN class=keyword>сессий</SPAN> 
            будет выдаваться ошибка.</P>
            <P>Сервер может обрабатывать большое количество <SPAN 
            class=keyword>сессий</SPAN> одновременно, и все их временные файлы 
            будут храниться в директории, заданной параметром <SPAN 
            class=keyword>session.save_path</SPAN>. Если система плохо работает 
            с папками большого размера, то удобно использовать поддиректории. 
            Для этого, кроме названия папки, в значение параметра добавляют еще 
            и число, определяющее глубину вложенности поддиректорий в этой 
            папке: <SPAN class=texample>N;/dir</SPAN>. Это значение нужно 
            обязательно взять в кавычки, поскольку точка с запятой является 
            одним из символов комментариев в файле настроек PHP. Все директории 
            и поддиректории для хранения данных <SPAN 
            class=keyword>сессии</SPAN> нужно создать самостоятельно.</P>
            <P>Например: <SPAN class=texample>2;/Temp</SPAN> определяет, что 
            переменные <SPAN class=keyword>сессий</SPAN> будут храниться в 
            папках вида <SPAN class=texample>c:\Temp\0\a\</SPAN>, <SPAN 
            class=texample>c:\Temp\0\b\</SPAN> и т.п.</P>
            <P>Хранение данных на стороне клиента осуществляется с помощью <SPAN 
            class=keyword>cookies</SPAN>. Работу PHP с <SPAN 
            class=keyword>cookies</SPAN> можно настроить, в частности, с помощью 
            параметров <SPAN class=keyword>session.use_cookies</SPAN>, <SPAN 
            class=keyword>session.cookie_lifetime</SPAN> и т.п.</P>
            <P><A name=keyword-context.2></A>Параметр <SPAN 
            class=keyword_def>session.use_cookies</SPAN> определяет, 
            использовать ли <SPAN class=keyword>cookies</SPAN> при работе с 
            <SPAN class=keyword>сессиями</SPAN>. По умолчанию эта опция включена 
            (т.е. принимает значение <SPAN class=texample>"1"</SPAN>). </P>
            <P><A name=keyword-context.3></A>Параметр <SPAN 
            class=keyword_def>session.cookie_lifetime</SPAN> задает длительность 
            жизни <SPAN class=keyword>cookies</SPAN> в секундах. По умолчанию 
            это <SPAN class=texample>"0"</SPAN>, т.е. данные в <SPAN 
            class=keyword>cookies</SPAN> считаются правильными до закрытия окна 
            браузера. </P>
            <P>Кроме этих параметров, полезными могут оказаться <SPAN 
            class=keyword>session.name</SPAN>, определяющий имя <SPAN 
            class=keyword>сессии</SPAN>, <SPAN 
            class=keyword_def>session.auto_start</SPAN>, позволяющий 
            автоматически запускать <SPAN class=keyword>сессии</SPAN>, <SPAN 
            class=keyword_def>session.serialize_handler</SPAN>, задающий способ 
            кодировки данных <SPAN class=keyword>сессии</SPAN>, и параметр <SPAN 
            class=keyword_def>session.cache_expire</SPAN>, определяющий, через 
            сколько минут устаревает документ в кэше.</P>
            <P>Имя <SPAN class=keyword>сессии</SPAN> <SPAN 
            class=keyword>session.name</SPAN> по умолчанию устанавливается как 
            <SPAN class=texample>PHPSESSID</SPAN> и используется в <SPAN 
            class=keyword>cookies</SPAN> как имя переменной, в которой хранится 
            <SPAN class=keyword>идентификатор сессии</SPAN>. Автоматический 
            запуск <SPAN class=keyword>сессий</SPAN> по умолчанию отключен, но 
            его можно задать, сделав значение <SPAN 
            class=keyword>session.auto_start</SPAN> равным <SPAN 
            class=texample>"1"</SPAN>. Для кодирования данных <SPAN 
            class=keyword>сессии</SPAN> по умолчанию используется php. 
            Устаревание данных, сохраненных в кэше, происходит через 180 
            минут.</P>
            <P>Существует еще множество настроек, с которыми можно познакомиться 
            в документации или непосредственно в файле настроек php.ini. На наш 
            взгляд, знакомства с перечисленными выше параметрами достаточно для 
            работы с <SPAN class=keyword>сессиями</SPAN> в PHP. Так что 
            приступим.</P>
            <H3>Работа с сессиями</H3>
            <H4>Создание сессии</H4>
            <P>Первое, что нужно сделать для работы с <SPAN 
            class=keyword>сессиями</SPAN> (если они уже настроены 
            администратором сервера), это запустить механизм <SPAN 
            class=keyword>сессий</SPAN>. Если в настройках сервера переменная 
            <SPAN class=keyword>session.auto_start</SPAN> установлена в значение 
            <SPAN class=texample>"0"</SPAN> (если <SPAN 
            class=texample>session.auto_start=1</SPAN>, то <SPAN 
            class=keyword>сессии</SPAN> запускаются автоматически), то любой 
            скрипт, в котором нужно использовать данные <SPAN 
            class=keyword>сессии</SPAN>, должен начинаться с команды </P>
            <DIV class=example><PRE>session_start();
</PRE></DIV>
            <P>Получив такую команду, сервер создает новую <SPAN 
            class=keyword>сессию</SPAN> или восстанавливает текущую, основываясь 
            на <SPAN class=keyword>идентификаторе сессии</SPAN>, переданном по 
            запросу. Как это делается? Интерпретатор PHP ищет переменную, в 
            которой хранится <SPAN class=keyword>идентификатор сессии</SPAN> (по 
            умолчанию это PHPSESSID) сначала в <SPAN 
            class=keyword>cookies</SPAN>, потом в переменных, переданных с 
            помощью POST- и GET-запросов. Если идентификатор найден, то 
            пользователь считается идентифицированным, производится замена всех 
            URL и выставление <SPAN class=keyword>cookies</SPAN>. В противном 
            случае пользователь считается новым, для него генерируется новый 
            уникальный идентификатор, затем производится замена URL и 
            выставление <SPAN class=keyword>cookies</SPAN>.</P>
            <P>Команду <SPAN class=texample>session_start()</SPAN> нужно 
            вызывать во всех скриптах, в которых предстоит использовать 
            переменные <SPAN class=keyword>сессии</SPAN>, причем до вывода 
            каких-либо данных в браузер. Это связано с тем, что <SPAN 
            class=keyword>cookies</SPAN> выставляются только до вывода 
            информации на экран.</P>
            <P>Получить идентификатор текущей <SPAN class=keyword>сессии</SPAN> 
            можно с помощью <SPAN class=keyword>функции session_id()</SPAN>.</P>
            <P>Для наглядности <SPAN class=keyword>сессии</SPAN> можно задать 
            имя с помощью функции <SPAN 
            class=texample>session_name([имя_сессии])</SPAN>. Делать это нужно 
            еще до инициализации <SPAN class=keyword>сессии</SPAN>. Получить имя 
            текущей <SPAN class=keyword>сессии</SPAN> можно с помощью этой же 
            функции, вызванной без параметров: <SPAN 
            class=keyword>session_name();</SPAN></P>
            <P><B>Пример 12.2.</B> Создание сессии</P>
            <P>Переименуем наш файл index.html, чтобы обрабатывались 
            php-скрипты, например в Index.php, создадим <SPAN 
            class=keyword>сессию</SPAN> и посмотрим, какой она получит 
            идентификатор и имя.</P><A name=example.12.2></A>
            <DIV class=example><PRE>&lt;?
session_start(); 
    // создаем новую сессию или
    // восстанавливаем текущую
echo session_id(); 
    // выводим идентификатор сессии
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;My home page&lt;/title&gt;&lt;/head&gt;
... // домашняя страничка
&lt;/html&gt;
&lt;?
echo session_name(); 
    // выводим имя текущей сессии. 
    // В данном случае это PHPSESSID 
?&gt;
</PRE><SPAN class=objectName>Пример 12.2. Создание 
            сессии</SPAN></DIV>
            <P>Если проделать то же самое с файлом authorize.php, то значения 
            выводимых переменных (id <SPAN class=keyword>сессии</SPAN> и ее имя) 
            будут такими же, если перейти на него с index.php и не закрывать 
            перед этим окно браузера (тогда <SPAN class=keyword>идентификатор 
            сессии</SPAN> изменится).</P>
            <H4>Регистрация переменных сессии</H4>
            <P>Однако от самих идентификатора и имени <SPAN 
            class=keyword>сессии</SPAN> нам пользы для решения наших задач 
            немного. Мы же хотим передавать и сохранять в течение <SPAN 
            class=keyword>сессии</SPAN> наши собственные переменные (например, 
            логин и пароль). Для того чтобы этого добиться, нужно просто 
            зарегистрировать свои переменные:</P>
            <DIV class=example><PRE>session_register(имя_переменной1, 
                 имя_переменной2, ...);
</PRE></DIV>
            <P>Заметим, что регистрируются не значения, а имена переменных. 
            Зарегистрировать переменную достаточно один раз на любой странице, 
            где используются <SPAN class=keyword>сессии</SPAN>. Имена переменных 
            передаются <SPAN class=keyword>функции session_register()</SPAN> без 
            знака <SPAN class=texample>$</SPAN>. Все зарегистрированные таким 
            образом переменные становятся глобальными (т.е. доступными с любой 
            страницы) в течение данной <SPAN class=keyword>сессии</SPAN> работы 
            с сайтом.</P>
            <P>Зарегистрировать переменную также можно, просто записав ее 
            значение в ассоциативный <SPAN class=keyword>массив 
            $_SESSION</SPAN>, т.е. написав </P>
            <DIV class=example><PRE>$_SESSION['имя_переменной'] = 
       'значение_переменой';
</PRE></DIV>
            <P>В этом массиве хранятся все зарегистрированные (т.е. глобальные) 
            переменные <SPAN class=keyword>сессии</SPAN>. </P>
            <P>Доступ к таким переменным осуществляется с помощью массива <SPAN 
            class=texample>$_SESSION['имя_переменной']</SPAN> (или <SPAN 
            class=texample>$HTTP_SESSION_VARS['имя_переменной']</SPAN> для 
            версии PHP 4.0.6 и более ранних). Если же в настройках php включена 
            опция <SPAN class=keyword>register_globals</SPAN>, то к сессионным 
            переменным можно обращаться еще и как к обычным переменным, например 
            так: $имя_переменной.</P>
            <P>Если <SPAN class=texample>register_globals=off</SPAN> 
            (отключены), то пользоваться <SPAN 
            class=keyword>session_register()</SPAN> для регистрации переменных 
            переданных методами POST или GET, нельзя, т.е. это просто не 
            работает. И вообще, не рекомендуется одновременно использовать оба 
            метода <SPAN class=keyword>регистрации переменных</SPAN>, <SPAN 
            class=keyword>$_SESSION</SPAN> и <SPAN 
            class=keyword>session_register()</SPAN>.</P>
            <P><B>Пример 12.3.</B> Регистрация переменных</P>
            <P>Зарегистрируем логин и пароль, вводимые пользователем на странице 
            авторизации.</P><A name=example.12.3a></A>
            <DIV class=example><PRE>&lt;?
session_start();
    // создаем новую сессию или 
    // восстанавливаем текущую
if (!isset($_GET['go'])){
  echo "&lt;form&gt;
    Login: &lt;input type=text name=login&gt;
    Password: &lt;input type=password 
                        name=passwd&gt;
    &lt;input type=submit name=go value=Go&gt;
  &lt;/form&gt;";
}else {
   $_SESSION['login']=$_GET['login']; 
   // регистрируем переменную login
   $_SESSION['passwd']=$_GET['passwd']; 
   // регистрируем переменную passwd
// теперь логин и пароль - глобальные 
// переменные для этой сессии
    if ($_GET['login']=="pit" &amp;&amp; 
        $_GET['passwd']=="123") {
        Header("Location: secret_info.php"); 
        // перенаправляем на страницу 
        // secret_info.php
    }else echo "Неверный ввод, 
                попробуйте еще раз&lt;br&gt;";
}
print_r($_SESSION); 
    // выводим все переменные сессии
?&gt;
</PRE><SPAN class=objectName>Листинг 12.3a. 
            authorize.php</SPAN></DIV>
            <P>Теперь, попав на страничку <SPAN 
            class=texample>secret_info.php</SPAN>, да и на любую другую страницу 
            сайта, мы сможем работать с введенными пользователем логином и 
            паролем, которые будут храниться в <SPAN class=keyword>массиве 
            $_SESSION</SPAN>. Таким образом, если изменить код секретной 
            странички (заметьте, мы переименовали ее в secret_info.php) 
            так:</P><A name=example.12.3b></A>
            <DIV class=example><PRE>&lt;?php
session_start(); 
    // создаем новую сессию или 
    // восстанавливаем текущую
print_r($_SESSION); 
    // выводим все переменные сессии
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Secret info&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Здесь я хочу делиться секретами 
с другом Петей.
&lt;/body&gt;
&lt;/html&gt;
</PRE><SPAN class=objectName>Листинг 12.3b. 
            secret_info.php</SPAN></DIV>
            <P>То мы получим в браузере на секретной странице следующее:</P>
            <DIV class=example><PRE>Array ( [login] =&gt; pit [passwd] =&gt; 123 )
Здесь я хочу делиться секретами 
с другом Петей. 
</PRE></DIV>
            <P>В итоге получим.список переменных, зарегистрированных на 
            authorize.php и, собственно, саму секретную страничку.</P>
            <P>Что это нам дает? Допустим, хакер хочет прочитать секреты Васи и 
            Пети. И он как-то узнал, как называется секретная страничка (или 
            странички). Тогда он может попытаться просто ввести ее адрес в 
            строке браузера, минуя страницу авторизации (ввода пароля). Чтобы 
            избежать такого проникновения в наши тайны, нужно дописать всего 
            пару строк в код секретных страничек:</P><A name=example.12.3c></A>
            <DIV class=example><PRE>&lt;?php
session_start(); 
    // создаем новую сессию или 
    // восстанавливаем текущую
print_r($_SESSION); 
    // выводим все переменные сессии
if (!($_SESSION['login']=="pit" &amp;&amp; 
    $_SESSION['passwd']==123))  
    // проверяем правильность 
    // пароля-логина
    Header("Location: authorize.php"); 
    // если ошибка, то перенаправляем на 
    // страницу авторизации
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Secret info&lt;/title&gt;&lt;/head&gt;
... // здесь располагается 
    //секретная информация :)
&lt;/html&gt;
</PRE><SPAN class=objectName>Листинг 12.3c. 2-я версия 
            secret_info.php</SPAN></DIV>
            <H4>Удаление переменных сессии</H4>
            <P>Кроме умения регистрировать переменные <SPAN 
            class=keyword>сессии</SPAN> (т.е. делать их глобальными на 
            протяжении всего сеанса работы), полезно также уметь удалять такие 
            переменные и <SPAN class=keyword>сессию</SPAN> в целом.</P>
            <P><A name=keyword-context.4></A><SPAN class=keyword_def>Функция 
            session_unregister(имя_переменной)</SPAN> удаляет глобальную 
            переменную из текущей <SPAN class=keyword>сессии</SPAN> (т.е. 
            удаляет ее из списка зарегистрированных переменных). Если 
            регистрация производилась с помощью <SPAN 
            class=keyword>$_SESSION</SPAN> (<SPAN 
            class=keyword>$HTTP_SESSION_VARS</SPAN> для версии PHP 4.0.6 и более 
            ранних), то используют языковую конструкцию <SPAN 
            class=texample>unset()</SPAN>. Она не возвращает никакого значения, 
            а просто уничтожает указанные переменные.</P>
            <P>Где это может пригодиться? Например, для уничтожения данных о 
            посетителе (в частности, логина и пароля) после его ухода с 
            секретной странички. Если правильные логин и пароль сохранятся и 
            окно браузера после посещения сайта не закрыли, то любой другой 
            пользователь этого компьютера сможет прочитать закрытую 
            информацию.</P>
            <P><B>Пример 12.4.</B> Уничтожение переменных сессии</P>
            <P>В файл <SPAN class=texample>secret_info.php</SPAN> добавим 
            строчку для выхода на главную страницу:</P><A 
name=example.12.4a></A>
            <DIV class=example><PRE>&lt;?php
// ... php код 
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Secret info&lt;/title&gt;&lt;/head&gt;
... // здесь располагается 
    // секретная информация :)
&lt;a href="index.php"&gt;На главную&lt;/a&gt;
&lt;/html&gt;
</PRE><SPAN class=objectName>Пример 12.4a. 
            secret_info.php</SPAN></DIV>
            <P>В <SPAN class=texample>Index.php</SPAN> уничтожим логин и пароль, 
            введенные ранее:</P><A name=example.12.4b></A>
            <DIV class=example><PRE>&lt;?
session_start();
session_unregister('passwd'); 
    // уничтожаем пароль
unset($_SESSION['login']); 
    // уничтожаем логин
print_r($_SESSION); 
    // выводим глобальные переменные сессии
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;My home page&lt;/title&gt;&lt;/head&gt;
... // домашняя страничка
&lt;/html&gt;
</PRE><SPAN class=objectName>Пример 12.4b. Index.php</SPAN></DIV>
            <P>Теперь, чтобы попасть на секретную страницу, нужно будет опять 
            вводить логин и пароль.</P>
            <P>Для того чтобы сбросить значения всех переменных <SPAN 
            class=keyword>сессии</SPAN>, можно использовать <SPAN 
            class=keyword>функцию session_unset();</SPAN></P>
            <P>Уничтожить текущую <SPAN class=keyword>сессию</SPAN> целиком 
            можно командой <SPAN class=keyword>session_destroy();</SPAN> Она не 
            сбрасывает значения глобальных переменных <SPAN 
            class=keyword>сессии</SPAN> и не удаляет <SPAN 
            class=keyword>cookies</SPAN>, а уничтожает все данные, ассоциируемые 
            с текущей <SPAN class=keyword>сессией</SPAN>.</P><A 
            name=example.12.5></A>
            <DIV class=example><PRE>&lt;?
session_start(); // инициализируем сессию
$test = "Переменная сессии";
$_SESSION['test']= $test; 
// регистрируем переменную $test.
// если register_globals=on, 
// то можно использовать 
// session_register('test');
    
print_r($_SESSION); 
// выводим все глобальные переменные 

echo session_id(); 
// выводим идентификатор сессии

echo "&lt;hr&gt;";
session_unset(); 
// уничтожаем все глобальные 
// переменные сессии
print_r($_SESSION);
echo session_id();
echo "&lt;hr&gt;";
session_destroy(); // уничтожаем сессию
print_r($_SESSION);
echo session_id();
?&gt;
</PRE><SPAN class=objectName>Пример 12.5. Уничтожение сессии и 
            глобальных переменных</SPAN></DIV>
            <P>В результате работы этого скрипта будут выведены три строки: в 
            первой - массив с элементом <SPAN class=texample>test</SPAN> и его 
            значением, а также <SPAN class=keyword>идентификатор сессии</SPAN>, 
            во второй - пустой массив и <SPAN class=keyword>идентификатор 
            сессии</SPAN>, в третьей - пустой массив. Таким образом, видно, что 
            после уничтожения <SPAN class=keyword>сессии</SPAN> уничтожается и 
            ее идентификатор, и мы больше не можем ни регистрировать переменные, 
            ни вообще производить какие-либо действия с <SPAN 
            class=keyword>сессией</SPAN>.</P>
            <H3>Безопасность</H3>
            <P>Вообще говоря, cледует понимать, что использование механизма 
            <SPAN class=keyword>сессий</SPAN> не гарантирует полной безопасности 
            системы. Для этого нужно принимать дополнительные меры. Обратим 
            внимание на проблемы с безопасностью, которые могут возникнуть при 
            работе с <SPAN class=keyword>сессиями</SPAN> и, в частности, с теми 
            программами, что мы написали.</P>
            <P>Во-первых, опасно передавать туда-сюда пароль, его могут 
            перехватить. Кроме того, мы зарегистрировали его как глобальную 
            переменную <SPAN class=keyword>сессии</SPAN>, значит, он сохранился 
            в <SPAN class=keyword>cookies</SPAN> на компьютере-клиенте. Это тоже 
            плохо. И вообще, пароли и логины по-хорошему должны храниться в базе 
            данных. Пусть информация о пользователях хранится в базе данных 
            "test" (в таблице "users"), а мы имеем к ней доступ под логином 
            <SPAN class=texample>my_user</SPAN> и паролем <SPAN 
            class=texample>my_passwd</SPAN>.</P>
            <P>Во-вторых, что делать, если кто-то написал скрипт подбора пароля 
            для секретной страницы? В этом случае на страницу авторизации много 
            раз должен стучаться какой-то посторонний скрипт. Поэтому нужно 
            просто проверять, с нашего ли сайта пришел запрос на авторизацию, и 
            если нет, то не пускать его дальше. Адрес страницы, с которой 
            поступил запрос, можно получить с помощью глобальной переменной 
            <SPAN class=keyword>$_SERVER['HTTP_REFERER'])</SPAN>. Хотя, конечно, 
            если за взлом сайта взялись всерьез, то значение этой переменной 
            тоже подменят (например, с помощью того же PHP). Тем не менее 
            проверку ее значения можно считать одним из важнейших шагов на пути 
            к обеспечению безопасности своего сайта.</P><A 
name=example.12.6></A>
            <DIV class=example><PRE>&lt;?
session_start(); 
    // создаем новую сессию или 
    // восстанавливаем текущую
$conn = mysql_connect("localhost",
       "my_user","my_passwd"); 
    // устанавливаем соединение с БД
mysql_select_db("test"); 
    // выбираем рабочую базу данных

$SERVER_ROOT = "http://localhost/~nina/tasks/sessions/";
    // где находятся наши скрипты

/* с помощью регулярного выражения 
^$SERVER_ROOT и функции eregi проверяем, 
начинается ли адрес ссылающегося скрипта, 
т.е. строка $_SERVER['HTTP_REFERER']) 
со строки $SERVER_ROOT (как у нас) */

if(eregi("^$SERVER_ROOT",
         $_SERVER['HTTP_REFERER'])){
// если да, то делаем почти то же, что и
// раньше, пароль регистрировать не будем
if (!isset($_POST['go'])){
    echo "&lt;form method=POST &gt;
        Login: &lt;input type=text name=login&gt;
        Password: &lt;input type=password name=passwd&gt;
        &lt;input type=submit name=go value=Go&gt;
    &lt;/form&gt;";
}else {
/* запрос к базе данных: выбираем из таблицы
users login, который совпадает с переданным
по запросу, причем пароль у него тоже должен
совпасть с введенным пользователем. 
Если этого нет, то считаем, что логин и 
пароль введены неверно */
$sql = "SELECT login FROM users 
  WHERE login='" . $_POST['login'] . "' AND passwd='" . $_POST['passwd'] . "';";
$q = mysql_query($sql,$conn); // отправляем запрос к БД
$n = mysql_num_rows($q); // число строк в ответе на запрос
if (!$n==0){
    $_SESSION['user_login']=$_POST['login'];
    // регистрируем переменную login
    Header("Location: secret_info.php"); 
    // перенаправляем  на страницу secret_info.php
    }else echo "Неверный ввод, попробуйте еще раз&lt;br&gt;";
}
print_r($_SESSION); // выводим все переменные сессии
}
?&gt;
</PRE><SPAN class=objectName>Листинг 12.6. 
authorize.php</SPAN></DIV>
            <P>Вроде бы первые две проблемы решены. Но есть еще одна. Что 
            делать, если хакер просто допишет в строку запроса значение 
            какой-нибудь глобальной переменной (например, логина)? Вообще это 
            возможно, только если <SPAN 
            class=texample>register_globals=On</SPAN>. Просто иначе мы 
            используем для работы с глобальными переменными <SPAN 
            class=keyword>массив $_SESSION</SPAN> и с ним такие фокусы не 
            проходят. Все же попробуем решить и эту проблему. Для этого нужно 
            очистить строку запроса перед тем, как сравнивать значения 
            параметров. То есть сначала сбросим значение <SPAN 
            class=texample>$user_login</SPAN>. Потом данную переменную нужно 
            опять зарегистрировать, но не как новую, а как уже существующую. Для 
            этого знак доллара при регистрации НЕ опускается. Вот что 
            получилось:</P><A name=example.12.7></A>
            <DIV class=example><PRE>&lt;?php
unset($user_login); // уничтожаем переменную
session_start(); // создаем новую сессию или
                 // восстанавливаем текущую
session_register($user_login);  
    // регистрируем переменную 
    // как уже существующую
if (!($user_login=="pit")) // проверяем логин
    Header("Location: authorize.php"); 
    // если ошибка, то перенаправляем 
    // на страницу авторизации
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Secret info&lt;/title&gt;&lt;/head&gt;
... // здесь располагается 
    // секретная информация :)
&lt;/html&gt;
</PRE><SPAN class=objectName>Листинг 12.7. 
            secret_info.php</SPAN></DIV>
            <H3>Заключение</H3>
            <P>Итак, мы познакомились с <SPAN class=keyword>сессиями</SPAN> и 
            основными способами работы с ними, проблемами, возникающими при их 
            использовании, и возможными решениями этих проблем. Надеюсь, что 
            после прочтения лекции читателям стало ясно, насколько удобны и 
            просты в использовании <SPAN class=keyword>сессии</SPAN>, а 
            приведенные примеры пригодятся на практике.</P></TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Авторизация доступа с помощью сессий.files/empty.gif" 
          width=1></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG height=1 
      src="Авторизация доступа с помощью сессий.files/empty.gif" 
  width=8></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG height=1 
      src="Авторизация доступа с помощью сессий.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD class=ltxt align=middle>© 2003-2005 INTUIT.ru. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom --></BODY></HTML>
