<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://www.intuit.ru/department/pl/plphp/10/plphp_10.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="Базы данных и СУБД. Введение в SQL.files/printable.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY leftMargin=0 topMargin=6 marginwidth="0" marginheight="6">
<DIV align=left><SPAN style="FONT-WEIGHT: bold; COLOR: #000000">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD colSpan=3 height=8><IMG height=8 
      src="Базы данных и СУБД. Введение в SQL.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD class=orang colSpan=3 height=1><IMG height=1 
      src="Базы данных и СУБД. Введение в SQL.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD colSpan=3 height=8><IMG height=8 
      src="Базы данных и СУБД. Введение в SQL.files/empty.gif" width=1></TD></TR>
  <TR vAlign=top>
    <TD><IMG height=1 src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
      width=8></TD>
    <TD><!-- content -->
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD class=head>Язык программирования PHP</TD></TR>
        <TR>
          <TD height=4><IMG height=4 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR>
        <TR>
          <TD class=orang height=1><IMG height=1 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR>
        <TR>
          <TD><SPAN class=headsub>10. Лекция: Базы данных и СУБД. Введение в 
            SQL: версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматриваются понятия базы данных и СУБД, дается краткое описание 
            существующих типов баз данных (сетевые, реляционные, иерархические). 
            Рассматриваются основы языка запросов SQL: операции выбора, 
            добавления, изменения и удаления строки, а также операции создания, 
            изменения и удаления таблицы. База данных MySql. Использование 
            PhpMyAdmin для взаимодействия с базой данных MySql. Обсуждаются 
            основные принципы отображения объектной модели документа на 
            реляционную структуру базы данных. Пример – проектирование базы 
            данных виртуального музея истории.</SPAN> </TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR>
        <TR>
          <TD class=orang height=1><IMG height=1 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR>
        <TR>
          <TD>
            <H3></H3>
            <P>В данной лекции мы рассмотрим основные понятия теории <SPAN 
            class=keyword>баз данных</SPAN> и познакомим читателей с системой 
            управления <SPAN class=keyword>базами данных</SPAN> <SPAN 
            class=keyword>MySql</SPAN>, способами работы с ней, ее особенностями 
            и реализацией языка запросов <SPAN class=keyword>SQL</SPAN> в этой 
            <SPAN class=keyword>СУБД</SPAN>. В основе приводимых в лекции 
            примеров лежит информационная модель виртуального музея истории 
            информатики. Эта модель есть набор коллекций описания исторических 
            личностей, экспонатов музея (артефактов), статей и изображений.</P>
            <H3>Базы данных: основные понятия</H3>
            <P>В жизни мы часто сталкиваемся с необходимостью хранить какую-либо 
            информацию, а потому часто имеем дело и с <SPAN class=keyword>базами 
            данных</SPAN>. Например, мы используем записную книжку для хранения 
            номеров телефонов своих друзей и планирования своего времени. 
            Телефонная книга содержит информацию о людях, живущих в одном 
            городе. Все это своего рода <SPAN class=keyword>базы данных</SPAN>. 
            Ну а раз это <SPAN class=keyword>базы данных</SPAN>, то посмотрим, 
            как в них хранятся данные. Например, телефонная книга представляет 
            собой таблицу (<A 
            href="http://www.intuit.ru/department/pl/plphp/10/plphp_10.html#table.10.1">табл. 
            10.1</A>).</P>
            <P>В этой таблице данные – это собственно номера телефонов, адреса и 
            ФИО., т.е. строки «Иванов Иван Иванович», «32-43-12» и т.п., а 
            названия столбцов этой таблицы, т.е. строки «ФИО», «Номер телефона» 
            и «Адрес» задают смысл этих данных, их семантику.</P>
            <DIV class=xml_table_env><A name=table.10.1></A>
            <TABLE class=xml_table cellSpacing=1 cellPadding=2 border=0>
              <CAPTION>Таблица 10.1. Пример базы данных: телефонная 
              книга</CAPTION>
              <TBODY>
              <TR>
                <TH bgColor=#d8d8d8>ФИО</TH>
                <TH bgColor=#d8d8d8>Номер телефона</TH>
                <TH bgColor=#d8d8d8>Адрес</TH></TR>
              <TR>
                <TD vAlign=top bgColor=#eaeaea>Иванов Иван Иванович</TD>
                <TD vAlign=top bgColor=#eaeaea>32-43-12</TD>
                <TD vAlign=top bgColor=#eaeaea>ул. Ленина, 12, 43</TD></TR>
              <TR>
                <TD vAlign=top bgColor=#eaeaea>Ильин Федор Иванович</TD>
                <TD vAlign=top bgColor=#eaeaea>32-32-34</TD>
                <TD vAlign=top bgColor=#eaeaea>пр. Маркса, 32, 
            45</TD></TR></TBODY></TABLE></DIV>
            <P>Теперь представьте, что записей в этой таблице не две, а две 
            тысячи, вы занимаетесь созданием этого справочника и где-то 
            произошла ошибка (например, опечатка в адресе). Видимо, тяжеловато 
            будет найти и исправить эту ошибку вручную. Нужно воспользоваться 
            какими-то средствами автоматизации. Для управления большим 
            количеством данных программисты (не без помощи математиков) 
            придумали системы управления <SPAN class=keyword>базами 
            данных</SPAN> (<SPAN class=keyword>СУБД</SPAN>). По сравнению с 
            текстовыми <SPAN class=keyword>базами данных</SPAN> электронные 
            <SPAN class=keyword>СУБД</SPAN> имеют огромное число преимуществ, от 
            возможности быстрого поиска информации, взаимосвязи данных между 
            собой до использования этих данных в различных прикладных программах 
            и одновременного доступа к данным нескольких пользователей.</P>
            <P>Для точности дадим определение <SPAN class=keyword>базы 
            данных</SPAN>, предлагаемое Глоссарий.ру</P>
            <P><A name=keyword-context.1></A><B>База данных</B> – это 
            совокупность связанных данных, организованных по определенным 
            правилам, предусматривающим общие принципы описания, хранения и 
            манипулирования, независимая от прикладных программ. <SPAN 
            class=keyword>База данных</SPAN> является информационной моделью 
            предметной области. Обращение к <SPAN class=keyword>базам 
            данных</SPAN> осуществляется с помощью системы управления <SPAN 
            class=keyword>базами данных</SPAN> (<B>СУБД</B>). <SPAN 
            class=keyword>СУБД</SPAN> обеспечивает поддержку создания <SPAN 
            class=keyword>баз данных</SPAN>, централизованного управления и 
            организации доступа к ним различных пользователей.</P>
            <P>Итак, мы пришли к выводу, что хранить данные независимо от 
            программ, так, что они связаны между собой и организованы по 
            определенным правилам, целесообразно. Но вопрос, как хранить данные, 
            по каким правилам они должны быть организованы, остался открытым. 
            Способов существует множество (кстати, называются они моделями 
            представления или хранения данных). Наиболее популярные – объектная 
            и <SPAN class=keyword>реляционная</SPAN> модели данных.</P>
            <P>Автором <B>реляционной модели</B> считается Э. Кодд, который 
            первым предложил использовать для обработки данных аппарат теории 
            множеств (объединение, пересечение, разность, декартово 
            произведение) и показал, что любое представление данных сводится к 
            совокупности двумерных таблиц особого вида, известного в математике 
            как отношение.</P>
            <P>Таким образом, реляционная <SPAN class=keyword>база данных</SPAN> 
            представляет собой набор таблиц (точно таких же, как приведенная 
            выше), связанных между собой. Строка в таблице соответствует 
            сущности реального мира (в приведенном выше примере это информация о 
            человеке).</P>
            <P>Примеры реляционных <SPAN class=keyword>СУБД</SPAN>: <SPAN 
            class=keyword>MySql</SPAN>, PostgreSql.</P>
            <P>В основу <B>объектной модели</B> положена концепция 
            объектно-ориентированного программирования, в которой данные 
            представляются в виде набора объектов и классов, связанных между 
            собой родственными отношениями, а работа с объектами осуществляется 
            с помощью скрытых (инкапсулированных) в них методов.</P>
            <P>Примеры объектных <SPAN class=keyword>СУБД</SPAN>: Cache, 
            GemStone (от Servio Corporation), ONTOS (ONTOS).</P>
            <P>В последнее время производители <SPAN class=keyword>СУБД</SPAN> 
            стремятся соединить два этих подхода и проповедуют 
            объектно-реляционную модель представления данных. Примеры таких 
            <SPAN class=keyword>СУБД</SPAN> – IBM DB2 for Common Servers, 
            Oracle8.</P>
            <P>Поскольку мы собираемся работать с <SPAN 
            class=keyword>Mysql</SPAN>, то будем обсуждать аспекты работы только 
            с реляционными <SPAN class=keyword>базами данных</SPAN>. Нам 
            осталось рассмотреть еще два важных понятия из этой области: <SPAN 
            class=keyword>ключи</SPAN> и <SPAN 
            class=keyword>индексирование</SPAN>, после чего мы сможем приступить 
            к изучению языка запросов <SPAN class=keyword>SQL</SPAN>.</P>
            <H4>Ключи</H4>
            <P>Для начала давайте подумаем над таким вопросом: какую информацию 
            нужно дать о человеке, чтобы собеседник точно сказал, что это именно 
            тот человек, сомнений быть не может, второго такого нет? Сообщить 
            фамилию, очевидно, недостаточно, поскольку существуют однофамильцы. 
            Если собеседник человек, то мы можем приблизительно объяснить, о ком 
            речь, например вспомнить поступок, который совершил тот человек, или 
            еще как-то. Компьютер же такого объяснения не поймет, ему нужны 
            четкие правила, как определить, о ком идет речь. В системах 
            управления <SPAN class=keyword>базами данных</SPAN> для решения 
            такой задачи ввели понятие <SPAN class=keyword>первичного 
            ключа</SPAN>.</P>
            <P><A name=keyword-context.2></A><SPAN class=keyword_def>Первичный 
            ключ</SPAN> (primary key, PK) – минимальный набор полей, уникально 
            идентифицирующий запись в таблице. Значит, <SPAN 
            class=keyword>первичный ключ</SPAN> – это в первую очередь набор 
            полей таблицы, во-вторых, каждый набор значений этих полей должен 
            определять единственную запись (строку) в таблице и, в-третьих, этот 
            набор полей должен быть минимальным из всех обладающих таким же 
            свойством. Поскольку <SPAN class=keyword>первичный ключ</SPAN> 
            определяет только одну уникальную запись, то никакие две записи 
            таблицы не могут иметь одинаковых значений <SPAN 
            class=keyword>первичного ключа</SPAN>. </P>
            <P>Например, в нашей таблице (<A 
            href="http://www.intuit.ru/department/pl/plphp/10/plphp_10.html#table.10.1">см. 
            выше</A>) ФИО и адрес позволяют однозначно выделить запись о 
            человеке. Если же говорить в общем, без связи с решаемой задачей, то 
            такие знания не позволяют точно указать на единственного человека, 
            поскольку существуют однофамильцы, живущие в разных городах по 
            одному адресу. Все дело в границах, которые мы сами себе задаем. 
            Если считаем, что знания ФИО, телефона и адреса без указания города 
            для наших целей достаточно, то все замечательно, тогда поля ФИО и 
            адрес могут образовывать <SPAN class=keyword>первичный ключ</SPAN>. 
            В любом случае проблема создания <SPAN class=keyword>первичного 
            ключа</SPAN> ложится на плечи того, кто проектирует <SPAN 
            class=keyword>базу данных</SPAN> (разрабатывает структуру хранения 
            данных). Решением этой проблемы может стать либо выделение 
            характеристик, которые естественным образом определяют запись в 
            таблице (задание так называемого логического, или естественного, 
            PK), либо создание дополнительного поля, предназначенного именно для 
            однозначной идентификации записей в таблице (задание так называемого 
            суррогатного, или искусственного, PK). Примером логического <SPAN 
            class=keyword>первичного ключа</SPAN> является номер паспорта в 
            <SPAN class=keyword>базе данных</SPAN> о паспортных данных жителей 
            или ФИО и адрес в телефонной книге (таблица выше). Для задания 
            суррогатного <SPAN class=keyword>первичного ключа</SPAN> в нашу 
            таблицу можно добавить поле id (идентификатор), значением которого 
            будет целое число, уникальное для каждой строки таблицы. 
            Использование таких суррогатных <SPAN class=keyword>ключей</SPAN> 
            имеет смысл, если естественный <SPAN class=keyword>первичный 
            ключ</SPAN> представляет собой большой набор полей или его выделение 
            нетривиально.</P>
            <P>Кроме однозначной идентификации записи, <SPAN 
            class=keyword>первичные ключи</SPAN> используются для организации 
            связей с другими таблицами.</P>
            <P>Например, у нас есть три таблицы: содержащая информацию об 
            исторических личностях (Persons), содержащая информацию об их 
            изобретениях (Artifacts) и содержащая изображения как личностей, так 
            и артефактов (Images) (<A 
            href="http://www.intuit.ru/department/pl/plphp/10/plphp_10.html#image.10.1">рис 
            10.1</A>).</P>
            <P><SPAN class=keyword>Первичным ключом</SPAN> во всех этих таблицах 
            является поле id (идентификатор). В таблице Artifacts есть поле 
            author, в котором записан идентификатор, присвоенный автору 
            изобретения в таблице Persons. Каждое значение этого поля является 
            <B>внешним ключом</B> для <SPAN class=keyword>первичного 
            ключа</SPAN> таблицы Persons. Кроме того, в таблицах Persons и 
            Artifacts есть поле photo, которое ссылается на изображение в 
            таблице Images. Эти поля также являются <SPAN class=keyword>внешними 
            ключами</SPAN> для <SPAN class=keyword>первичного ключа</SPAN> 
            таблицы Images и устанавливают однозначную логическую связь 
            Persons-Images и Artifacts-Images. То есть если значение <SPAN 
            class=keyword>внешнего ключа</SPAN> photo в таблице личности равно 
            10, то это значит, что фотография этой личности имеет id=10 в 
            таблице изображений. Таким образом, <B>внешние ключи</B> 
            используются для организации связей между таблицами <SPAN 
            class=keyword>базы данных</SPAN> (родительскими и дочерними) и для 
            поддержания ограничений ссылочной целостности данных.</P>
            <P align=center><A name=image.10.1></A><IMG height=194 
            alt="Пример использования первичных ключей для организации связей с другими таблицами" 
            src="Базы данных и СУБД. Введение в SQL.files/10-1.gif" 
            width=365><BR><B>Рис. 10.1.</B>&nbsp; Пример использования первичных 
            ключей для организации связей с другими таблицами</P>
            <H4>Индексирование</H4>
            <P>Одна из основных задач, возникающих при работе с <SPAN 
            class=keyword>базами данных</SPAN>, – это задача поиска. При этом, 
            поскольку информации в <SPAN class=keyword>базе данных</SPAN>, как 
            правило, содержится много, перед программистами встает задача не 
            просто поиска, а эффективного поиска, т.е. поиска за сравнительно 
            небольшое время и с достаточной точностью. Для этого (для 
            оптимизации производительности запросов) производят 
            <B>индексирование</B> некоторых полей таблицы. Использовать индексы 
            полезно для быстрого поиска строк с указанным значением одного 
            столбца. Без индекса чтение таблицы осуществляется по всей таблице, 
            начиная с первой записи, пока не будут найдены соответствующие 
            строки. Чем больше таблица, тем больше накладные расходы. Если же 
            таблица содержит индекс по рассматриваемым столбцам, то <SPAN 
            class=keyword>база данных</SPAN> может быстро определить позицию для 
            поиска в середине файла данных без просмотра всех данных. Это 
            происходит потому, что <SPAN class=keyword>база данных</SPAN> 
            помещает проиндексированные поля поближе в памяти, так, чтобы можно 
            было побыстрее найти их значения. Для таблицы, содержащей 1000 
            строк, это будет как минимум в 100 раз быстрее по сравнению с 
            последовательным перебором всех записей. Однако в случае, когда 
            необходим доступ почти ко всем 1000 строкам, быстрее будет 
            последовательное чтение, так как при этом не требуется операций 
            поиска по диску. Так что иногда индексы бывают только помехой. 
            Например, если копируется большой объем данных в таблицу, то лучше 
            не иметь никаких индексов. Однако в некоторых случаях требуется 
            задействовать сразу несколько индексов (например, для обработки 
            запросов к часто используемым таблицам).</P>
            <P>Если говорить о <SPAN class=keyword>MySQL</SPAN>, то там 
            существует три вида индексов: <SPAN class=texample><SPAN 
            class=keyword>PRIMARY</SPAN></SPAN>, <SPAN class=texample><SPAN 
            class=keyword>UNIQUE</SPAN></SPAN>, и <SPAN class=texample><SPAN 
            class=keyword>INDEX</SPAN></SPAN>, а слово ключ (<SPAN 
            class=texample>KEY</SPAN>) используется как синоним слова индекс 
            (<SPAN class=texample><SPAN class=keyword>INDEX</SPAN></SPAN>). Все 
            индексы хранятся в памяти в виде <SPAN 
            class=keyword>B-деревьев</SPAN>.</P>
            <P><A name=keyword-context.3></A><SPAN class=texample><SPAN 
            class=keyword_def>PRIMARY</SPAN></SPAN> – уникальный индекс (ключ) с 
            ограничением, что все индексированные им поля не могут иметь пустого 
            значения (т.е. они <SPAN class=texample>NOT NULL</SPAN>). Таблица 
            может иметь только один первичный индекс, но он может состоять из 
            нескольких полей. </P>
            <P><A name=keyword-context.4></A><SPAN class=texample><SPAN 
            class=keyword_def>UNIQUE</SPAN></SPAN> – ключ (индекс), задающий 
            поля, которые могут иметь только уникальные значения. </P>
            <P><A name=keyword-context.5></A><SPAN class=texample><SPAN 
            class=keyword_def>INDEX</SPAN></SPAN> – обычный индекс (как мы 
            описали выше). В <SPAN class=keyword>MySqL</SPAN>, кроме того, можно 
            индексировать строковые поля по заданному числу символов от начала 
            строки. </P>
            <H3>СУБД MySQL</H3>
            <P>Продолжим разговор о <SPAN class=keyword>СУБД</SPAN> <SPAN 
            class=keyword>MySQL</SPAN>. <A name=keyword-context.6></A><SPAN 
            class=keyword_def>MySQL</SPAN> – это реляционная система управления 
            <SPAN class=keyword>базами данных</SPAN>. То есть данные в ее базах 
            хранятся в виде логически связанных между собой таблиц, доступ к 
            которым осуществляется с помощью языка запросов <SPAN 
            class=keyword>SQL</SPAN>. <SPAN class=keyword>MySQL</SPAN> – 
            свободно распространяемая система, т.е. платить за ее применение не 
            нужно. Кроме того, это достаточно быстрая, надежная и, главное, 
            простая в использовании <SPAN class=keyword>СУБД</SPAN>, вполне 
            подходящая для не слишком глобальных проектов.</P>
            <P><A name=keyword-context.7></A>Работать с <SPAN 
            class=keyword>MySQL</SPAN> можно не только в текстовом режиме, но и 
            в графическом. Существует очень популярный визуальный интерфейс 
            (кстати, написанный на PHP) для работы с этой <SPAN 
            class=keyword>СУБД</SPAN>. Называется он <SPAN 
            class=keyword_def>PhpMyAdmin</SPAN>. Этот интерфейс позволяет 
            значительно упростить работу с <SPAN class=keyword>базами 
            данных</SPAN> в <SPAN class=keyword>MySQL</SPAN>. </P>
            <P>В текстовом режиме работа с <SPAN class=keyword>базой 
            данных</SPAN> выглядит просто как ввод команд в командную строку (<A 
            href="http://www.intuit.ru/department/pl/plphp/10/plphp_10.html#image.10.2">рис 
            10.2</A>), а результаты выборок возвращаются в виде своеобразных 
            таблиц, поля в которых налезают друг на друга, если данные не 
            помещаются на экран (<A 
            href="http://www.intuit.ru/department/pl/plphp/10/plphp_10.html#image.10.3">рис 
            10.3</A>).</P>
            <P align=center><A name=image.10.2></A><IMG height=17 
            alt="Работа с MySQL в коммандной строке. Команда show databases — вывести все имеющиеся базы данных" 
            src="Базы данных и СУБД. Введение в SQL.files/10-2.gif" 
            width=147><BR><B>Рис. 10.2.</B>&nbsp; Работа с MySQL в коммандной 
            строке. Команда show databases — вывести все имеющиеся базы 
            данных</P>
            <P><SPAN class=keyword>PhpMyAdmin</SPAN> позволяет пользоваться 
            всеми достоинствами браузера, включая прокрутку изображения, если 
            оно не умещается на экран. Многие из базовых <SPAN 
            class=keyword>SQL</SPAN>-функций работы с данными в <SPAN 
            class=keyword>PhpMyAdmin</SPAN> сведены к интуитивно понятным 
            интерфейсам и действиям, напоминающим переход по ссылкам в Internet. 
            Но тем не менее стоит все же поработать и в текстовом режиме.</P>
            <P align=center><A name=image.10.3></A><IMG height=131 
            alt="Работа с MySQL в коммандной строке. Результат обработки команды show databases" 
            src="Базы данных и СУБД. Введение в SQL.files/10-3.gif" 
            width=198><BR><B>Рис. 10.3.</B>&nbsp; Работа с MySQL в коммандной 
            строке. Результат обработки команды show databases</P>
            <P>Перед тем как переходить к детальному изучению языка <SPAN 
            class=keyword>SQL</SPAN>, несколько слов об установке <SPAN 
            class=keyword>MySQL</SPAN> и подготовке к работе. Если вы не 
            собираетесь заниматься администрированием сервера, то информация, 
            приведенная ниже, пригодится вам только для общего развития. Итак, 
            устанавливается <SPAN class=keyword>MySQL</SPAN> очень просто – 
            автоматически, пару раз нажмите OK, и все. После этого вы можете 
            зайти в директорию, где лежат файлы типа <SPAN 
            class=texample>mysql.exe</SPAN>, <SPAN 
            class=texample>mysqld.exe</SPAN> и т.п. (у нас под Windows XP это 
            <SPAN class=texample>c:\mysql\bin</SPAN>) Последний файл запускает 
            Mysql-сервер. В некоторых системах сервер запускается в виде 
            сервиса. После запуска сервера следует запустить mysql-клиент, 
            запустив программу <SPAN class=texample>mysql.exe</SPAN>. Здесь даже 
            пароля не спросят. Более того, если вы наберете</P>
            <DIV class=example><PRE>shell&gt; mysql.exe -u root
</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>shell&gt;mysql -u root mysql</PRE></DIV>
            <P>то получите все права администратора mysql сервера. Кстати, 
            выполнять эти команды надо, находясь в той директории, где лежат 
            файлы <SPAN class=texample>mysql.exe</SPAN>.</P>
            <P>Для начала, не вдаваясь в подробности команд, исправим эти два 
            недочета (отсутствие пароля у администратора и возможность входа 
            анонимным пользователям):</P>
            <DIV class=example><PRE>shell&gt; mysql -u root mysql
mysql&gt; UPDATE user SET Password=PASSWORD('new_password')
    WHERE user='root';
mysql&gt; DELETE FROM user WHERE user='';
mysql&gt; FLUSH PRIVILEGES;
</PRE></DIV>
            <P>Все данные о пользователях <SPAN class=keyword>MySQL</SPAN> 
            хранит в таблице <SPAN class=texample>user</SPAN> в специальной 
            <SPAN class=keyword>базе данных</SPAN> mysql, доступ к которой имеет 
            только администратор сервера. Поэтому, чтобы изменить какой-либо 
            пароль, нужно изменить эту таблицу. Пароль задается с помощью 
            функции <SPAN class=texample>PASSWORD</SPAN>, которая кодирует 
            введенные данные. Кроме изменения пароля администратора, нужно еще 
            удалить всех пользователей, не имеющих логина (команда <SPAN 
            class=texample><SPAN class=keyword>DELETE</SPAN></SPAN>). Команда 
            <SPAN class=texample>Flush Privileges</SPAN> заставляет вступить в 
            действие изменения, произошедшие в системной <SPAN 
            class=keyword>базе данных</SPAN> (mysql).</P>
            <P>Теперь создадим <SPAN class=keyword>базу данных</SPAN>, с которой 
            будем работать (мы все еще работаем как администратор сервера):</P>
            <DIV class=example><PRE>mysql&gt;create database book;
</PRE></DIV>
            <P>Как можно заметить, все команды в <SPAN 
            class=keyword>MySQL</SPAN> заканчиваются точкой с запятой. Если вы 
            забыли поставить этот знак, то выдается приглашение его поставить до 
            тех пор, пока это не будет сделано:</P>
            <DIV class=example><PRE>mysql&gt; show tables
    -&gt;
    -&gt;
</PRE></DIV>
            <P>Теперь последнее действие – создадим простого пользователя, 
            предоставим ему доступ к созданной <SPAN class=keyword>базе 
            данных</SPAN>, и начнем работать.</P>
            <DIV class=example><PRE>mysql&gt; GRANT ALL PRIVILEGES ON book.* TO nina@localhost 
    IDENTIFIED BY '123';
</PRE></DIV>
            <P>Команда <SPAN class=texample>GRANT</SPAN> наделяет пользователя 
            nina, зашедшего на сервер с этой же машины (c localhost) и 
            идентифицируемого паролем <SPAN class=texample>«123»</SPAN>, 
            определенными правами (в данном случае всеми) на все таблицы <SPAN 
            class=keyword>базы данных</SPAN> <SPAN class=texample>book</SPAN>. 
            Теперь мы можем выйти и зайти как пользователь <SPAN 
            class=texample>nina</SPAN> с соответствующим паролем:</P>
            <DIV class=example><PRE>shell&gt;mysql -u nina -p
Enter password: *** 
Welcome to the MySQL monitor!...
mysql&gt;
</PRE></DIV>
            <P>Если вы собираетесь пользоваться <SPAN class=keyword>базой 
            данных</SPAN> на чужом сервере, то его администратор проделает все 
            описанные выше действия за вас, т.е. все настроит и создаст 
            пользователя и <SPAN class=keyword>базу данных</SPAN>. В следующей 
            главе описаны команды языка <SPAN class=keyword>SQL</SPAN>, которые 
            пригодятся для работы с данными, хранящимися в <SPAN 
            class=keyword>СУБД</SPAN> <SPAN class=keyword>MySQL</SPAN>.</P>
            <H3>Язык SQL</H3>
            <P>Итак, мы в общих чертах познакомились с основными понятиями 
            теории <SPAN class=keyword>баз данных</SPAN>, установили и настроили 
            для работы <SPAN class=keyword>MySQL</SPAN>. Теперь самое время 
            научиться манипулировать данными, хранящимися в <SPAN 
            class=keyword>базах данных</SPAN>. Для этого нам понадобится <A 
            name=keyword-context.8></A><SPAN class=keyword_def>SQL</SPAN> – 
            структурированный язык запросов. Этот язык дает возможность 
            создавать, редактировать и удалять информацию, хранящуюся в <SPAN 
            class=keyword>базах данных</SPAN>, создавать новые <SPAN 
            class=keyword>базы данных</SPAN> и многое другое. <SPAN 
            class=keyword>SQL</SPAN> является стандартом ANSI (Американский 
            национальный институт стандартов) и ISO (Международная организация 
            по стандартизации). </P>
            <H4>Немного истории</H4>
            <P>Первый международный стандарт языка <SPAN 
            class=keyword>SQL</SPAN> был принят в 1989 г., его часто называют 
            <SPAN class=keyword>SQL/89</SPAN>. Среди недостатков этого стандарта 
            выделяют в первую очередь то, что многие важные свойства он 
            устанавливал как определяемые в реализации. Отсюда произошло 
            множество расхождений в реализациях языка разными производителями. 
            Кроме того, высказывались претензии по поводу отсутствия в этом 
            стандарте упоминаний о практических аспектах языка, таких как его 
            встраивание в язык программирования Си.</P>
            <P>Следующий международный стандарт языка <SPAN 
            class=keyword>SQL</SPAN> был принят в конце 1992 г. И стал 
            называться <SPAN class=keyword>SQL/92</SPAN>. Он получился гораздо 
            более точным и полным, чем <SPAN class=keyword>SQL/89</SPAN>, хотя и 
            не был лишен недостатков. В настоящее время большинство систем почти 
            полностью реализуют этот стандарт. Однако, как известно, прогресс не 
            остановишь, и в 1999 году появился новый стандарт <SPAN 
            class=keyword>SQL</SPAN>:1999, также известный как SQL3. SQL3 
            характеризуется как «объектно-ориентированный <SPAN 
            class=keyword>SQL</SPAN>» и является основой нескольких 
            объектно-реляционных систем управления <SPAN class=keyword>базами 
            данных</SPAN> (например, ORACLE8 компании Oracle, Universal Server 
            компании Informix и DB2 Universal Database компании IBM). Этот 
            стандарт является не просто слиянием SQL-92 и объектной технологии. 
            Он содержит ряд расширений традиционного <SPAN 
            class=keyword>SQL</SPAN>, а сам документ составлен таким образом, 
            чтобы добиться более эффективной работы в области стандартизации в 
            будущем.</P>
            <P>Если говорить о <SPAN class=keyword>MySQL</SPAN>, то она 
            соответствует начальному уровню SQL92, содержит несколько расширений 
            этого стандарта и стремится к полной поддержке стандарта ANSI SQL99, 
            но без ущерба для скорости и качества кода.</P>
            <P>Далее, говоря об основах языка <SPAN class=keyword>SQL</SPAN>, 
            будем придерживаться его реализации в <SPAN 
            class=keyword>СУБД</SPAN> <SPAN class=keyword>MySQL</SPAN>.</P>
            <H4>Основные операторы языка SQL</H4>
            <P>Функции любой <SPAN class=keyword>СУБД</SPAN> включают:</P>
            <OL>
              <LI>создание, удаление, изменение <SPAN class=keyword>базы 
              данных</SPAN> (БД);
              <LI>добавление, изменение, удаление, назначение прав пользователя;
              <LI>внесение, удаление и изменение данных в БД (таблиц и записей);
              <LI>выборку данных из БД.</LI></OL>
            <P>К первым двум функциям имеют доступ только администраторы <SPAN 
            class=keyword>СУБД</SPAN> или привилегированные пользователи. 
            Рассмотрим, как решаются последние две задачи (на самом деле это 
            семь задач).</P>
            <P>Прежде чем что-либо делать с данными, нужно создать таблицы, в 
            которых эти данные будут храниться, научиться изменять структуру 
            этих таблиц и удалять их, если потребуется. Для этого в языке <SPAN 
            class=keyword>SQL</SPAN> существуют операторы <SPAN 
            class=texample><SPAN class=keyword>CREATE TABLE</SPAN></SPAN>, <SPAN 
            class=texample><SPAN class=keyword>ALTER TABLE</SPAN></SPAN> и <SPAN 
            class=texample><SPAN class=keyword>DROP TABLE</SPAN></SPAN>.</P>
            <H5>Оператор CREATE TABLE</H5>
            <P><A name=keyword-context.9></A>Оператор <SPAN class=texample><SPAN 
            class=keyword_def>CREATE TABLE</SPAN></SPAN> создает таблицу с 
            заданным именем в текущей <SPAN class=keyword>базе данных</SPAN>. 
            Правила для допустимых имен таблицы приведены в документации. Если 
            нет активной текущей <SPAN class=keyword>базы данных</SPAN> или 
            указанная таблица уже существует, то возникает ошибка выполнения 
            команды.</P>
            <P>В версии <SPAN class=keyword>MySQL</SPAN> 3.22 и более поздних 
            имя таблицы может быть указано как <SPAN 
            class=texample>имя_базы_данных.имя_таблицы</SPAN>. Эта форма записи 
            работает независимо от того, является ли указанная <SPAN 
            class=keyword>база данных</SPAN> текущей.</P>
            <P>В версии <SPAN class=keyword>MySQL</SPAN> 3.23 при создании 
            таблицы можно использовать ключевое слово <SPAN 
            class=texample>TEMPORARY</SPAN>. Временная таблица автоматически 
            удаляется по завершении соединения, а ее имя действительно только в 
            течение данного соединения. Это означает, что в двух разных 
            соединениях могут использоваться временные таблицы с одинаковыми 
            именами без конфликта друг с другом или с существующей таблицей с 
            тем же именем (существующая таблица скрыта, пока не удалена 
            временная таблица). В версии <SPAN class=keyword>MySQL</SPAN> 4.0.2 
            для создания временных таблиц необходимо иметь привилегии <SPAN 
            class=texample>CREATE TEMPORARY TABLES</SPAN>.</P>
            <P>В версии <SPAN class=keyword>MySQL</SPAN> 3.23 и более поздних 
            можно использовать ключевые слова <SPAN class=texample>IF NOT 
            EXISTS</SPAN> для того, чтобы не возникала ошибка, если указанная 
            таблица уже существует. Следует учитывать, что при этом идентичность 
            структур этих таблиц не проверяется.</P>
            <P>Каждая таблица представлена набором определенных файлов в 
            директории <SPAN class=keyword>базы данных</SPAN>. </P>
            <P>Синтаксис</P>
            <DIV class=example><PRE>CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
     имя_таблицы [(определение_столбца,...)]
    [опции_таблицы] [select_выражение]
</PRE></DIV>
            <P>В выражении <SPAN class=texample>определение_столбца</SPAN> 
            перечисляют, какие столбцы должны быть созданы в таблице. Каждый 
            столбец таблицы может быть пустым (<SPAN 
            class=texample>NULL</SPAN>), иметь значение по умолчанию, являться 
            ключом или автоинкрементом. Кроме того, для каждого столбца 
            обязательно указывается тип данных, которые будут в нем храниться. 
            Если не указывается ни <SPAN class=texample>NULL</SPAN>, ни <SPAN 
            class=texample>NOT NULL</SPAN>, то столбец интерпретируется так, как 
            будто указано <SPAN class=texample>NULL</SPAN>. Если поле помечают 
            как автоинкремент (<SPAN class=texample>AUTO_INCREMENT</SPAN>), то 
            его значение автоматически увеличивается на единицу каждый раз, 
            когда происходит добавление данных в таблицу и в это поле 
            записывается пустое значение (<SPAN class=texample>NULL</SPAN>, т.е. 
            ничего не записывается) или <SPAN class=texample>0</SPAN>. 
            Автоинкремент в таблице может быть только один, и при этом он 
            обязательно должен быть проиндексирован. Последовательность <SPAN 
            class=texample>AUTO_INCREMENT</SPAN> начинается с <SPAN 
            class=texample>1</SPAN>. Наличие автоинкремента является одной из 
            особенностей <SPAN class=keyword>MySQL</SPAN>. Формально описание 
            столбца (определение_столбца) выглядит так:</P>
            <DIV class=example><PRE>имя_столбца тип [NOT NULL | NULL] 
    [DEFAULT значение_по_умолчанию]
    [AUTO_INCREMENT][PRIMARY KEY] 
    [reference_definition]
</PRE></DIV>
            <P>Тип столбца (тип в выражении определение_столбца) может быть 
            одним из следующих:</P>
            <UL>
              <LI>целый: <SPAN class=texample>INT[(length)] [UNSIGNED] 
              [ZEROFILL]</SPAN>
              <LI>действительный: <SPAN class=texample>REAL[(length,decimals)] 
              [UNSIGNED] [ZEROFILL]</SPAN>
              <LI>символьный: <SPAN class=texample>CHAR(length) [BINARY]</SPAN> 
              и <SPAN class=texample>VARCHAR(length) [BINARY]</SPAN>
              <LI>дата и время: <SPAN class=texample>DATE</SPAN> и <SPAN 
              class=texample>TIME</SPAN>
              <LI>для работы с большими объектами: <SPAN 
              class=texample>BLOB</SPAN>
              <LI>текстовый: <SPAN class=texample>TEXT</SPAN>
              <LI>перечислимое множество: <SPAN 
              class=texample>ENUM(value1,value2,value3,...)</SPAN> и <SPAN 
              class=texample>SET(value1,value2,value3,...)</SPAN></LI></UL>
            <P>Полный список типов смотрите в документации <SPAN 
            class=keyword>MySQL</SPAN>.</P>
            <P>Вместо перечисления столбцов и их свойств в <SPAN 
            class=texample>определении_столбца</SPAN> можно задавать списки 
            ключевых и индексных полей, ограничения и проверки:</P>
            <DIV class=example><PRE>PRIMARY KEY (имя_индексируемого_столбца, ...)</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>KEY [имя_индекса] (имя_индексируемого_столбца,...)</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>INDEX [имя_индекса] (имя_индексируемого_столбца,...)</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>UNIQUE [INDEX] [имя_индекса] 
    (имя_индексируемого_столбца,...)</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>FULLTEXT [INDEX] [имя_индекса] 
    (имя_индексируемого_столбца,...)</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>[CONSTRAINT symbol] 
FOREIGN KEY [имя_индекса] 
    (имя_индексируемого_столбца,...) 
[reference_definition]</PRE></DIV>
            <P>или</P>
            <DIV class=example><PRE>CHECK (expr)</PRE></DIV>
            <P>При задании всех этих элементов указывается список полей 
            (столбцов), которые будут входить в индекс, ключ или ограничение, 
            <SPAN class=texample>имя_индексируемого_столбца</SPAN> записывается 
            следующим образом:</P>
            <DIV class=example><PRE>имя_столбца [(длина_индекса)]
</PRE></DIV>
            <P><SPAN class=texample>FOREIGN KEY</SPAN>, <SPAN 
            class=texample>CHECK</SPAN> и <SPAN class=texample>REFERENCES</SPAN> 
            на самом деле ничего не делают в <SPAN class=keyword>MySQL</SPAN>. 
            Они добавлены только для совместимости с другими SQL-серверами. 
            Поэтому на них мы останавливаться не будем.</P>
            <P>Кроме всего перечисленного, при создании таблицы можно указать 
            некоторые ее свойства (опции_таблицы), например такие:</P>
            <UL>
              <LI>тип таблицы: <SPAN class=texample>TYPE = {BDB | HEAP | ISAM | 
              InnoDB | MERGE | MRG_MYISAM | MYISAM }</SPAN>
              <LI>начальное значение счетчика автоинкремента: <SPAN 
              class=texample>AUTO_INCREMENT = число</SPAN>
              <LI>средняя длина строк в таблице: <SPAN 
              class=texample>AVG_ROW_LENGTH = число</SPAN>
              <LI>комментарии к таблице (строка из 60 символов): <SPAN 
              class=texample>COMMENT = "строка"</SPAN>
              <LI>максимальное и минимальное предполагаемое число строк: <SPAN 
              class=texample>MAX_ROWS = число</SPAN> и <SPAN 
              class=texample>MIN_ROWS = число</SPAN></LI></UL>
            <P>И последний (опять же опциональный) элемент команды <SPAN 
            class=texample>CREATE</SPAN> – это выражение <SPAN 
            class=texample><SPAN class=keyword>SELECT</SPAN> 
            (select_выражение)</SPAN>. Синтаксис такой:</P>
            <DIV class=example><PRE>[IGNORE | REPLACE] SELECT ... 
    (любое корректное выражение SELECT)
</PRE></DIV>
            <P>Если при создании таблицы в команде <SPAN 
            class=texample>CREATE</SPAN> указывается выражение <SPAN 
            class=texample><SPAN class=keyword>SELECT</SPAN></SPAN>, то все 
            поля, полученные выборкой, добавляются в создаваемую таблицу.</P>
            <P><B>Пример 10.1</B>. Создадим таблицу <SPAN 
            class=texample>Persons</SPAN>, структура которой была приведена на 
            <A 
            href="http://www.intuit.ru/department/pl/plphp/10/1.html#image.10.1">рисунке 
            10.1</A>.</P><A name=example.10.1></A>
            <DIV class=example><PRE>mysql&gt;CREATE TABLE Persons 
    (id INT PRIMARY KEY AUTO_INCREMENT,
   first_name VARCHAR(50), last_name 
    VARCHAR(100), death_date INT, 
   description TEXT, photo INT, 
   citienship CHAR(50) DEFAULT 'Russia');
</PRE><SPAN class=objectName>Пример 10.1. Создание таблицы 
            Persons</SPAN></DIV>
            <P>С помощью специфичной для <SPAN class=keyword>MySql</SPAN> 
            команды <SPAN class=texample>SHOW</SPAN> можно просмотреть 
            существующие <SPAN class=keyword>базы данных</SPAN>, таблицы в <SPAN 
            class=keyword>базе данных</SPAN> и поля в таблице.</P>
            <P>Показать все <SPAN class=keyword>базы данных</SPAN>:</P>
            <DIV class=example><PRE>mysql&gt;SHOW databases;
</PRE></DIV>
            <P>Сделать текущей <SPAN class=keyword>базу данных</SPAN> <SPAN 
            class=texample>book</SPAN> и показать все таблицы в ней:</P>
            <DIV class=example><PRE>mysql&gt;use book;
mysql&gt;show tables;
</PRE></DIV>
            <P>Показать все столбцы в таблице <SPAN 
            class=texample>Persons</SPAN>:</P>
            <DIV class=example><PRE>mysql&gt; show columns from Persons;
</PRE></DIV>
            <H5>Оператор DROP TABLE</H5>
            <P><A name=keyword-context.10></A>Оператор <SPAN 
            class=texample><SPAN class=keyword_def>DROP TABLE</SPAN></SPAN> 
            удаляет одну или несколько таблиц. Все табличные данные и 
            определения удаляются, так что при работе с этой командой следует 
            соблюдать осторожность. </P>
            <P>Синтаксис:</P>
            <DIV class=example><PRE>DROP TABLE [IF EXISTS] имя_таблицы 
    [, имя_таблицы,...] 
    [RESTRICT | CASCADE]
</PRE></DIV>
            <P>В версии <SPAN class=keyword>MySQL</SPAN> 3.22 и более поздних 
            можно использовать ключевые слова <SPAN class=texample>IF 
            EXISTS</SPAN>, чтобы предупредить ошибку, если указанные таблицы не 
            существуют.</P>
            <P>Опции <SPAN class=texample>RESTRICT</SPAN> и <SPAN 
            class=texample>CASCADE</SPAN> позволяют упростить перенос программы 
            с других <SPAN class=keyword>СУБД</SPAN>. В данный момент они не 
            задействованы. </P><A name=example.10.2></A>
            <DIV class=example><PRE>mysql&gt; DROP TABLE IF EXISTS Persons,
       Artifacts, test;
</PRE><SPAN class=objectName>Пример 10.2. Использование оператора 
            DROP TABLE </SPAN></DIV>
            <H5>Оператор ALTER TABLE</H5>
            <P><A name=keyword-context.11></A>Оператор <SPAN 
            class=texample><SPAN class=keyword_def>ALTER TABLE</SPAN></SPAN> 
            обеспечивает возможность изменять структуру существующей таблицы. 
            Например, можно добавлять или удалять столбцы, создавать или 
            уничтожать индексы или переименовывать столбцы либо саму таблицу. 
            Можно также изменять комментарий для таблицы и ее тип. </P>
            <P>Синтаксис:</P>
            <DIV class=example><PRE>ALTER [IGNORE] TABLE имя_таблицы 
    alter_specification 
    [, alter_specification ...]
</PRE></DIV>
            <P>Можно производить следующие изменения в таблице (все они 
            записываются в <SPAN class=texample>alter_specification</SPAN>):</P>
            <UL>
              <LI>добавление поля: 
              <DIV class=example><PRE>    ADD [COLUMN] определение_столбца 
[FIRST | AFTER имя_столбца ]
</PRE></DIV>
              <P>или</P>
              <DIV class=example><PRE>ADD [COLUMN] (определение_столбца, 
    определение_столбца,...)</PRE></DIV></LI></UL>
            <P>Здесь, как и далее, определение_столбца записывается так же, как 
            при создании таблицы.</P>
            <UL>
              <LI>добавление индексов: 
              <P><SPAN class=texample>ADD <SPAN class=keyword>INDEX</SPAN> 
              [имя_индекса] (имя_индексируемого_столбца,...)</SPAN> или <SPAN 
              class=texample>ADD <SPAN class=keyword>PRIMARY</SPAN> KEY 
              (имя_индексируемого_столбца,...)</SPAN> или <SPAN 
              class=texample>ADD <SPAN class=keyword>UNIQUE</SPAN> [имя_индекса] 
              (имя_индексируемого_столбца,...)</SPAN> или <SPAN 
              class=texample>ADD FULLTEXT [имя_индекса] 
              (имя_индексируемого_столбца,...)</SPAN></P>
              <LI>изменение поля: 
              <P><SPAN class=texample>ALTER [COLUMN] имя_столбца {SET DEFAULT 
              literal | DROP DEFAULT}</SPAN> или <SPAN class=texample>CHANGE 
              [COLUMN] старое_имя_столбца определение_столбца</SPAN> или <SPAN 
              class=texample>MODIFY [COLUMN] определение_столбца</SPAN></P>
              <LI>удаление поля, индекса, ключа: 
              <DIV class=example><PRE>   DROP [COLUMN] имя_столбца
    DROP PRIMARY KEY
    DROP INDEX имя_индекса
</PRE></DIV>
              <LI>переименование таблицы: 
              <P><SPAN class=texample>RENAME [TO] новое_имя_таблицы</SPAN></P>
              <LI>переупорядочение полей таблицы: 
              <DIV class=example><PRE>ORDER BY поле</PRE></DIV>
              <P>или</P>
              <DIV class=example><PRE>опции_таблицы</PRE></DIV></LI></UL>
            <P>Если оператор <SPAN class=texample><SPAN class=keyword>ALTER 
            TABLE</SPAN></SPAN> используется для изменения определения типа 
            столбца, но <SPAN class=texample>DESCRIBE имя_таблицы</SPAN> 
            показывает, что столбец не изменился, то, возможно, <SPAN 
            class=keyword>MySQL</SPAN> игнорирует данную модификацию по одной из 
            причин, описанных в специальном разделе документации. Например, при 
            попытке изменить столбец <SPAN class=texample>VARCHAR</SPAN> на 
            <SPAN class=texample>CHAR</SPAN> <SPAN class=keyword>MySQL</SPAN> 
            будет продолжать использовать <SPAN class=texample>VARCHAR</SPAN>, 
            если данная таблица содержит другие столбцы с переменной длиной.</P>
            <P>Оператор <SPAN class=texample><SPAN class=keyword>ALTER 
            TABLE</SPAN></SPAN> во время работы создает временную копию исходной 
            таблицы. Требуемое изменение выполняется на копии, затем исходная 
            таблица удаляется, а новая переименовывается. Это делается для того, 
            чтобы в новую таблицу автоматически попадали все обновления, кроме 
            неудавшихся. Во время выполнения <SPAN class=texample><SPAN 
            class=keyword>ALTER TABLE</SPAN></SPAN> исходная таблица доступна 
            для чтения другими клиентами. Операции обновления и записи в этой 
            таблице приостанавливаются, пока не будет готова новая таблица. 
            Следует отметить, что при использовании любой другой опции для <SPAN 
            class=texample>ALTER TABLE</SPAN>, кроме <SPAN 
            class=texample>RENAME</SPAN>, <SPAN class=keyword>MySQL</SPAN> 
            всегда будет создавать временную таблицу, даже если данные, строго 
            говоря, и не нуждаются в копировании (например, при изменении имени 
            столбца).</P>
            <P><B>Пример10.3</B>. Добавим в созданную таблицу <SPAN 
            class=texample>Persons</SPAN> поле для записи года рождения 
            человека:</P><A name=example.10.3></A>
            <DIV class=example><PRE>mysql&gt; ALTER TABLE Persons 
    ADD bday INTEGER AFTER last_name;
</PRE><SPAN class=objectName>Пример 10.3. Добавление в таблицу 
            Persons поля для записи года рождения человека</SPAN></DIV>
            <P>Итак, мы научились работать с таблицами: создавать, удалять и 
            изменять их. Теперь разберемся, как делать то же самое с данными, 
            которые в этих таблицах хранятся.</P>
            <H5>Оператор SELECT</H5>
            <P><A name=keyword-context.12></A>Оператор <SPAN 
            class=texample><SPAN class=keyword_def>SELECT</SPAN></SPAN> 
            применяется для извлечения строк, выбранных из одной или нескольких 
            таблиц. То есть с его помощью мы задаем столбцы или выражения, 
            которые надо извлечь (<SPAN class=texample>select_выражения</SPAN>), 
            таблицы (<SPAN class=texample>table_references</SPAN>), из которых 
            должна производиться выборка, и, возможно, условие (<SPAN 
            class=texample>where_definition</SPAN>), которому должны 
            соответствовать данные в этих столбцах, и порядок, в котором эти 
            данные нужно выдать. </P>
            <P>Кроме того, оператор <SPAN class=texample><SPAN 
            class=keyword>SELECT</SPAN></SPAN> можно использовать для извлечения 
            строк, вычисленных без ссылки на какую-либо таблицу. Например, чтобы 
            вычислить, чему равно <SPAN class=texample>2*2</SPAN>, нужно просто 
            написать</P>
            <DIV class=example><PRE>mysql&gt; SELECT 2*2;
</PRE></DIV>
            <P>Упрощенно структуру оператора <SPAN class=texample><SPAN 
            class=keyword>SELECT</SPAN></SPAN> можно представить следующим 
            образом: </P>
            <DIV class=example><PRE>SELECT select_выражение1, select_выражение2,
    ...
    [FROM table_references
        [WHERE where_definition]
        [ORDER BY {число | имя_столбца |
                 формула}
            [ASC | DESC], ...]]
</PRE></DIV>
            <P>Квадратные скобки <SPAN class=texample>[ ]</SPAN> означают, что 
            использование находящегося в них оператора необязательно, 
            вертикальная черта <SPAN class=texample>|</SPAN> означает 
            перечисление возможных вариантов. После ключевого слова <SPAN 
            class=texample>ORDER BY</SPAN> указывают имя столбца, число (целое 
            беззнаковое) или формулу и способ упорядочения (по возрастанию – 
            <SPAN class=texample>ASC</SPAN>, или по убыванию – <SPAN 
            class=texample>DESC</SPAN>). По умолчанию используется упорядочение 
            по возрастанию.</P>
            <P>Когда в select_выражении мы пишем «<SPAN 
            class=texample>*</SPAN>», это значит выбрать все столбцы. Кроме 
            «<SPAN class=texample>*</SPAN>» в <SPAN 
            class=texample>select_выражения</SPAN> могут использоваться функции 
            типа <SPAN class=texample>max</SPAN>, <SPAN 
            class=texample>min</SPAN> и <SPAN class=texample>avg</SPAN>.</P>
            <P><B>Пример 10.4</B>. Выбрать из таблицы <SPAN 
            class=texample>Persons</SPAN> все данные, для которых поле <SPAN 
            class=texample>first_name</SPAN> имеет значение <SPAN 
            class=texample>'Александр'</SPAN>:</P><A name=example.10.4></A>
            <DIV class=example><PRE>mysql&gt; SELECT * FROM Persons 
       WHERE first_name='Александр';
</PRE><SPAN class=objectName>Пример 10.4. Использование оператора 
            SELECT </SPAN></DIV>
            <P>Выбрать название и описание (<SPAN class=texample>title</SPAN>, 
            <SPAN class=texample>description</SPAN>) артефакта под номером 
            10:</P>
            <DIV class=example><PRE>mysql&gt; SELECT title,description 
     FROM Artifacts WHERE id=10;
</PRE></DIV>
            <H5>Оператор INSERT</H5>
            <P><A name=keyword-context.13></A>Оператор <SPAN 
            class=texample><SPAN class=keyword_def>INSERT</SPAN></SPAN> 
            вставляет новые строки в существующую таблицу. Оператор имеет 
            несколько форм. Параметр <SPAN class=texample>имя_таблицы</SPAN> во 
            всех этих формах задает таблицу, в которую должны быть внесены 
            строки. Столбцы, для которых задаются значения, указываются в списке 
            имен столбцов (<SPAN class=texample>имя_столбца</SPAN>) или в части 
            <SPAN class=texample>SET</SPAN>.</P>
            <P>Синтаксис:</P>
            <OL>
              <LI>
              <DIV class=example><PRE>INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
    [INTO] имя_таблицы [(имя_столбца,...)]
    VALUES (выражение,...),(...),...
</PRE></DIV>
              <P>Эта форма команды <SPAN class=texample><SPAN 
              class=keyword>INSERT</SPAN></SPAN> вставляет строки в соответствии 
              с точно указанными в команде значениями. В скобках после имени 
              таблицы перечисляются столбцы, а после ключевого слова <SPAN 
              class=texample>VALUES</SPAN> – их значения.</P>
              <P>Например:</P>
              <DIV class=example><PRE>mysql&gt; INSERT INTO Persons 
    (last_name, bday) VALUES 
    ('Иванов', '1934');
</PRE></DIV>
              <P>вставит в таблицу <SPAN class=texample>Persons</SPAN> строку, в 
              которой значения фамилии (<SPAN class=texample>last_name</SPAN>) и 
              даты рождения (<SPAN class=texample>bday</SPAN>) будут заданы 
              соответственно как «Иванов» и «1934».</P>
              <LI>
              <DIV class=example><PRE>INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
    [INTO] имя_таблицы [(имя_столбца,...)]
    SELECT ...
</PRE></DIV>
              <P>Эта форма команды <SPAN class=texample><SPAN 
              class=keyword>INSERT</SPAN></SPAN> вставляет строки, выбранные из 
              другой таблицы или таблиц.</P>
              <P>Например: </P>
              <DIV class=example><PRE>mysql&gt; INSERT INTO Artifacts (author)
       SELECT id FROM Persons 
          WHERE last_name='Иванов' 
            AND bday='1934'; 
</PRE></DIV>
              <P>вставит в таблицу <SPAN class=texample>Artifacts</SPAN> в поле 
              «автор» (<SPAN class=texample>author</SPAN>) значение 
              идентификатора, выбранного из таблицы <SPAN 
              class=texample>Persons</SPAN> по условию, что фамилия человека 
              Иванов.</P>
              <LI>
              <DIV class=example><PRE>INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
    [INTO] имя_таблицы
    SET имя_столбца=выражение, 
       имя_столбца=выражение, ...
</PRE></DIV>
              <P>Например: </P>
              <DIV class=example><PRE>mysql&gt; INSERT INTO Persons 
          SET last_name='Петров',
              first_name='Иван';
</PRE></DIV>
              <P>Эта команда вставит в таблицу <SPAN 
              class=texample>Persons</SPAN> в поле <SPAN 
              class=texample>last_name</SPAN> значение «Петров», а в поле <SPAN 
              class=texample>first_name</SPAN> – строку «Иван».</P></LI></OL>
            <P>Форма <SPAN class=texample><SPAN class=keyword>INSERT</SPAN> ... 
            VALUES</SPAN> со списком из нескольких значений поддерживается в 
            версии <SPAN class=keyword>MySQL</SPAN> 3.22.5 и более поздних. 
            Синтаксис выражения <SPAN 
            class=texample>имя_столбца=выражение</SPAN> поддерживается в версии 
            <SPAN class=keyword>MySQL</SPAN> 3.22.10 и более поздних.</P>
            <P>Действуют следующие соглашения.</P>
            <UL>
              <LI>Если не указан список столбцов для <SPAN class=texample><SPAN 
              class=keyword>INSERT</SPAN> ... VALUES</SPAN> или <SPAN 
              class=texample><SPAN class=keyword>INSERT</SPAN> ... <SPAN 
              class=keyword>SELECT</SPAN></SPAN>, то величины для всех столбцов 
              должны быть определены в списке <SPAN 
              class=texample>VALUES()</SPAN> или в результате работы <SPAN 
              class=texample><SPAN class=keyword>SELECT</SPAN></SPAN>. Если 
              порядок столбцов в таблице неизвестен, для его получения можно 
              использовать <SPAN class=texample>DESCRIBE имя_таблицы</SPAN>.
              <LI>Любой столбец, для которого явно не указано значение, будет 
              установлен в свое значение по умолчанию. Например, если в заданном 
              списке столбцов не указаны все столбцы в данной таблице, то не 
              упомянутые столбцы устанавливаются в свои значения по умолчанию.
              <LI>Выражение <SPAN class=texample>expression</SPAN> может 
              относиться к любому столбцу, который ранее был внесен в список 
              значений. Например, можно указать следующее: 
              <DIV class=example><PRE>mysql&gt; INSERT INTO имя_таблицы (col1,col2)
       VALUES(15,col1*2);
</PRE></DIV>
              <P>Но нельзя указать: </P>
              <DIV class=example><PRE>mysql&gt; INSERT INTO имя_таблицы (col1,col2)
       VALUES(col2*2,15);
</PRE></DIV></LI></UL>
            <P>Мы еще не обсудили три необязательных параметра, присутствующих 
            во всех трех формах команды: <SPAN 
            class=texample>LOW_PRIORITY</SPAN>, <SPAN 
            class=texample>DELAYED</SPAN> и <SPAN 
            class=texample>IGNORE</SPAN>.</P>
            <P>Параметры <SPAN class=texample>LOW_PRIORITY</SPAN> и <SPAN 
            class=texample>DELAYED</SPAN> используются, когда с таблицей 
            работает большое число пользователей. Они предписывают устанавливать 
            приоритет данной операции перед операциями других пользователей. 
            Если указывается ключевое слово <SPAN 
            class=texample>LOW_PRIORITY</SPAN>, то выполнение данной команды 
            <SPAN class=texample><SPAN class=keyword>INSERT</SPAN></SPAN> будет 
            задержано до тех пор, пока другие клиенты не завершат чтение этой 
            таблицы. В этом случае клиент должен ожидать, пока данная команда 
            вставки не будет завершена, что в случае интенсивного использования 
            таблицы может потребовать значительного времени. В противоположность 
            этому команда <SPAN class=texample><SPAN class=keyword>INSERT</SPAN> 
            DELAYED</SPAN> позволяет данному клиенту продолжать операцию сразу 
            же, независимо от других пользователей.</P>
            <P>Если в команде <SPAN class=texample><SPAN 
            class=keyword>INSERT</SPAN></SPAN> указывается ключевое слово <SPAN 
            class=texample>IGNORE</SPAN>, то все строки, имеющие дублирующиеся 
            ключи <SPAN class=texample><SPAN class=keyword>PRIMARY</SPAN></SPAN> 
            или <SPAN class=texample><SPAN class=keyword>UNIQUE</SPAN></SPAN> в 
            этой таблице, будут проигнорированы и не внесены в таблицу. Если не 
            указывать <SPAN class=texample>IGNORE</SPAN>, то данная операция 
            вставки прекращается при обнаружении строки, имеющей дублирующееся 
            значение существующего ключа. </P>
            <H5>Оператор UPDATE</H5>
            <P>Синтаксис:</P>
            <DIV class=example><PRE>UPDATE [LOW_PRIORITY] [IGNORE] имя_таблицы
    SET имя_столбца1=выражение1 
   [, имя_столбца2=выражение2, ...]
    [WHERE where_definition]
    [LIMIT число]
</PRE></DIV>
            <P><A name=keyword-context.14></A>Оператор <SPAN 
            class=texample><SPAN class=keyword_def>UPDATE</SPAN></SPAN> 
            обновляет значения существующих столбцов таблицы в соответствии с 
            введенными значениями. В выражении <SPAN class=texample>SET</SPAN> 
            указывается, какие именно столбцы следует модифицировать и какие 
            величины должны быть в них установлены. В выражении <SPAN 
            class=texample>WHERE</SPAN>, если оно присутствует, задается, какие 
            строки подлежат обновлению. В остальных случаях обновляются все 
            строки. Если задано выражение <SPAN class=texample>ORDER BY</SPAN>, 
            то строки будут обновляться в указанном в нем порядке.</P>
            <P>Если указывается ключевое слово <SPAN 
            class=texample>LOW_PRIORITY</SPAN>, то выполнение данной команды 
            <SPAN class=texample><SPAN class=keyword>UPDATE</SPAN></SPAN> 
            задерживается до тех пор, пока другие клиенты не завершат чтение 
            этой таблицы.</P>
            <P>Если указывается ключевое слово <SPAN 
            class=texample>IGNORE</SPAN>, то команда обновления не будет 
            прервана, даже если возникнет ошибка дублирования ключей. Строки, 
            из-за которых возникают конфликтные ситуации, обновлены не 
будут.</P>
            <P>Если в выражении, которое задает новое значение столбца, 
            используется имя этого поля, то команда <SPAN class=texample><SPAN 
            class=keyword>UPDATE</SPAN></SPAN> использует для этого столбца его 
            текущее значение. Например, следующая команда устанавливает столбец 
            <SPAN class=texample>death_date</SPAN> в значение, на единицу 
            большее его текущей величины:</P>
            <DIV class=example><PRE>mysql&gt; UPDATE Persons 
       SET death_date=death_date+1;
</PRE></DIV>
            <P>В версии <SPAN class=keyword>MySQL</SPAN> 3.23 можно использовать 
            параметр <SPAN class=texample>LIMIT #</SPAN>, чтобы убедиться, что 
            было изменено только заданное количество строк.</P>
            <P>Например, такая операция заменит в первой строке нашей таблицы 
            экспонатов название <SPAN class=texample>title</SPAN> на строку 
            «Ламповая ЭВМ»:</P>
            <DIV class=example><PRE>mysql&gt; UPDATE Artifacts 
       SET title='Ламповая ЭВМ' Limit 1;
</PRE></DIV>
            <H5>Оператор DELETE</H5>
            <P><A name=keyword-context.15></A>Оператор <SPAN 
            class=texample><SPAN class=keyword_def>DELETE</SPAN></SPAN> удаляет 
            из таблицы <SPAN class=texample>имя_таблицы</SPAN> строки, 
            удовлетворяющие заданным в <SPAN 
            class=texample>where_definition</SPAN> условиям, и возвращает число 
            удаленных записей. </P>
            <P>Если оператор <SPAN class=texample><SPAN 
            class=keyword>DELETE</SPAN></SPAN> запускается без определения <SPAN 
            class=texample>WHERE</SPAN>, то удаляются все строки. </P>
            <P>Синтаксис:</P>
            <DIV class=example><PRE>DELETE [LOW_PRIORITY] FROM имя_таблицы
    [WHERE where_definition]
    [LIMIT rows]
</PRE></DIV>
            <P>Например, следующая команда удалит из таблицы <SPAN 
            class=texample>Persons</SPAN> все записи, у которых поле «год 
            рождения» (<SPAN class=texample>bday</SPAN>) больше 2003:</P>
            <DIV class=example><PRE>mysql&gt; DELETE FROM Persons WHERE bday&gt;2003;
</PRE></DIV>
            <P>Удалить все записи в таблице можно еще и с помощью такой 
            команды:</P>
            <DIV class=example><PRE>mysql&gt; DELETE FROM Persons WHERE 1&gt;0;
</PRE></DIV>
            <P>Но этот метод работает гораздо медленнее, чем использование той 
            же команды без условия:</P>
            <DIV class=example><PRE>mysql&gt; DELETE FROM Persons;
</PRE></DIV>
            <P>Специфическая для <SPAN class=keyword>MySQL</SPAN> опция <SPAN 
            class=texample>LIMIT</SPAN> для команды <SPAN class=texample><SPAN 
            class=keyword>DELETE</SPAN></SPAN> указывает серверу максимальное 
            количество строк, которые следует удалить до возврата управления 
            клиенту. Эта опция может использоваться для гарантии того, что 
            данная команда <SPAN class=texample><SPAN 
            class=keyword>DELETE</SPAN></SPAN> не потребует слишком много 
            времени для выполнения.</P>
            <H3>Заключение</H3>
            <P>Итак, мы разобрались с основами реляционных <SPAN 
            class=keyword>баз данных</SPAN>, научились создавать простые и не 
            очень SQL-запросы. Надеюсь, что большое количество технических 
            деталей не помешало читателям получить представление о базовых 
            элементах языка, поскольку все это наверняка пригодится для решения 
            практических задач.</P></TD></TR>
        <TR>
          <TD height=8><IMG height=8 
            src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
        width=1></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG height=1 src="Базы данных и СУБД. Введение в SQL.files/empty.gif" 
      width=8></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG height=1 
      src="Базы данных и СУБД. Введение в SQL.files/empty.gif" width=1></TD></TR>
  <TR>
    <TD class=ltxt align=middle>© 2003-2005 INTUIT.ru. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom --></BODY></HTML>
